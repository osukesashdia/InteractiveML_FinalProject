function t(t,e){return e.forEach((function(e){e&&"string"!=typeof e&&!Array.isArray(e)&&Object.keys(e).forEach((function(n){if("default"!==n&&!(n in t)){var i=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,i.get?i:{enumerable:!0,get:function(){return e[n]}})}}))})),Object.freeze(t)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class n{refCount(t){return i("refCount")}incRef(t){return i("incRef")}timerAvailable(){return!0}time(t){return i("time")}read(t){return i("read")}readSync(t){return i("readSync")}readToGPU(t,e){return i("readToGPU")}numDataIds(){return i("numDataIds")}disposeData(t,e){return i("disposeData")}write(t,e,n){return i("write")}move(t,e,n,r,s){return i("move")}createTensorFromGPUData(t,e,n){return i("createTensorFromGPUData")}memory(){return i("memory")}floatPrecision(){return i("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return i("dispose")}}function i(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,a(t,e,n)}function s(t,e,n){return Math.max(t,Math.min(e,n))}function o(t){return t%2==0?t:t+1}function a(t,e,n){const i=t[e];t[e]=t[n],t[n]=i}function l(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function c(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function u(t,e,n=""){c(m(t,e),(()=>n+` Shapes ${t} and ${e} must match`))}function h(t){c(null!=t,(()=>"The input to the tensor constructor must be a non-null value."))}function d(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function p(t){return 0===t.length}function f(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(null!==t[n]&&null!==e[n]&&t[n]!==e[n])return!1;return!0}function m(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function g(t){return t%1==0}function y(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function b(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function v(t,e=(t=>0),n,i){return new Promise(((r,s)=>{let o=0;const a=()=>{if(t())return void r();o++;const l=e(o);null!=n&&o>=n?s():null!=i?i(a,l):setTimeout(a,l)};a()}))}function x(t,e){let n=1,i=-1;for(let e=0;e<t.length;++e)if(t[e]>=0)n*=t[e];else if(-1===t[e]){if(-1!==i)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${i} and dim ${e}`);i=e}else if(t[e]<0)throw Error(`Shapes can not be < 0. Found ${t[e]} at dim ${e}`);if(-1===i){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const r=t.slice();return r[i]=e/n,r}function w(t,e){const n=e.length;return t=null==t?e.map(((t,e)=>e)):[].concat(t),c(t.every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),c(t.every((t=>g(t))),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?n+t:t))}function S(t,e){const n=[],i=[],r=null!=e&&Array.isArray(e)&&0===e.length,s=null==e||r?null:w(e,t).sort();let o=0;for(let e=0;e<t.length;++e){if(null!=s){if(s[o]===e&&1!==t[e])throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);(null==s[o]||s[o]>e)&&1===t[e]&&(n.push(t[e]),i.push(e)),s[o]<=e&&o++}1!==t[e]&&(n.push(t[e]),i.push(e))}return{newShape:n,keptDims:i}}function k(t,e){return C(t,e)}function C(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function T(t,e){for(let n=0;n<t.length;n++){const i=t[n];if(isNaN(i)||!isFinite(i))throw Error(`A tensor of type ${e} being uploaded contains ${i}.`)}}function _(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function E(t,e){return"complex64"!==e&&(("float32"!==e||"complex64"===t)&&(("int32"!==e||"float32"===t||"complex64"===t)&&("bool"!==e||"bool"!==t)))}function M(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function $(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}function I(t){return"string"==typeof t||t instanceof String}function A(t){return"boolean"==typeof t}function N(t){return"number"==typeof t}function R(t){return Array.isArray(t)?R(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":N(t)?"float32":I(t)?"string":A(t)?"bool":"float32"}function P(t){return!!(t&&t.constructor&&t.call&&t.apply)}function O(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function L(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let i=e-3;i>=0;--i)n[i]=n[i+1]*t[i+1];return n}function D(t,e,n,i=!1){const r=new Array;if(1===e.length){const s=e[0]*(i?2:1);for(let e=0;e<s;e++)r[e]=n[t+e]}else{const s=e[0],o=e.slice(1),a=o.reduce(((t,e)=>t*e))*(i?2:1);for(let e=0;e<s;e++)r[e]=D(t+e*a,o,n,i)}return r}function F(t,e,n=!1){if(0===t.length)return e[0];const i=t.reduce(((t,e)=>t*e))*(n?2:1);if(0===i)return[];if(i!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return D(0,t,e,n)}function z(t,e){if(Array.isArray(t))return t;if("float32"===e)return t instanceof Float32Array?t:new Float32Array(t);if("int32"===e)return t instanceof Int32Array?t:new Int32Array(t);if("bool"===e||"string"===e)return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${e}`)}function B(t,e){const n=U(t,e);for(let t=0;t<n.length;t++)n[t]=1;return n}function U(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function V(t,e){const n=t.reduce(((t,e)=>t*e),1);if(null==e||"float32"===e)return F(t,new Float32Array(n));if("int32"===e)return F(t,new Int32Array(n));if("bool"===e)return F(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function W(t){t.forEach((e=>{c(Number.isInteger(e)&&e>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`))}))}function H(t,e,n){if(0===e)return 0;if(1===e)return t[0];let i=t[t.length-1];for(let e=0;e<t.length-1;++e)i+=n[e]*t[e];return i}function j(t,e,n){if(0===e)return[];if(1===e)return[t];const i=new Array(e);for(let e=0;e<i.length-1;++e)i[e]=Math.floor(t/n[e]),t-=i[e]*n[e];return i[i.length-1]=t,i}function G(t){return t&&t.then&&"function"==typeof t.then}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q="tfjsflags";class X{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=K,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(Y().getBool("IS_TEST")||Y().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];Y().getBool("IS_TEST")||Y().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(G(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);if(q in t){t[q].split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){const n=e.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:e}(0,n)}))}}}function K(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("=")))),e}function Y(){return J}let Z,J=null;function Q(){if(null==Z){let t;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}Z=t}return Z}function tt(t,e){const n=function(){const t=Q();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const i=e();return n.set(t,i),n.get(t)}}const et="Abs",nt="Acos",it="Acosh",rt="Add",st="AddN",ot="All",at="Any",lt="ArgMax",ct="ArgMin",ut="Asin",ht="Asinh",dt="Atan",pt="Atanh",ft="Atan2",mt="AvgPool",gt="AvgPoolGrad",yt="AvgPool3D",bt="AvgPool3DGrad",vt="BatchMatMul",xt="BatchToSpaceND",wt="Bincount",St="BitwiseAnd",kt="BroadcastTo",Ct="BroadcastArgs",Tt="Cast",_t="Ceil",Et="ClipByValue",Mt="Complex",$t="ComplexAbs",It="Concat",At="Conv2D",Nt="Conv2DBackpropFilter",Rt="Conv2DBackpropInput",Pt="Conv3D",Ot="Conv3DBackpropFilterV2",Lt="Conv3DBackpropInputV2",Dt="Cos",Ft="Cosh",zt="Cumprod",Bt="Cumsum",Ut="CropAndResize",Vt="DenseBincount",Wt="DepthToSpace",Ht="DepthwiseConv2dNative",jt="DepthwiseConv2dNativeBackpropFilter",Gt="DepthwiseConv2dNativeBackpropInput",qt="Diag",Xt="Dilation2D",Kt="Dilation2DBackpropInput",Yt="Dilation2DBackpropFilter",Zt="Draw",Jt="RealDiv",Qt="Einsum",te="Elu",ee="EluGrad",ne="Erf",ie="Equal",re="Exp",se="ExpandDims",oe="Expm1",ae="FFT",le="Fill",ce="FlipLeftRight",ue="Floor",he="FloorDiv",de="FusedBatchNorm",pe="GatherV2",fe="GatherNd",me="Greater",ge="GreaterEqual",ye="Identity",be="IFFT",ve="Imag",xe="IsFinite",we="IsInf",Se="IsNan",ke="LeakyRelu",Ce="Less",Te="LessEqual",_e="LinSpace",Ee="Log",Me="Log1p",$e="LogicalAnd",Ie="LogicalNot",Ae="LogicalOr",Ne="LogSoftmax",Re="LRN",Pe="LRNGrad",Oe="Max",Le="Maximum",De="MaxPool",Fe="MaxPoolGrad",ze="MaxPool3D",Be="MaxPool3DGrad",Ue="MaxPoolWithArgmax",Ve="Mean",We="Min",He="Minimum",je="MirrorPad",Ge="Mod",qe="Multinomial",Xe="Multiply",Ke="Neg",Ye="NotEqual",Ze="NonMaxSuppressionV3",Je="NonMaxSuppressionV4",Qe="NonMaxSuppressionV5",tn="OnesLike",en="OneHot",nn="Pack",rn="PadV2",sn="Pow",on="Prelu",an="Prod",ln="RaggedGather",cn="RaggedRange",un="RaggedTensorToTensor",hn="Range",dn="Real",pn="Reciprocal",fn="Relu",mn="Reshape",gn="ResizeNearestNeighbor",yn="ResizeNearestNeighborGrad",bn="ResizeBilinear",vn="ResizeBilinearGrad",xn="Relu6",wn="Reverse",Sn="Round",kn="Rsqrt",Cn="ScatterNd",Tn="TensorScatterUpdate",_n="SearchSorted",En="Select",Mn="Selu",$n="Slice",In="Sin",An="Sinh",Nn="Sign",Rn="Sigmoid",Pn="Softplus",On="Sqrt",Ln="Sum",Dn="SpaceToBatchND",Fn="SplitV",zn="Softmax",Bn="SparseFillEmptyRows",Un="SparseReshape",Vn="SparseSegmentMean",Wn="SparseSegmentSum",Hn="SparseToDense",jn="SquaredDifference",Gn="Square",qn="StaticRegexReplace",Xn="StridedSlice",Kn="StringNGrams",Yn="StringSplit",Zn="StringToHashBucketFast",Jn="Sub",Qn="Tan",ti="Tanh",ei="Tile",ni="TopK",ii="Transform",ri="Transpose",si="Unique",oi="Unpack",ai="UnsortedSegmentSum",li="ZerosLike",ci="Step",ui="FromPixels",hi="RotateWithOffset",di="_FusedMatMul",pi="FusedConv2D",fi="FusedDepthwiseConv2D";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mi(...t){Y().getBool("IS_TEST")||Y().getBool("PROD")||console.warn(...t)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const gi=tt("kernelRegistry",(()=>new Map)),yi=tt("gradRegistry",(()=>new Map));function bi(t,e){const n=ki(t,e);return gi.get(n)}function vi(t){return yi.get(t)}function xi(t){const e=gi.entries(),n=[];for(;;){const{done:i,value:r}=e.next();if(i)break;const[s,o]=r,[a]=s.split("_");a===t&&n.push(o)}return n}function wi(t){const{kernelName:e,backendName:n}=t,i=ki(e,n);gi.has(i)&&mi(`The kernel '${e}' for backend '${n}' is already registered`),gi.set(i,t)}function Si(t){const{kernelName:e}=t;yi.has(e)&&Y().getBool("DEBUG")&&mi(`Overriding the gradient for '${e}'`),yi.set(e,t)}function ki(t,e){return`${e}_${t}`}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ci(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var Ti="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function _i(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function Ei(t){if(t.__esModule)return t;var e=t.default;if("function"==typeof e){var n=function t(){if(this instanceof t){var n=[null];return n.push.apply(n,arguments),new(Function.bind.apply(e,n))}return e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(t).forEach((function(e){var i=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(n,e,i.get?i:{enumerable:!0,get:function(){return t[e]}})})),n}var Mi=Ii,$i=null;try{$i=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(vZt){}function Ii(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function Ai(t){return!0===(t&&t.__isLong__)}Ii.prototype.__isLong__,Object.defineProperty(Ii.prototype,"__isLong__",{value:!0}),Ii.isLong=Ai;var Ni={},Ri={};function Pi(t,e){var n,i,r;return e?(r=0<=(t>>>=0)&&t<256)&&(i=Ri[t])?i:(n=Li(t,(0|t)<0?-1:0,!0),r&&(Ri[t]=n),n):(r=-128<=(t|=0)&&t<128)&&(i=Ni[t])?i:(n=Li(t,t<0?-1:0,!1),r&&(Ni[t]=n),n)}function Oi(t,e){if(isNaN(t))return e?ji:Hi;if(e){if(t<0)return ji;if(t>=Ui)return Yi}else{if(t<=-Vi)return Zi;if(t+1>=Vi)return Ki}return t<0?Oi(-t,e).neg():Li(t%Bi|0,t/Bi|0,e)}function Li(t,e,n){return new Ii(t,e,n)}Ii.fromInt=Pi,Ii.fromNumber=Oi,Ii.fromBits=Li;var Di=Math.pow;function Fi(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return Hi;if("number"==typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var i;if((i=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===i)return Fi(t.substring(1),e,n).neg();for(var r=Oi(Di(n,8)),s=Hi,o=0;o<t.length;o+=8){var a=Math.min(8,t.length-o),l=parseInt(t.substring(o,o+a),n);if(a<8){var c=Oi(Di(n,a));s=s.mul(c).add(Oi(l))}else s=(s=s.mul(r)).add(Oi(l))}return s.unsigned=e,s}function zi(t,e){return"number"==typeof t?Oi(t,e):"string"==typeof t?Fi(t,e):Li(t.low,t.high,"boolean"==typeof e?e:t.unsigned)}Ii.fromString=Fi,Ii.fromValue=zi;var Bi=4294967296,Ui=Bi*Bi,Vi=Ui/2,Wi=Pi(1<<24),Hi=Pi(0);Ii.ZERO=Hi;var ji=Pi(0,!0);Ii.UZERO=ji;var Gi=Pi(1);Ii.ONE=Gi;var qi=Pi(1,!0);Ii.UONE=qi;var Xi=Pi(-1);Ii.NEG_ONE=Xi;var Ki=Li(-1,2147483647,!1);Ii.MAX_VALUE=Ki;var Yi=Li(-1,-1,!0);Ii.MAX_UNSIGNED_VALUE=Yi;var Zi=Li(0,-2147483648,!1);Ii.MIN_VALUE=Zi;var Ji=Ii.prototype;Ji.toInt=function(){return this.unsigned?this.low>>>0:this.low},Ji.toNumber=function(){return this.unsigned?(this.high>>>0)*Bi+(this.low>>>0):this.high*Bi+(this.low>>>0)},Ji.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Zi)){var e=Oi(t),n=this.div(e),i=n.mul(e).sub(this);return n.toString(t)+i.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var r=Oi(Di(t,6),this.unsigned),s=this,o="";;){var a=s.div(r),l=(s.sub(a.mul(r)).toInt()>>>0).toString(t);if((s=a).isZero())return l+o;for(;l.length<6;)l="0"+l;o=""+l+o}},Ji.getHighBits=function(){return this.high},Ji.getHighBitsUnsigned=function(){return this.high>>>0},Ji.getLowBits=function(){return this.low},Ji.getLowBitsUnsigned=function(){return this.low>>>0},Ji.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Zi)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},Ji.isZero=function(){return 0===this.high&&0===this.low},Ji.eqz=Ji.isZero,Ji.isNegative=function(){return!this.unsigned&&this.high<0},Ji.isPositive=function(){return this.unsigned||this.high>=0},Ji.isOdd=function(){return 1==(1&this.low)},Ji.isEven=function(){return 0==(1&this.low)},Ji.equals=function(t){return Ai(t)||(t=zi(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&(this.high===t.high&&this.low===t.low)},Ji.eq=Ji.equals,Ji.notEquals=function(t){return!this.eq(t)},Ji.neq=Ji.notEquals,Ji.ne=Ji.notEquals,Ji.lessThan=function(t){return this.comp(t)<0},Ji.lt=Ji.lessThan,Ji.lessThanOrEqual=function(t){return this.comp(t)<=0},Ji.lte=Ji.lessThanOrEqual,Ji.le=Ji.lessThanOrEqual,Ji.greaterThan=function(t){return this.comp(t)>0},Ji.gt=Ji.greaterThan,Ji.greaterThanOrEqual=function(t){return this.comp(t)>=0},Ji.gte=Ji.greaterThanOrEqual,Ji.ge=Ji.greaterThanOrEqual,Ji.compare=function(t){if(Ai(t)||(t=zi(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},Ji.comp=Ji.compare,Ji.negate=function(){return!this.unsigned&&this.eq(Zi)?Zi:this.not().add(Gi)},Ji.neg=Ji.negate,Ji.add=function(t){Ai(t)||(t=zi(t));var e=this.high>>>16,n=65535&this.high,i=this.low>>>16,r=65535&this.low,s=t.high>>>16,o=65535&t.high,a=t.low>>>16,l=0,c=0,u=0,h=0;return u+=(h+=r+(65535&t.low))>>>16,c+=(u+=i+a)>>>16,l+=(c+=n+o)>>>16,l+=e+s,Li((u&=65535)<<16|(h&=65535),(l&=65535)<<16|(c&=65535),this.unsigned)},Ji.subtract=function(t){return Ai(t)||(t=zi(t)),this.add(t.neg())},Ji.sub=Ji.subtract,Ji.multiply=function(t){if(this.isZero())return Hi;if(Ai(t)||(t=zi(t)),$i)return Li($i.mul(this.low,this.high,t.low,t.high),$i.get_high(),this.unsigned);if(t.isZero())return Hi;if(this.eq(Zi))return t.isOdd()?Zi:Hi;if(t.eq(Zi))return this.isOdd()?Zi:Hi;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(Wi)&&t.lt(Wi))return Oi(this.toNumber()*t.toNumber(),this.unsigned);var e=this.high>>>16,n=65535&this.high,i=this.low>>>16,r=65535&this.low,s=t.high>>>16,o=65535&t.high,a=t.low>>>16,l=65535&t.low,c=0,u=0,h=0,d=0;return h+=(d+=r*l)>>>16,u+=(h+=i*l)>>>16,h&=65535,u+=(h+=r*a)>>>16,c+=(u+=n*l)>>>16,u&=65535,c+=(u+=i*a)>>>16,u&=65535,c+=(u+=r*o)>>>16,c+=e*l+n*a+i*o+r*s,Li((h&=65535)<<16|(d&=65535),(c&=65535)<<16|(u&=65535),this.unsigned)},Ji.mul=Ji.multiply,Ji.divide=function(t){if(Ai(t)||(t=zi(t)),t.isZero())throw Error("division by zero");var e,n,i;if($i)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?Li((this.unsigned?$i.div_u:$i.div_s)(this.low,this.high,t.low,t.high),$i.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?ji:Hi;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return ji;if(t.gt(this.shru(1)))return qi;i=ji}else{if(this.eq(Zi))return t.eq(Gi)||t.eq(Xi)?Zi:t.eq(Zi)?Gi:(e=this.shr(1).div(t).shl(1)).eq(Hi)?t.isNegative()?Gi:Xi:(n=this.sub(t.mul(e)),i=e.add(n.div(t)));if(t.eq(Zi))return this.unsigned?ji:Hi;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();i=Hi}for(n=this;n.gte(t);){e=Math.max(1,Math.floor(n.toNumber()/t.toNumber()));for(var r=Math.ceil(Math.log(e)/Math.LN2),s=r<=48?1:Di(2,r-48),o=Oi(e),a=o.mul(t);a.isNegative()||a.gt(n);)a=(o=Oi(e-=s,this.unsigned)).mul(t);o.isZero()&&(o=Gi),i=i.add(o),n=n.sub(a)}return i},Ji.div=Ji.divide,Ji.modulo=function(t){return Ai(t)||(t=zi(t)),$i?Li((this.unsigned?$i.rem_u:$i.rem_s)(this.low,this.high,t.low,t.high),$i.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},Ji.mod=Ji.modulo,Ji.rem=Ji.modulo,Ji.not=function(){return Li(~this.low,~this.high,this.unsigned)},Ji.and=function(t){return Ai(t)||(t=zi(t)),Li(this.low&t.low,this.high&t.high,this.unsigned)},Ji.or=function(t){return Ai(t)||(t=zi(t)),Li(this.low|t.low,this.high|t.high,this.unsigned)},Ji.xor=function(t){return Ai(t)||(t=zi(t)),Li(this.low^t.low,this.high^t.high,this.unsigned)},Ji.shiftLeft=function(t){return Ai(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?Li(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):Li(0,this.low<<t-32,this.unsigned)},Ji.shl=Ji.shiftLeft,Ji.shiftRight=function(t){return Ai(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?Li(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):Li(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},Ji.shr=Ji.shiftRight,Ji.shiftRightUnsigned=function(t){if(Ai(t)&&(t=t.toInt()),0===(t&=63))return this;var e=this.high;return t<32?Li(this.low>>>t|e<<32-t,e>>>t,this.unsigned):Li(32===t?e:e>>>t-32,0,this.unsigned)},Ji.shru=Ji.shiftRightUnsigned,Ji.shr_u=Ji.shiftRightUnsigned,Ji.toSigned=function(){return this.unsigned?Li(this.low,this.high,!1):this},Ji.toUnsigned=function(){return this.unsigned?this:Li(this.low,this.high,!0)},Ji.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},Ji.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},Ji.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},Ii.fromBytes=function(t,e,n){return n?Ii.fromBytesLE(t,e):Ii.fromBytesBE(t,e)},Ii.fromBytesLE=function(t,e){return new Ii(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},Ii.fromBytesBE=function(t,e){return new Ii(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)};var Qi=_i(Mi);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const tr=Qi||t({__proto__:null,default:Qi},[Mi]);function er(t){return tr.fromString(t,!0,16)}const nr=er("c3a5c85c97cb3127"),ir=er("b492b66fbe98f273"),rr=er("9ae16a3b2f90404f");function sr(t){return t.xor(t.shru(47))}function or(t,e,n){const i=t.slice(e,e+n);return tr.fromBytes(Array.from(i),!0,!0)}function ar(t,e){return or(t,e,8)}function lr(t,e){return or(t,e,4)}function cr(t,e){return 0===e?t:t.shru(e).or(t.shl(64-e))}function ur(t,e,n=er("9ddfea08eb382d69")){let i=t.xor(e).mul(n);i=i.xor(i.shru(47));let r=e.xor(i).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function hr(t,e,n,i){return function(t,e,n,i,r,s){r=r.add(t),s=cr(s.add(r).add(i),21);const o=r;return r=(r=r.add(e)).add(n),s=s.add(cr(r,44)),[r.add(i),s.add(o)]}(ar(t,e),ar(t,e+8),ar(t,e+16),ar(t,e+24),n,i)}function dr(t,e=t.length){const n=tr.fromNumber(81,!0);if(e<=32)return e<=16?function(t,e=t.length){if(e>=8){const n=rr.add(2*e),i=ar(t,0).add(rr),r=ar(t,e-8);return ur(cr(r,37).mul(n).add(i),cr(i,25).add(r).mul(n),n)}if(e>=4){const n=rr.add(2*e);return ur(lr(t,0).shl(3).add(e),lr(t,e-4),n)}if(e>0){const n=t[0]+(t[e>>1]<<8),i=e+(t[e-1]<<2);return sr(rr.mul(n).xor(nr.mul(i))).mul(rr)}return rr}(t,e):function(t,e=t.length){const n=rr.add(2*e),i=ar(t,0).mul(ir),r=ar(t,8),s=ar(t,e-8).mul(n),o=ar(t,e-16).mul(rr);return ur(cr(i.add(r),43).add(cr(s,30)).add(o),i.add(cr(r.add(rr),18)).add(s),n)}(t,e);if(e<=64)return function(t,e=t.length){const n=rr.add(2*e),i=ar(t,0).mul(rr),r=ar(t,8),s=ar(t,e-8).mul(n),o=ar(t,e-16).mul(rr),a=cr(i.add(r),43).add(cr(s,30)).add(o),l=ur(a,i.add(cr(r.add(rr),18)).add(s),n),c=ar(t,16).mul(n),u=ar(t,24),h=a.add(ar(t,e-32)).mul(n),d=l.add(ar(t,e-24)).mul(n);return ur(cr(c.add(u),43).add(cr(h,30)).add(d),c.add(cr(u.add(i),18)).add(h),n)}(t,e);let i=n,r=n.mul(ir).add(113),s=sr(r.mul(rr).add(113)).mul(rr),o=[tr.UZERO,tr.UZERO],a=[tr.UZERO,tr.UZERO];i=i.mul(rr).add(ar(t,0));let l=0;const c=64*(e-1>>6),u=c+(e-1&63)-63;do{i=cr(i.add(r).add(o[0]).add(ar(t,l+8)),37).mul(ir),r=cr(r.add(o[1]).add(ar(t,l+48)),42).mul(ir),i=i.xor(a[1]),r=r.add(o[0]).add(ar(t,l+40)),s=cr(s.add(a[0]),33).mul(ir),o=hr(t,l,o[1].mul(ir),i.add(a[0])),a=hr(t,l+32,s.add(a[1]),r.add(ar(t,l+16))),[s,i]=[i,s],l+=64}while(l!==c);const h=ir.add(s.and(255).shl(1));return l=u,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),i=cr(i.add(r).add(o[0]).add(ar(t,l+8)),37).mul(h),r=cr(r.add(o[1]).add(ar(t,l+48)),42).mul(h),i=i.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(ar(t,l+40))),s=cr(s.add(a[0]),33).mul(h),o=hr(t,l,o[1].mul(h),i.add(a[0])),a=hr(t,l+32,s.add(a[1]),r.add(ar(t,l+16))),[s,i]=[i,s],ur(ur(o[0],a[0],h).add(sr(r).mul(nr)).add(s),ur(o[1],a[1],h).add(i),h)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pr(t,e){return"string"===e?gr(t):fr([t],e)}function fr(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=vr(t)),Y().getBool("DEBUG")&&T(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function mr(){return Y().platform.now()}function gr(t,e="utf-8"){return e=e||"utf-8",Y().platform.encode(t,e)}function yr(t,e="utf-8"){return e=e||"utf-8",Y().platform.decode(t,e)}function br(t){return null!=Y().platform.isTypedArray?Y().platform.isTypedArray(t):Ci(t)}function vr(t,e=[],n=!1){if(null==e&&(e=[]),"boolean"==typeof t||"number"==typeof t||"string"==typeof t||G(t)||null==t||br(t)&&n)e.push(t);else if(Array.isArray(t)||br(t))for(let i=0;i<t.length;++i)vr(t[i],e,n);else{let i=-1;for(const e of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(e)&&(i=Math.max(i,Number(e)));for(let r=0;r<=i;r++)vr(t[r],e,n)}return e}var xr=Object.freeze({__proto__:null,arraysEqual:m,arraysEqualWithNull:f,assert:c,assertNonNegativeIntegerDimensions:W,assertNonNull:h,assertShapesMatch:u,bytesFromStringArray:$,bytesPerElement:M,checkConversionForErrors:T,clamp:s,computeStrides:L,convertBackendValuesAndArrayBuffer:z,createScalarValue:pr,createShuffledIndices:function(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return r(e),e},decodeString:yr,distSquared:function(t,e){let n=0;for(let i=0;i<t.length;i++){const r=Number(t[i])-Number(e[i]);n+=r*r}return n},encodeString:gr,fetch:function(t,e){return Y().platform.fetch(t,e)},fingerPrint64:dr,flatten:vr,getArrayFromDType:C,getTypedArrayFromDType:k,hasEncodingLoss:E,hexToLong:er,indexToLoc:j,inferDtype:R,inferFromImplicitShape:x,isBoolean:A,isFunction:P,isInt:g,isNumber:N,isPromise:G,isScalarShape:p,isString:I,isTypedArray:br,isValidDtype:_,locToIndex:H,makeOnesTypedArray:B,makeZerosNestedTypedArray:V,makeZerosTypedArray:U,nearestDivisor:O,nearestLargerEven:o,now:mr,parseAxisParam:w,randUniform:function(t,e){const n=Math.random();return e*n+(1-n)*t},repeatedTry:v,rightPad:b,shuffle:r,shuffleCombo:function(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n=t.length,i=0;for(;n>0;)i=Math.random()*n|0,n--,a(t,n,i),a(e,n,i)},sizeFromShape:d,sizeToSquarishShape:y,squeezeShape:S,sum:l,swap:a,tanh:function(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}},toNestedArray:F,toTypedArray:fr});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wr{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new kr)}profileKernel(t,e,n){let i;const r=()=>{i=n()};let s;const o=mr();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(r);else{r();for(const t of i)t.dataSync();s=Promise.resolve({kernelMs:mr()-o})}if(Y().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let e=0;e<i.length;e++){const n=i[e];n.data().then((e=>{Sr(e,n.dtype,t)}))}return{kernelName:t,outputs:i,inputs:e,timeMs:s.then((t=>t.kernelMs)),extraInfo:s.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:i,inputs:r,extraInfo:s}=t;n.forEach((t=>{Promise.all([t.data(),i,s]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],r,n[2])}))}))}}function Sr(t,e,n){if("float32"!==e)return!1;for(let e=0;e<t.length;e++){const i=t[e];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${n}'`),!0}return!1}class kr{logKernelProfile(t,e,n,i,r,s){const o="number"==typeof i?b(`${i}ms`,9):i.error,a=b(t,25),l=e.rank,c=e.size,u=b(e.shape.toString(),14);let h="";for(const t in r){const n=r[t];if(null!=n){const i=n.shape||e.shape,r=i.length;h+=`${t}: ${r}D ${r>0?i:""} `}}console.log(`%c${a}\t%c${o}\t%c${l}D ${u}\t%c${c}\t%c${h}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Cr=20,Tr=3,_r=7;function Er(t,e,n,i){const r=L(e),s=function(t,e,n,i){const r=d(e),s=i[i.length-1],o=new Array(s).fill(0),a=e.length,l="complex64"===n?Ar(t):t;if(a>1)for(let t=0;t<r/s;t++){const e=t*s;for(let t=0;t<s;t++)o[t]=Math.max(o[t],Mr(l[e+t],0,n).length)}return o}(t,e,n,r),o=e.length,a=Ir(t,e,n,r,s),l=["Tensor"];return i&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map((t=>"    "+t)).join("\n")),l.join("\n")}function Mr(t,e,n){let i;return i=Array.isArray(t)?`${parseFloat(t[0].toFixed(_r))} + ${parseFloat(t[1].toFixed(_r))}j`:I(t)?`'${t}'`:"bool"===n?$r(t):parseFloat(t.toFixed(_r)).toString(),b(i,e)}function $r(t){return 0===t?"false":"true"}function Ir(t,e,n,i,r,s=!0){const o="complex64"===n?2:1,a=e[0],l=e.length;if(0===l){if("complex64"===n){return[Mr(Ar(t)[0],0,n)]}return"bool"===n?[$r(t[0])]:[t[0].toString()]}if(1===l){if(a>Cr){const e=Tr*o;let i=Array.from(t.slice(0,e)),s=Array.from(t.slice((a-Tr)*o,a*o));return"complex64"===n&&(i=Ar(i),s=Ar(s)),["["+i.map(((t,e)=>Mr(t,r[e],n))).join(", ")+", ..., "+s.map(((t,e)=>Mr(t,r[a-Tr+e],n))).join(", ")+"]"]}return["["+("complex64"===n?Ar(t):Array.from(t)).map(((t,e)=>Mr(t,r[e],n))).join(", ")+"]"]}const c=e.slice(1),u=i.slice(1),h=i[0]*o,d=[];if(a>Cr){for(let e=0;e<Tr;e++){const i=e*h,s=i+h;d.push(...Ir(t.slice(i,s),c,n,u,r,!1))}d.push("...");for(let e=a-Tr;e<a;e++){const i=e*h,s=i+h;d.push(...Ir(t.slice(i,s),c,n,u,r,e===a-1))}}else for(let e=0;e<a;e++){const i=e*h,s=i+h;d.push(...Ir(t.slice(i,s),c,n,u,r,e===a-1))}const p=2===l?",":"";d[0]="["+(a>0?d[0]+p:"");for(let t=1;t<d.length-1;t++)d[t]=" "+d[t]+p;let f=",\n";for(let t=2;t<l;t++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function Ar(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nr{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=d(t),null!=n){const t=n.length;c(t===this.size,(()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||C(e,this.size),this.strides=L(t)}set(t,...e){0===e.length&&(e=[0]),c(e.length===this.rank,(()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`));const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const n of t){if(n<0||n>=this.shape[e]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}e++}let n=t[t.length-1];for(let e=0;e<t.length-1;++e)n+=this.strides[e]*t[e];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Rr().makeTensor(this.values,this.shape,this.dtype)}}let Rr=null,Pr=null;class Or{constructor(t,e,n,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=d(t),this.strides=L(t),this.dataId=n,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Pr.buffer(this.shape,this.dtype,t)}bufferSync(){return Pr.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return F(this.shape,t,"complex64"===this.dtype)}arraySync(){return F(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=Rr().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map((t=>yr(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Rr().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Rr().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>yr(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Rr().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Rr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Pr.print(this,t)}clone(){return this.throwIfDisposed(),Pr.clone(this)}toString(t=!1){return Er(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Pr.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),Rr().makeVariable(this,t,e,n)}}function Lr(){return tt("Tensor",(()=>Or))}Object.defineProperty(Or,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),Lr();class Dr extends Or{constructor(t,e,n,i){super(t.shape,t.dtype,t.dataId,i),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!m(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Rr().disposeTensor(this),this.dataId=t.dataId,Rr().incRef(this,null)}dispose(){Rr().disposeVariable(this),this.isDisposedInternal=!0}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Fr,zr,Br,Ur,Vr;Object.defineProperty(Dr,Symbol.hasInstance,{value:t=>t instanceof Or&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Fr||(Fr={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(zr||(zr={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Br||(Br={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(Ur||(Ur={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Vr||(Vr={}));const Wr={float32:Ur,int32:zr,bool:Br,complex64:Vr};function Hr(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return Wr[t][e]}function jr(t){return Hr(t,"int32")}function Gr(t){return null!=t&&"object"==typeof t&&"texture"in t&&t.texture instanceof WebGLTexture}function qr(t){return"undefined"!=typeof GPUBuffer&&null!=t&&"object"==typeof t&&"buffer"in t&&t.buffer instanceof GPUBuffer}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xr(t,e){if(t.dtype===e.dtype)return[t,e];const n=Hr(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Kr(t,e){c(t.dtype===e.dtype,(()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`))}function Yr(t,e){return e.some((e=>e.id===t.id))}function Zr(t){const e=[];return Jr(t,e,new Set),e}function Jr(t,e,n){if(null==t)return;if(t instanceof Or)return void e.push(t);if(i=t,!Array.isArray(i)&&"object"!=typeof i)return;var i;const r=t;for(const t in r){const i=r[t];n.has(i)||(n.add(i),Jr(i,e,n))}}var Qr=Object.freeze({__proto__:null,assertTypesMatch:Kr,getTensorsInContainer:Zr,isTensorInList:Yr,makeTypesMatch:Xr});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ts(t){return null!=t.kernelName}class es{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class ns{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new es}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(mi(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new wr(this.backendInstance),!0}setupRegisteredKernels(){xi(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){xi(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const i=e.factory();if(!i||i instanceof n||"function"!=typeof i.then)return this.registry[t]=i,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,n=i.then((n=>!(e<this.pendingBackendInitId)&&(this.registry[t]=n,this.pendingBackendInit=null,!0))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,mi(`Initialization of backend ${t} failed`),mi(n.stack||n.message)),!1)));return this.pendingBackendInit=n,{success:n,asyncInit:!0}}}catch(e){return mi(`Initialization of backend ${t} failed`),mi(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:i,asyncInit:r}=this.initializeBackend(n);if(r||i)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),i=n.backend,r=this.readSync(e),s=i.refCount(e);i.disposeData(e,!0),n.backend=t,t.move(e,r,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,i=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");i=t}return this.scopedRun((()=>this.startScope(i)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(t){throw e(),t}}nextTensorId(){return ns.nextTensorId++}nextVariableId(){return ns.nextVariableId++}clone(t){const e=rs.runKernel(ye,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t},n={dtype:"float32"};return rs.runKernel(Tt,e,n)}})),[],{}),e}runKernel(t,e,n){null==this.backendName&&this.backend;if(!(null!=bi(t,this.backendName)))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const i=this.backend.numDataIds();let r=0;n.forEach((t=>{r+="complex64"===t.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=i-e-r-s;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const i=this.isTapeOn(),r=this.state.numBytes,s=this.state.numTensors;let o,a;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=ts(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(ts(t)){const{kernelName:e,inputs:r,attrs:s}=t;null==this.backendName&&this.backend;const l=bi(e,this.backendName);c(null!=l,(()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`)),o=()=>{const t=this.backend.numDataIds();a=l.kernelFunc({inputs:r,attrs:s,backend:this.backend});const o=Array.isArray(a)?a:[a];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,o);const c=o.map((t=>null!=t.rank?t:this.makeTensorFromTensorInfo(t)));if(i){const t=this.getTensorsForGradient(e,r,c);n=this.saveTensorsForBackwardMode(t)}return c}}else{const{forwardFunc:e}=t,r=t=>{i&&(n=t.map((t=>this.keep(this.clone(t)))))};o=()=>{const t=this.backend.numDataIds();a=this.tidy((()=>e(this.backend,r)));const n=Array.isArray(a)?a:[a];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:u,attrs:h}=t,d=ts(t)?null:t.backwardsFunc;let p;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(l,u,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),e=p.outputs):e=o()})),i&&this.addTapeNode(l,u,e,d,n,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((t=>null!=u[t]?u[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(a)?e:e[0]}saveTensorsForBackwardMode(t){const e=t.map((t=>this.keep(this.clone(t))));return e}getTensorsForGradient(t,e,n){const i=vi(t);if(null!=i){const t=i.inputsToSave||[],r=i.outputsToSave||[];let s;i.saveAllInputs?(c(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(e).map((t=>e[t]))):s=t.map((t=>e[t]));const o=n.filter(((t,e)=>r[e]));return s.concat(o)}return[]}makeTensor(t,e,n,i){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",i=i||this.backend;let r=t;"string"===n&&I(t[0])&&(r=t.map((t=>gr(t))));const s=i.write(r,e,n),o=new Or(e,n,s,this.nextTensorId());if(this.trackTensor(o,i),"string"===n){const t=this.state.tensorInfo.get(s),e=$(r);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,i){const r={dataId:t,shape:e,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(r,i)}makeTensorFromTensorInfo(t,e){const{dataId:n,shape:i,dtype:r}=t,s=new Or(i,r,n,this.nextTensorId());return this.trackTensor(s,e),s}makeVariable(t,e=!0,n,i){n=n||this.nextVariableId().toString(),null!=i&&i!==t.dtype&&(t=t.cast(i));const r=new Dr(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*M(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Dr||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*M(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const t of this.state.activeProfile.kernels)t.kernelTimeMs=await t.kernelTimeMs,t.extraInfo=await t.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,i,r,s){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:r},a=vi(t);null!=a&&(i=a.gradFunc),null!=i&&(o.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],i=U(t.size,t.dtype);return this.makeTensor(i,t.shape,t.dtype)}return t})),i(t.length>1?t:t[0],r,s))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=Zr(t),n=new Set(e.map((t=>t.id)));for(let t=0;t<this.state.activeScope.track.length;t++){const e=this.state.activeScope.track[t];e.kept||n.has(e.id)||e.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==i.id||this.track(t)}))}gradients(t,e,n,i=!1){if(c(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const r=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));c(r instanceof Or,(()=>"The result y returned by f() must be a tensor."));const s=function(t,e,n){const i={},r={};for(let t=0;t<e.length;t++)i[e[t].id]=!0;for(let n=0;n<t.length;n++){const s=t[n],o=s.inputs;for(const t in o){const n=o[t];let a=!1;for(let t=0;t<e.length;t++)if(i[n.id]){s.outputs.forEach((t=>i[t.id]=!0)),a=!0,r[s.id]=!0;break}if(a)break}}const s={};s[n.id]=!0;const o={};for(let e=t.length-1;e>=0;e--){const n=t[e],i=n.inputs;for(let t=0;t<n.outputs.length;t++)if(s[n.outputs[t].id]){for(const t in i)s[i[t].id]=!0,o[n.id]=!0;break}}const a=[];for(let e=0;e<t.length;e++){const n=t[e];if(r[n.id]&&o[n.id]){const t={};for(const e in n.inputs){const r=n.inputs[e];i[r.id]&&(t[e]=r)}const e=Object.assign({},n);e.inputs=t,e.outputs=n.outputs,a.push(e)}}return a}(this.state.activeTape,e,r);if(!i&&0===s.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[r.id]=null==n?function(t){const e=B(d(t),"float32");return rs.makeTensor(e,t,"float32")}(r.shape):n,function(t,e,n,i){for(let r=e.length-1;r>=0;r--){const s=e[r],o=[];if(s.outputs.forEach((e=>{const n=t[e.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const a=s.gradient(o);for(const e in s.inputs){if(!(e in a))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(a)}.`);const r=n((()=>a[e]()));if("float32"!==r.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${r.dtype}'`);const o=s.inputs[e];if(!m(r.shape,o.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${e}' has shape '${r.shape}', which does not match the shape of the input '${o.shape}'`);if(null==t[o.id])t[o.id]=r;else{const e=t[o.id];t[o.id]=i(e,r),e.dispose()}}}}(t,s,(t=>this.tidy(t)),ss);const i=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:r,grads:i}}))}customGrad(t){return c(P(t),(()=>"The f passed in customGrad(f) must be a function.")),(...e)=>{let n;c(e.every((t=>t instanceof Or)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const i={};e.forEach(((t,e)=>{i[e]=t}));return this.runKernelFunc({forwardFunc:(i,r)=>(n=t(...e,r),c(n.value instanceof Or,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),c(P(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(t,i)=>{const r=n.gradFunc(t,i),s=Array.isArray(r)?r:[r];c(s.length===e.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),c(s.every((t=>t instanceof Or)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return s.forEach(((t,e)=>{o[e]=()=>t})),o},inputs:i})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=mr(),n=await this.backend.time(t);return n.wallMs=mr()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new es;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function is(){const t=Q();if(null==t._tfengine){const e=new X(t);t._tfengine=new ns(e)}var e;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */return e=t._tfengine.ENV,J=e,function(t){Rr=t}((()=>t._tfengine)),t._tfengine}ns.nextTensorId=0,ns.nextVariableId=0;const rs=is();function ss(t,e){const n={a:t,b:e};return rs.runKernel(rt,n)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let os;function as(t){if(void 0!==os)return os;if(t||"undefined"!=typeof navigator&&null!=navigator){if(t||(t=navigator),"ReactNative"===t.product)return!0;const e=t.userAgent||t.vendor||("undefined"!=typeof window?window.opera:"");if(!e){const e=t;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function ls(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var cs=Object.freeze({__proto__:null,isBrowser:ls,isMobile:as,mockIsMobile:function(t){os=t}});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const us=Y();
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hs(t,e){let n=t;if(br(t))return"string"===e?[]:[t.length];if(Gr(t)){const e=t.channels||"RGBA";return[t.height,t.width*e.length]}if(qr(t))return[t.buffer.size/(null==e?4:M(e))];if(!Array.isArray(t))return[];const i=[];for(;Array.isArray(n)||br(n)&&"string"!==e;)i.push(n.length),n=n[0];return Array.isArray(t)&&Y().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ds(t,i,[]),i}function ds(t,e,n){if(n=n||[],!Array.isArray(t)&&!br(t))return void c(0===e.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`));c(e.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`)),c(t.length===e[0],(()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`));const i=e.slice(1);for(let e=0;e<t.length;++e)ds(t[e],i,n.concat(e))}function ps(t,e,n,i){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${i}' must be ${t} tensor, but got ${e} tensor`)}}function fs(t,e,n,i="numeric"){if(t instanceof Or)return ps(i,t.dtype,e,n),t;let r=R(t);if("string"!==r&&["bool","int32","float32"].indexOf(i)>=0&&(r=i),ps(i,r,e,n),null==t||!br(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){const i=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${i}'`)}const s=hs(t,r);br(t)||Array.isArray(t)||(t=[t]);const o="string"!==r?fr(t,r):vr(t,[],!0);return rs.makeTensor(o,s,r)}function ms(t,e,n,i="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map(((t,r)=>fs(t,`${e}[${r}]`,n,i)))}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */us.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),us.registerFlag("IS_BROWSER",(()=>ls())),us.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),us.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),us.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),us.registerFlag("PROD",(()=>!1)),us.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>us.getBool("DEBUG"))),us.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),us.registerFlag("IS_TEST",(()=>!1)),us.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>us.getBool("DEBUG"))),us.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),us.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),us.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const gs="__op";function ys(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const i=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=gs;const r=(...t)=>{rs.startScope(n);try{const e=i(...t);return G(e)&&console.error("Cannot return a Promise inside of tidy."),rs.endScope(e),e}catch(t){throw rs.endScope(null),t}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bs=ys({complex_:function(t,e){const n=fs(t,"real","complex"),i=fs(e,"imag","complex");u(n.shape,i.shape,`real and imag shapes, ${n.shape} and ${i.shape}, must match in call to tf.complex().`);const r={real:n,imag:i};return rs.runKernel(Mt,r)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vs(t,e,n,i){if(null==i)i=R(t);else if("complex64"===i)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(qr(t)||Gr(t)){if("float32"!==i&&"int32"!==i)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${i}.`);return rs.backend.createTensorFromGPUData(t,e||n,i)}if(!br(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){W(e);const t=d(e),i=d(n);c(t===i,(()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${i}`));for(let t=0;t<n.length;++t){const i=n[t],r=t!==n.length-1||i!==d(e.slice(t));c(n[t]===e[t]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `))}}return br(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==i?fr(t,i):vr(t,[],!0),rs.makeTensor(t,e,i)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xs(t,e,n){return vs(t,e,hs(t,n),n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ws={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Ss{static join(t){return new Ss(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,null==t)return;if(t instanceof Array||(t=[t]),0===(t=t.map((t=>br(t)?t.buffer:t))).length)return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let n=0;n<t.length;n++){const i=t[n];n!==t.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=e+i.byteLength;this.shards.push({buffer:i,start:e,end:r}),e=r}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),(e=Math.min(this.byteLength,e))<=t)return new ArrayBuffer(0);const n=this.findShardForByte(t);if(-1===n)throw new Error(`Could not find start shard for byte ${t}`);const i=new ArrayBuffer(e-t),r=new Uint8Array(i);let s=0;for(let i=n;i<this.shards.length;i++){const n=this.shards[i],o=t+s-n.start,a=s,l=Math.min(e,n.end)-n.start,c=new Uint8Array(n.buffer,o,l-o);if(r.set(c,a),s+=c.length,e<n.end)break}return i}findShardForByte(t){if(0===this.shards.length||t<0||t>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(e){return t<e.start?-1:t>=e.end?1:0}if(0===e(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(t,e){let n=0,i=t.length;for(;n<=i;){const r=Math.floor((i-n)/2)+n,s=e(t[r]);if(0===s)return r;s<0?i=r:n=r+1}return-1}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(this.shards,e);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}const ks=4;async function Cs(t,e){const n=[],i=[],r=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let s=0;s<r.length;++s){const o=r[s],a=Array.isArray(t)?t[s].tensor:t[o];if("float32"!==a.dtype&&"int32"!==a.dtype&&"bool"!==a.dtype&&"string"!==a.dtype&&"complex64"!==a.dtype)throw new Error(`Unsupported dtype in weight '${o}': ${a.dtype}`);const l={name:o,shape:a.shape,dtype:a.dtype};if("string"===a.dtype){const t=new Promise((async t=>{const e=await a.bytes(),n=e.reduce(((t,e)=>t+e.length),0)+ks*e.length,i=new Uint8Array(n);let r=0;for(let t=0;t<e.length;t++){const n=e[t],s=new Uint8Array(new Uint32Array([n.length]).buffer);i.set(s,r),r+=ks,i.set(n,r),r+=n.length}t(i)}));i.push(t)}else i.push(a.data());null!=e&&(l.group=e),n.push(l)}return{data:_s(await Promise.all(i)),specs:n}}function Ts(t,e){const n=new Ss(t),i={};let r,s=0;for(const t of e){const e=t.name,o=t.dtype,a=t.shape,l=d(a);let c;if("quantization"in t){const i=t.quantization;if("uint8"===i.dtype||"uint16"===i.dtype){if(!("min"in i)||!("scale"in i))throw new Error(`Weight ${t.name} with quantization ${i.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==i.dtype)throw new Error(`Weight ${t.name} has unknown quantization dtype ${i.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${t.name} is quantized with ${i.dtype} which only supports weights of type float32 not ${o}.`)}const a=ws[i.dtype],u=n.slice(s,s+l*a),h="uint8"===i.dtype?new Uint8Array(u):new Uint16Array(u);if("float32"===o)if("uint8"===i.dtype||"uint16"===i.dtype){c=new Float32Array(h.length);for(let t=0;t<h.length;t++){const e=h[t];c[t]=e*i.scale+i.min}}else{if("float16"!==i.dtype)throw new Error(`Unsupported quantization type ${i.dtype} for weight type float32.`);void 0===r&&(r=Ls()),c=r(h)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${e}': ${o}`);if("uint8"!==i.dtype&&"uint16"!==i.dtype)throw new Error(`Unsupported quantization type ${i.dtype} for weight type int32.`);c=new Int32Array(h.length);for(let t=0;t<h.length;t++){const e=h[t];c[t]=Math.round(e*i.scale+i.min)}}s+=l*a}else if("string"===o){const e=d(t.shape);c=[];for(let t=0;t<e;t++){const t=new Uint32Array(n.slice(s,s+ks))[0];s+=ks;const e=new Uint8Array(n.slice(s,s+t));c.push(e),s+=t}}else{const t=ws[o],r=n.slice(s,s+l*t);if("float32"===o)c=new Float32Array(r);else if("int32"===o)c=new Int32Array(r);else if("bool"===o)c=new Uint8Array(r);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${e}': ${o}`);{c=new Float32Array(r);const t=new Float32Array(c.length/2),n=new Float32Array(c.length/2);for(let e=0;e<t.length;e++)t[e]=c[2*e],n[e]=c[2*e+1];const s=xs(t,a,"float32"),o=xs(n,a,"float32");i[e]=bs(s,o),s.dispose(),o.dispose()}}s+=l*t}"complex64"!==o&&(i[e]=xs(c,a,o))}return i}function _s(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach((t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)}));const i=new Uint8Array(e);let r=0;return n.forEach((t=>{i.set(new Uint8Array(t.buffer),r),r+=t.byteLength})),i.buffer}const Es="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function Ms(t){return Es?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function $s(t){return Ss.join(t)}function Is(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);const e=t.split("/");return e[e.length-1]}function As(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(n.initializerSignature=t.initializerSignature),null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),n}function Ns(t,e,n){const i={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(i.trainingConfig=t.trainingConfig),null!=t.weightsManifest){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");i.weightSpecs=e,i.weightData=n}return null!=t.signature&&(i.signature=t.signature),null!=t.userDefinedMetadata&&(i.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(i.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(i.initializerSignature=t.initializerSignature),i}async function Rs(t,e){let n,i;return null!=t.weightsManifest&&([n,i]=await e(t.weightsManifest)),Ns(t,n,i)}function Ps(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:Ms(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:Ms(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:new Ss(t.weightData).byteLength}}function Os(t){const e=[];for(const n of t)e.push(...n.weights);return e}function Ls(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0==(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return i=>{const r=new ArrayBuffer(4*i.length),s=new Uint32Array(r);for(let r=0;r<i.length;r++){const o=i[r],a=t[n[o>>10]+(1023&o)]+e[o>>10];s[r]=a}return new Float32Array(r)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ds{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Ds.instance&&(Ds.instance=new Ds),Ds.instance}static registerSaveRouter(t){Ds.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Ds.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Ds.getHandlers(t,"save")}static getLoadHandlers(t,e){return Ds.getHandlers(t,"load",e)}static getHandlers(t,e,n){const i=[];return("load"===e?Ds.getInstance().loadRouters:Ds.getInstance().saveRouters).forEach((e=>{const r=e(t,n);null!==r&&i.push(r)})),i}}const Fs=t=>Ds.getSaveHandlers(t),zs=(t,e)=>Ds.getLoadHandlers(t,e)
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */,Bs="tensorflowjs",Us="models_store",Vs="model_info_store";function Ws(){if(!Y().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Hs(t){const e=t.result;e.createObjectStore(Us,{keyPath:"modelPath"}),e.createObjectStore(Vs,{keyPath:"modelPath"})}class js{constructor(t){if(this.indexedDB=Ws(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const i=this.indexedDB.open(Bs,1);i.onupgradeneeded=()=>Hs(i),i.onsuccess=()=>{const r=i.result;if(null==e){const e=r.transaction(Us,"readonly"),i=e.objectStore(Us).get(this.modelPath);i.onsuccess=()=>{if(null==i.result)return r.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(i.result.modelArtifacts)},i.onerror=t=>(r.close(),n(i.error)),e.oncomplete=()=>r.close()}else{e.weightData=Ss.join(e.weightData);const i=Ps(e),s=r.transaction(Vs,"readwrite");let o,a,l=s.objectStore(Vs);try{o=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(t){return n(t)}o.onsuccess=()=>{a=r.transaction(Us,"readwrite");const o=a.objectStore(Us);let c;try{c=o.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:i})}catch(t){return n(t)}c.onsuccess=()=>t({modelArtifactsInfo:i}),c.onerror=t=>{l=s.objectStore(Vs);const e=l.delete(this.modelPath);e.onsuccess=()=>(r.close(),n(c.error)),e.onerror=t=>(r.close(),n(c.error))}},o.onerror=t=>(r.close(),n(o.error)),s.oncomplete=()=>{null==a?r.close():a.oncomplete=()=>r.close()}}},i.onerror=t=>n(i.error)}))}}js.URL_SCHEME="indexeddb://";const Gs=t=>{return Y().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(js.URL_SCHEME)?(e=t.slice(js.URL_SCHEME.length),new js(e)):null;var e};Ds.registerSaveRouter(Gs),Ds.registerLoadRouter(Gs);class qs{constructor(){this.indexedDB=Ws()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(Bs,1);n.onupgradeneeded=()=>Hs(n),n.onsuccess=()=>{const i=n.result,r=i.transaction(Vs,"readonly"),s=r.objectStore(Vs).getAll();s.onsuccess=()=>{const e={};for(const t of s.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},s.onerror=t=>(i.close(),e(s.error)),r.oncomplete=()=>i.close()},n.onerror=t=>e(n.error)}))}async removeModel(t){return t=function(t){return t.startsWith(js.URL_SCHEME)?t.slice(js.URL_SCHEME.length):t}(t),new Promise(((e,n)=>{const i=this.indexedDB.open(Bs,1);i.onupgradeneeded=()=>Hs(i),i.onsuccess=()=>{const r=i.result,s=r.transaction(Vs,"readwrite"),o=s.objectStore(Vs),a=o.get(t);let l;a.onsuccess=()=>{if(null==a.result)return r.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const i=o.delete(t),s=()=>{l=r.transaction(Us,"readwrite");const i=l.objectStore(Us).delete(t);i.onsuccess=()=>e(a.result.modelArtifactsInfo),i.onerror=t=>n(a.error)};i.onsuccess=s,i.onerror=t=>(s(),r.close(),n(a.error))}},a.onerror=t=>(r.close(),n(a.error)),s.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}},i.onerror=t=>n(i.error)}))}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xs="/",Ks="tensorflowjs_models",Ys="info",Zs="model_topology",Js="weight_specs",Qs="weight_data",to="model_metadata";function eo(t){return{info:[Ks,t,Ys].join(Xs),topology:[Ks,t,Zs].join(Xs),weightSpecs:[Ks,t,Js].join(Xs),weightData:[Ks,t,Qs].join(Xs),modelMetadata:[Ks,t,to].join(Xs)}}function no(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function io(t){const e=t.split(Xs);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(Xs)}class ro{constructor(t){if(!Y().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=eo(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),i=Ps(t),r=Ss.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(Es)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let t=0,i=e.length;t<i;t++)n+=String.fromCharCode(e[t]);return btoa(n)}(r));const s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,initializerSignature:null!=t.initializerSignature?t.initializerSignature:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:i}}catch(t){throw no(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==i)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=i;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const t=JSON.parse(r);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(e.initializerSignature=t.initializerSignature),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if(Es){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let t=0;t<e.length;++t)n.set([e.charCodeAt(t)],t);return n.buffer}(s),e}}ro.URL_SCHEME="localstorage://";const so=t=>{return Y().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ro.URL_SCHEME)?(e=t.slice(ro.URL_SCHEME.length),new ro(e)):null;var e};Ds.registerSaveRouter(so),Ds.registerLoadRouter(so);class oo{constructor(){c(Y().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),c("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=Ks+Xs,n=Xs+Ys;for(let i=0;i<this.LS.length;++i){const r=this.LS.key(i);if(r.startsWith(e)&&r.endsWith(n)){t[io(r)]=JSON.parse(this.LS.getItem(r))}}return t}async removeModel(t){t=function(t){return t.startsWith(ro.URL_SCHEME)?t.slice(ro.URL_SCHEME.length):t}(t);const e=eo(t);if(null==this.LS.getItem(e.info))throw new Error(`Cannot find model at path '${t}'`);const n=JSON.parse(this.LS.getItem(e.info));return no(e),n}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ao="://";class lo{constructor(){this.managers={}}static getInstance(){return null==lo.instance&&(lo.instance=new lo),lo.instance}static registerManager(t,e){c(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(ao)&&(t=t.slice(0,t.indexOf(ao))),c(t.length>0,(()=>"scheme must not be an empty string."));const n=lo.getInstance();c(null==n.managers[t],(()=>`A model store manager is already registered for scheme '${t}'.`)),n.managers[t]=e}static getManager(t){const e=lo.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(lo.getInstance().managers)}}function co(t){if(-1===t.indexOf(ao))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${lo.getSchemes().join(",")}`);return{scheme:t.split(ao)[0],path:t.split(ao)[1]}}async function uo(t,e,n=!1){c(t!==e,(()=>`Old path and new path are the same: '${t}'`));const i=Ds.getLoadHandlers(t);c(i.length>0,(()=>`Copying failed because no load handler is found for source URL ${t}.`)),c(i.length<2,(()=>`Copying failed because more than one (${i.length}) load handlers for source URL ${t}.`));const r=i[0],s=Ds.getSaveHandlers(e);c(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${e}.`)),c(s.length<2,(()=>`Copying failed because more than one (${i.length}) save handlers for destination URL ${e}.`));const o=s[0],a=co(t).scheme,l=co(t).path,u=a===co(t).scheme,h=await r.load();n&&u&&await lo.getManager(a).removeModel(l);const d=await o.save(h);return n&&!u&&await lo.getManager(a).removeModel(l),d.modelArtifactsInfo}async function ho(){const t=lo.getSchemes(),e={};for(const n of t){const t=await lo.getManager(n).listModels();for(const i in t){e[n+ao+i]=t[i]}}return e}async function po(t){const e=co(t);return lo.getManager(e.scheme).removeModel(e.path)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class fo{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){"undefined"!=typeof window&&Y().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(t=>{if(t.source===window&&t.data.name===this.messageName){t.stopPropagation();(0,this.functionRefs[t.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(t,e)}isTypedArray(t){return Ci(t)}}if(Y().get("IS_BROWSER")){Y().setPlatform("browser",new fo);try{lo.registerManager(ro.URL_SCHEME,new oo)}catch(t){}try{lo.registerManager(js.URL_SCHEME,new qs)}catch(t){}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mo=()=>require("node-fetch");let go;class yo{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Y().global.fetch?Y().global.fetch(t,e):(null==go&&(go=mo()),go(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bo(t,e="float32",n){return e=e||"float32",W(t),new Nr(t,e,n)}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Y().get("IS_NODE")&&!Y().get("IS_BROWSER")&&Y().setPlatform("node",new yo);const vo=ys({cast_:function(t,e){const n=fs(t,"x","cast");if(!_(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const i={x:n},r={dtype:e};return rs.runKernel(Tt,i,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xo=ys({clone_:function(t){const e={x:fs(t,"x","clone","string_or_numeric")};return rs.runKernel(ye,e)}});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wo(t,e=!1){console.log(t.toString(e))}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */is();function So(){return rs}function ko(){return rs.memory()}function Co(t,e){return rs.tidy(t,e)}function To(t){Zr(t).forEach((t=>t.dispose()))}function _o(t){return rs.keep(t)}function Eo(){return rs.ready()}function Mo(){return rs.backendName}function $o(t,e,n=1){return rs.registerBackend(t,e,n)}function Io(){return rs.backend}Pr={buffer:bo,cast:vo,clone:xo,print:wo};const Ao=ys({add_:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t,e){let n=fs(t,"a","add"),i=fs(e,"b","add");[n,i]=Xr(n,i);const r={a:n,b:i};return rs.runKernel(rt,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const No=ys({floorDiv_:function(t,e){let n=fs(t,"a","floorDiv"),i=fs(e,"b","floorDiv");[n,i]=Xr(n,i);const r={a:n,b:i};return rs.runKernel(he,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ro=ys({div_:function(t,e){let n=fs(t,"a","div"),i=fs(e,"b","div");if([n,i]=Xr(n,i),"int32"===n.dtype&&"int32"===i.dtype)return No(n,i);const r={a:n,b:i};return rs.runKernel(Jt,r,{})}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Po=ys({mul_:function(t,e){let n=fs(t,"a","mul"),i=fs(e,"b","mul");[n,i]=Xr(n,i);const r={a:n,b:i};return rs.runKernel(Xe,r)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oo=ys({abs_:function(t){const e=fs(t,"x","abs");if("complex64"===e.dtype){const t={x:e};return rs.runKernel($t,t)}{const t={x:e};return rs.runKernel(et,t)}}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lo=ys({acos_:function(t){const e={x:fs(t,"x","acos")};return rs.runKernel(nt,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Do=ys({acosh_:function(t){const e={x:fs(t,"x","acosh")};return rs.runKernel(it,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fo=ys({addN_:function(t){c(Array.isArray(t),(()=>"The argument passed to tf.addN() must be a list of tensors")),c(t.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`));const e=t.map(((t,e)=>fs(t,`tensors${e}`,"addN"))),n=e[0];e.forEach((t=>{if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),e.forEach((t=>{if(!m(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const i=e;return rs.runKernel(st,i)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zo=ys({all_:function(t,e=null,n=!1){const i={x:fs(t,"x","all","bool")},r={axis:e,keepDims:n};return rs.runKernel(ot,i,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bo=ys({any_:function(t,e=null,n=!1){const i={x:fs(t,"x","any","bool")},r={axis:e,keepDims:n};return rs.runKernel(at,i,r)}});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uo=ys({argMax_:function(t,e=0){const n={x:fs(t,"x","argMax")},i={axis:e};return rs.runKernel(lt,n,i)}});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vo=ys({argMin_:function(t,e=0){const n={x:fs(t,"x","argMin")},i={axis:e};return rs.runKernel(ct,n,i)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wo=ys({asin_:function(t){const e={x:fs(t,"x","asin")};return rs.runKernel(ut,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ho=ys({asinh_:function(t){const e={x:fs(t,"x","asinh")};return rs.runKernel(ht,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jo=ys({atan_:function(t){const e={x:fs(t,"x","atan")};return rs.runKernel(dt,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Go=ys({atan2_:function(t,e){let n=fs(t,"a","atan2"),i=fs(e,"b","atan2");[n,i]=Xr(n,i);const r={a:n,b:i};return rs.runKernel(ft,r)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qo=ys({atanh_:function(t){const e={x:fs(t,"x","atanh")};return rs.runKernel(pt,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xo(t,e,n,i,r="NHWC",s){return Zo(t,[...e,t[3]],n,s,i,null,null,aa(r))}function Ko(t,e,n,i,r,s,o="channelsLast"){const[a,l]=ta(e);let c;if("channelsLast"===o)c=[a,l,t[3],t[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);c=[a,l,t[1],t[1]]}return Zo(t,c,n,i,r,s,!1,o)}function Yo(t,e,n,i,r,s,o="NDHWC"){const[a,l,c]=ea(e);let u,h;if("NDHWC"===o)h="channelsLast",u=[a,l,c,t[4],t[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);h="channelsFirst",u=[a,l,c,t[1],t[1]]}return Jo(t,u,n,i,r,!1,h,s)}function Zo(t,e,n,i,r,s,o=!1,a="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if("channelsLast"===a)[l,c,u,h]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,h,c,u]=t}const[d,p,,f]=e,[m,g]=ta(n),[y,b]=ta(i),v=na(d,y),x=na(p,b),{padInfo:w,outHeight:S,outWidth:k}=function(t,e,n,i,r,s,o,a,l){let c,u,h;if("number"==typeof t){c={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const r=function(t,e,n,i,r){null==i&&(i=Qo(t,e,n));const s=t[0],o=t[1],a=ia((s-e+2*i)/n+1,r),l=ia((o-e+2*i)/n+1,r);return[a,l]}([e,n],s,i,t,a);u=r[0],h=r[1]}else if("same"===t){u=Math.ceil(e/i),h=Math.ceil(n/r);const t=Math.max(0,(u-1)*i+s-e),a=Math.max(0,(h-1)*r+o-n),l=Math.floor(t/2),d=t-l,p=Math.floor(a/2);c={top:l,bottom:d,left:p,right:a-p,type:"SAME"}}else if("valid"===t)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-s+1)/i),h=Math.ceil((n-o+1)/r);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],m="channelsLast"===l?t[2][1]:t[3][1];c={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},u=ia((e-s+d+p)/i+1,a),h=ia((n-o+f+m)/r+1,a)}}return{padInfo:c,outHeight:u,outWidth:h}}(r,c,u,m,g,v,x,s,a),C=o?f*h:f;let T;return"channelsFirst"===a?T=[l,C,S,k]:"channelsLast"===a&&(T=[l,S,k,C]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:h,outHeight:S,outWidth:k,outChannels:C,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:t,outShape:T,filterShape:e}}function Jo(t,e,n,i,r,s=!1,o="channelsLast",a){let[l,c,u,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,c,u,h,d]=t;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,c,u,h]=t}const[p,f,m,,g]=e,[y,b,v]=ea(n),[x,w,S]=ea(i),k=na(p,x),C=na(f,w),T=na(m,S),{padInfo:_,outDepth:E,outHeight:M,outWidth:$}=function(t,e,n,i,r,s,o,a,l,c,u){let h,d,p,f;"valid"===t&&(t=0);if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const m=function(t,e,n,i,r,s){null==r&&(r=Qo(t,e[0],i[0]));const o=[0,0,0,n];for(let n=0;n<3;n++)t[n]+2*r>=e[n]&&(o[n]=ia((t[n]-e[n]+2*r)/i[n]+1,s));return o}([e,n,i,1],[a,l,c],1,[r,s,o],t,u);d=m[0],p=m[1],f=m[2]}else{if("same"!==t)throw Error(`Unknown padding parameter: ${t}`);{d=Math.ceil(e/r),p=Math.ceil(n/s),f=Math.ceil(i/o);const t=(d-1)*r+a-e,u=(p-1)*s+l-n,m=(f-1)*o+c-i,g=Math.floor(t/2),y=t-g,b=Math.floor(u/2),v=u-b,x=Math.floor(m/2);h={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(r,c,u,h,y,b,v,k,C,T,a),I=s?g*d:g;let A;return"channelsFirst"===o?A=[l,I,E,M,$]:"channelsLast"===o&&(A=[l,E,M,$,I]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:E,outHeight:M,outWidth:$,outChannels:I,padInfo:_,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:C,effectiveFilterWidth:T,dilationDepth:x,dilationHeight:w,dilationWidth:S,inShape:t,outShape:A,filterShape:e}}function Qo(t,e,n,i=1){const r=na(e,i);return Math.floor((t[0]*(n-1)-n+r)/2)}function ta(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function ea(t){return"number"==typeof t?[t,t,t]:t}function na(t,e){return e<=1?t:t+(t-1)*(e-1)}function ia(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function ra(t){const[e,n,i]=ta(t);return 1===e&&1===n&&1===i}function sa(t,e){return ra(t)||ra(e)}function oa(t){return ta(t).every((t=>t>0))}function aa(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function la(t,e,n){if(null!=n){if("string"==typeof e)throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if("number"==typeof e)c(g(e),(()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`));else{if("object"!=typeof e)throw Error(`Error in ${t}: Unknown padding parameter: ${e}`);e.forEach((e=>{e.forEach((e=>{c(g(e),(()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`))}))}))}}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ca=ys({reshape_:function(t,e){const n={x:fs(t,"x","reshape","string_or_numeric")},i={shape:e};return rs.runKernel(mn,n,i)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ua=ys({avgPool_:function(t,e,n,i,r){const s=fs(t,"x","avgPool","float32");c(sa(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let o=s,a=!1;3===s.rank&&(a=!0,o=ca(s,[1,s.shape[0],s.shape[1],s.shape[2]])),c(4===o.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`)),la("avgPool",i,r);const l={x:o},u={filterSize:e,strides:n,pad:i,dimRoundingMode:r};let h=rs.runKernel(mt,l,u);return h=vo(h,s.dtype),a?ca(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ha=ys({avgPool3d_:function(t,e,n,i,r,s="NDHWC"){const o=fs(t,"x","avgPool3d","float32");let a=o,l=!1;4===o.rank&&(l=!0,a=ca(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),c(5===a.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`)),c("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),c("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),la("avgPool3d",i,r);const u={x:a},h={filterSize:e,strides:n,pad:i,dimRoundingMode:r,dataFormat:s};let d=rs.runKernel(yt,u,h);return d=vo(d,a.dtype),l?ca(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const da=ys({concat_:function(t,e=0){c(t.length>=1,(()=>"Pass at least one tensor to concat"));const n=ms(t,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)})),1===n.length)return xo(n[0]);const i=n,r={axis:e};return rs.runKernel(It,i,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pa=ys({matMul_:function(t,e,n=!1,i=!1){let r=fs(t,"a","matMul"),s=fs(e,"b","matMul");[r,s]=Xr(r,s);const o={a:r,b:s},a={transposeA:n,transposeB:i};return rs.runKernel(vt,o,a)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fa=ys({sigmoid_:function(t){const e={x:fs(t,"x","sigmoid","float32")};return rs.runKernel(Rn,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ma=ys({slice_:function(t,e,n){const i=fs(t,"x","slice","string_or_numeric");if(0===i.rank)throw new Error("Slicing scalar is not possible");const r={x:i},s={begin:e,size:n};return rs.runKernel($n,r,s)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ga=ys({tanh_:function(t){const e={x:fs(t,"x","tanh","float32")};return rs.runKernel(ti,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ya=ys({basicLSTMCell_:function(t,e,n,i,r,s){const o=fs(t,"forgetBias","basicLSTMCell"),a=fs(e,"lstmKernel","basicLSTMCell"),l=fs(n,"lstmBias","basicLSTMCell"),c=fs(i,"data","basicLSTMCell"),u=fs(r,"c","basicLSTMCell"),h=fs(s,"h","basicLSTMCell"),d=da([c,h],1),p=pa(d,a),f=Ao(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=ma(f,[0,0],y),v=ma(f,[0,g],y),x=ma(f,[0,2*g],y),w=ma(f,[0,3*g],y),S=Ao(Po(fa(b),ga(v)),Po(u,fa(Ao(o,x))));return[S,Po(ga(S),fa(w))]}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ba=ys({batchToSpaceND_:function(t,e,n){const i=fs(t,"x","batchToSpaceND"),r=e.reduce(((t,e)=>t*e));c(i.rank>=1+e.length,(()=>`input rank is ${i.rank} but should be > than blockShape.length ${e.length}`)),c(n.length===e.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`)),c(i.shape[0]%r==0,(()=>`input tensor batch is ${i.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`));const s={x:i},o={blockShape:e,crops:n};return rs.runKernel(xt,s,o)}});const va=ys({batchNorm_:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t,e,n,i,r,s){null==s&&(s=.001);const o=fs(t,"x","batchNorm"),a=fs(e,"mean","batchNorm"),l=fs(n,"variance","batchNorm");let u,h;null!=r&&(u=fs(r,"scale","batchNorm")),null!=i&&(h=fs(i,"offset","batchNorm")),c(a.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),c(null==h||a.rank===h.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),c(null==u||a.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d=function(t){let e;return e=0===t.rank||1===t.rank?ca(t,[1,1,1,t.size]):2===t.rank?ca(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?ca(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(o),p={x:d,scale:u,offset:h,mean:a,variance:l},f={varianceEpsilon:s},m=rs.runKernel(de,p,f);return ca(m,o.shape)}});const xa=ys({batchNorm2d_:function(t,e,n,i,r,s){const o=fs(t,"x","batchNorm"),a=fs(e,"mean","batchNorm"),l=fs(n,"variance","batchNorm");let u,h;return null!=r&&(u=fs(r,"scale","batchNorm")),null!=i&&(h=fs(i,"offset","batchNorm")),c(2===o.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`)),c(2===a.rank||1===a.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`)),c(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&c(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=h&&c(2===h.rank||1===h.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`)),va(o,a,l,h,u,s)}});const wa=ys({batchNorm3d_:function(t,e,n,i,r,s){const o=fs(t,"x","batchNorm"),a=fs(e,"mean","batchNorm"),l=fs(n,"variance","batchNorm");let u,h;return null!=r&&(u=fs(r,"scale","batchNorm")),null!=i&&(h=fs(i,"offset","batchNorm")),c(3===o.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`)),c(3===a.rank||1===a.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`)),c(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&c(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=h&&c(3===h.rank||1===h.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`)),va(o,a,l,h,u,s)}});const Sa=ys({batchNorm4d_:function(t,e,n,i,r,s){const o=fs(t,"x","batchNorm"),a=fs(e,"mean","batchNorm"),l=fs(n,"variance","batchNorm");let u,h;return null!=r&&(u=fs(r,"scale","batchNorm")),null!=i&&(h=fs(i,"offset","batchNorm")),c(4===o.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`)),c(4===a.rank||1===a.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`)),c(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&c(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=h&&c(4===h.rank||1===h.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`)),va(o,a,l,h,u,s)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ka=ys({bincount_:function(t,e,n){const i=fs(t,"x","bincount"),r=fs(e,"weights","bincount");c("int32"===i.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${i.dtype}`)),c(n>=0,(()=>`size must be non-negative, but got ${n}.`)),c(r.size===i.size||0===r.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${i.shape}, weights shape: ${r.shape}.`));const s={x:i,weights:r},o={size:n};return rs.runKernel(wt,s,o)}});
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ca=ys({bitwiseAnd_:function(t,e){const n=fs(t,"x","bitwiseAnd"),i=fs(e,"y","bitwiseAnd");if(!m(n.shape,i.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${i.shape}`);if("int32"!==n.dtype||"int32"!==i.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${i.dtype}`);const r={a:n,b:i};return rs.runKernel(St,r)}});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ta=ys({broadcastArgs_:function(t,e){const n=fs(t,"s0","broadcastArgs","int32"),i=fs(e,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==i.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${i.rank}`);const r={s0:n,s1:i};return rs.runKernel(Ct,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _a=ys({broadcastTo_:function(t,e){let n=fs(t,"broadcastTo","x");const i=n.shape;if(W(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=ca(n,t)}const r=n.shape,s=Array.from(e);for(let t=e.length-1;t>=0;t--)if(r[t]===e[t])s[t]=1;else if(1!==n.shape[t])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${e}].`);const o=s.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0));if(0===o.length)return xo(n);const a={x:n},l={reps:s};return rs.runKernel(ei,a,l)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ea=ys({ceil_:function(t){const e={x:fs(t,"x","ceil","float32")};return rs.runKernel(_t,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ma(t,e,n){W(t);const i={shape:t,value:e,dtype:n=n||R(e)};return rs.runKernel(le,{},i)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $a=ys({clipByValue_:function(t,e,n){const i=fs(t,"x","clipByValue");if(c(e<=n,(()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`)),e===n)return Ma(i.shape,e,i.dtype);const r={x:i},s={clipValueMin:e,clipValueMax:n};return rs.runKernel(Et,r,s)}});const Ia=ys({concat1d_:function(t){return da(t,0)}});const Aa=ys({concat2d_:function(t,e){return da(t,e)}});const Na=ys({concat3d_:function(t,e){return da(t,e)}});const Ra=ys({concat4d_:function(t,e){return da(t,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pa=ys({conv2d_:function(t,e,n,i,r="NHWC",s=[1,1],o){const a=fs(t,"x","conv2d","float32"),l=fs(e,"filter","conv2d","float32");let u=a,h=!1;3===a.rank&&(h=!0,u=ca(a,[1,a.shape[0],a.shape[1],a.shape[2]])),c(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),c(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),la("conv2d",i,o);const d="NHWC"===r?u.shape[3]:u.shape[1];c(d===l.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`)),c(sa(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),c(oa(s),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),c(oa(n),(()=>"Error in conv2D: Strides should be larger than 0."));const p={x:u,filter:l},f={strides:n,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o},m=rs.runKernel(At,p,f);return h?ca(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const Oa=ys({conv1d_:function(t,e,n,i,r="NWC",s=1,o){const a=fs(t,"x","conv1d"),l=fs(e,"filter","conv1d");let u=a,h=!1;2===a.rank&&(h=!0,u=ca(a,[1,a.shape[0],a.shape[1]])),c(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),c(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),la("conv1d",i,o),c(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),c(sa(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),c(oa(s),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),c(oa(n),(()=>"Error in conv1D: Stride should be larger than 0.")),c("NWC"===r,(()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`));const d=ca(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=ca(u,[u.shape[0],1,u.shape[1],u.shape[2]]),f=Pa(p,d,[1,n],i,"NHWC",[1,s],o);return ca(f,h?[f.shape[2],f.shape[3]]:[f.shape[0],f.shape[2],f.shape[3]])}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const La=ys({conv2DBackpropInput_:function(t,e,n,i,r,s="NHWC",o){c(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let a=t,l=e,u=!1;3===e.rank&&(u=!0,l=ca(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),c(4===a.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`)),c(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),c(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const h="NHWC"===s?a[3]:a[1],d="NHWC"===s?l.shape[3]:l.shape[1];c(h===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${n.shape[2]}.`)),c(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),la("conv2dDerInput",r,o);const p={dy:l,filter:n},f={strides:i,pad:r,dataFormat:s,dimRoundingMode:o,inputShape:a},m=rs.runKernel(Rt,p,f);return u?ca(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const Da=ys({conv2dTranspose_:function(t,e,n,i,r,s){const o=fs(t,"x","conv2dTranspose"),a=fs(e,"filter","conv2dTranspose");return La(n,o,a,i,r,"NHWC",s)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fa=ys({conv3d_:function(t,e,n,i,r="NDHWC",s=[1,1,1]){const o=fs(t,"x","conv3d"),a=fs(e,"filter","conv3d");let l=o,u=!1;4===o.rank&&(u=!0,l=ca(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),c(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),c(5===a.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`)),c(l.shape[4]===a.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`)),c(sa(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),c("NDHWC"===r,(()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`)),c(oa(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),c(oa(n),(()=>"Error in conv3D: Strides should be larger than 0."));const h={x:l,filter:a},d={strides:n,pad:i,dataFormat:r,dilations:s},p=rs.runKernel(Pt,h,d);return u?ca(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const za=ys({conv3DBackpropInput_:function(t,e,n,i,r){c(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let s=t,o=e,a=!1;4===e.rank&&(a=!0,o=ca(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);const l=s[4],u=o.shape[4];c(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),c(5===o.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`)),c(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),c(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),c(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const h={dy:o,filter:n},d={pad:r,strides:i,inputShape:s},p=rs.runKernel(Lt,h,d);return a?ca(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}});const Ba=ys({conv3dTranspose_:function(t,e,n,i,r){const s=fs(t,"x","conv3dTranspose"),o=fs(e,"filter","conv3dTranspose");return za(n,s,o,i,r)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ua=ys({cos_:function(t){const e={x:fs(t,"x","cos","float32")};return rs.runKernel(Dt,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Va=ys({cosh_:function(t){const e={x:fs(t,"x","cosh","float32")};return rs.runKernel(Ft,e)}});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wa=ys({cumprod_:function(t,e=0,n=!1,i=!1){const r={x:fs(t,"x","cumprod")},s={axis:e,exclusive:n,reverse:i};return rs.runKernel(zt,r,s)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ha=ys({cumsum_:function(t,e=0,n=!1,i=!1){const r={x:fs(t,"x","cumsum")},s={axis:e,exclusive:n,reverse:i};return rs.runKernel(Bt,r,s)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ja=ys({denseBincount_:function(t,e,n,i=!1){const r=fs(t,"x","denseBincount"),s=fs(e,"weights","denseBincount");c("int32"===r.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`)),c(r.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`)),c(n>=0,(()=>`size must be non-negative, but got ${n}.`)),c(s.size===r.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`));const o={x:r,weights:s},a={size:n,binaryOutput:i};return rs.runKernel(Vt,o,a)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ga=ys({depthToSpace_:function(t,e,n="NHWC"){const i=fs(t,"x","depthToSpace","float32"),r="NHWC"===n?i.shape[1]:i.shape[2],s="NHWC"===n?i.shape[2]:i.shape[3],o="NHWC"===n?i.shape[3]:i.shape[1];c(e>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`)),c(r*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${e}  for depthToSpace with input shape\n    ${i.shape}`)),c(s*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${e} for depthToSpace with input shape\n        ${i.shape}`)),c(o%(e*e)==0,(()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${i.shape}`));const a={x:i},l={blockSize:e,dataFormat:n};return rs.runKernel(Wt,a,l)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qa=ys({depthwiseConv2d_:function(t,e,n,i,r="NHWC",s=[1,1],o){const a=fs(t,"x","depthwiseConv2d","float32"),l=fs(e,"filter","depthwiseConv2d","float32");let u=a,h=!1;3===a.rank&&(h=!0,u=ca(a,[1,a.shape[0],a.shape[1],a.shape[2]])),c(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),c(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));const d="NHWC"===r?u.shape[3]:u.shape[1];c(d===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`)),la("depthwiseConv2d",i,o);const p={x:u,filter:l},f={strides:n,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o},m=rs.runKernel(Ht,p,f);return h?ca(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xa=ys({diag_:function(t){const e={x:fs(t,"x","diag")};return rs.runKernel(qt,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ka=ys({dilation2d_:function(t,e,n,i,r=[1,1],s="NHWC"){const o=fs(t,"x","dilation2d"),a=fs(e,"filter","dilation2d");c(3===o.rank||4===o.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`)),c(3===a.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`)),c("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let l=o,u=!1;3===o.rank&&(l=ca(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0),c(l.shape[3]===a.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`));const h={x:l,filter:a},d={strides:n,pad:i,dilations:r},p=rs.runKernel(Xt,h,d);return u?ca(p,[p.shape[1],p.shape[2],p.shape[3]]):p}});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ya(t,e){const n=t.length,i=[];for(let r=0;r<n;r++){const s=n-1-r,o=t[s]||1;(e[e.length-1-r]||1)>1&&1===o&&i.unshift(s)}return i}function Za(t,e){const n=[];for(let i=0;i<e.length;i++){const r=t[t.length-i-1],s=e.length-i-1,o=e[s];(null==r||1===r&&o>1)&&n.unshift(s)}return n}function Ja(t,e){const n=Math.max(t.length,e.length),i=new Array(n);for(let r=0;r<n;r++){let s=t[t.length-r-1];null==s&&(s=1);let o=e[e.length-r-1];if(null==o&&(o=1),1===s)i[n-r-1]=o;else if(1===o)i[n-r-1]=s;else{if(s!==o){throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`)}i[n-r-1]=s}}return i}var Qa=Object.freeze({__proto__:null,assertAndGetBroadcastShape:Ja,getBroadcastDims:Ya,getReductionAxes:Za});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tl=ys({equal_:function(t,e){let n=fs(t,"a","equal","string_or_numeric"),i=fs(e,"b","equal","string_or_numeric");[n,i]=Xr(n,i),Ja(n.shape,i.shape);const r={a:n,b:i};return rs.runKernel(ie,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const el=ys({where_:function(t,e,n){const i=fs(e,"a","where"),r=fs(n,"b","where"),s=fs(t,"condition","where","bool"),o=Ja(Ja(s.shape,i.shape),r.shape),a={condition:_a(s,o),t:_a(i,o),e:_a(r,o)};return rs.runKernel(En,a)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nl=ys({zerosLike_:function(t){const e={x:fs(t,"x","zerosLike")};return rs.runKernel(li,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const il=ys({divNoNan_:function(t,e){let n=fs(t,"a","div"),i=fs(e,"b","div");[n,i]=Xr(n,i);const r=Ro(n,i),s=nl(r),o=tl(i,s);return el(o,s,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rl=ys({dot_:function(t,e){const n=fs(t,"t1","dot"),i=fs(e,"t2","dot");c(!(1!==n.rank&&2!==n.rank||1!==i.rank&&2!==i.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${i.rank}.`));const r=1===n.rank?n.size:n.shape[1],s=1===i.rank?i.size:i.shape[0];if(c(r===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${s}.`)),1===n.rank&&1===i.rank){const t=ca(n,[1,-1]),e=ca(i,[-1,1]),r=pa(t,e);return ca(r,[])}if(1===n.rank&&2===i.rank){const t=ca(n,[1,-1]),e=ca(i,[i.shape[0],i.shape[1]]),r=pa(t,e);return ca(r,[r.size])}if(2===n.rank&&1===i.rank){const t=ca(i,[-1,1]),e=pa(n,t);return ca(e,[e.size])}{const t=ca(i,[i.shape[0],i.shape[1]]);return pa(n,t)}}});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sl=ys({einsum_:function(t,...e){const n=e.map(((t,e)=>fs(t,`tensors${e}`,"einsum"))),i={equation:t};return rs.runKernel(Qt,n,i)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ol=ys({elu_:function(t){const e={x:fs(t,"x","elu","float32")};return rs.runKernel(te,e)}});
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const al=ys({ensureShape_:function(t,e){const n=fs(t,"x","ensureShape","string_or_numeric");if(!f(n.shape,e))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${e}`);return t}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ll=ys({erf_:function(t){let e=fs(t,"x","erf");c("int32"===e.dtype||"float32"===e.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===e.dtype&&(e=vo(e,"float32"));const n={x:e};return rs.runKernel(ne,n)}});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cl(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function ul(t,e,n){const i=t.length+e.length,r=[];let s=0,o=0;for(let a=0;a<i;a++)-1===n.indexOf(a)?r.push(t[s++]):r.push(e[o++]);return r}function hl(t,e){const n=[],i=t.length;for(let r=0;r<i;r++)-1===e.indexOf(r)&&n.push(t[r]);return[n,e.map((e=>t[e]))]}function dl(t,e){return ul(t,e.map((t=>1)),e)}function pl(t,e,n){c(cl(e,n),(()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`))}function fl(t,e){if(cl(t,e))return null;const n=[];for(let i=0;i<e;++i)-1===t.indexOf(i)&&n.push(i);return t.forEach((t=>n.push(t))),n}function ml(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}function gl(t,e){const n=[];for(let i=e-t;i<e;++i)n.push(i);return n}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yl=ys({max_:function(t,e=null,n=!1){const i={x:fs(t,"x","max")},r={reductionIndices:e,keepDims:n};return rs.runKernel(Oe,i,r)}});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bl=ys({min_:function(t,e=null,n=!1){const i={x:fs(t,"x","min")},r={axis:e,keepDims:n};return rs.runKernel(We,i,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vl=ys({pow_:function(t,e){let n=fs(t,"base","pow"),i=fs(e,"exp","pow");[n,i]=Xr(n,i);const r={a:n,b:i};return rs.runKernel(sn,r)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xl(t,e){if((br(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&br(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return vs(t,[],[],e)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wl=ys({sqrt_:function(t){const e={x:fs(t,"x","sqrt","float32")};return rs.runKernel(On,e)}});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sl=ys({square_:function(t){const e=fs(t,"x","square");return rs.runKernel("Square",{x:e},{})}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kl=ys({sum_:function(t,e=null,n=!1){let i=fs(t,"x","sum");"bool"===i.dtype&&(i=vo(i,"int32"));const r={x:i},s={axis:e,keepDims:n};return rs.runKernel(Ln,r,s)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cl(t,e,n=null){if(0===t.rank)return Oo(t);if(1!==t.rank&&null===n)return Cl(ca(t,[-1]),e,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===e)return kl(Oo(t),n);if(e===1/0)return yl(Oo(t),n);if(e===-1/0)return bl(Oo(t),n);if("euclidean"===e||2===e)return wl(kl(vl(Oo(t),xl(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&2===n.length){if(1===e)return yl(kl(Oo(t),n[0]),n[1]-1);if(e===1/0)return yl(kl(Oo(t),n[1]),n[0]);if(e===-1/0)return bl(kl(Oo(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return wl(kl(Sl(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Tl=ys({norm_:function(t,e="euclidean",n=null,i=!1){const r=Cl(t=fs(t,"x","norm"),e,n);let s=r.shape;if(i){const e=w(n,t.shape);s=dl(r.shape,e)}return ca(r,s)}});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _l=ys({euclideanNorm_:function(t,e=null,n=!1){return Tl(t,"euclidean",e,n)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const El=ys({exp_:function(t){const e={x:fs(t,"x","exp")};return rs.runKernel(re,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ml=ys({expandDims_:function(t,e=0){const n=fs(t,"x","expandDims","string_or_numeric");c(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const i={input:n},r={dim:e};return rs.runKernel(se,i,r)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $l=ys({expm1_:function(t){const e={x:fs(t,"x","expm1")};return rs.runKernel(oe,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Il=ys({tile_:function(t,e){const n=fs(t,"x","tile","string_or_numeric");c(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`));const i={x:n},r={reps:e};return rs.runKernel(ei,i,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Al=ys({eye_:function(t,e,n,i="float32"){null==e&&(e=t);const r=bo([t,e],i),s=t<=e?t:e;for(let t=0;t<s;++t)r.set(1,t,t);const o=ca(r.toTensor(),[t,e]);if(null==n)return o;if(1===n.length)return Il(Ml(o,0),[n[0],1,1]);if(2===n.length)return Il(Ml(Ml(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return Il(Ml(Ml(Ml(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nl=ys({floor_:function(t){const e={x:fs(t,"x","floor","float32")};return rs.runKernel(ue,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rl=ys({gather_:function(t,e,n=0,i=0){const r={x:fs(t,"x","gather"),indices:fs(e,"indices","gather","int32")},s={axis:n,batchDims:i};return rs.runKernel(pe,r,s)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pl=ys({greater_:function(t,e){let n=fs(t,"a","greater","string_or_numeric"),i=fs(e,"b","greater","string_or_numeric");[n,i]=Xr(n,i),Ja(n.shape,i.shape);const r={a:n,b:i};return rs.runKernel(me,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ol=ys({greaterEqual_:function(t,e){let n=fs(t,"a","greaterEqual","string_or_numeric"),i=fs(e,"b","greaterEqual","string_or_numeric");[n,i]=Xr(n,i),Ja(n.shape,i.shape);const r={a:n,b:i};return rs.runKernel(ge,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ll=ys({imag_:function(t){const e={input:fs(t,"input","imag")};return rs.runKernel(ve,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dl=ys({isFinite_:function(t){const e={x:fs(t,"x","isFinite")};return rs.runKernel(xe,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fl=ys({isInf_:function(t){const e={x:fs(t,"x","isInf")};return rs.runKernel(we,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zl=ys({isNaN_:function(t){const e={x:fs(t,"x","isNaN")};return rs.runKernel(Se,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bl=ys({leakyRelu_:function(t,e=.2){const n={x:fs(t,"x","leakyRelu")},i={alpha:e};return rs.runKernel(ke,n,i)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ul=ys({less_:function(t,e){let n=fs(t,"a","less","string_or_numeric"),i=fs(e,"b","less","string_or_numeric");[n,i]=Xr(n,i),Ja(n.shape,i.shape);const r={a:n,b:i};return rs.runKernel(Ce,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vl=ys({lessEqual_:function(t,e){let n=fs(t,"a","lessEqual","string_or_numeric"),i=fs(e,"b","lessEqual","string_or_numeric");[n,i]=Xr(n,i),Ja(n.shape,i.shape);const r={a:n,b:i};return rs.runKernel(Te,r)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wl(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const i={start:t,stop:e,num:n};return rs.runKernel(_e,{},i)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hl=ys({localResponseNormalization_:function(t,e=5,n=1,i=1,r=.5){const s=fs(t,"x","localResponseNormalization");c(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),c(g(e),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`));let o=s,a=!1;3===s.rank&&(a=!0,o=ca(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:o},u={depthRadius:e,bias:n,alpha:i,beta:r},h=rs.runKernel(Re,l,u);return a?ca(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jl=ys({log_:function(t){const e={x:fs(t,"x","log","float32")};return rs.runKernel(Ee,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gl=ys({log1p_:function(t){const e={x:fs(t,"x","log1p")};return rs.runKernel(Me,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ql(t,e){c(P(t),(()=>"The f passed in variableGrads(f) must be a function")),c(null==e||Array.isArray(e)&&e.every((t=>t instanceof Dr)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=e;if(!n){e=[];for(const t in rs.registeredVariables)e.push(rs.registeredVariables[t])}const i=n?e.filter((t=>!t.trainable)):null,r=e.length;e=e.filter((t=>t.trainable)),c(e.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`));const{value:s,grads:o}=rs.gradients(t,e,null,!0);c(o.some((t=>null!=t)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),c(0===s.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`));const a={};return e.forEach(((t,e)=>{null!=o[e]&&(a[t.name]=o[e])})),null!=i&&i.forEach((t=>a[t.name]=null)),{value:s,grads:a}}function Xl(t){return rs.customGrad(t)}function Kl(t){const e=t.filter((t=>null==t)).length;if(e>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yl=ys({neg_:function(t){const e={x:fs(t,"x","neg")};return rs.runKernel(Ke,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zl=ys({softplus_:function(t){const e={x:fs(t,"x","softplus")};return rs.runKernel(Pn,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jl=ys({logSigmoid_:function(t){const e=fs(t,"x","logSigmoid"),n=Xl((t=>({value:Yl(Zl(Yl(t))),gradFunc:e=>Po(e,fa(Yl(t)))})));return n(e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ql=ys({sub_:function(t,e){let n=fs(t,"a","sub"),i=fs(e,"b","sub");[n,i]=Xr(n,i);const r={a:n,b:i};return rs.runKernel(Jn,r)}});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tc=ys({logSoftmax_:function(t,e=-1){const n=fs(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);const i=Xl(((t,n)=>{const i=yl(t,e,!0),r=Ql(t,i),s=Ql(vo(r,"float32"),jl(kl(El(r),e,!0)));n([s]);return{value:s,gradFunc:(t,n)=>{const[i]=n,r=El(i);return Ql(t,Po(kl(t,e,!0),r))}}}));return i(n)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ec=ys({logSumExp_:function(t,e=null,n=!1){const i=fs(t,"x","logSumExp"),r=w(e,i.shape),s=yl(i,r,!0),o=Ql(i,s),a=El(o),l=kl(a,r),c=jl(l),u=Ao(ca(s,c.shape),c);if(n){const t=dl(u.shape,r);return ca(u,t)}return u}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nc=ys({logicalAnd_:function(t,e){const n=fs(t,"a","logicalAnd","bool"),i=fs(e,"b","logicalAnd","bool");Ja(n.shape,i.shape);const r={a:n,b:i};return rs.runKernel($e,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ic=ys({logicalNot_:function(t){const e={x:fs(t,"x","logicalNot","bool")};return rs.runKernel(Ie,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rc=ys({logicalOr_:function(t,e){const n=fs(t,"a","logicalOr","bool"),i=fs(e,"b","logicalOr","bool");Ja(n.shape,i.shape);const r={a:n,b:i};return rs.runKernel(Ae,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sc=ys({logicalXor_:function(t,e){const n=fs(t,"a","logicalXor","bool"),i=fs(e,"b","logicalXor","bool");return Ja(n.shape,i.shape),nc(rc(t,e),ic(nc(t,e)))}}),oc=2147483648;
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ac=ys({searchSorted_:function(t,e,n="left"){const i=fs(t,"sortedSequence","searchSorted"),r=fs(e,"values","searchSorted"),s=i.shape[i.shape.length-1],o=r.shape[r.shape.length-1],a=ca(i,[-1,s]),l=ca(r,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(d(l.shape)>=oc)throw new Error("values tensor size must less than 2147483648");if(a.shape[1]>=oc)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${a.shape[1]}`);const c={sortedSequence:a,values:l},u={side:n};return rs.runKernel(_n,c,u)}});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lc(t,e){return ac(t,e,"left")}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cc=ys({maxPool_:function(t,e,n,i,r){const s=fs(t,"x","maxPool");let o=s,a=!1;3===s.rank&&(a=!0,o=ca(s,[1,s.shape[0],s.shape[1],s.shape[2]])),c(4===o.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`)),c(sa(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),la("maxPool",i,r);const l={x:o},u={filterSize:e,strides:n,pad:i,dimRoundingMode:r},h=rs.runKernel(De,l,u);return a?ca(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uc=ys({maxPool3d_:function(t,e=[1,1,1],n,i,r,s="NDHWC"){const o=fs(t,"x","maxPool3d");let a=o,l=!1;4===o.rank&&(l=!0,a=ca(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),c(5===a.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`)),c("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),la("maxPool3d",i,r);const u={x:a},h={filterSize:e,strides:n,pad:i,dimRoundingMode:r,dataFormat:s},d=rs.runKernel(ze,u,h);return l?ca(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hc=ys({maxPoolWithArgmax_:function(t,e,n,i,r=!1){const s={x:fs(t,"x","maxPoolWithArgmax")},o={filterSize:e,strides:n,pad:i,includeBatchInIndex:r},a=rs.runKernel(Ue,s,o);return{result:a[0],indexes:a[1]}}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dc=ys({maximum_:function(t,e){let n=fs(t,"a","maximum"),i=fs(e,"b","maximum");[n,i]=Xr(n,i),"bool"===n.dtype&&(n=vo(n,"int32"),i=vo(i,"int32")),Ja(n.shape,i.shape);const r={a:n,b:i};return rs.runKernel(Le,r)}});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pc=ys({mean_:function(t,e=null,n=!1){const i={x:fs(t,"x","mean")},r={axis:e,keepDims:n};return rs.runKernel(Ve,i,r)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fc(t,e="float32"){if(W(t),"complex64"===e){const e=fc(t,"float32"),n=fc(t,"float32");return bs(e,n)}const n=U(d(t),e);return rs.makeTensor(n,t,e)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mc(t,e="float32"){if(W(t),"complex64"===e){const e=mc(t,"float32"),n=fc(t,"float32");return bs(e,n)}const n=B(d(t),e);return rs.makeTensor(n,t,e)}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gc(t,e,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===t)return[];let i=fs(t,"x","meshgrid",t instanceof Or?t.dtype:"float32");if(void 0===e)return[i];let r=fs(e,"y","meshgrid",e instanceof Or?e.dtype:"float32");const s=d(i.shape),o=d(r.shape);return"xy"===n?(i=ca(i,[1,-1]),r=ca(r,[-1,1]),[pa(mc([o,1],i.dtype),i),pa(r,mc([1,s],r.dtype))]):(i=ca(i,[-1,1]),r=ca(r,[1,-1]),[pa(i,mc([1,o],i.dtype)),pa(mc([s,1],r.dtype),r)])}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yc=ys({minimum_:function(t,e){let n=fs(t,"a","minimum"),i=fs(e,"b","minimum");[n,i]=Xr(n,i),"bool"===n.dtype&&(n=vo(n,"int32"),i=vo(i,"int32")),Ja(n.shape,i.shape);const r={a:n,b:i};return rs.runKernel(He,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bc=ys({mirrorPad_:function(t,e,n){c("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const i=fs(t,"x","mirrorPad");if(0===i.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");c(e.length===i.rank,(()=>`Padding doesn't match input. Must be ${i.rank}. Got ${e.length}.`));const r="reflect"===n?1:0;for(let t=0;t<i.rank;t++)c(2===e[t].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),c(e[t][0]>=0&&e[t][0]<=i.shape[t]-r&&e[t][1]>=0&&e[t][1]<=i.shape[t]-r,(()=>`Padding in dimension ${t} cannot be greater than or equal to ${i.shape[t]-r} or less than 0 for input of shape ${i.shape}`));const s={paddings:e,mode:n},o={x:i};return rs.runKernel(je,o,s)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vc=ys({mod_:function(t,e){let n=fs(t,"a","mod"),i=fs(e,"b","mod");[n,i]=Xr(n,i);const r={a:n,b:i};return rs.runKernel(Ge,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xc=ys({moments_:function(t,e=null,n=!1){const i=w(e,(t=fs(t,"x","moments")).shape),r=pc(t,i,n);let s=r.shape;n||(s=dl(r.shape,i));const o=Sl(Ql(vo(t,"float32"),ca(r,s)));return{mean:r,variance:pc(o,i,n)}}});const wc=ys({multiRNNCell_:function(t,e,n,i){const r=fs(e,"data","multiRNNCell"),s=ms(n,"c","multiRNNCell"),o=ms(i,"h","multiRNNCell");let a=r;const l=[];for(let e=0;e<t.length;e++){const n=t[e](a,s[e],o[e]);l.push(n[0]),l.push(n[1]),a=n[1]}const c=[],u=[];for(let t=0;t<l.length;t+=2)c.push(l[t]),u.push(l[t+1]);return[c,u]}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sc=ys({multinomial_:function(t,e,n,i=!1){const r=fs(t,"logits","multinomial"),s=r.size,o=r.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const a={logits:1===o?ca(r,[1,-1]):r},l={numSamples:e,seed:n,normalized:i},c=rs.runKernel(qe,a,l);return 1===o?ca(c,[c.size]):c}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kc=ys({notEqual_:function(t,e){let n=fs(t,"a","notEqual","string_or_numeric"),i=fs(e,"b","notEqual","string_or_numeric");[n,i]=Xr(n,i),Ja(n.shape,i.shape);const r={a:n,b:i};return rs.runKernel(Ye,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cc=ys({oneHot_:function(t,e,n=1,i=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const s={indices:fs(t,"indices","oneHot","int32")},o={dtype:r,depth:e,onValue:n,offValue:i};return rs.runKernel(en,s,o)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tc=ys({onesLike_:function(t){const e={x:fs(t,"x","onesLike")};return rs.runKernel(tn,e)}});const _c=ys({outerProduct_:function(t,e){const n=fs(t,"v1","outerProduct"),i=fs(e,"v2","outerProduct");c(1===n.rank&&1===i.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${i.rank}.`));const r=ca(n,[-1,1]),s=ca(i,[1,-1]);return pa(r,s)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ec=ys({pad_:function(t,e,n=0){const i=fs(t,"x","pad");if(0===i.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:n},s={x:i};return rs.runKernel(rn,s,r)}});const Mc=ys({pad1d_:function(t,e,n=0){return c(2===e.length,(()=>"Invalid number of paddings. Must be length of 2.")),Ec(t,[e],n)}});const $c=ys({pad2d_:function(t,e,n=0){return c(2===e.length&&2===e[0].length&&2===e[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Ec(t,e,n)}});const Ic=ys({pad3d_:function(t,e,n=0){return c(3===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Ec(t,e,n)}});const Ac=ys({pad4d_:function(t,e,n=0){return c(4===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length&&2===e[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Ec(t,e,n)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nc=ys({spaceToBatchND_:function(t,e,n){const i=fs(t,"x","spaceToBatchND");c(i.rank>=1+e.length,(()=>`input rank ${i.rank} should be > than [blockShape] ${e.length}`)),c(n.length===e.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`)),c(i.shape.reduce(((t,i,r)=>r>0&&r<=e.length?t&&(i+n[r-1][0]+n[r-1][1])%e[r-1]==0:t),!0),(()=>`input spatial dimensions ${i.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`));const r={x:i},s={blockShape:e,paddings:n};return rs.runKernel(Dn,r,s)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rc=ys({pool_:function(t,e,n,i,r,s,o){null==r&&(r=[1,1]),null==s&&(s=1),0===i&&(i="valid");const a=fs(t,"x","maxPool");let l=a,u=!1;3===a.rank&&(u=!0,l=ca(a,[1,a.shape[0],a.shape[1],a.shape[2]])),c(sa(s,r),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${r}'`));const h=Ko(l.shape,e,s,r,i),d=[h.dilationHeight,h.dilationWidth];let p;p="same"===i?function(t,e){const n=t.map(((t,n)=>t+(t-1)*(e[n]-1))),i=n.map((t=>t-1)),r=i.map((t=>Math.floor(t/2))),s=i.map(((t,e)=>t-r[e]));return i.map(((t,e)=>[r[e],s[e]]))}([h.filterHeight,h.filterWidth],d):[[0,0],[0,0]];const f=1===d[0]&&1===d[1],[m,g]=function(t,e,n){const i=n.map((t=>t[0])),r=n.map((t=>t[1])),s=t.concat(i,r),o=e.map(((t,e)=>(t-s[e]%t)%t)),a=r.map(((t,e)=>t+o[e])),l=e.map(((t,e)=>[i[e],a[e]])),c=e.map(((t,e)=>[0,o[e]]));return[l,c]}([h.inHeight,h.inWidth],d,p),y=f?i:"valid",b=f?l:Nc(l,d,m),v=("avg"===n?()=>ua(b,e,s,y,o):()=>cc(b,e,s,y,o))(),x=f?v:ba(v,d,g);return u?ca(x,[x.shape[1],x.shape[2],x.shape[3]]):x}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pc=ys({prelu_:function(t,e){const n={x:fs(t,"x","prelu"),alpha:fs(e,"alpha","prelu")};return rs.runKernel(on,n)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oc=ys({prod_:function(t,e=null,n=!1){let i=fs(t,"x","prod");"bool"===i.dtype&&(i=vo(i,"int32"));const r={x:i},s={axis:e,keepDims:n};return rs.runKernel(an,r,s)}});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lc=ys({raggedGather_:function(t,e,n,i){const r=t.map(((t,e)=>fs(t,`tensors${e}`,"raggedGather","int32"))),s={paramsNestedSplits:r,paramsDenseValues:fs(e,"paramsDenseValues","raggedGather"),indices:fs(n,"indices","raggedGather","int32")},o={outputRaggedRank:i},a=rs.runKernel(ln,s,o);return{outputNestedSplits:a.slice(0,a.length-1),outputDenseValues:a[a.length-1]}}});
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dc=ys({raggedRange_:function(t,e,n){const i=fs(t,"starts","raggedRange"),r={starts:i,limits:fs(e,"limits","raggedRange",i.dtype),deltas:fs(n,"deltas","raggedRange",i.dtype)},s=rs.runKernel(cn,r);return{rtNestedSplits:s[0],rtDenseValues:s[1]}}});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fc=ys({raggedTensorToTensor_:function(t,e,n,i,r){const s=fs(t,"shape","raggedTensorToTensor","int32"),o=fs(e,"values","raggedTensorToTensor"),a=fs(n,"defaultValue","raggedTensorToTensor",o.dtype),l=i.map(((t,e)=>fs(t,`tensors${e}`,"raggedTensorToTensor","int32"))),c={shape:s,values:o,defaultValue:a,rowPartitionTensors:l},u={rowPartitionTypes:r};return rs.runKernel(un,c,u)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zc=ys({rand_:function(t,e,n){W(t);const i=d(t);let r=null;if(null==n||"float32"===n)r=new Float32Array(i);else if("int32"===n)r=new Int32Array(i);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);r=new Uint8Array(i)}for(let t=0;t<i;t++)r[t]=e();return rs.makeTensor(r,t,n)}});var Bc={exports:{}};!function(t,e,n){function i(t){var e=this,n=function(){var t=4022871197,e=function(e){e=String(e);for(var n=0;n<e.length;n++){var i=.02519603282416938*(t+=e.charCodeAt(n));i-=t=i>>>0,t=(i*=t)>>>0,t+=4294967296*(i-=t)}return 2.3283064365386963e-10*(t>>>0)};return e}();e.next=function(){var t=2091639*e.s0+2.3283064365386963e-10*e.c;return e.s0=e.s1,e.s1=e.s2,e.s2=t-(e.c=0|t)},e.c=1,e.s0=n(" "),e.s1=n(" "),e.s2=n(" "),e.s0-=n(t),e.s0<0&&(e.s0+=1),e.s1-=n(t),e.s1<0&&(e.s1+=1),e.s2-=n(t),e.s2<0&&(e.s2+=1),n=null}function r(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function s(t,e){var n=new i(t),s=e&&e.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,s&&("object"==typeof s&&r(s,n),o.state=function(){return r(n,{})}),o}e&&e.exports?e.exports=s:n&&n.amd?n((function(){return s})):this.alea=s}(0,Bc,!1);var Uc=Bc.exports,Vc={exports:{}};!function(t,e,n){function i(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var i=0;i<n.length+64;i++)e.x^=0|n.charCodeAt(i),e.next()}function r(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function s(t,e){var n=new i(t),s=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,s&&("object"==typeof s&&r(s,n),o.state=function(){return r(n,{})}),o}e&&e.exports?e.exports=s:n&&n.amd?n((function(){return s})):this.xor128=s}(0,Vc,!1);var Wc=Vc.exports,Hc={exports:{}};!function(t,e,n){function i(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var i=0;i<n.length+64;i++)e.x^=0|n.charCodeAt(i),i==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function r(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function s(t,e){var n=new i(t),s=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,s&&("object"==typeof s&&r(s,n),o.state=function(){return r(n,{})}),o}e&&e.exports?e.exports=s:n&&n.amd?n((function(){return s})):this.xorwow=s}(0,Hc,!1);var jc=Hc.exports,Gc={exports:{}};!function(t,e,n){function i(t){var e=this;e.next=function(){var t,n,i=e.x,r=e.i;return t=i[r],n=(t^=t>>>7)^t<<24,n^=(t=i[r+1&7])^t>>>10,n^=(t=i[r+3&7])^t>>>3,n^=(t=i[r+4&7])^t<<7,t=i[r+7&7],n^=(t^=t<<13)^t<<9,i[r]=n,e.i=r+1&7,n},function(t,e){var n,i=[];if(e===(0|e))i[0]=e;else for(e=""+e,n=0;n<e.length;++n)i[7&n]=i[7&n]<<15^e.charCodeAt(n)+i[n+1&7]<<13;for(;i.length<8;)i.push(0);for(n=0;n<8&&0===i[n];++n);for(8==n?i[7]=-1:i[n],t.x=i,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function r(t,e){return e.x=t.x.slice(),e.i=t.i,e}function s(t,e){null==t&&(t=+new Date);var n=new i(t),s=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,s&&(s.x&&r(s,n),o.state=function(){return r(n,{})}),o}e&&e.exports?e.exports=s:n&&n.amd?n((function(){return s})):this.xorshift7=s}(0,Gc,!1);var qc=Gc.exports,Xc={exports:{}};!function(t,e,n){function i(t){var e=this;e.next=function(){var t,n,i=e.w,r=e.X,s=e.i;return e.w=i=i+1640531527|0,n=r[s+34&127],t=r[s=s+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=r[s]=n^t,e.i=s,n+(i^i>>>16)|0},function(t,e){var n,i,r,s,o,a=[],l=128;for(e===(0|e)?(i=e,e=null):(e+="\0",i=0,l=Math.max(l,e.length)),r=0,s=-32;s<l;++s)e&&(i^=e.charCodeAt((s+32)%e.length)),0===s&&(o=i),i^=i<<10,i^=i>>>15,i^=i<<4,i^=i>>>13,s>=0&&(o=o+1640531527|0,r=0==(n=a[127&s]^=i+o)?r+1:0);for(r>=128&&(a[127&(e&&e.length||0)]=-1),r=127,s=512;s>0;--s)i=a[r+34&127],n=a[r=r+1&127],i^=i<<13,n^=n<<17,i^=i>>>15,n^=n>>>12,a[r]=i^n;t.w=o,t.X=a,t.i=r}(e,t)}function r(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function s(t,e){null==t&&(t=+new Date);var n=new i(t),s=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,s&&(s.X&&r(s,n),o.state=function(){return r(n,{})}),o}e&&e.exports?e.exports=s:n&&n.amd?n((function(){return s})):this.xor4096=s}(0,Xc,!1);var Kc=Xc.exports,Yc={exports:{}};!function(t,e,n){function i(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,i=e.d,r=e.a;return t=t<<25^t>>>7^n,n=n-i|0,i=i<<24^i>>>8^r,r=r-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-i|0,e.d=i<<16^n>>>16^r,e.a=r-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var i=0;i<n.length+20;i++)e.b^=0|n.charCodeAt(i),e.next()}function r(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function s(t,e){var n=new i(t),s=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,s&&("object"==typeof s&&r(s,n),o.state=function(){return r(n,{})}),o}e&&e.exports?e.exports=s:n&&n.amd?n((function(){return s})):this.tychei=s}(0,Yc,!1);var Zc,Jc=Yc.exports,Qc={exports:{}},tu=Ei(Object.freeze({__proto__:null,default:{}}));Zc=Qc,function(t,e,n){var i,r=256,s="random",o=n.pow(r,6),a=n.pow(2,52),l=2*a,c=r-1;function u(c,u,g){var y=[],b=f(p((u=1==u?{entropy:!0}:u||{}).entropy?[c,m(e)]:null==c?function(){try{var n;return i&&(n=i.randomBytes)?n=n(r):(n=new Uint8Array(r),(t.crypto||t.msCrypto).getRandomValues(n)),m(n)}catch(n){var s=t.navigator,o=s&&s.plugins;return[+new Date,t,o,t.screen,m(e)]}}():c,3),y),v=new h(y),x=function(){for(var t=v.g(6),e=o,n=0;t<a;)t=(t+n)*r,e*=r,n=v.g(1);for(;t>=l;)t/=2,e/=2,n>>>=1;return(t+n)/e};return x.int32=function(){return 0|v.g(4)},x.quick=function(){return v.g(4)/4294967296},x.double=x,f(m(v.S),e),(u.pass||g||function(t,e,i,r){return r&&(r.S&&d(r,v),t.state=function(){return d(v,{})}),i?(n[s]=t,e):t})(x,b,"global"in u?u.global:this==n,u.state)}function h(t){var e,n=t.length,i=this,s=0,o=i.i=i.j=0,a=i.S=[];for(n||(t=[n++]);s<r;)a[s]=s++;for(s=0;s<r;s++)a[s]=a[o=c&o+t[s%n]+(e=a[s])],a[o]=e;(i.g=function(t){for(var e,n=0,s=i.i,o=i.j,a=i.S;t--;)e=a[s=c&s+1],n=n*r+a[c&(a[s]=a[o=c&o+e])+(a[o]=e)];return i.i=s,i.j=o,n})(r)}function d(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function p(t,e){var n,i=[],r=typeof t;if(e&&"object"==r)for(n in t)try{i.push(p(t[n],e-1))}catch(t){}return i.length?i:"string"==r?t:t+"\0"}function f(t,e){for(var n,i=t+"",r=0;r<i.length;)e[c&r]=c&(n^=19*e[c&r])+i.charCodeAt(r++);return m(e)}function m(t){return String.fromCharCode.apply(0,t)}if(f(n.random(),e),Zc.exports){Zc.exports=u;try{i=tu}catch(t){}}else n["seed"+s]=u}("undefined"!=typeof self?self:Ti,[],Math);var eu=Uc,nu=Wc,iu=jc,ru=qc,su=Kc,ou=Jc,au=Qc.exports;au.alea=eu,au.xor128=nu,au.xorwow=iu,au.xorshift7=ru,au.xor4096=su,au.tychei=ou;var lu=au;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cu=.001,uu=.1;function hu(){return 32===rs.backend.floatPrecision()?cu:uu}function du(t,e,n){let i=!0;if((br(t)||br(e))&&(i=!1),br(t)&&br(e)&&(i=!0),i){const n=t.constructor.name,i=e.constructor.name;if(n!==i)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${i}`)}if(Array.isArray(t)&&Array.isArray(e)){const n=hs(t),i=hs(e);if(!m(n,i))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${i}]`)}const r=br(t)?t:vr(t),s=br(e)?e:vr(e);if(r.length!==s.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${s.length}.\nActual:   ${r}.\nExpected: ${s}.`);for(let t=0;t<s.length;++t){const e=r[t],i=s[t];if(!n(e,i))throw new Error(`Arrays differ: actual[${t}] = ${e}, expected[${t}] = ${i}.\nActual:   ${r}.\nExpected: ${s}.`)}"undefined"!=typeof expect&&expect().nothing()}function pu(t,e,n){return!isFinite(t)&&!isFinite(e)||!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}var fu=Object.freeze({__proto__:null,TEST_EPSILON_FLOAT16:uu,createVideoElement:function(t){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(t),new Promise((t=>{e.addEventListener("loadeddata",(n=>t(e))),e.load()}))},encodeStrings:function t(e){for(let n=0;n<e.length;n++){const i=e[n];Array.isArray(i)?t(i):e[n]=gr(i)}return e},expectArrayBuffersEqual:function(t,e){const n=new Float32Array(t),i=new Float32Array(e);if(n.length!==i.length)throw new Error(`Expected ArrayBuffer to be of length ${i.length}, but it was ${n.length}`);for(let t=0;t<i.length;t++)if(n[t]!==i[t])throw new Error(`Expected ArrayBuffer value at ${t} to be ${i[t]} but got ${n[t]} instead`)},expectArraysClose:function(t,e,n){return null==n&&(n=hu()),du(t,e,((t,e)=>pu(t,e,n)))},expectArraysEqual:function(t,e){const n="string"==typeof e||"number"==typeof e||"boolean"==typeof e?[e]:e;return I(t)||I(t[0])||I(e)||I(e[0])?du(t,n,((t,e)=>t==e)):du(t,e,((t,e)=>pu(t,e,0)))},expectNumbersClose:function(t,e,n){if(null==n&&(n=hu()),!pu(t,e,n))throw new Error(`Numbers differ: actual === ${t}, expected === ${e}`);"undefined"!=typeof expect&&expect().nothing()},expectPromiseToFail:function(t,e){t().then((()=>e.fail()),(()=>e())),"undefined"!=typeof expect&&expect().nothing()},expectValuesInRange:function(t,e,n){for(let i=0;i<t.length;i++)if(t[i]<e||t[i]>n)throw new Error(`Value out of range:${t[i]} low: ${e}, high: ${n}`)},play:async function(t){await t.play(),"requestVideoFrameCallback"in t&&await new Promise((e=>{t.requestVideoFrameCallback(e)}))},testEpsilon:hu});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mu{constructor(t,e,n,i,r){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=r||Math.random();this.random=lu.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let i,r,s;do{i=2*this.random()-1,r=2*this.random()-1,s=i*i+r*r}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*i*o,e=this.mean+this.stdDev*r*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class gu{constructor(t,e,n,i){this.alpha=t,this.beta=1/e,this.dtype=n;const r=i||Math.random();this.randu=lu.alea(r.toString()),this.randn=new mu(0,1,n,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,i,r,s;for(;;){do{i=this.randn.nextValue(),s=1+this.c*i}while(s<=0);if(s*=s*s,t=i*i,e=1-.331*t*t,n=.5*t+this.d*(1-s+Math.log(s)),r=this.randu(),r<e||Math.log(r)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class yu{constructor(t=0,e=1,n,i){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==i&&(i=Math.random()),"number"==typeof i&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=lu.alea(i)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bu=ys({randomGamma_:function(t,e,n=1,i="float32",r){if(W(t),null==n&&(n=1),null==i&&(i="float32"),"float32"!==i&&"int32"!==i)throw new Error(`Unsupported data type ${i}`);const s=new gu(e,n,i,r),o=bo(t,i);for(let t=0;t<o.values.length;t++)o.values[t]=s.nextValue();return o.toTensor()}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vu=ys({randomNormal_:function(t,e=0,n=1,i,r){if(W(t),null!=i&&"bool"===i)throw new Error(`Unsupported data type ${i}`);const s=new mu(e,n,i,!1,r),o=bo(t,i);for(let t=0;t<o.values.length;t++)o.values[t]=s.nextValue();return o.toTensor()}});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xu=ys({randomStandardNormal_:function(t,e,n){if(null!=e&&"bool"===e)throw new Error(`Unsupported data type ${e}`);return vu(t,0,1,e,n)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wu=ys({randomUniform_:function(t,e=0,n=1,i="float32",r){W(t);const s=bo(t,i),o=new yu(e,n,null,r);for(let t=0;t<s.values.length;t++)s.values[t]=o.nextValue();return s.toTensor()}});
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Su=ys({randomUniformInt_:function(t,e,n,i){return wu(t,e,n,"int32",i)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ku(t,e,n=1,i="float32"){if(0===n)throw new Error("Cannot have a step of zero");const r={start:t,stop:e,step:n,dtype:i};return rs.runKernel(hn,{},r)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cu=ys({real_:function(t){const e={input:fs(t,"input","real")};return rs.runKernel(dn,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tu=ys({reciprocal_:function(t){const e={x:fs(t,"x","reciprocal")};return rs.runKernel(pn,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _u=ys({relu_:function(t){const e={x:fs(t,"x","relu")};return rs.runKernel(fn,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eu=ys({relu6_:function(t){const e={x:fs(t,"x","relu6")};return rs.runKernel(xn,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mu=ys({reverse_:function(t,e){const n={x:fs(t,"x","reverse")},i={dims:e};return rs.runKernel(wn,n,i)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $u=ys({reverse1d_:function(t){const e=fs(t,"x","reverse");return c(1===e.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`)),Mu(e,0)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iu=ys({reverse2d_:function(t,e){const n=fs(t,"x","reverse");return c(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),Mu(n,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Au=ys({reverse3d_:function(t,e){const n=fs(t,"x","reverse");return c(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),Mu(n,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nu=ys({reverse4d_:function(t,e){const n=fs(t,"x","reverse");return c(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),Mu(n,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ru=ys({round_:function(t){const e={x:fs(t,"x","round")};return rs.runKernel(Sn,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pu=ys({rsqrt_:function(t){const e={x:fs(t,"x","rsqrt","float32")};return rs.runKernel(kn,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ou=ys({selu_:function(t){const e={x:fs(t,"x","selu")};return rs.runKernel(Mn,e)}});const Lu=ys({separableConv2d_:function(t,e,n,i,r,s=[1,1],o="NHWC"){const a=fs(t,"x","separableConv2d"),l=fs(e,"depthwiseFilter","separableConv2d"),u=fs(n,"pointwiseFilter","separableConv2d");let h=a,d=!1;if(3===a.rank&&(d=!0,h=ca(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");c(4===h.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`)),c(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),c(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),c(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),c(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const p=l.shape[2],f=l.shape[3];c(u.shape[2]===p*f,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*f}, but got ${u.shape[2]}.`));const m=qa(h,l,i,r,o,s),g=Pa(m,u,1,"valid",o);return d?ca(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Du=async function(t,e){const n=fs(t,"x","setdiff1d"),i=fs(e,"y","setdiff1d");c(n.dtype===i.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${i.dtype}).`)),c(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),c(1===i.rank,(()=>`y should be 1D tensor, but got y (${i.shape}).`));const r=await n.data(),s=await i.data(),o=new Set(s);let a=0;for(let t=0;t<r.length;t++)o.has(r[t])||a++;const l=new Nr([a],n.dtype),u=new Nr([a],"int32");for(let t=0,e=0;t<r.length;t++)o.has(r[t])||(l.values[e]=r[t],u.values[e]=t,e++);return[l.toTensor(),u.toTensor()]};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fu=ys({sign_:function(t){const e={x:fs(t,"x","sign")};return rs.runKernel(Nn,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zu=ys({sin_:function(t){const e={x:fs(t,"x","sin","float32")};return rs.runKernel(In,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bu=ys({sinh_:function(t){const e={x:fs(t,"x","sinh")};return rs.runKernel(An,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uu=ys({slice1d_:function(t,e,n){const i=fs(t,"x","slice1d");return c(1===i.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${i.rank} tensor`)),ma(i,[e],[n])}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vu=ys({slice2d_:function(t,e,n){const i=fs(t,"x","slice2d");return c(2===i.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${i.rank} tensor`)),ma(i,e,n)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wu=ys({slice3d_:function(t,e,n){const i=fs(t,"x","slice3d");return c(3===i.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${i.rank} tensor`)),ma(i,e,n)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hu=ys({slice4d_:function(t,e,n){const i=fs(t,"x","slice4d");return c(4===i.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${i.rank} tensor`)),ma(i,e,n)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ju=ys({softmax_:function(t,e=-1){const n=fs(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const i={logits:n},r={dim:e};return rs.runKernel(zn,i,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gu=ys({fft_:function(t){c("complex64"===t.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`));const e={input:t};return rs.runKernel(ae,e)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qu=ys({ifft_:function(t){c("complex64"===t.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`));const e={input:t};return rs.runKernel(be,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xu=ys({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let i;if(e<=2){const r=ca(t,[n,e]);i=qu(r)}else{const r=[n,2*(e-1)],s=ca(Cu(t),[n,e]),o=ca(Ll(t),[n,e]),a=Mu(ma(s,[0,1],[n,e-2]),1),l=Po(Mu(ma(o,[0,1],[n,e-2]),1),xl(-1)),c=da([s,a],1),u=da([o,l],1),h=ca(bs(c,u),[r[0],r[1]]);i=qu(h)}if(i=Cu(i),3===t.rank&&0!==t.shape[0]){const e=i,n=t.shape[0];i=ca(i,[n,i.shape[0]/n,i.shape[1]]),e.dispose()}return i}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ku=ys({split_:function(t,e,n=0){const i={x:fs(t,"x","split")},r={numOrSizeSplits:e,axis:n};return rs.runKernel(Fn,i,r)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yu=ys({rfft_:function(t,e){c("float32"===t.dtype,(()=>`The dtype for rfft() must be real value but got ${t.dtype}`));let n=t.shape[t.shape.length-1];const i=t.size/n;let r;if(null!=e&&e<n){const i=t.shape.map((t=>0)),s=t.shape.map((t=>t));s[t.shape.length-1]=e,r=ma(t,i,s),n=e}else if(null!=e&&e>n){const i=t.shape.map((t=>t));i[t.shape.length-1]=e-n,r=da([t,fc(i)],t.shape.length-1),n=e}else r=t;const s=nl(r),o=ca(bs(r,s),[i,n]),a=Gu(o),l=Math.floor(n/2)+1,u=Cu(a),h=Ll(a),d=Ku(u,[l,n-l],u.shape.length-1),p=Ku(h,[l,n-l],h.shape.length-1),f=r.shape.slice();return f[r.shape.length-1]=l,ca(bs(d[0],p[0]),f)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zu=ys({squaredDifference_:function(t,e){let n=fs(t,"a","squaredDifference"),i=fs(e,"b","squaredDifference");[n,i]=Xr(n,i),Ja(n.shape,i.shape);const r={a:n,b:i};return rs.runKernel(jn,r,{})}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ju=ys({squeeze_:function(t,e){const n=fs(t,"x","squeeze","string_or_numeric");return ca(n,S(n.shape,e).newShape)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qu=ys({stack_:function(t,e=0){const n=ms(t,"tensors","stack","string_or_numeric");c(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&c(e<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const i=n,r={axis:e};return rs.runKernel(nn,i,r)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const th=ys({step_:function(t,e=0){const n={x:fs(t,"x","step")},i={alpha:e};return rs.runKernel(ci,n,i)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eh=ys({stridedSlice_:function(t,e,n,i,r=0,s=0,o=0,a=0,l=0){const c={x:fs(t,"x","stridedSlice","string_or_numeric")},u={begin:e,end:n,strides:i,beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return rs.runKernel(Xn,c,u)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nh=ys({tan_:function(t){const e={x:fs(t,"x","tan","float32")};return rs.runKernel(Qn,e)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ih(t,e){h(t);const n=hs(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return vs(t,null,n,e)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rh(t,e,n){if(h(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const i=hs(t,n);if(2!==i.length&&1!==i.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===i.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return vs(t,e,i,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sh(t,e,n){if(h(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const i=hs(t,n);if(3!==i.length&&1!==i.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===i.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return vs(t,e,i,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oh(t,e,n){if(h(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");const i=hs(t,n);if(4!==i.length&&1!==i.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===i.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return vs(t,e,i,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ah(t,e,n){if(h(t),null!=e&&5!==e.length)throw new Error("tensor5d() requires shape to have five numbers");const i=hs(t,n);if(5!==i.length&&1!==i.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===i.length&&null==e)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return vs(t,e,i,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lh(t,e,n){if(h(t),null!=e&&6!==e.length)throw new Error("tensor6d() requires shape to have six numbers");const i=hs(t,n);if(6!==i.length&&1!==i.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===i.length&&null==e)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return vs(t,e=e||i,i,n)}function ch(t,e,n){const i=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${i}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(s+` update.rank < ${r}. `);if(t.length<i+(n.rank-r))throw new Error(s+` Output shape length < ${i+(n.rank-r)}`);if(n.rank!==r+t.length-i)throw new Error(s+" update.rank != "+(r+t.length-i));for(let t=0;t<r;++t)if(n.shape[t]!==e.shape[t])throw new Error(s+` updates.shape[${t}] (${n.shape[t]}) != indices.shape[${t}] (${e.shape[t]}).`);for(let e=0;e<n.rank-r;++e)if(n.shape[e+r]!==t[e+i])throw new Error(s+` updates.shape[${e+r}] (${n.shape[e+r]}) != shape[${e+r}] (${t[e+r]})`)}function uh(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}ch(n,e,t)}function hh(t,e,n){const i=e.shape.length,r=i>1?e.shape[i-1]:1,s=n.length;let o=1;for(let t=r;t<s;++t)o*=n[t];const a=r<1?1:r;return{sliceRank:r,numUpdates:d(e.shape)/a,sliceSize:o,strides:[...L(n.slice(0,r)),1],outputSize:d(n)}}var dh=Object.freeze({__proto__:null,calculateShapes:hh,validateInput:uh,validateUpdateShape:ch});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ph=ys({tensorScatterUpdate_:function(t,e,n){const i=fs(t,"tensor","tensorScatterupdate"),r=fs(e,"indices","tensorScatterupdate","int32"),s=fs(n,"updates","tensorScatterupdate");if(uh(s,r,i.shape),i.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${i.dtype} and ${s.dtype}.`);const o={tensor:i,indices:r,updates:s};return rs.runKernel(Tn,o,{})}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fh=ys({topk_:function(t,e=1,n=!0){const i=fs(t,"x","topk");if(0===i.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=i.shape[i.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const s={x:i},o={k:e,sorted:n},[a,l]=rs.runKernel(ni,s,o);return{values:a,indices:l}}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mh=ys({truncatedNormal_:function(t,e=0,n=1,i,r){if(W(t),null!=i&&"bool"===i)throw new Error("Unsupported data type $ { dtype }");const s=new mu(e,n,i,!0,r),o=bo(t,i);for(let t=0;t<o.values.length;t++)o.values[t]=s.nextValue();return o.toTensor()}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gh=ys({unique_:function(t,e=0){const n=fs(t,"x","unique","string_or_numeric");c(n.rank>0,(()=>"The input tensor must be at least 1D"));const i={x:n},r={axis:e},[s,o]=rs.runKernel(si,i,r);return{values:s,indices:o}}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yh=ys({unsortedSegmentSum_:function(t,e,n){const i=fs(t,"x","unsortedSegmentSum"),r=fs(e,"segmentIds","unsortedSegmentSum","int32");c(g(n),(()=>"numSegments must be of dtype int"));const s={x:i,segmentIds:r},o={numSegments:n};return rs.runKernel(ai,s,o)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bh=ys({unstack_:function(t,e=0){const n=fs(t,"x","unstack","string_or_numeric");c(e>=-n.shape.length&&e<n.shape.length,(()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`));const i={value:n},r={axis:e};return rs.runKernel(oi,i,r)}});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vh(t,e){return ac(t,e,"right")}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xh(t,e=!0,n,i){return rs.makeVariable(t,e,n,i)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wh(t,e){const n=[];for(let t=0;t<e.length;t++)e[t]&&n.push(t);const i=bo(t,"int32"),r=bo([n.length,t.length],"int32");for(let e=0;e<n.length;e++){const s=i.indexToLoc(n[e]),o=e*t.length;r.values.set(s,o)}return r.toTensor()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sh=async function(t){const e=fs(t,"condition","whereAsync","bool"),n=await e.data(),i=wh(e.shape,n);return t!==e&&e.dispose(),i};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kh=async function(t,e,n){const i=fs(t,"tensor","boolMask"),r=fs(e,"mask","boolMask","bool"),s=null==n?0:n,o=r.rank,a=i.shape;c(o>0,(()=>"mask cannot be scalar")),u(a.slice(s,s+o),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let t=s;t<s+o;t++)l*=a[t];const h=a.slice(0,s).concat([l],a.slice(s+o)),d=ca(i,h),p=ca(r,[-1]),f=await Sh(p),m=Ju(f,[1]),g=Rl(d,m,s);return t!==i&&i.dispose(),e!==r&&r.dispose(),m.dispose(),d.dispose(),p.dispose(),f.dispose(),g};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ch=ys({transpose_:function(t,e,n){const i=fs(t,"x","transpose");if(null==e&&(e=i.shape.map(((t,e)=>e)).reverse()),c(i.rank===e.length,(()=>`Error in transpose: rank of input ${i.rank} must match length of perm ${e}.`)),e.forEach((t=>{c(t>=0&&t<i.rank,(()=>"All entries in 'perm' must be between 0 and "+(i.rank-1)+` but got ${e}`))})),i.rank<=1)return i.clone();const r={x:i},s={perm:e};return"complex64"===i.dtype?Co((()=>{let t=Cu(i),e=Ll(i);return t=rs.runKernel(ri,{x:t},s),e=rs.runKernel(ri,{x:e},s),n&&(e=Yl(e)),bs(t,e)})):rs.runKernel(ri,r,s)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Th=ys({movingAverage_:function(t,e,n,i,r=!0){const s=fs(t,"v","movingAverage"),o=fs(e,"x","movingAverage"),a=fs(n,"decay","movingAverage");Kr(s,o),c(m(s.shape,o.shape),(()=>"Shape mismatch in v and x"));const l=xl(1),u=Ql(l,a);let h=Po(Ql(o,s),u);if(r){c(null!=i,(()=>"When using zeroDebias: true, step is required."));const t=fs(i,"step","movingAverage");h=Ro(h,Ql(l,vl(a,t)))}return Ao(s,h)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _h=ys({scatterND_:function(t,e,n){W(n);const i=fs(t,"indices","scatterND","int32"),r=fs(e,"updates","scatterND");uh(r,i,n);const s={indices:i,updates:r},o={shape:n};return rs.runKernel(Cn,s,o)}});const Eh=ys({sparseToDense_:
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t,e,n,i=0){W(n);const r=fs(t,"sparseIndices","sparseToDense","int32"),s=fs(e,"sparseValues","sparseToDense","string_or_numeric"),o=fs(i,"defaultValue","sparseToDense",s.dtype);!function(t,e,n,i){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const r=t.rank>0?t.shape[0]:1,s=t.rank>1?t.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);const o=e.size;if(0!==e.rank&&(1!==e.rank||o!==r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==i.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(r,s,n,o);const a={sparseIndices:r,sparseValues:s,defaultValue:o},l={outputShape:n};return rs.runKernel(Hn,a,l)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mh=ys({gatherND_:function(t,e){const n=fs(e,"indices","gatherND","int32"),i={params:fs(t,"x","gatherND","string_or_numeric"),indices:n};return rs.runKernel(fe,i)}});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $h=ys({dropout_:
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t,e,n,i){const r=fs(t,"x","dropout");if(c("float32"===r.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`)),c(e>=0&&e<1,(()=>`rate must be a float in the range [0, 1), but got ${e}.`)),0===e)return t instanceof Or?r.clone():r;const s=function(t,e){if(null==e)return t.shape.slice();if(m(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let i=0;i<t.shape.length;i++)null==e[i]&&null!=t.shape[i]?n.push(t.shape[i]):n.push(e[i]);return n}return e}(r,n),o=1-e,a=Ro(Nl(Ao(wu(s,0,1,"float32",i),o)),o);return Po(r,a)}});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ih(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function Ah(t,e,n){const i=1-t%2,r=new Float32Array(t);for(let s=0;s<t;++s){const o=2*Math.PI*s/(t+i-1);r[s]=e-n*Math.cos(o)}return ih(r,"float32")}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nh=async function(t,e,n=1){const i=fs(t,"predictions","inTopK"),r=fs(e,"targets","inTopK");c(i.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${i.rank}`)),c(i.rank-1===r.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${i.rank} and targets rank ${r.rank}`)),u(i.shape.slice(0,i.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=i.shape[i.shape.length-1];c(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));const o=await i.data(),a=await r.data(),[l,h]=[o.length/s,s],d=k("bool",l);for(let t=0;t<l;t++){const e=t*h,i=o.subarray(e,e+h),r=[];for(let t=0;t<i.length;t++)r.push({value:i[t],index:t});r.sort(((t,e)=>e.value-t.value)),d[t]=0;for(let e=0;e<n;e++)if(r[e].index===a[t]){d[t]=1;break}}return t!==i&&i.dispose(),e!==r&&r.dispose(),xs(d,r.shape,"bool")};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rh=ys({conv2DBackpropFilter_:function(t,e,n,i,r,s="NHWC",o){let a=t;3===t.rank&&(a=ca(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=ca(e,[1,e.shape[0],e.shape[1],e.shape[2]])),c(4===a.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`)),c(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),c(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===s?a.shape[3]:a.shape[1],h="NHWC"===s?l.shape[3]:l.shape[1];c(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),c(h===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${n[3]}).`)),la("conv2dDerFilter",r,o);const d={x:a,dy:l},p={strides:i,pad:r,dataFormat:s,dimRoundingMode:o,filterShape:n};return rs.runKernel(Nt,d,p)}});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ph(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return Po(t,th(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Oh(t,e){let n=e;const i=Za(t.shape,e.shape);return i.length>0&&(n=kl(n,i)),ca(n,t.shape)}function Lh(t,e,n,i){if("linear"===e)return t;if("relu"===e)return _u(t);if("elu"===e)return ol(t);if("relu6"===e)return Eu(t);if("prelu"===e)return Pc(t,n);if("leakyrelu"===e)return Bl(t,i);if("sigmoid"===e)return fa(t);throw new Error(`Unknown fused activation ${e}.`)}const Dh=(t,e)=>!(t>0)||"linear"===e;
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fh=ys({fusedConv2d_:function({x:t,filter:e,strides:n,pad:i,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}){if(l=l||"linear",!1===Dh(rs.state.gradientDepth,l)){c("NHWC"===r,(()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let d=Pa(t,e,n,i,r,s,o);return null!=a&&(d=Ao(d,a)),Lh(d,l,u,h)}const d=fs(t,"x","conv2d","float32"),p=fs(e,"filter","conv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=ca(d,[1,d.shape[0],d.shape[1],d.shape[2]])),c(4===f.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`)),c(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),la("fused conv2d",i,o);const g="NHWC"===r?f.shape[3]:f.shape[1];c(p.shape[2]===g,(()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`)),c(sa(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));const y=Zo(f.shape,p.shape,n,s,i,o);let b,v;if(null!=a&&(b=fs(a,"bias","fused conv2d"),[b]=Xr(b,d),"NHWC"===r?Ja(y.outShape,b.shape):(c(b.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`)),c(0===b.shape.length||b.shape[0]===y.outChannels||1===b.shape[0],(()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${y.outChannels})`)))),null!=u){const t=u.shape;if(c(t.length<=1||3===t.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${t.length}.`)),1===t.length)c(1===t[0]||t[0]===y.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${t}) is not compatible with the number of output channels (${y.outChannels}).`));else if(3===t.length)try{Ja(t,y.outShape)}catch(e){const n=`Error in fused conv2d: PReLU activation weights (${t}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(n)}v=fs(u,"prelu weights","fused conv2d")}const x=(t,e)=>{c("NHWC"===r,(()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`));const[o,a,u,h]=e,d=Ph(t,u,l);c(ra(s),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));const p=[La(a.shape,d,o,n,i),Rh(a,d,o.shape,n,i)];if(null!=h){const t=Oh(h,d);p.push(t)}return p},w={x:f,filter:p,bias:b,preluActivationWeights:v},S={strides:n,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:h};if(null==a){const t=Xl(((t,e,n)=>{let i=rs.runKernel(pi,w,S);return n([e,t,i]),m&&(i=ca(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:x}}));return t(f,p)}{const t=Xl(((t,e,n,i)=>{let r=rs.runKernel(pi,w,S);return i([e,t,r,n]),m&&(r=ca(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return t(f,p,b)}}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zh=ys({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,i,r,s=[1,1],o){let a=t;3===t.rank&&(a=ca(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=ca(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},u={strides:i,pad:r,dimRoundingMode:o,dilations:s,filterShape:n};return rs.runKernel(jt,c,u)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bh=ys({depthwiseConv2dNativeBackpropInput_:function(t,e,n,i,r,s=[1,1],o){let a=e,l=!1;3===e.rank&&(l=!0,a=ca(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:n},u={strides:i,pad:r,dimRoundingMode:o,dilations:s,inputShape:t},h=rs.runKernel(Gt,c,u);return l?ca(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uh=ys({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:i,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}){if(!1===Dh(rs.state.gradientDepth,l)){let c=qa(t,e,n,i,r,s,o);return null!=a&&(c=Ao(c,a)),Lh(c,l,u,h)}const d=fs(t,"x","depthwiseConv2d","float32"),p=fs(e,"filter","depthwiseConv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=ca(d,[1,d.shape[0],d.shape[1],d.shape[2]])),c(4===f.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`)),c(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),c(f.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==s&&(s=[1,1]),c(sa(n,s),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),la("fused depthwiseConv2d",i,o);const g=Zo(f.shape,p.shape,n,s,i,o,!0);let y,b;null!=a&&(y=fs(a,"bias","fused conv2d"),[y]=Xr(y,d),Ja(g.outShape,y.shape)),null!=u&&(b=fs(u,"prelu weights","fused depthwiseConv2d"));const v=(t,e)=>{c(ra(s),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`));const[r,a,u,h]=e,d=Ph(t,u,l),p=Bh(a.shape,d,r,n,i,s,o),f=zh(a,d,r.shape,n,i,s,o);if(null!=h){return[p,f,Oh(y,d)]}return[p,f]},x={x:f,filter:p,bias:y,preluActivationWeights:b},w={strides:n,pad:i,dataFormat:r,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:h};if(null==a){const t=Xl(((t,e,n)=>{let i=rs.runKernel(fi,x,w);return n([e,t,i]),m&&(i=ca(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:v}}));return t(f,p)}{const t=Xl(((t,e,n,i)=>{let r=rs.runKernel(fi,x,w);return i([e,t,r,n]),m&&(r=ca(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return t(f,p,y)}}});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vh=ys({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:i=!1,bias:r,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(!1===Dh(rs.state.gradientDepth,s)){let l=pa(t,e,n,i);return null!=r&&(l=Ao(l,r)),Lh(l,s,o,a)}let l=fs(t,"a","fused matMul"),u=fs(e,"b","fused matMul");[l,u]=Xr(l,u);const h=n?l.shape[l.rank-2]:l.shape[l.rank-1],p=i?u.shape[u.rank-1]:u.shape[u.rank-2],f=n?l.shape[l.rank-1]:l.shape[l.rank-2],m=i?u.shape[u.rank-2]:u.shape[u.rank-1],g=l.shape.slice(0,-2),y=u.shape.slice(0,-2),b=d(g),v=d(y);c(h===p,(()=>`Error in fused matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${i} must match.`));const x=Ja(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([f,m]),w=ca(l,n?[b,h,f]:[b,f,h]),S=ca(u,i?[v,m,p]:[v,p,m]);let k,C;null!=r&&(k=fs(r,"bias","fused matMul"),[k]=Xr(k,l),Ja(x,k.shape)),null!=o&&(C=fs(o,"prelu weights","fused matMul"));const T=(t,e)=>{const[o,a,l,c]=e,u=Ph(ca(t,l.shape),l,s);let h,d;if(n||i?!n&&i?(h=pa(u,a,!1,!1),d=pa(u,o,!0,!1)):n&&!i?(h=pa(a,u,!1,!0),d=pa(o,u,!1,!1)):(h=pa(a,u,!0,!0),d=pa(u,o,!0,!0)):(h=pa(u,a,!1,!0),d=pa(o,u,!0,!1)),null!=r){return[h,d,Oh(c,u)]}return[h,d]},_={a:w,b:S,bias:k,preluActivationWeights:C},E={transposeA:n,transposeB:i,activation:s,leakyreluAlpha:a};if(null==r){const t=Xl(((t,e,n)=>{const i=rs.runKernel(di,_,E);return n([t,e,i]),{value:ca(i,x),gradFunc:T}}));return t(w,S)}{const t=Xl(((t,e,n,i)=>{const r=rs.runKernel(di,_,E);return i([t,e,r,n]),{value:ca(r,x),gradFunc:T}}));return t(w,S,k)}}});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Wh=Object.freeze({__proto__:null,conv2d:Fh,depthwiseConv2d:Uh,matMul:Vh});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hh=ys({hammingWindow_:function(t){return Ah(t,.54,.46)}});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jh=ys({hannWindow_:function(t){return Ah(t,.5,.5)}});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gh=ys({frame_:function(t,e,n,i=!1,r=0){let s=0;const o=[];for(;s+e<=t.size;)o.push(ma(t,s,e)),s+=n;if(i)for(;s<t.size;){const i=s+e-t.size,a=da([ma(t,s,e-i),Ma([i],r)]);o.push(a),s+=n}return 0===o.length?rh([],[0,e]):ca(da(o),[o.length,e])}});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qh=ys({stft_:function(t,e,n,i,r=jh){null==i&&(i=Ih(e));const s=Gh(t,e,n),o=Po(s,r(e));return Yu(o,i)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xh=ys({cropAndResize_:function(t,e,n,i,r="bilinear",s=0){const o=fs(t,"image","cropAndResize"),a=fs(e,"boxes","cropAndResize","float32"),l=fs(n,"boxInd","cropAndResize","int32"),u=a.shape[0];c(4===o.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`)),c(2===a.rank&&4===a.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`)),c(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`)),c(2===i.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${i.length}.`)),c(i[0]>=1&&i[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${i}`)),c("bilinear"===r||"nearest"===r,(()=>`method must be bilinear or nearest, but was ${r}`));const h={image:o,boxes:a,boxInd:l},d={method:r,extrapolationValue:s,cropSize:i};return rs.runKernel(Ut,h,d)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kh=ys({flipLeftRight_:function(t){const e=fs(t,"image","flipLeftRight","float32");c(4===e.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`));const n={image:e};return rs.runKernel(ce,n,{})}});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yh=ys({grayscaleToRGB_:function(t){const e=fs(t,"image","grayscaleToRGB"),n=e.rank-1,i=e.shape[n];c(e.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`)),c(1===i,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${i}.`));const r=new Array(e.rank);return r.fill(1,0,n),r[n]=3,Il(e,r)}});
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zh=ys({rgbToGrayscale_:function(t){const e=fs(t,"image","RGBToGrayscale"),n=e.rank-1,i=e.shape[n];c(e.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`)),c(3===i,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${i}.`));const r=e.dtype,s=vo(e,"float32"),o=ih([.2989,.587,.114]);let a;switch(e.rank){case 2:a=sl("ij,j->i",s,o);break;case 3:a=sl("ijk,k->ij",s,o);break;case 4:a=sl("ijkl,l->ijk",s,o);break;case 5:a=sl("ijklm,m->ijkl",s,o);break;case 6:a=sl("ijklmn,n->ijklm",s,o);break;default:throw new Error("Not a valid tensor rank.")}return a=Ml(a,-1),vo(a,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jh=ys({rotateWithOffset_:function(t,e,n=0,i=.5){const r=fs(t,"image","rotateWithOffset","float32");c(4===r.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`));const s={image:r},o={radians:e,fillValue:n,center:i};return rs.runKernel(hi,s,o)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qh(t,e,n,i,r,s){null==i&&(i=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=t.shape[0];return n=Math.min(n,o),c(0<=i&&i<=1,(()=>`iouThreshold must be in [0, 1], but was '${i}'`)),c(2===t.rank,(()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`)),c(4===t.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`)),c(1===e.rank,(()=>"scores must be a 1D tensor")),c(e.shape[0]===o,(()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`)),c(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:i,scoreThreshold:r,softNmsSigma:s}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const td=ys({nonMaxSuppression_:function(t,e,n,i=.5,r=Number.NEGATIVE_INFINITY){const s=fs(t,"boxes","nonMaxSuppression","float32"),o=fs(e,"scores","nonMaxSuppression","float32"),a=Qh(s,o,n,i,r),l={maxOutputSize:n=a.maxOutputSize,iouThreshold:i=a.iouThreshold,scoreThreshold:r=a.scoreThreshold};return rs.runKernel(Ze,{boxes:s,scores:o},l)}});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ed(t,e,n){const i=function(t,e,n){return function(t,e,n){let i=0,r=t.length,s=0,o=!1;for(;i<r;){s=i+(r-i>>>1);const a=n(e,t[s]);a>0?i=s+1:(r=s,o=!a)}return o?i:-i-1}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(t,e,n||nd)}(t,e,n),r=i<0?-(i+1):i;t.splice(r,0,e)}function nd(t,e){return t>e?1:t<e?-1:0}function id(t,e,n,i,r){return od(t,e,n,i,r,0)}function rd(t,e,n,i,r,s){return od(t,e,n,i,r,0,!1,s,!0)}function sd(t,e,n,i,r,s){return od(t,e,n,i,r,s,!0)}function od(t,e,n,i,r,s,o=!1,a=!1,l=!1){const c=[];for(let t=0;t<e.length;t++)e[t]>r&&c.push({score:e[t],boxIndex:t,suppressBeginIndex:0});c.sort(cd);const u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&c.length>0;){const e=c.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=e;if(n<r)break;let a=!1;for(let n=h.length-1;n>=o;--n){const o=ad(t,s,h[n]);if(o>=i){a=!0;break}if(e.score=e.score*ld(i,u,o),e.score<=r)break}e.suppressBeginIndex=h.length,a||(e.score===n?(h.push(s),d.push(e.score)):e.score>r&&ed(c,e,cd))}const p=h.length,f=n-p;a&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return o&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function ad(t,e,n){const i=t.subarray(4*e,4*e+4),r=t.subarray(4*n,4*n+4),s=Math.min(i[0],i[2]),o=Math.min(i[1],i[3]),a=Math.max(i[0],i[2]),l=Math.max(i[1],i[3]),c=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(a-s)*(l-o),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const m=Math.max(s,c),g=Math.max(o,u),y=Math.min(a,h),b=Math.min(l,d),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function ld(t,e,n){const i=Math.exp(e*n*n);return n<=t?i:0}function cd(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ud=async function(t,e,n,i=.5,r=Number.NEGATIVE_INFINITY){const s=fs(t,"boxes","nonMaxSuppressionAsync"),o=fs(e,"scores","nonMaxSuppressionAsync"),a=Qh(s,o,n,i,r);n=a.maxOutputSize,i=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=id(c,u,n,i,r);return s!==t&&s.dispose(),o!==e&&o.dispose(),ih(h,"int32")};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hd=ys({nonMaxSuppressionWithScore_:function(t,e,n,i=.5,r=Number.NEGATIVE_INFINITY,s=0){const o=fs(t,"boxes","nonMaxSuppression"),a=fs(e,"scores","nonMaxSuppression"),l=Qh(o,a,n,i,r,s),c={boxes:o,scores:a},u={maxOutputSize:n=l.maxOutputSize,iouThreshold:i=l.iouThreshold,scoreThreshold:r=l.scoreThreshold,softNmsSigma:s=l.softNmsSigma},h=rs.runKernel(Qe,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dd=async function(t,e,n,i=.5,r=Number.NEGATIVE_INFINITY,s=0){const o=fs(t,"boxes","nonMaxSuppressionAsync"),a=fs(e,"scores","nonMaxSuppressionAsync"),l=Qh(o,a,n,i,r,s);n=l.maxOutputSize,i=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=sd(u,h,n,i,r,s);return o!==t&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:ih(d,"int32"),selectedScores:ih(p)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pd=ys({nonMaxSuppressionPadded_:function(t,e,n,i=.5,r=Number.NEGATIVE_INFINITY,s=!1){const o=fs(t,"boxes","nonMaxSuppression"),a=fs(e,"scores","nonMaxSuppression"),l=Qh(o,a,n,i,r,null),c={boxes:o,scores:a},u={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},h=rs.runKernel(Je,c,u);return{selectedIndices:h[0],validOutputs:h[1]}}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fd=async function(t,e,n,i=.5,r=Number.NEGATIVE_INFINITY,s=!1){const o=fs(t,"boxes","nonMaxSuppressionAsync"),a=fs(e,"scores","nonMaxSuppressionAsync"),l=Qh(o,a,n,i,r,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),a.data()]),{selectedIndices:f,validOutputs:m}=rd(d,p,c,u,h,s);return o!==t&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:ih(f,"int32"),validOutputs:xl(m,"int32")}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const md=ys({resizeBilinear_:function(t,e,n=!1,i=!1){const r=fs(t,"images","resizeBilinear");c(3===r.rank||4===r.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`)),c(2===e.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`)),c(!1===i||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=r,o=!1;3===r.rank&&(o=!0,s=ca(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:s},l={alignCorners:n,halfPixelCenters:i,size:e},u=rs.runKernel(bn,a,l);return o?ca(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gd=ys({resizeNearestNeighbor_:function(t,e,n=!1,i=!1){const r=fs(t,"images","resizeNearestNeighbor");c(3===r.rank||4===r.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`)),c(2===e.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`)),c("float32"===r.dtype||"int32"===r.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),c(!1===i||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=r,o=!1;3===r.rank&&(o=!0,s=ca(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:s},l={alignCorners:n,halfPixelCenters:i,size:e},u=rs.runKernel(gn,a,l);return o?ca(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yd=ys({threshold_:function(t,e="binary",n=!1,i=.5){const r=fs(t,"image","threshold"),s=r.shape[0]*r.shape[1];let o,a,l,u,h=Po(ih([i]),255);if(c(3===r.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`)),c(3===r.shape[2]||1===r.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`)),c("int32"===r.dtype||"float32"===r.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`)),c("otsu"===e||"binary"===e,(()=>`Method must be binary or otsu, but was ${e}`)),3===r.shape[2]){[o,a,l]=Ku(r,[1,1,1],-1);const t=Po(o,.2989),e=Po(a,.587),n=Po(l,.114);u=Ao(Ao(t,e),n)}else u=t;if("otsu"===e){h=function(t,e){let n,i,r,s,o,a,l=ih([-1]),c=ih([0]),u=ih([0]);for(let h=0;h<t.size-1;h++){n=ma(t,0,h+1),i=ma(t,h+1),o=Ro(kl(n),e),a=Ro(kl(i),e);const d=kl(Po(n,ku(0,n.size)));r=Ro(d,kl(n));const p=Ma(i.shape,n.size),f=Ao(ku(0,i.size),p),m=Po(i,f);s=Ro(kl(m),kl(i));const g=Ql(r,s),y=Ql(r,s),b=Po(o,a);u=Po(Po(b,g),y);const v=Pl(u,c);c=el(v,u,c),l=el(v,ih([h]),l)}return l}(ka(vo(Ru(u),"int32"),xs([]),256),s)}const d=n?Vl(u,h):Pl(u,h);return vo(Po(d,255),"int32")}});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bd=ys({transform_:function(t,e,n="nearest",i="constant",r=0,s){const o=fs(t,"image","transform","float32"),a=fs(e,"transforms","transform","float32");c(4===o.rank,(()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`)),c(2===a.rank&&(a.shape[0]===o.shape[0]||1===a.shape[0])&&8===a.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),c(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));const l={image:o,transforms:a},u={interpolation:n,fillMode:i,fillValue:r,outputShape:s};return rs.runKernel(ii,l,u)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vd=ys({bandPart_:function(t,e,n){const i=fs(t,"a","bandPart");c(i.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${i.rank}.`));const r=i.shape,[s,o]=i.shape.slice(-2);let a,l;"number"==typeof e?(c(e%1==0,(()=>`bandPart(): numLower must be an integer, got ${e}.`)),c(e<=s,(()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`)),a=fs(e<0?s:e,"numLower","bandPart")):(c("int32"===e.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),a=el(Ul(e,0),s,yc(e,s))),"number"==typeof n?(c(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),c(n<=o,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`)),l=fs(n<0?o:n,"numUpper","bandPart")):(c("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=el(Ul(n,0),o,yc(n,o)));const u=ca(ku(0,s,1,"int32"),[-1,1]),h=ku(0,o,1,"int32"),d=Ql(u,h),p=nc(Vl(d,a),Ol(d,Yl(l))),f=fc([s,o],i.dtype);return ca(Qu(bh(ca(i,[-1,s,o])).map((t=>el(p,t,f)))),r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xd=ys({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,c(null!=t&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=t[0].shape[0];for(let e=1;e<t.length;++e)c(t[e].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`))}else e=!0,t=Ku(t,t.shape[0],0).map((t=>Ju(t,[0])));c(t.length<=t[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`));const n=[],i=t;for(let e=0;e<t.length;++e)n.push(rs.tidy((()=>{let t=i[e];if(e>0)for(let i=0;i<e;++i){const e=Po(kl(Po(n[i],t)),n[i]);t=Ql(t,e)}return Ro(t,Tl(t,"euclidean"))})));return e?Qu(n,0):n}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wd(t,e=!1){return rs.tidy((()=>{c(2===t.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`));const n=t.shape[0],i=t.shape[1];let r=Al(n),s=xo(t);const o=rh([[1]],[1,1]);let a=xo(o);const l=n>=i?i:n;for(let t=0;t<l;++t){const e=s,l=a,c=r;[a,s,r]=rs.tidy((()=>{const e=ma(s,[t,t],[n-t,1]),l=Tl(e),c=ma(s,[t,t],[1,1]),u=el(Pl(c,0),rh([[-1]]),rh([[1]])),h=Ql(c,Po(u,l)),d=Ro(e,h);a=1===d.shape[0]?xo(o):da([o,ma(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=Yl(Ro(pa(u,h),l)),f=ma(s,[t,0],[n-t,i]),m=Po(p,a),g=Ch(a);if(0===t)s=Ql(f,pa(m,pa(g,f)));else{const e=Ql(f,pa(m,pa(g,f)));s=da([ma(s,[0,0],[t,i]),e],0)}const y=Ch(m),b=ma(r,[0,t],[n,r.shape[1]-t]);if(0===t)r=Ql(b,pa(pa(b,a),y));else{const e=Ql(b,pa(pa(b,a),y));r=da([ma(r,[0,0],[n,t]),e],1)}return[a,s,r]})),To([e,l,c])}return!e&&n>i&&(r=ma(r,[0,0],[n,i]),s=ma(s,[0,0],[i,i])),[r,s]}))}const Sd=ys({qr_:function(t,e=!1){if(c(t.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`)),2===t.rank)return wd(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce(((t,e)=>t*e)),i=bh(ca(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),r=[],s=[];i.forEach((t=>{const[n,i]=wd(t,e);r.push(n),s.push(i)}));return[ca(Qu(r,0),t.shape),ca(Qu(s,0),t.shape)]}}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var kd;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(kd||(kd={}));const Cd=ys({computeWeightedLoss_:function(t,e,n=kd.SUM_BY_NONZERO_WEIGHTS){const i=fs(t,"losses","computeWeightedLoss");let r=null;null!=e&&(r=fs(e,"weights","computeWeightedLoss"));const s=null==r?i:Po(i,r);if(n===kd.NONE)return s;if(n===kd.SUM)return kl(s);if(n===kd.MEAN){if(null==r)return pc(s);{const t=i.size/r.size,e=Ro(kl(s),kl(r));return t>1?Ro(e,xl(t)):e}}if(n===kd.SUM_BY_NONZERO_WEIGHTS){if(null==r)return Ro(kl(s),xl(i.size));{const t=Po(r,mc(i.shape)),e=vo(kl(kc(t,xl(0))),"float32");return Ro(kl(s),e)}}throw Error(`Unknown reduction: ${n}`)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Td=ys({absoluteDifference_:function(t,e,n,i=kd.SUM_BY_NONZERO_WEIGHTS){const r=fs(t,"labels","absoluteDifference"),s=fs(e,"predictions","absoluteDifference");let o=null;null!=n&&(o=fs(n,"weights","absoluteDifference")),u(r.shape,s.shape,"Error in absoluteDifference: ");const a=Oo(Ql(r,s));return Cd(a,o,i)}});const _d=ys({cosineDistance_:function(t,e,n,i,r=kd.SUM_BY_NONZERO_WEIGHTS){const s=fs(t,"labels","cosineDistance"),o=fs(e,"predictions","cosineDistance");let a=null;null!=i&&(a=fs(i,"weights","cosineDistance")),u(s.shape,o.shape,"Error in cosineDistance: ");const l=xl(1),c=Ql(l,kl(Po(s,o),n,!0));return Cd(c,a,r)}});const Ed=ys({hingeLoss_:function(t,e,n,i=kd.SUM_BY_NONZERO_WEIGHTS){let r=fs(t,"labels","hingeLoss");const s=fs(e,"predictions","hingeLoss");let o=null;null!=n&&(o=fs(n,"weights","hingeLoss")),u(r.shape,s.shape,"Error in hingeLoss: ");const a=xl(1);r=Ql(Po(xl(2),r),a);const l=_u(Ql(a,Po(r,s)));return Cd(l,o,i)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Md=ys({huberLoss_:function(t,e,n,i=1,r=kd.SUM_BY_NONZERO_WEIGHTS){const s=fs(t,"labels","huberLoss"),o=fs(e,"predictions","huberLoss");let a=null;null!=n&&(a=fs(n,"weights","huberLoss")),u(s.shape,o.shape,"Error in huberLoss: ");const l=xl(i),c=Oo(Ql(o,s)),h=yc(c,l),d=Ql(c,h),p=Ao(Po(xl(.5),Sl(h)),Po(l,d));return Cd(p,a,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $d=ys({logLoss_:function(t,e,n,i=1e-7,r=kd.SUM_BY_NONZERO_WEIGHTS){const s=fs(t,"labels","logLoss"),o=fs(e,"predictions","logLoss");let a=null;null!=n&&(a=fs(n,"weights","logLoss")),u(s.shape,o.shape,"Error in logLoss: ");const l=xl(1),c=xl(i),h=Yl(Po(s,jl(Ao(o,c)))),d=Po(Ql(l,s),jl(Ao(Ql(l,o),c))),p=Ql(h,d);return Cd(p,a,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Id=ys({meanSquaredError_:function(t,e,n,i=kd.SUM_BY_NONZERO_WEIGHTS){const r=fs(t,"labels","meanSquaredError"),s=fs(e,"predictions","meanSquaredError");let o=null;null!=n&&(o=fs(n,"weights","meanSquaredError")),u(r.shape,s.shape,"Error in meanSquaredError: ");const a=Zu(r,s);return Cd(a,o,i)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ad=ys({sigmoidCrossEntropy_:function(t,e,n,i=0,r=kd.SUM_BY_NONZERO_WEIGHTS){let s=fs(t,"multiClassLabels","sigmoidCrossEntropy");const o=fs(e,"logits","sigmoidCrossEntropy");let a=null;if(null!=n&&(a=fs(n,"weights","sigmoidCrossEntropy")),u(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),i>0){const t=xl(i),e=xl(1),n=xl(.5);s=Ao(Po(s,Ql(e,t)),Po(n,t))}const l=function(t,e){const n=fs(t,"labels","sigmoidCrossEntropyWithLogits"),i=fs(e,"logits","sigmoidCrossEntropyWithLogits");u(n.shape,i.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=_u(i),s=Po(i,n),o=Gl(El(Yl(Oo(i))));return Ao(Ql(r,s),o)}(s,o);return Cd(l,a,r)}});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nd=ys({softmaxCrossEntropy_:function(t,e,n,i=0,r=kd.SUM_BY_NONZERO_WEIGHTS){let s=fs(t,"onehotLabels","softmaxCrossEntropy");const o=fs(e,"logits","softmaxCrossEntropy");let a=null;if(null!=n&&(a=fs(n,"weights","softmaxCrossEntropy")),u(s.shape,o.shape,"Error in softmaxCrossEntropy: "),i>0){const t=xl(i),e=xl(1),n=xl(s.shape[1]);s=Ao(Po(s,Ql(e,t)),Ro(t,n))}const l=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);const i=Xl(((t,e,i)=>{const r=ec(e,[n],!0),s=Ql(vo(e,"float32"),r);i([t,s]);const o=Yl(Po(s,t));return{value:kl(o,[n]),gradFunc:(t,e)=>{const[i,r]=e,s=dl(t.shape,[n]);return[Po(ca(t,s),Ql(vo(i,"float32"),El(r))),Po(ca(t,s),Ql(El(r),vo(i,"float32")))]}}}));return i(t,e)}(s,o);return Cd(l,a,r)}});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rd=ys({sparseFillEmptyRows_:function(t,e,n,i){const r=fs(t,"indices","sparseFillEmptyRows","int32"),s=fs(e,"values","sparseFillEmptyRows"),o=fs(n,"denseShape","sparseFillEmptyRows","int32"),a=fs(i,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==r.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:r,values:s,denseShape:o,defaultValue:a},c=rs.runKernel(Bn,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pd=ys({sparseReshape_:function(t,e,n){const i=fs(t,"inputIndices","sparseReshape","int32"),r=fs(e,"inputShape","sparseReshape","int32"),s=fs(n,"newShape","sparseReshape","int32");if(2!==i.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${i.shape}`);if(1!==r.rank)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const o={inputIndices:i,inputShape:r,newShape:s},a=rs.runKernel(Un,o);return{outputIndices:a[0],outputShape:a[1]}}});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Od=ys({sparseSegmentMean_:function(t,e,n){const i=fs(t,"data","sparseSegmentMean"),r=fs(e,"indices","sparseSegmentMean","int32"),s=fs(n,"segmentIds","sparseSegmentMean","int32");if(i.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${r.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);const o={data:i,indices:r,segmentIds:s};return rs.runKernel(Vn,o)}});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ld=ys({sparseSegmentSum_:function(t,e,n){const i=fs(t,"data","sparseSegmentSum"),r=fs(e,"indices","sparseSegmentSum","int32"),s=fs(n,"segmentIds","sparseSegmentSum","int32");if(i.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${r.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);const o={data:i,indices:r,segmentIds:s};return rs.runKernel(Wn,o)}});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dd=ys({stringNGrams_:function(t,e,n,i,r,s,o,a){const l=fs(t,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=fs(e,"dataSplits","stringNGrams");if("int32"!==c.dtype)throw new Error("Data splits must be of datatype int32");const u={separator:n,nGramWidths:i,leftPad:r,rightPad:s,padWidth:o,preserveShortSequences:a},h={data:l,dataSplits:c},d=rs.runKernel(Kn,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fd={fft:Gu,ifft:qu,rfft:Yu,irfft:Xu},zd={hammingWindow:Hh,hannWindow:jh,frame:Gh,stft:qh},Bd={flipLeftRight:Kh,grayscaleToRGB:Yh,resizeNearestNeighbor:gd,resizeBilinear:md,rgbToGrayscale:Zh,rotateWithOffset:Jh,cropAndResize:Xh,nonMaxSuppression:td,nonMaxSuppressionAsync:ud,nonMaxSuppressionWithScore:hd,nonMaxSuppressionWithScoreAsync:dd,nonMaxSuppressionPadded:pd,nonMaxSuppressionPaddedAsync:fd,threshold:yd,transform:bd},Ud={bandPart:vd,gramSchmidt:xd,qr:Sd},Vd={absoluteDifference:Td,computeWeightedLoss:Cd,cosineDistance:_d,hingeLoss:Ed,huberLoss:Md,logLoss:$d,meanSquaredError:Id,sigmoidCrossEntropy:Ad,softmaxCrossEntropy:Nd},Wd={sparseFillEmptyRows:Rd,sparseReshape:Pd,sparseSegmentMean:Od,sparseSegmentSum:Ld},Hd={stringNGrams:Dd,stringSplit:ys({stringSplit_:function(t,e,n=!0){const i=fs(t,"input","stringSplit","string"),r=fs(e,"delimiter","stringSplit","string");if(1!==i.rank)throw new Error(`Input should be Tensor1D but received shape ${i.shape}`);if(0!==r.rank)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const s={skipEmpty:n},o={input:i,delimiter:r},a=rs.runKernel(Yn,o,s);return{indices:a[0],values:a[1],shape:a[2]}}}),stringToHashBucketFast:ys({stringToHashBucketFast_:
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t,e){const n=fs(t,"input","stringToHashBucketFast","string"),i={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return rs.runKernel(Zn,r,i)}}),staticRegexReplace:ys({staticRegexReplace_:
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t,e,n,i=!0){const r=fs(t,"input","staticRegexReplace","string"),s={pattern:e,rewrite:n,replaceGlobal:i};return rs.runKernel(qn,{x:r},s)}})},jd=new Map,Gd=new Map;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qd{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Xd{constructor(){this.classNameMap={}}static getMap(){return null==Xd.instance&&(Xd.instance=new Xd),Xd.instance}static register(t){Xd.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Kd(t,e,n){c(null!=t.className,(()=>"Class being registered does not have the static className property defined.")),c("string"==typeof t.className,(()=>"className is required to be a string, but got type "+typeof t.className)),c(t.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),void 0===e&&(e="Custom"),void 0===n&&(n=t.className);const i=e+">"+n;return Xd.register(t),jd.set(i,t),Gd.set(t,i),t}var Yd=Object.freeze({__proto__:null,Serializable:qd,SerializationMap:Xd,getRegisteredName:function(t){return Gd.has(t)?Gd.get(t):t.className},registerClass:Kd});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zd extends qd{minimize(t,e=!1,n){const{value:i,grads:r}=this.computeGradients(t,n);if(null!=n){const t=n.map((t=>({name:t.name,tensor:r[t.name]})));this.applyGradients(t)}else this.applyGradients(r);return To(r),e?i:(i.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return ql(t,e)}dispose(){null!=this.iterations_&&To(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:xl(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Zd,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Jd extends Zd{static get className(){return"Adadelta"}constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=rs.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const i=rs.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${e}/accum_grad`,variable:Co((()=>nl(i).variable(false)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${e}/accum_var`,variable:Co((()=>nl(i).variable(false)))});const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;Co((()=>{const t=Ao(Po(s,this.rho),Po(Sl(r),1-this.rho)),e=Po(Ro(wl(Ao(o,this.epsilon)),wl(Ao(s,this.epsilon))),r),n=Ao(Po(o,this.rho),Po(Sl(e),1-this.rho));s.assign(t),o.assign(n);const a=Ao(Po(e,-this.learningRate),i);i.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(To(this.accumulatedGrads.map((t=>t.variable))),To(this.accumulatedUpdates.map((t=>t.variable))))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)}))),this.accumulatedUpdates=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qd extends Zd{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const i=rs.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:`${e}/accumulator`,variable:Co((()=>Ma(i.shape,this.initialAccumulatorValue).variable(t)))}}const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const s=this.accumulatedGrads[n].variable;Co((()=>{const t=Ao(s,Sl(r));s.assign(t);const e=Ao(Po(Ro(r,wl(Ao(t,rs.backend.epsilon()))),-this.learningRate),i);i.assign(e)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&To(this.accumulatedGrads.map((t=>t.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tp extends Zd{static get className(){return"Adam"}constructor(t,e,n,i=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Co((()=>{this.accBeta1=xl(e).variable(),this.accBeta2=xl(n).variable()})),null==i&&(this.epsilon=rs.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);Co((()=>{const n=Ql(1,this.accBeta1),i=Ql(1,this.accBeta2);e.forEach(((e,r)=>{const s=rs.registeredVariables[e];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${e}/m`,variable:Co((()=>nl(s).variable(false)))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:`${e}/v`,variable:Co((()=>nl(s).variable(false)))});const o=Array.isArray(t)?t[r].tensor:t[e];if(null==o)return;const a=this.accumulatedFirstMoment[r].variable,l=this.accumulatedSecondMoment[r].variable,c=Ao(Po(a,this.beta1),Po(o,1-this.beta1)),u=Ao(Po(l,this.beta2),Po(Sl(o),1-this.beta2)),h=Ro(c,n),d=Ro(u,i);a.assign(c),l.assign(u);const p=Ao(Po(Ro(h,Ao(wl(d),this.epsilon)),-this.learningRate),s);s.assign(p)})),this.accBeta1.assign(Po(this.accBeta1,this.beta1)),this.accBeta2.assign(Po(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&To(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedSecondMoment&&To(this.accumulatedSecondMoment.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),Co((()=>{this.accBeta1.assign(vl(this.beta1,this.iterations_+1)),this.accBeta2.assign(vl(this.beta2,this.iterations_+1))}));const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)}))),this.accumulatedSecondMoment=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ep extends Zd{static get className(){return"Adamax"}constructor(t,e,n,i=null,r=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=i,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Co((()=>{this.iteration=xl(0).variable(),this.accBeta1=xl(e).variable()})),null==i&&(this.epsilon=rs.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);Co((()=>{const n=Ql(1,this.accBeta1),i=Ro(-this.learningRate,Ao(Po(this.iteration,this.decay),1));e.forEach(((e,r)=>{const s=rs.registeredVariables[e];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${e}/m`,variable:nl(s).variable(false)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:`${e}/v`,variable:nl(s).variable(false)});const o=Array.isArray(t)?t[r].tensor:t[e];if(null==o)return;const a=this.accumulatedFirstMoment[r].variable,l=this.accumulatedWeightedInfNorm[r].variable,c=Ao(Po(a,this.beta1),Po(o,1-this.beta1)),u=Po(l,this.beta2),h=Oo(o),d=dc(u,h);a.assign(c),l.assign(d);const p=Ao(Po(Ro(i,n),Ro(c,Ao(d,this.epsilon))),s);s.assign(p)})),this.iteration.assign(Ao(this.iteration,1)),this.accBeta1.assign(Po(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&To(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedWeightedInfNorm&&To(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class np extends Zd{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);e.forEach(((e,n)=>{const i=Array.isArray(t)?t[n].tensor:t[e];if(null==i)return;const r=rs.registeredVariables[e];Co((()=>{const t=Ao(Po(this.c,i),r);r.assign(t)}))})),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=_o(xl(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ip extends np{static get className(){return"Momentum"}constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=xl(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const i=rs.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:`${e}/momentum`,variable:Co((()=>nl(i).variable(t)))}}const r=this.accumulations[n].variable,s=Array.isArray(t)?t[n].tensor:t[e];null!=s&&Co((()=>{let t;const e=Ao(Po(this.m,r),s);t=this.useNesterov?Ao(Po(this.c,Ao(s,Po(e,this.m))),i):Ao(Po(this.c,e),i),r.assign(e),i.assign(t)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&To(this.accumulations.map((t=>t.variable)))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rp extends Zd{static get className(){return"RMSProp"}constructor(t,e=.9,n=0,i=null,r=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==i&&(this.epsilon=rs.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const i=rs.registeredVariables[e],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${e}/rms`,variable:Co((()=>nl(i).variable(r)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${e}/momentum`,variable:Co((()=>nl(i).variable(r)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${e}/mg`,variable:Co((()=>nl(i).variable(r)))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,a=this.accumulatedMoments[n].variable;Co((()=>{const t=Ao(Po(o,this.decay),Po(Sl(s),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,r=Ao(Po(e,this.decay),Po(s,1-this.decay)),l=Ro(Po(s,this.learningRate),wl(Ql(t,Ao(Sl(r),this.epsilon)))),c=Ao(Po(a,this.momentum),l);o.assign(t),e.assign(r),a.assign(c);const u=Ql(i,c);i.assign(u)}else{const t=Ao(Po(o,this.decay),Po(Sl(s),1-this.decay)),e=Ao(Po(a,this.momentum),Ro(Po(s,this.learningRate),wl(Ao(t,this.epsilon))));o.assign(t),a.assign(e);const n=Ql(i,e);i.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&To(this.accumulatedMeanSquares.map((t=>t.variable))),null!=this.accumulatedMeanGrads&&this.centered&&To(this.accumulatedMeanGrads.map((t=>t.variable))),null!=this.accumulatedMoments&&To(this.accumulatedMoments.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.accumulatedMoments=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sp=[Jd,Qd,tp,ep,ip,rp,np];function op(t){return new Promise((t=>setTimeout(t))).then(t)}class ap{constructor(t){if(!Y().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(ap.URL_SCHEME)&&(t=t.slice(ap.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=Ss.join(t.weightData),n=window.URL.createObjectURL(new Blob([e],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const e=As(t,[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]),i=window.URL.createObjectURL(new Blob([JSON.stringify(e)],{type:"application/json"})),r=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(r.download=this.modelJsonFileName,r.href=i,await op((()=>r.dispatchEvent(new MouseEvent("click")))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=n,await op((()=>t.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Ps(t)}}}}ap.URL_SCHEME="downloads://";class lp{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise(((t,e)=>{const n=new FileReader;n.onload=n=>{const i=JSON.parse(n.target.result),r=i.modelTopology;if(null==r)return void e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==i.weightsManifest)return void e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void t({modelTopology:r});const s=Rs(i,(t=>this.loadWeights(t)));t(s)},n.onerror=t=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(t){const e=[],n=[];for(const i of t)e.push(...i.weights),n.push(...i.paths);const i=this.checkManifestAndWeightFiles(t),r=n.map((t=>this.loadWeightsFile(t,i[t])));return Promise.all(r).then((t=>[e,t]))}loadWeightsFile(t,e){return new Promise(((n,i)=>{const r=new FileReader;r.onload=t=>{const e=t.target.result;n(e)},r.onerror=e=>i(`Failed to weights data from file of path '${t}'.`),r.readAsArrayBuffer(e)}))}checkManifestAndWeightFiles(t){const e=[],n=this.weightsFiles.map((t=>Is(t.name))),i={};for(const r of t)r.paths.forEach((t=>{const r=Is(t);if(-1!==e.indexOf(r))throw new Error(`Duplicate file basename found in weights manifest: '${r}'`);if(e.push(r),-1===n.indexOf(r))throw new Error(`Weight file with basename '${r}' is not provided.`);i[t]=this.weightsFiles[n.indexOf(r)]}));if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}function cp(t){return new lp(t)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function up(t,e,n,i){!function(t){c(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){c(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`)),c(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`)),c(e>=t,(()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`))}(n=null==n?0:n,i=null==i?1:i);let r=0;return Promise.all(t.map((s=>(s.then((s=>{const o=n+ ++r/t.length*(i-n);return e(o),s})),s))))}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function hp(t,e){null==e&&(e={});const n=null==e.fetchFunc?Y().platform.fetch:e.fetchFunc,i=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),r=(null==e.onProgress?await Promise.all(i):await up(i,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(r):await up(r,e.onProgress,.5,1)}function dp(t){return async(e,n="",i)=>{const r=e.map((()=>!1)),s={},o=null!=i?i.map((()=>!1)):[],a=[];if(e.forEach(((t,e)=>{let n=0;t.weights.forEach((t=>{const l="quantization"in t?t.quantization.dtype:t.dtype,c=ws[l]*d(t.shape),u=()=>{r[e]=!0,null==s[e]&&(s[e]=[]),s[e].push({manifestEntry:t,groupOffset:n,sizeBytes:c})};null!=i?i.forEach(((e,n)=>{e===t.name&&(u(),o[n]=!0)})):u(),a.push(t.name),n+=c}))})),!o.every((t=>t))){const t=i.filter(((t,e)=>!o[e]));throw new Error(`Could not find weights in manifest with names: ${t.join(", ")}. \nManifest JSON has weights with names: ${a.join(", ")}.`)}const l=r.reduce(((t,e,n)=>(e&&t.push(n),t)),[]),c=[];l.forEach((t=>{e[t].paths.forEach((t=>{const e=n+(n.endsWith("/")?"":"/")+t;c.push(e)}))}));const u=await t(c),h={};let p=0;return l.forEach((t=>{const n=e[t].paths.length,i=new Ss(u.slice(p,p+n));s[t].forEach((t=>{const e=Ts(i.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(const t in e)h[t]=e[t]})),p+=n})),h}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ds.registerSaveRouter((t=>Y().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ap.URL_SCHEME)?function(t="model"){return new ap(t)}(t.slice(ap.URL_SCHEME.length)):null));class pp{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(c("function"==typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=Y().platform.fetch,c(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&c(2===t.length,(()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`)),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=As(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);if(e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData){const n=Ss.join(t.weightData);e.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const i=await this.fetch(this.path,e);if(i.ok)return{modelArtifactsInfo:Ps(t),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,i=e.weightsManifest;if(null==n&&null==i)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Rs(e,(t=>this.loadWeights(t)))}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,i]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),i=t.substring(0,e),r=n>e?t.substring(n):"";return[i+"/",r]}(e),r=this.weightPathPrefix||n,s=Os(t),o=[],a=[];for(const e of t)for(const t of e.paths)null!=this.weightUrlConverter?a.push(this.weightUrlConverter(t)):o.push(r+t+i);this.weightUrlConverter&&o.push(...await Promise.all(a));return[s,await hp(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})]}}function fp(t){return null!=t.match(pp.URL_SCHEME_REGEX)}pp.URL_SCHEME_REGEX=/^https?:\/\//;const mp=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>fp(t))):fp(t),n)return gp(t,e)}return null};function gp(t,e){return new pp(t,e)}function yp(t,e){return gp(t,e)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ds.registerSaveRouter(mp),Ds.registerLoadRouter(mp);class bp{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class vp{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class xp{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function wp(t,e,n,i){if(1===arguments.length){return null!=t.modelTopology||null!=t.weightSpecs?new bp(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new bp({modelTopology:t}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new bp({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:i})}function Sp(t){return new vp(t)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var kp=Object.freeze({__proto__:null,CompositeArrayBuffer:Ss,browserFiles:cp,browserHTTPRequest:yp,concatenateArrayBuffers:$s,copyModel:async function(t,e){return uo(t,e,!1)},decodeWeights:Ts,encodeWeights:Cs,fromMemory:function(t,e,n,i){return new xp(wp(...arguments))},fromMemorySync:wp,getLoadHandlers:zs,getModelArtifactsForJSON:Rs,getModelArtifactsForJSONSync:Ns,getModelArtifactsInfoForJSON:Ps,getSaveHandlers:Fs,getWeightSpecs:Os,http:gp,isHTTPScheme:fp,listModels:ho,loadWeights:async function(t,e="",n,i){return dp((t=>hp(t,{requestInit:i})))(t,e,n)},moveModel:async function(t,e){return uo(t,e,!0)},registerLoadRouter:t=>Ds.registerLoadRouter(t),registerSaveRouter:t=>Ds.registerSaveRouter(t),removeModel:po,weightsLoaderFactory:dp,withSaveHandler:Sp,withSaveHandlerSync:function(t){return new vp(t)}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cp=ys({confusionMatrix_:function(t,e,n){const i=fs(t,"labels","confusionMatrix"),r=fs(e,"predictions","confusionMatrix");c(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),c(1===i.rank,(()=>`Expected the rank of labels to be 1, but got ${i.rank}`)),c(1===r.rank,(()=>`Expected the rank of predictions to be 1, but got ${r.rank}`)),c(i.shape[0]===r.shape[0],(()=>`Mismatch in the number of examples: ${i.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`)),c(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));const s=Cc(vo(i,"int32"),n),o=Cc(vo(r,"int32"),n),a=Ch(s),l=pa(a,o);return vo(l,"int32")}});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Tp=Object.freeze({__proto__:null,confusionMatrix:Cp});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _p,Ep=!1;function Mp(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,i=!1,r=!1,s=!1,o=!1,a=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)i=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)r=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)s=!0;else if(null!=t.getContext)o=!0;else{if(!("undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);a=!0}if(null!=bi(ui,rs.backendName)){const n={pixels:t},i={numChannels:e};return rs.runKernel(ui,n,i)}const[l,c]=r?[t.videoWidth,t.videoHeight]:[t.width,t.height];let u,h;if(o)u=t.getContext("2d").getImageData(0,0,l,c).data;else if(i||n)u=t.data;else if(s||r||a){if(null==_p)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");_p=new OffscreenCanvas(1,1).getContext("2d")}else _p=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});_p.canvas.width=l,_p.canvas.height=c,_p.drawImage(t,0,0,l,c),u=_p.getImageData(0,0,l,c).data}if(4===e)h=new Int32Array(u);else{const t=l*c;h=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)h[n*e+t]=u[4*n+t]}return sh(h,[c,l,e],"int32")}function $p(t){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(t instanceof ImageBitmap)&&function(t){return null!=t&&0!==t.width&&0!==t.height}(t)&&!function(t){return null!=t&&t.data instanceof Uint8Array}(t)}function Ip(t){if(2!==t.rank&&3!==t.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const e=2===t.rank?1:t.shape[2];if(e>4||2===e)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if("float32"!==t.dtype&&"int32"!==t.dtype)throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`)}async function Ap(t,e){let n=fs(t,"img","toPixels");if(!(t instanceof Or)){const t=n;n=vo(t,"int32"),t.dispose()}Ip(n);const[i,r]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2],o=await n.data(),a="float32"===n.dtype?255:1,l=new Uint8ClampedArray(r*i*4);for(let t=0;t<i*r;++t){const e=[0,0,0,255];for(let i=0;i<s;i++){const r=o[t*s+i];if("float32"===n.dtype){if(r<0||r>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${r}.`)}else if("int32"===n.dtype&&(r<0||r>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${r}.`);1===s?(e[0]=r*a,e[1]=r*a,e[2]=r*a):e[i]=r*a}const i=4*t;l[i+0]=Math.round(e[0]),l[i+1]=Math.round(e[1]),l[i+2]=Math.round(e[2]),l[i+3]=Math.round(e[3])}if(null!=e){if(!Ep){null!=bi(Zt,rs.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),Ep=!0)}e.width=r,e.height=i;const t=e.getContext("2d"),n=new ImageData(l,r,i);t.putImageData(n,0,0)}return n!==t&&n.dispose(),l}const Np=ys({fromPixels_:Mp});var Rp=Object.freeze({__proto__:null,draw:function(t,e,n){let i=fs(t,"img","draw");if(!(t instanceof Or)){const t=i;i=vo(t,"int32"),t.dispose()}Ip(i),function(t){const e=(null==t?void 0:t.alpha)||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}(null==n?void 0:n.imageOptions);const r={image:i},s={canvas:e,options:n};rs.runKernel(Zt,r,s)},fromPixels:Np,fromPixelsAsync:async function(t,e=3){let n=null;if(Y().getBool("WRAP_TO_IMAGEBITMAP")&&$p(t)){let e;try{e=await createImageBitmap(t,{premultiplyAlpha:"none"})}catch(t){e=null}n=null!=e&&e.width===t.width&&e.height===t.height?e:t}else n=t;return Mp(n,e)},toPixels:Ap});function Pp(t,e){const n=t.shape.length,i=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(i<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${i}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[i-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[i-1]} vs. ${n}`);if(0===d(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const r=e.shape,s=r[r.length-1];let o=1;for(let t=0;t<r.length-1;++t)o*=r[t];const a=t.shape,l=r.slice();l.pop();let c=1;for(let t=s;t<n;++t)c*=a[t],l.push(a[t]);const u=[...L(t.shape).map((t=>t/c)),1].slice(0,s);return[l,o,c,u]}var Op=Object.freeze({__proto__:null,prepareAndValidate:Pp});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lp=-2,Dp=-1;function Fp(t,e,n){const i=t.shape.length;c(i===e.length,(()=>`Error in slice${i}D: Length of begin ${e} must match the rank of the array (${i}).`)),c(i===n.length,(()=>`Error in slice${i}D: Length of size ${n} must match the rank of the array (${i}).`));for(let r=0;r<i;++r)c(e[r]+n[r]<=t.shape[r],(()=>`Error in slice${i}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`))}function zp(t,e,n){const i=[];for(let r=0;r<t.length;r++)i[r]=Math.ceil((e[r]-t[r])/n[r]);return i}function Bp(t,e,n,i){const r=[...t];for(let t=r.length;t<i.length;t++)r.push(1);for(let t=0;t<n;t++)0===t?r[e]=1:(r.splice(e,0,1),r.pop());return r}function Up(t,e,n){return n<=t?n:n-(e-1)}function Vp(t,e){const n=[];for(let i=0;i<t;i++)n.push(e+i);return n}function Wp(t,e,n,i,r){const s=[...r],o=Vp(n,e);for(let r=0;r<s.length;r++)if(o.indexOf(r)>-1)s[r]=0;else{const o=Up(e,n,r);let a=i[o];t&1<<o&&(a=0),s[r]=a}return s}function Hp(t,e,n,i,r){const o=[...r],a=Vp(n,e);for(let r=0;r<o.length;r++)if(a.indexOf(r)>-1)o[r]=Number.MAX_SAFE_INTEGER;else{const s=Up(e,n,r);let a=i[s];t&1<<s&&(a=Number.MAX_SAFE_INTEGER),o[r]=a}for(let t=0;t<o.length;t++){const e=r[t];o[t]<0&&(o[t]+=e),o[t]=s(0,o[t],r[t])}return o}function jp(t,e,n){let i=t[e];return(n&1<<e||null==i)&&(i=1),i}function Gp(t,e,n,i,r,o){let a=e[r];const l=n[r]||1;(t&1<<r||o&1<<r||null==a)&&(a=l>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=i[r];return a<0&&(a+=c),a=s(0,a,c-1),a}function qp(t,e,n,i,r,o){let a=e[r];const l=n[r]||1;(t&1<<r||o&1<<r||null==a)&&(a=l>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=i[r];return a<0&&(a+=c),a=l>0?s(0,a,c):s(-1,a,c-1),a}function Xp(t,e,n){let i=n.length;for(let t=0;t<n.length;t++)if(n[t]>1){i=t;break}for(let r=i+1;r<n.length;r++)if(e[r]>0||n[r]!==t[r])return!1;return!0}function Kp(t,e){let n=t.length>0?t[t.length-1]:1;for(let i=0;i<t.length-1;i++)n+=t[i]*e[i];return n}function Yp(t,e,n){let i;const r=t.shape.length;let s;return i="number"==typeof e?[e,...new Array(r-1).fill(0)]:e.length<r?e.concat(new Array(r-e.length).fill(0)):e.slice(),i.forEach((t=>{c(-1!==t,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(r).fill(-1):"number"==typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,s=s.map(((e,n)=>e>=0?e:(c(-1===e,(()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`)),t.shape[n]-i[n]))),[i,s]}function Zp(t,e,n,i,r,s,o,a,l){let c;if(null==i?(c=new Array(e.length),c.fill(1)):c=i,null!=o&&0!=(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:c.slice(),beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let t=0;t<h.dims;t++)u&&0!=(1<<t&a)&&h.numAddAxisAfterEllipsis++,1<<t&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=null!=t.begin,e.endValid=null!=t.end,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let i=0;i<t.dims;i++)if(1<<i&t.ellipsisMask){const r=Math.min(e.dims-(t.dims-i)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<r;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=i}else if(1<<i&t.newAxisMask)e.finalShapeGatherIndices.push(Lp),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);null!=t.begin&&(e.begin[n]=t.begin[i]),null!=t.end&&(e.end[n]=t.end[i]),e.strides[n]=t.strides[i],t.beginMask&1<<i&&(e.beginMask|=1<<n),t.endMask&1<<i&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<i?(e.finalShapeGatherIndices.push(Dp),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(i)),e.inputShapeGatherIndicesSparse[n]=i,n++}}(h,d);let p=!0,f=!0,m=!0;const g=[],y=[];for(let e=0;e<t.length;++e){if(0===d.strides[e])throw Error(`strides[${e}] must be non-zero`);const n=!!(d.shrinkAxisMask&1<<e),i=t[e];if(-1===i){g.push(n?1:-1);continue}const r=[d.beginMask&1<<e,d.endMask&1<<e],s=[d.strides[e]>0?0:-1,d.strides[e]>0?i:i-1];if(n&&d.strides[e]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[e];const o=!!(d.beginMask&1<<e&&d.endMask&1<<e);if(d.beginValid&&d.endValid){if(n){const t=d.begin[e]<0?i+d.begin[e]:d.begin[e];if(d.begin[e]=t,d.end[e]=d.begin[e]+1,t<0||t>=i)throw Error(`slice index ${d.begin[e]} of dimension ${e} out of bounds.`)}else d.begin[e]=Jp(d.begin[e],0,d.strides[e],i,r,s),d.end[e]=Jp(d.end[e],1,d.strides[e],i,r,s);const t=1===d.strides[e]&&0===d.begin[e]&&d.end[e]===i;p=p&&t,f=f&&(0===e&&1===d.strides[e]||t)}else p=p&&1===d.strides[e]&&o,f=f&&(0===e&&1===d.strides[e]||o);let a,l=!1;if(d.beginValid&&d.endValid?(a=d.end[e]-d.begin[e],l=!0):n?(a=1,l=!0):o&&i>=0&&(a=d.strides[e]<0?-i:i,l=!0),l){let t;t=0===a||a<0!=d.strides[e]<0?0:Math.trunc(a/d.strides[e])+(a%d.strides[e]!=0?1:0),g.push(t)}else g.push(-1)}for(let t=0;t<d.finalShapeGatherIndices.length;++t){const e=d.finalShapeGatherIndices[t];e>=0?y.push(g[e]):e===Lp&&y.push(1)}const b=y.filter(((t,e)=>d.finalShapeGatherIndices[e]!==Lp));return{finalShapeSparse:b,finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function Jp(t,e,n,i,r,s){if(r[e])return n>0?s[e]:s[e+1&1];{const e=t<0?i+t:t;return e<s[0]?s[0]:e>s[1]?s[1]:e}}var Qp=Object.freeze({__proto__:null,assertParamsValid:Fp,computeFlatOffset:Kp,computeOutShape:zp,getNormalizedAxes:function(t,e,n,i,r,s,o,a,l){const c=t.length;let u=new Array(c),h=new Array(c),d=new Array(c);if(e.length&&n>0){const l=e[0],c=n+1;u=Wp(o,l,c,i,t),h=Hp(a,l,c,r,t),d=Bp(s,l,c,t)}else for(let e=0;e<c;e++)u[e]=Gp(o,i,s,t,e,l),h[e]=qp(a,r,s,t,e,l),d[e]=jp(s,e,l);return{begin:u,end:h,strides:d}},isSliceContinous:Xp,maskToAxes:function(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e},parseSliceParams:Yp,sliceInfo:Zp,startForAxis:Gp,startIndicesWithElidedDims:Wp,stopForAxis:qp,stopIndicesWithElidedDims:Hp,stridesForAxis:jp,stridesWithElidedDims:Bp});
/** @license See the LICENSE file. */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class tf{static sgd(t){return new np(t)}static momentum(t,e,n=!1){return new ip(t,e,n)}static rmsprop(t,e=.9,n=0,i=null,r=!1){return new rp(t,e,n,i,r)}static adam(t=.001,e=.9,n=.999,i=null){return new tp(t,e,n,i)}static adadelta(t=.001,e=.95,n=null){return new Jd(t,e,n)}static adamax(t=.002,e=.9,n=.999,i=null,r=0){return new ep(t,e,n,i,r)}static adagrad(t,e=.1){return new Qd(t,e)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ef=tf,nf="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:t=>t();
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rf(){return new Promise((t=>nf((()=>t()))))}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sf(t,e){const n=t[0].length;t.forEach(((t,e)=>{c(t.length===n,(()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`))})),c(e>=0&&e<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const i=t[0];t.forEach(((t,r)=>{for(let s=0;s<n;s++)c(s===e||t[s]===i[s],(()=>`Error in concat${n}D: Shape of tensors[${r}] (${t}) does not match the shape of the rest (${i}) along the non-concatenated axis ${r}.`))}))}function of(t,e){const n=t[0].slice();for(let i=1;i<t.length;i++)n[e]+=t[i][e];return n}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var af;function lf(t,e,n){let i=new Array;if(null==n&&null==e)return i;if(null==e)for(;i.length<t+n.length;)i.push(-1);else i=e.slice();if(null==n)return i;if(t+n.length!==i.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${i.length}`);for(let r=1;r<n.length;++r){const s=n[r],o=i[i.length-n.length+r],a=i[o];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+t}] = ${s} but shape[${r+t}] = ${a}`)}else i[o]=s}return i}function cf(t){const e={FIRST_DIM_SIZE:af.FIRST_DIM_SIZE,VALUE_ROWIDS:af.VALUE_ROWIDS,ROW_LENGTHS:af.ROW_LENGTHS,ROW_SPLITS:af.ROW_SPLITS,ROW_LIMITS:af.ROW_LIMITS,ROW_STARTS:af.ROW_STARTS},n=[];for(const i of t){if(!(i in e))break;n.push(e[i])}return n}function uf(t){return 0===t.length?0:t[0]===af.FIRST_DIM_SIZE?t.length-1:t.length}function hf(t,e){if(null==t||null==e)return;const n=t.length,i=e.length;if(n>=i)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${i})`);for(let r=0;r<Math.min(n,i-1);++r){const n=t[r],i=e[r+1];if(n>=0&&i>=0&&1!==n&&n!==i)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-t.length}] = ${n} but ragged tensor input.flatValues.shape[${r-t.length}] = ${i}`)}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */!function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"}(af||(af={}));const df=30;function pf(t){return t<=df?t:O(t,Math.floor(Math.sqrt(t)))}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ff(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mf(t,e,n,i=!0){let r=[];if(i)r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const n=e.length;for(let i=0;i<n;++i)r=r.concat([t[i+1]/e[i],e[i]]);r=r.concat(t.slice(n+1))}return r}function gf(t,e,n=!0){const i=[];if(n){i.push(e);for(let n=e+1;n<t;++n)n<=2*e?(i.push(n),i.push(n-(e+1))):i.push(n)}else{const n=[],r=[];for(let i=1;i<t;++i)i>=2*e+1||i%2==1?r.push(i):n.push(i);i.push(...n),i.push(0),i.push(...r)}return i}function yf(t,e,n,i=!0){const r=[];i?r.push(t[0]/n):r.push(t[0]*n);for(let n=1;n<t.length;++n)n<=e.length?i?r.push(e[n-1]*t[n]):r.push(t[n]/e[n-1]):r.push(t[n]);return r}function bf(t,e){const n=[0];for(let i=0;i<e;++i)n.push(t[i][0]);return n}function vf(t,e,n){const i=t.slice(0,1);for(let r=0;r<n;++r)i.push(t[r+1]-e[r][0]-e[r][1]);return i}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xf=1.7580993408473768,wf=1.0507009873554805,Sf=.3275911,kf=.254829592,Cf=-.284496736,Tf=1.421413741,_f=-1.453152027,Ef=1.061405429;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Mf(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let i=0;i<n.length;i+=2)n[i]=t[i/2],n[i+1]=e[i/2];return n}function $f(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let i=0;i<t.length;i+=2)e[i/2]=t[i],n[i/2]=t[i+1];return{real:e,imag:n}}function If(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),i=new Float32Array(e);for(let e=0;e<t.length;e+=4)n[Math.floor(e/4)]=t[e],i[Math.floor(e/4)]=t[e+1];return{real:n,imag:i}}function Af(t){const e=Math.floor(t.length/4),n=new Float32Array(e),i=new Float32Array(e);for(let e=2;e<t.length;e+=4)n[Math.floor(e/4)]=t[e],i[Math.floor(e/4)]=t[e+1];return{real:n,imag:i}}function Nf(t,e){return{real:t[2*e],imag:t[2*e+1]}}function Rf(t,e,n,i){t[2*i]=e,t[2*i+1]=n}function Pf(t,e){const n=new Float32Array(t/2),i=new Float32Array(t/2);for(let r=0;r<Math.ceil(t/2);r++){const s=(e?2:-2)*Math.PI*(r/t);n[r]=Math.cos(s),i[r]=Math.sin(s)}return{real:n,imag:i}}function Of(t,e,n){const i=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(i),imag:Math.sin(i)}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lf="->",Df=/->/g,Ff=",",zf="...";function Bf(t,e){const n=((t=t.replace(/\s/g,"")).length-t.replace(Df,"").length)/Lf.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Lf}").`);const[i,r]=t.split(Lf);c(-1===i.indexOf(zf),(()=>`The ellipsis notation ("${zf}") is not supported yet.`));const s=i.split(Ff),o=s.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let t=0;t<r.length;++t){const e=r[t];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===a.indexOf(e)&&a.push(e)}for(let t=0;t<i.length;++t){const e=i[t];-1===a.indexOf(e)&&e!==Ff&&a.push(e)}const l=new Array(s.length);for(let t=0;t<o;++t){if(new Set(s[t].split("")).size!==s[t].length)throw new Error(`Found duplicate axes in input component ${s[t]}. Support for duplicate axes in input is not implemented yet.`);l[t]=[];for(let e=0;e<s[t].length;++e)l[t].push(a.indexOf(s[t][e]))}const u=a.length,h=[];for(let t=r.length;t<u;++t)h.push(t);return{allDims:a,summedDims:h,idDims:l}}function Uf(t,e){let n=new Array(t);n.fill(-1);for(let t=0;t<e.length;++t)n[e[t]]=t;const i=[];for(let e=0;e<t;++e)-1===n[e]&&i.push(e);return n=n.filter((t=>-1!==t)),{permutationIndices:n,expandDims:i}}function Vf(t,e,n){const i=new Array(t);for(let t=0;t<n.length;++t){const r=n[t].shape;for(let n=0;n<e[t].length;++n)void 0===i[e[t][n]]?i[e[t][n]]=r[n]:c(i[e[t][n]]===r[n],(()=>`Expected dimension ${i[e[t][n]]} at axis ${n} of input shaped ${JSON.stringify(r)}, but got dimension ${r[n]}`))}}function Wf(t,e){const n=t,i=[];let r=0;0===t.length&&n.push(-1),r=t.length+1;for(let t=0;t<r;++t)i.push([]);const s=[];for(let t=0;t<n.length;++t){const r=jf(e,n[t]);for(const e of r)-1===s.indexOf(e)&&(i[t].push(e),s.push(e))}return{path:n,steps:i}}function Hf(t){return t.every(((t,e)=>t===e))}function jf(t,e){const n=[];for(let i=0;i<t.length;++i)0!==t[i].length&&-1===t[i].indexOf(e)&&-1!==e||n.push(i);return n}function Gf(t,e,n=0){let i=[];if("number"==typeof e)c(t.shape[n]%e==0,(()=>"Number of splits must evenly divide the axis.")),i=new Array(e).fill(t.shape[n]/e);else{const r=e.reduce(((t,e)=>(-1===e&&(t+=1),t)),0);c(r<=1,(()=>"There should be only one negative value in split array."));const s=e.indexOf(-1);if(-1!==s){const i=e.reduce(((t,e)=>e>0?t+e:t));e[s]=t.shape[n]-i}c(t.shape[n]===e.reduce(((t,e)=>t+e)),(()=>"The sum of sizes must match the size of the axis dimension.")),i=e}return i}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qf(t){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${t}`}function Xf(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function Kf(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yf(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function Zf(t,e){return`size ${t} must be non-negative, not ${e}`}function Jf(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Qf(t,e){return`Input to reshape is a SparseTensor with ${d(t)}\n  dense values, but the requested shape requires a multiple of ${d(e)}. inputShape=${t} outputShape= ${e}`}function tm(t,e){return`Input to reshape is a tensor with ${d(t)} dense values, but the requested shape has ${d(e)}. inputShape=${t} outputShape=${e}`}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function em(){return"segment ids must be >= 0"}function nm(){return"segment ids are not increasing"}function im(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function rm(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sm(t,e){let n,i=!1;for(t<=df?(n=t,i=!0):n=O(t,Math.floor(Math.sqrt(t)));!i;)n>e||n===t?i=!0:n=O(t,n+1);return n}function om(t,e,n){const i=[],r=t.length;for(let s=0;s<r;s++)s!==e?i.push(t[s]):i.push(n);return i}function am(t,e,n,i){const r=e.shape.length,s=t.shape.length;if(0!==i&&(i<-r||i>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${i}`);if(i<0&&(i+=r),i>s)throw new Error(`batchDims (${i}) must be less than rank(x) (\n    ${s}).`);if(n<i)throw new Error(`batchDims (${i}) must be less than or equal to axis (${n}).`);for(let n=0;n<i;++n)if(t.shape[n]!==e.shape[n])throw new Error(`x.shape[${n}]: ${t.shape[n]} should be equal to indices.shape[${n}]: ${e.shape[n]}.`);const o=t.shape[n],a=[];let l=1,c=1,u=1;for(let e=0;e<i;++e)a.push(t.shape[e]),l*=t.shape[e];for(let e=i;e<n;e++)a.push(t.shape[e]),c*=t.shape[e];for(let t=i;t<r;t++)a.push(e.shape[t]);for(let e=n+1;e<s;e++)a.push(t.shape[e]),u*=t.shape[e];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}var lm=Object.freeze({__proto__:null,collectGatherOpShapeInfo:am,computeOutShape:om,segOpComputeOptimalWindowSize:sm});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cm(t){try{return t.map((t=>yr(t)))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function um(t){return t.map((t=>gr(t)))}var hm=Object.freeze({__proto__:null,ERF_A1:kf,ERF_A2:Cf,ERF_A3:Tf,ERF_A4:_f,ERF_A5:Ef,ERF_P:Sf,PARALLELIZE_THRESHOLD:df,get RowPartitionType(){return af},SELU_SCALE:wf,SELU_SCALEALPHA:xf,applyActivation:Lh,assertAndGetBroadcastShape:Ja,assertAxesAreInnerMostDims:pl,assertParamsConsistent:sf,assignToTypedArray:Rf,axesAreInnerMostDims:cl,calculateShapes:hh,checkEinsumDimSizes:Vf,checkPadOnDimRoundingMode:la,combineLocations:ul,combineRaggedTensorToTensorShapes:lf,complexWithEvenIndex:If,complexWithOddIndex:Af,computeConv2DInfo:Zo,computeConv3DInfo:Jo,computeDefaultPad:Qo,computeDilation2DInfo:Xo,computeOptimalWindowSize:pf,computeOutAndReduceShapes:hl,computeOutShape:of,computePool2DInfo:Ko,computePool3DInfo:Yo,convertConv2DDataFormat:aa,decodeEinsumEquation:Bf,eitherStridesOrDilationsAreOne:sa,expandShapeToKeepDim:dl,exponent:Of,exponents:Pf,fromStringArrayToUint8:um,fromUint8ToStringArray:cm,getAxesPermutation:fl,getBroadcastDims:Ya,getComplexWithIndex:Nf,getEinsumComputePath:Wf,getEinsumPermutation:Uf,getFusedBiasGradient:Oh,getFusedDyActivation:Ph,getImageCenter:ff,getInnerMostAxes:gl,getPermuted:gf,getRaggedRank:uf,getReductionAxes:Za,getReshaped:mf,getReshapedPermuted:yf,getRowPartitionTypesHelper:cf,getSliceBeginCoords:bf,getSliceSize:vf,getSparseFillEmptyRowsIndicesDenseShapeMismatch:qf,getSparseFillEmptyRowsNegativeIndexErrorMessage:Xf,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Kf,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Jf,getSparseReshapeInputOutputMismatchErrorMessage:tm,getSparseReshapeInputOutputMultipleErrorMessage:Qf,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:Yf,getSparseReshapeNegativeOutputDimErrorMessage:Zf,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:rm,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:em,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:nm,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:im,getUndoAxesPermutation:ml,isIdentityPermutation:Hf,log:function(...t){Y().getBool("IS_TEST")||Y().getBool("PROD")||console.log(...t)},mergeRealAndImagArrays:Mf,prepareAndValidate:Pp,prepareSplitSize:Gf,segment_util:lm,shouldFuse:Dh,slice_util:Qp,splitRealAndImagArrays:$f,stridesOrDilationsArePositive:oa,tupleValuesAreOne:ra,upcastType:Hr,validateDefaultValueShape:hf,validateInput:uh,validateUpdateShape:ch,warn:mi}),dm=Object.freeze({__proto__:null,nonMaxSuppressionV3Impl:id,nonMaxSuppressionV4Impl:rd,nonMaxSuppressionV5Impl:sd,whereImpl:wh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(){for(const t of sp)Kd(t)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */();var pm=Object.freeze({__proto__:null,Abs:et,Acos:nt,Acosh:it,AdadeltaOptimizer:Jd,AdagradOptimizer:Qd,AdamOptimizer:tp,AdamaxOptimizer:ep,Add:rt,AddN:st,All:ot,Any:at,ArgMax:lt,ArgMin:ct,Asin:ut,Asinh:ht,Atan:dt,Atan2:ft,Atanh:pt,AvgPool:mt,AvgPool3D:yt,AvgPool3DGrad:bt,AvgPoolGrad:gt,BatchMatMul:vt,BatchToSpaceND:xt,Bincount:wt,BitwiseAnd:St,BroadcastArgs:Ct,BroadcastTo:kt,Cast:Tt,Ceil:_t,ClipByValue:Et,Complex:Mt,ComplexAbs:$t,Concat:It,Conv2D:At,Conv2DBackpropFilter:Nt,Conv2DBackpropInput:Rt,Conv3D:Pt,Conv3DBackpropFilterV2:Ot,Conv3DBackpropInputV2:Lt,Cos:Dt,Cosh:Ft,CropAndResize:Ut,Cumprod:zt,Cumsum:Bt,DataStorage:e,DenseBincount:Vt,DepthToSpace:Wt,DepthwiseConv2dNative:Ht,DepthwiseConv2dNativeBackpropFilter:jt,DepthwiseConv2dNativeBackpropInput:Gt,Diag:qt,Dilation2D:Xt,Dilation2DBackpropFilter:Yt,Dilation2DBackpropInput:Kt,Draw:Zt,get ENV(){return J},Einsum:Qt,Elu:te,EluGrad:ee,Environment:X,Equal:ie,Erf:ne,Exp:re,ExpandDims:se,Expm1:oe,FFT:ae,Fill:le,FlipLeftRight:ce,Floor:ue,FloorDiv:he,FromPixels:ui,FusedBatchNorm:de,FusedConv2D:pi,FusedDepthwiseConv2D:fi,GatherNd:fe,GatherV2:pe,Greater:me,GreaterEqual:ge,IFFT:be,Identity:ye,Imag:ve,IsFinite:xe,IsInf:we,IsNan:Se,KernelBackend:n,LRN:Re,LRNGrad:Pe,LeakyRelu:ke,Less:Ce,LessEqual:Te,LinSpace:_e,Log:Ee,Log1p:Me,LogSoftmax:Ne,LogicalAnd:$e,LogicalNot:Ie,LogicalOr:Ae,LogicalXor:"LogicalXor",LowerBound:"LowerBound",MatrixBandPart:"MatrixBandPart",Max:Oe,MaxPool:De,MaxPool3D:ze,MaxPool3DGrad:Be,MaxPoolGrad:Fe,MaxPoolWithArgmax:Ue,Maximum:Le,Mean:Ve,Min:We,Minimum:He,MirrorPad:je,Mod:Ge,MomentumOptimizer:ip,Multinomial:qe,Multiply:Xe,Neg:Ke,NonMaxSuppressionV3:Ze,NonMaxSuppressionV4:Je,NonMaxSuppressionV5:Qe,NotEqual:Ye,OP_SCOPE_SUFFIX:gs,OneHot:en,OnesLike:tn,Optimizer:Zd,OptimizerConstructors:tf,Pack:nn,PadV2:rn,Pool:"Pool",Pow:sn,Prelu:on,Prod:an,RMSPropOptimizer:rp,RaggedGather:ln,RaggedRange:cn,RaggedTensorToTensor:un,Range:hn,get Rank(){return Fr},Real:dn,RealDiv:Jt,Reciprocal:pn,get Reduction(){return kd},Relu:fn,Relu6:xn,Reshape:mn,ResizeBilinear:bn,ResizeBilinearGrad:vn,ResizeNearestNeighbor:gn,ResizeNearestNeighborGrad:yn,Reverse:wn,RotateWithOffset:hi,Round:Sn,Rsqrt:kn,SGDOptimizer:np,ScatterNd:Cn,SearchSorted:_n,Select:En,Selu:Mn,Sigmoid:Rn,Sign:Nn,Sin:In,Sinh:An,Slice:$n,Softmax:zn,Softplus:Pn,SpaceToBatchND:Dn,SparseFillEmptyRows:Bn,SparseReshape:Un,SparseSegmentMean:Vn,SparseSegmentSum:Wn,SparseToDense:Hn,SplitV:Fn,Sqrt:On,Square:Gn,SquaredDifference:jn,StaticRegexReplace:qn,Step:ci,StridedSlice:Xn,StringNGrams:Kn,StringSplit:Yn,StringToHashBucketFast:Zn,Sub:Jn,Sum:Ln,Tan:Qn,Tanh:ti,Tensor:Or,TensorBuffer:Nr,TensorScatterUpdate:Tn,Tile:ei,TopK:ni,Transform:ii,Transpose:ri,Unique:si,Unpack:oi,UnsortedSegmentSum:ai,UpperBound:"UpperBound",Variable:Dr,ZerosLike:li,_FusedMatMul:di,abs:Oo,acos:Lo,acosh:Do,add:Ao,addN:Fo,all:zo,any:Bo,argMax:Uo,argMin:Vo,asin:Wo,asinh:Ho,atan:jo,atan2:Go,atanh:qo,avgPool:ua,avgPool3d:ha,backend:Io,backend_util:hm,basicLSTMCell:ya,batchNorm:va,batchNorm2d:xa,batchNorm3d:wa,batchNorm4d:Sa,batchToSpaceND:ba,bincount:ka,bitwiseAnd:Ca,booleanMaskAsync:kh,broadcastArgs:Ta,broadcastTo:_a,broadcast_util:Qa,browser:Rp,buffer:bo,cast:vo,ceil:Ea,clipByValue:$a,clone:xo,complex:bs,concat:da,concat1d:Ia,concat2d:Aa,concat3d:Na,concat4d:Ra,conv1d:Oa,conv2d:Pa,conv2dTranspose:Da,conv3d:Fa,conv3dTranspose:Ba,copyRegisteredKernels:function(t,e){xi(t).forEach((t=>{wi(Object.assign({},t,{backendName:e}))}))},cos:Ua,cosh:Va,cosineWindow:Ah,cumprod:Wa,cumsum:Ha,customGrad:Xl,denseBincount:ja,deprecationWarn:function(t){Y().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")},depthToSpace:Ga,depthwiseConv2d:qa,device_util:cs,diag:Xa,dilation2d:Ka,disableDeprecationWarnings:function(){Y().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")},dispose:To,disposeVariables:function(){rs.disposeVariables()},div:Ro,divNoNan:il,dot:rl,dropout:$h,einsum:sl,elu:ol,enableDebugMode:function(){Y().set("DEBUG",!0)},enableProdMode:
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(){Y().set("PROD",!0)},enclosingPowerOfTwo:Ih,engine:So,ensureShape:al,env:Y,equal:tl,erf:ll,euclideanNorm:_l,exp:El,expandDims:Ml,expm1:$l,eye:Al,fft:Gu,fill:Ma,findBackend:function(t){return rs.findBackend(t)},findBackendFactory:function(t){return rs.findBackendFactory(t)},floor:Nl,floorDiv:No,fused:Wh,gather:Rl,gatherND:Mh,gather_util:Op,getBackend:Mo,getGradient:vi,getKernel:bi,getKernelsForBackend:xi,grad:function(t){return c(P(t),(()=>"The f passed in grad(f) must be a function")),(e,n)=>{const i=fs(e,"x","tf.grad","string_or_numeric"),r=null!=n?fs(n,"dy","tf.grad"):null;return rs.tidy((()=>{const{value:e,grads:n}=rs.gradients((()=>t(i)),[i],r);return null!=r&&u(e.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Kl(n),n[0]}))}},grads:function(t){return c(P(t),(()=>"The f passed in grads(f) must be a function")),(e,n)=>{c(Array.isArray(e),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));const i=ms(e,"args","tf.grads","string_or_numeric"),r=null!=n?fs(n,"dy","tf.grads"):null;return rs.tidy((()=>{const{value:e,grads:n}=rs.gradients((()=>t(...i)),i,r);return null!=r&&u(e.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Kl(n),n}))}},greater:Pl,greaterEqual:Ol,ifft:qu,imag:Ll,image:Bd,inTopKAsync:Nh,io:kp,irfft:Xu,isFinite:Dl,isInf:Fl,isNaN:zl,keep:_o,kernel_impls:dm,leakyRelu:Bl,less:Ul,lessEqual:Vl,linalg:Ud,linspace:Wl,localResponseNormalization:Hl,log:jl,log1p:Gl,logSigmoid:Jl,logSoftmax:tc,logSumExp:ec,logicalAnd:nc,logicalNot:ic,logicalOr:rc,logicalXor:sc,losses:Vd,lowerBound:lc,matMul:pa,math:Tp,max:yl,maxPool:cc,maxPool3d:uc,maxPoolWithArgmax:hc,maximum:dc,mean:pc,memory:ko,meshgrid:gc,min:bl,minimum:yc,mirrorPad:bc,mod:vc,moments:xc,movingAverage:Th,mul:Po,multiRNNCell:wc,multinomial:Sc,neg:Yl,nextFrame:rf,norm:Tl,notEqual:kc,oneHot:Cc,ones:mc,onesLike:Tc,op:ys,outerProduct:_c,pad:Ec,pad1d:Mc,pad2d:$c,pad3d:Ic,pad4d:Ac,pool:Rc,pow:vl,prelu:Pc,print:wo,prod:Oc,profile:function(t){return rs.profile(t)},raggedGather:Lc,raggedRange:Dc,raggedTensorToTensor:Fc,rand:zc,randomGamma:bu,randomNormal:vu,randomStandardNormal:xu,randomUniform:wu,randomUniformInt:Su,range:ku,ready:Eo,real:Cu,reciprocal:Tu,registerBackend:$o,registerGradient:Si,registerKernel:wi,relu:_u,relu6:Eu,removeBackend:function(t){rs.removeBackend(t)},reshape:ca,reverse:Mu,reverse1d:$u,reverse2d:Iu,reverse3d:Au,reverse4d:Nu,rfft:Yu,round:Ru,rsqrt:Pu,scalar:xl,scatterND:_h,scatter_util:dh,searchSorted:ac,selu:Ou,separableConv2d:Lu,serialization:Yd,setBackend:function(t){return rs.setBackend(t)},setPlatform:function(t,e){Y().setPlatform(t,e)},setdiff1dAsync:Du,sigmoid:fa,sign:Fu,signal:zd,sin:zu,sinh:Bu,slice:ma,slice1d:Uu,slice2d:Vu,slice3d:Wu,slice4d:Hu,slice_util:Qp,softmax:ju,softplus:Zl,spaceToBatchND:Nc,sparse:Wd,sparseToDense:Eh,spectral:Fd,split:Ku,sqrt:wl,square:Sl,squaredDifference:Zu,squeeze:Ju,stack:Qu,step:th,stridedSlice:eh,string:Hd,sub:Ql,sum:kl,sumOutType:jr,tan:nh,tanh:ga,tensor:xs,tensor1d:ih,tensor2d:rh,tensor3d:sh,tensor4d:oh,tensor5d:ah,tensor6d:lh,tensorScatterUpdate:ph,tensor_util:Qr,test_util:fu,tidy:Co,tile:Il,time:function(t){return rs.time(t)},topk:fh,train:ef,transpose:Ch,truncatedNormal:mh,unique:gh,unregisterGradient:function(t){if(!yi.has(t))throw new Error(`The gradient '${t}' for backend is not registered`);yi.delete(t)},unregisterKernel:function(t,e){const n=ki(t,e);if(!gi.has(n))throw new Error(`The kernel '${t}' for backend '${e}' is not registered`);gi.delete(n)},unsortedSegmentSum:yh,unstack:bh,upcastType:Hr,upperBound:vh,util:xr,valueAndGrad:function(t){return c(P(t),(()=>"The f passed in valueAndGrad(f) must be a function")),(e,n)=>{c(e instanceof Or,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),c(null==n||n instanceof Or,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));const{grads:i,value:r}=rs.gradients((()=>t(e)),[e],n);return Kl(i),{grad:i[0],value:r}}},valueAndGrads:function(t){return c(P(t),(()=>"The f passed in valueAndGrads(f) must be a function")),(e,n)=>{c(Array.isArray(e)&&e.every((t=>t instanceof Or)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),c(null==n||n instanceof Or,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));const i=rs.gradients((()=>t(...e)),e,n);return null!=n&&u(i.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Kl(i.grads),i}},variable:xh,variableGrads:ql,version_core:"4.11.0",where:el,whereAsync:Sh,zeros:fc,zerosLike:nl});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fm(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&c("complex64"!==t.dtype,(()=>`${e} does not support complex64 tensors in the CPU backend.`))}))}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mm=wh;class gm extends n{nextDataId(){return gm.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new e(this,So())}write(t,e,n){this.firstUse&&(this.firstUse=!1,Y().get("IS_NODE")&&mi("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const i={id:this.nextDataId()};return this.data.set(i,{values:t,dtype:n,refCount:1}),i}makeTensorInfo(t,e,n){let i;if("string"===e&&null!=n&&n.length>0&&I(n[0])){const r=n.map((t=>gr(t)));i=this.write(r,t,e)}else i=this.write(n,t,e);return{dataId:i,shape:t,dtype:e}}refCount(t){if(this.data.has(t)){return this.data.get(t).refCount}return 0}incRef(t){this.data.get(t).refCount++}decRef(t){if(this.data.has(t)){this.data.get(t).refCount--}}move(t,e,n,i,r){this.data.set(t,{values:e,dtype:i,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:n}=this.data.get(t);if("complex64"===e){return Mf(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return z(this.data.get(t).values,e)}bufferSync(t){const e=this.readSync(t.dataId);if("string"===t.dtype)try{const n=e.map((t=>yr(t)));return bo(t.shape,t.dtype,n)}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}return bo(t.shape,t.dtype,e)}makeOutput(t,e,n){return So().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(t);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=mr();t();return{kernelMs:mr()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){fm([t],"where");const e=this.readSync(t.dataId);return mm(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ym(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}gm.nextDataId=0;const bm={kernelName:et,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend;fm(e,"abs");let i=new Float32Array(d(e.shape));return i=ym(n.data.get(e.dataId).values),n.makeOutput(i,e.shape,e.dtype)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vm(t){return(e,n,i,r,s)=>{const o=Ja(e,n),a=o.length,l=L(o),c=k(s,d(o)),u=e.length,h=n.length,p=L(e),f=L(n),m=Ya(e,o),g=Ya(n,o);if(m.length+g.length===0)for(let e=0;e<c.length;++e)c[e]=t(i[e%i.length],r[e%r.length]);else for(let e=0;e<c.length;++e){const n=j(e,a,l),s=n.slice(-u);m.forEach((t=>s[t]=0));const o=H(s,u,p),d=n.slice(-h);g.forEach((t=>d[t]=0));const y=H(d,h,f);c[e]=t(i[o],r[y])}return[c,o]}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xm(t){const{inputs:e,backend:n}=t,{real:i,imag:r}=e,s=n.data.get(i.dataId).values,o=n.data.get(r.dataId).values,a=n.makeTensorInfo(i.shape,"complex64");return n.data.get(a.dataId).complexTensorInfos={real:n.makeTensorInfo(i.shape,"float32",s),imag:n.makeTensorInfo(r.shape,"float32",o)},a}const wm={kernelName:Mt,backendName:"cpu",kernelFunc:xm};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sm(t,e,n="float32"){if("complex64"===n){return xm({inputs:{real:Sm(t,e,"float32"),imag:Sm(t,e,"float32")},backend:t})}const i=U(d(e),n);return t.makeTensorInfo(e,n,i)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function km(t){const{inputs:e,backend:n}=t,{x:i}=e;return n.incRef(i.dataId),{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}const Cm={kernelName:ye,backendName:"cpu",kernelFunc:km};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tm(t){const{inputs:e,backend:n}=t,{input:i}=e,r=n.data.get(i.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}const _m={kernelName:dn,backendName:"cpu",kernelFunc:Tm};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Em(t,e,n,i){if("int32"===i){return[e,"int32",Int32Array.from(t)]}if("bool"===i){const i=fr([0],n),[r,s]=vm(((t,e)=>t!==e?1:0))(e,[],t,i,"bool");return[s,"bool",r]}throw new Error(`Error in Cast: failed to cast ${n} to ${i}`)}function Mm(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{dtype:s}=i;if("complex64"===s){if("complex64"===r.dtype)return km({inputs:{x:r},backend:n});const t=Sm(n,r.shape,r.dtype),e=Mm({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=xm({inputs:{real:e,imag:t},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),i}if("complex64"===r.dtype){const t=Tm({inputs:{input:r},backend:n}),e=Mm({inputs:{x:t},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(t),e}if(!E(r.dtype,s)){const t=km({inputs:{x:r},backend:n});return{dataId:t.dataId,shape:t.shape,dtype:s}}const o=n.data.get(r.dataId).values,[a,l,c]=Em(o,r.shape,r.dtype,s);return n.makeTensorInfo(a,l,c)}const $m={kernelName:Tt,backendName:"cpu",kernelFunc:Mm};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Im(t,e,n,i){return null==n?({inputs:n,backend:r})=>{const{a:s,b:o}=n,a=r;fm([s,o],t);const l=a.data.get(s.dataId).values,c=a.data.get(o.dataId).values,u="string"===s.dtype?cm(l):l,h="string"===s.dtype?cm(c):c,d=i||s.dtype,[p,f]=e(s.shape,o.shape,u,h,d);return a.makeTensorInfo(f,d,p)}:({inputs:t,backend:r})=>{const{a:s,b:o}=t,a=r;if("complex64"===s.dtype||"complex64"===o.dtype){const t=Mm({inputs:{x:s},backend:a,attrs:{dtype:"complex64"}}),e=a.data.get(t.dataId),i=e.complexTensorInfos.real,r=e.complexTensorInfos.imag,l=a.data.get(i.dataId).values,c=a.data.get(r.dataId).values,u=Mm({inputs:{x:o},backend:a,attrs:{dtype:"complex64"}}),h=a.data.get(u.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=a.data.get(d.dataId).values,m=a.data.get(p.dataId).values,[g,y,b]=n(s.shape,o.shape,l,c,f,m),v=a.makeTensorInfo(b,"float32",g),x=a.makeTensorInfo(b,"float32",y),w=xm({inputs:{real:v,imag:x},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(u),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),w}{const t=a.data.get(s.dataId).values,n=a.data.get(o.dataId).values,r=i||s.dtype,[l,c]=e(s.shape,o.shape,t,n,r);return a.makeTensorInfo(c,r,l)}}}function Am(t){return(e,n,i,r,s,o)=>{const a=Ja(e,n),l=d(a),c=a.length,u=L(a),h=k("float32",l),p=k("float32",l),f=Ya(e,a),m=Ya(n,a),g=Mf(i,r),y=Mf(s,o),b=e.length,v=L(e),x=n.length,w=L(n);if(f.length+m.length===0)for(let e=0;e<h.length;e++){const n=e%g.length,i=e%y.length,r=t(g[2*n],g[2*n+1],y[2*i],y[2*i+1]);h[e]=r.real,p[e]=r.imag}else for(let e=0;e<h.length;e++){const n=j(e,c,u),i=n.slice(-b);f.forEach((t=>i[t]=0));const r=H(i,b,v),s=n.slice(-x);m.forEach((t=>s[t]=0));const o=H(s,x,w),a=t(g[2*r],g[2*r+1],y[2*o],y[2*o+1]);h[e]=a.real,p[e]=a.imag}return[h,p,a]}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nm=vm(((t,e)=>t+e)),Rm=Am(((t,e,n,i)=>({real:t+n,imag:e+i}))),Pm=Im(rt,Nm,Rm),Om={kernelName:rt,backendName:"cpu",kernelFunc:Pm};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Lm(t,e,n,i,r){const s=d(i),o=U(r,n);for(let n=0;n<t.length;n++){const i=t[n];if(i<0)throw new Error("Input x must be non-negative!");i>=r||(o[i]+=s>0?e[n]:1)}return o}function Dm(t,e,n,i=!1){const r=t.shape[0],s=t.shape[1],o=bo([r,n],e.dtype);for(let a=0;a<r;a++)for(let r=0;r<s;r++){const s=t.get(a,r);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(i?o.set(1,a,s):e.size>0?o.set(o.get(a,s)+e.get(a,r),a,s):o.set(o.get(a,s)+1,a,s))}return o}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fm=vm(((t,e)=>t&e)),zm=Im(St,Fm),Bm={kernelName:St,backendName:"cpu",kernelFunc:zm};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Um(t){return(e,n,i)=>{const r=C(n,e.length);for(let n=0;n<e.length;++n)r[n]=t(e[n],i);return r}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vm(t,e,n){return Wm(t,Um(e),n)}function Wm(t,e,n){return({inputs:i,attrs:r,backend:s})=>{const{x:o}=i;fm(o,t);const a=s,l=a.data.get(o.dataId).values;let c;if("string"===o.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=cm(l)}else c=l;const u=n||o.dtype,h=e(c,u,r);return a.makeTensorInfo(o.shape,u,h)}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hm=Um((t=>Math.ceil(t))),jm=Wm(_t,Hm),Gm={kernelName:_t,backendName:"cpu",kernelFunc:jm};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qm(t,e,n,i){const r=C(n,d(e));if(i&&"string"!==n){let e=0;t.forEach((t=>{const n=d(t.shape);r.set(t.vals,e),e+=n}))}else{let i=0;t.forEach((t=>{const s="string"===n?cm(t.vals):t.vals;let o=0;for(let n=0;n<t.shape[0];++n){const a=n*e[1]+i;for(let e=0;e<t.shape[1];++e)r[a+e]=s[o++]}i+=t.shape[1]}))}return r}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xm=vm(((t,e)=>t===e?1:0)),Km=Im(ie,Xm,null,"bool"),Ym={kernelName:ie,backendName:"cpu",kernelFunc:Km},Zm=Um((t=>Math.exp(t))),Jm=Wm(re,Zm,"float32"),Qm={kernelName:re,backendName:"cpu",kernelFunc:Jm},tg=Um((t=>Math.expm1(t))),eg=Wm(oe,tg),ng={kernelName:oe,backendName:"cpu",kernelFunc:eg},ig=Um((t=>Math.floor(t))),rg=Wm(ue,ig),sg={kernelName:ue,backendName:"cpu",kernelFunc:rg},og=vm(((t,e)=>Math.floor(t/e))),ag=Im(he,og,null,"int32"),lg={kernelName:he,backendName:"cpu",kernelFunc:ag};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cg(t,e,n,i,r,s,o,a,l){const c=bo([i,s],n);for(let n=0;n<i;n++){const i=[];let u=0;for(let e=0;e<r;e++){const s=t[n*r+e];u+=s*o[e],i.push(s)}if(u<0||u>=l/s)throw new Error(`Invalid indices: ${i} does not index into ${a}`);for(let t=0;t<s;t++)c.values[n*s+t]=e.get(...e.indexToLoc(u*s+t))}return c}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ug(t,e,n){const i=bo(n,t.dtype);for(let n=0;n<i.size;++n){const r=i.indexToLoc(n).slice(),s=r[0],o=r[2],a=e.locToIndex([s,o]);r[2]=e.values[a];const l=t.locToIndex(r);0<=l&&l<t.values.length&&(i.values[n]=t.values[l])}return i}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hg=vm(((t,e)=>t>e?1:0)),dg=Im(me,hg,null,"bool"),pg={kernelName:me,backendName:"cpu",kernelFunc:dg},fg=vm(((t,e)=>t>=e?1:0)),mg=Im(ge,fg,null,"bool"),gg={kernelName:ge,backendName:"cpu",kernelFunc:mg},yg=vm(((t,e)=>t<e?1:0)),bg=Im(Ce,yg,null,"bool"),vg={kernelName:Ce,backendName:"cpu",kernelFunc:bg},xg=vm(((t,e)=>t<=e?1:0)),wg=Im(Te,xg,null,"bool"),Sg={kernelName:Te,backendName:"cpu",kernelFunc:wg};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kg(t,e,n){const i=(e-t)/(n-1),r=U(n,"float32");r[0]=t;for(let t=1;t<r.length;t++)r[t]=r[t-1]+i;return r}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cg=Um((t=>Math.log(t))),Tg=Wm(Ee,Cg),_g={kernelName:Ee,backendName:"cpu",kernelFunc:Tg};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Eg(t,e,n,i){const r=k(i,d(n));for(let n=0;n<r.length;++n){const i=n*e;let s=t[i];for(let n=0;n<e;++n){const e=t[i+n];(Number.isNaN(e)||e>s)&&(s=e)}r[n]=s}return r}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mg=vm(((t,e)=>Math.max(t,e))),$g=Im(Le,Mg),Ig={kernelName:Le,backendName:"cpu",kernelFunc:$g},Ag=vm(((t,e)=>Math.min(t,e))),Ng=Im(He,Ag),Rg={kernelName:He,backendName:"cpu",kernelFunc:Ng},Pg=vm(((t,e)=>t*e)),Og=Am(((t,e,n,i)=>({real:t*n-e*i,imag:t*i+e*n}))),Lg=Im(Xe,Pg,Og),Dg={kernelName:Xe,backendName:"cpu",kernelFunc:Lg};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fg(t,e,n){const i=pr(-1,n);return Pg([],e,i,t,n)}const zg={kernelName:Ke,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:i}=e;fm(i,"neg");const r=n.data.get(i.dataId).values,[s,o]=Fg(r,i.shape,i.dtype);return n.makeTensorInfo(o,i.dtype,s)}},Bg=vm(((t,e)=>t!==e?1:0)),Ug=Im(Ye,Bg,null,"bool"),Vg={kernelName:Ye,backendName:"cpu",kernelFunc:Ug};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Wg(t,e,n,i,r){const s=e.length,o=d(e),a=L(e),l=L(r),c=k(n,d(r));for(let e=0;e<o;++e){const n=j(e,s,a),r=new Array(n.length);for(let t=0;t<r.length;t++)r[t]=n[i[t]];c[H(r,s,l)]=t[e]}return c}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hg(t){const{inputs:e,attrs:n,backend:i}=t,{x:r}=e,{perm:s}=n;fm(r,"transpose");const o=r.shape.length,a=new Array(o);for(let t=0;t<a.length;t++)a[t]=r.shape[s[t]];const l=Wg(i.data.get(r.dataId).values,r.shape,r.dtype,s,a);return{dataId:i.write(l,a,r.dtype),shape:a,dtype:r.dtype}}const jg={kernelName:ri,backendName:"cpu",kernelFunc:Hg};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gg(t,e,n,i){const[r,s]=hl(t,i),o=Hr(e,"int32"),a=U(d(r),o),l=d(s);for(let t=0;t<a.length;++t){const e=t*l;let i=1;for(let t=0;t<l;++t)i*=n[e+t];a[t]=i}return{outVals:a,outShape:r,outDtype:o}}const qg={kernelName:an,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,keepDims:o}=i;fm(r,"prod");const a=r.shape.length,l=w(s,r.shape),c=fl(l,a);let u=l,h=r;const d=[];null!=c&&(h=Hg({inputs:{x:r},backend:n,attrs:{perm:c}}),d.push(h),u=gl(u.length,a));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=Gg(h.shape,h.dtype,p,u);let y=m;return o&&(y=dl(m,l)),d.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(y,g,f)}};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xg(t,e,n,i){const r=[];let s=0;const o=e.length-1+n.length,a=new Array(o).fill(null).map((()=>[0]));!function(t,e){for(let n=0;n<t.length;++n){const i=t[n],r=n===t.length-1?e:t[n+1].length;if(0===i.length)throw new Error("Ragged splits may not be empty");if(i[0]<0)throw new Error("Ragged splits must be non-negative");if(i[i.length-1]>r)throw new Error("Ragged splits must not point past values");for(let t=1;t<i.length;++t)if(i[t-1]>i[t])throw new Error("Ragged splits must be sorted in ascending order")}}(n,i);let l=1;for(let t=0;t<e.length-1;++t){l*=e[t];const n=e[t+1];for(let e=1;e<l+1;++e)a[t].push(e*n)}for(let i=0;i<t.length;++i){let o=t[i],l=t[i]+1;for(let t=0;t<n.length;++t){const i=n[t],r=t+e.length-1;if(r>=0){const t=a[r],e=t[t.length-1]-i[o];for(let t=o;t<l;++t)a[r].push(i[t+1]+e)}o=i[o],l=i[l]}l!==o&&(r.push([o,l]),s+=l-o)}return{outSplits:a,valueSlices:r,numValues:s}}function Kg(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let i=e;i<t.length;i++)n[e-1]*=t[i];return n}function Yg(t,e,n,i,r){const s=e.slice();s[0]=r;const o=C(n,d(s)),a=t.length;return function(t,e,n,i,r,s){const o=Kg(e,2)[1],a=Kg(s,2)[1];let l=0;for(const e of n)for(let n=e[0];n<e[1];++n){for(let e=0;e<i;++e)r[l*a+e]=t[n*o+e];++l}}(t,e,i,0===a?0:a/e[0],o,s),[o,s]}function Zg(t,e,n,i,r,s,o,a){if(0===t.length)throw new Error("paramsNestedSplits must be non empty");if(0===e[0].length)throw new Error("Split tensors must not be scalars");if(function(t,e,n){t.forEach(((t,i)=>{if(t<0||t>=n){const r=j(i,e.length,L(e)).join(",");throw new Error(`indices[${r}] = ${t} is not in [0, ${n})`)}}))}(s,o,e[0][0]-1),0===i.length)throw new Error("params.rank must be nonzero");const l=i[0],{outSplits:c,valueSlices:u,numValues:h}=Xg(s,o,t,l),d=function(t){const e=[];for(let n=0;n<t.length;++n){const i=C("int32",t[n].length);e.push(i),t[n].forEach(((t,e)=>i[e]=t))}return e}(c),p=Yg(n,i,r,u,h);return[d,p[0],p[1]]}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jg=2147483647;function Qg(t,e,n,i,r,s,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=0===e.length,l=0===r.length,c=0===o.length,u=[];a||u.push(e[0]),l||u.push(r[0]),c||u.push(o[0]);for(let t=1;t<u.length;++t)if(u[t]!==u[t-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===u.length?1:u[0],d=C("int32",h+1);d[0]=0;for(let e=0;e<h;++e){const n=a?t[0]:t[e],r=l?i[0]:i[e],o=c?s[0]:s[e];if(0===o)throw new Error("Requires delta != 0");let u;if(o>0&&r<n||o<0&&r>n)u=0;else if(u=Math.ceil(Math.abs((r-n)/o)),u>Jg)throw new Error(`Requires ((limit - start) / delta) <= ${Jg}`);d[e+1]=d[e]+u}const p=C(n,d[h]);let f=0;for(let e=0;e<h;++e){const n=d[e+1]-d[e];let i=a?t[0]:t[e];const r=c?s[0]:s[e];for(let t=0;t<n;++t)p[f++]=i,i+=r}return[d,p]}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ty=af;class ey{constructor(t,e,n,i,r,s,o,a,l,c){this.shape=t,this.shapeShape=e,this.values=n,this.valuesShape=i,this.valuesDType=r,this.defaultValue=s,this.defaultValueShape=o,this.rowPartitionValues=a,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=cf(c),this.raggedRank=uf(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===ty.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===ty.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case ty.VALUE_ROWIDS:return ey.getMaxWidthValueRowID(e);case ty.ROW_SPLITS:return ey.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${ty[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let n=0;for(let i=0;i<e-1;++i){const e=t[i+1]-t[i];e>n&&(n=e)}return n}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let n=0,i=t[0],r=0;for(let s=1;s<e;++s){const e=t[s];e!==i&&(i=e,r=Math.max(s-n,r),n=s)}return Math.max(e-n,r)}tensorShapeFromTensor(t,e,n=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return iy(t,n)}calculateOutputSize(t){const e=this.valuesShape;hf(this.defaultValueShape,e);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=lf(this.raggedRank,n,e);i[0]<0&&(i[0]=t);for(let t=1;t<=this.raggedRank;++t)i[t]<0&&(i[t]=this.getMaxWidth(t));return i}calculateFirstParentOutputIndex(t,e,n){const i=Math.min(t,n),r=[];let s=0;for(let t=0;t<i;++t,s+=e)r.push(s);for(let e=i;e<t;++e)r.push(-1);return c(r.length===t,(()=>"Final length of result must be equal to firstDimension.")),r}calculateOutputIndexRowSplit(t,e,n,i){const r=t.length,s=[];for(let o=0;o<r-1;++o){const r=t[o+1]-t[o];let a=Math.min(i,r),l=e[o];-1===l&&(a=0);for(let t=0;t<a;++t)s.push(l),l+=n;for(let t=0;t<r-a;++t)s.push(-1)}if(r>0&&s.length!==t[r-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(t,e,n,i){const r=t.length,s=[];if(0===r)return[];let o=0,a=t[0];if(a>=e.length)throw new Error(`Got currentValueRowId=${a}, which is not less than ${e.length}`);let l=e[a];s.push(l);for(let c=1;c<r;++c){const r=t[c];if(r===a)l>=0&&(++o,o<i?l+=n:l=-1);else{if(o=0,a=r,r>=e.length)throw new Error(`Got nextValueRowId=${r} which is not less than ${e.length}`);l=e[r]}s.push(l)}if(s.length!==t.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(t,e,n,i){const r=this.getRowPartitionTensor(t),s=this.getRowPartitionTypeByDimension(t);switch(s){case ty.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,e,n,i);case ty.ROW_SPLITS:if(r.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${r.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(r,e,n,i);default:throw new Error(`Unsupported partition type: ${ty[s]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case ty.FIRST_DIM_SIZE:return t[0];case ty.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ty.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ty[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),e=this.calculateOutputSize(t),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let t=n.length-2;t>=0;--t)n[t]=n[t+1]*e[t+1];const i=iy(e,!1),r=C(this.valuesDType,d(i));if(n[0]*e[0]>0){let s=this.calculateFirstParentOutputIndex(t,n[0],e[0]);for(let t=1;t<=this.raggedRank;++t){s=this.calculateOutputIndex(t-1,s,n[t],e[t])}this.setOutput(this.raggedRank,s,r,i)}return[i,r]}setOutput(t,e,n,i){if(0===n.length)return;const r=this.values,s=n;let o=i.slice();o=o.slice(t+1);const a=d(o),l=e.length;let c=this.defaultValue;if(c.length!==a&&1!==c.length){const t=this.defaultValueShape;Co((()=>{const e=ca(c,t),n=_a(e,o);c=n.dataSync()}))}let u=0,h=0,p=0;for(let t=0;t<=l;++t){let i=t<l?e[t]:-1;if(i!==p){if(h<p){const t=r.subarray(u*a);ny(s.subarray(h*a),t,(p-h)*a)}if(t>=l){const t=n.length;i=Math.floor(t/a)}if(i>p)if(1===this.defaultValue.length)s.subarray(p*a,i*a).fill(this.defaultValue[0]),p=i;else for(;i>p;){ny(s.slice(p*a),c,a),++p}i<0?(u=t+1,h=p):(u=t,h=p,p=h+1)}else++p}}}function ny(t,e,n){for(let i=0;i<n;i++)t[i]=e[i]}function iy(t,e){const n=[];for(let i of t){if(i<0){if(!e)throw new Error(`Dimension ${i} must be >= 0`);if(i<-1)throw new Error(`Dimension ${i} must be >= -1`);i=-1}n.push(i)}return n}function ry(t,e,n,i,r,s,o,a,l,c){return new ey(t,e,n,i,r,s,o,a,l,c).compute()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sy(t,e,n,i){if(t===e||t<e&&n<0||e<t&&n>1)return U(0,i);const r=U(Math.abs(Math.ceil((e-t)/n)),i);e<t&&1===n&&(n=-1),r[0]=t;for(let t=1;t<r.length;t++)r[t]=r[t-1]+n;return r}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oy=Um((t=>1/Math.sqrt(t))),ay=Wm(kn,oy),ly={kernelName:kn,backendName:"cpu",kernelFunc:ay};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cy(t,e,n,i,r,s,o,a,l,c){const u=[i/r,r],h=t.values,d=e.values;if(0===i)return bo(n,e.dtype);const p=l instanceof Nr?l:bo(u,e.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let t=0;t<s;t++){const s=[];let l=0;for(let e=0;e<o;e++){const n=h[t*o+e];s.push(n),l+=n*a[e]}if(l<0||l>=i/r)throw new Error(`Invalid indices: ${s} does not index into ${n}`);for(let n=0;n<r;n++)c?p.values[l*r+n]+=d[t*r+n]:p.values[l*r+n]=0===e.rank?d[0]:d[t*r+n]}return p}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uy=Um((t=>1/(1+Math.exp(-t)))),hy=Vm(Rn,(t=>1/(1+Math.exp(-t)))),dy={kernelName:Rn,backendName:"cpu",kernelFunc:hy};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function py(t,e,n,i,r){const s=Xp(i,e,n),o=d(n),a=L(i);if(s){const n=Kp(e,a);return"string"===r?t.slice(n,n+o):t.subarray(n,n+o)}const l=bo(i,r,"string"===r?cm(t):t),c=bo(n,r);for(let t=0;t<c.size;++t){const n=c.indexToLoc(t),i=n.map(((t,n)=>t+e[n]));c.set(l.get(...i),...n)}return"string"===r?um(c.values):c.values}function fy(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{begin:s,size:o}=i;fm(r,"slice");const[a,l]=Yp(r,s,o);Fp(r,a,l);const c=py(n.data.get(r.dataId).values,a,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,c)}const my={kernelName:$n,backendName:"cpu",kernelFunc:fy};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gy(t,e,n,i,r,s,o){const a=e[0],l=s[0],c=new Array(l),u=new Array(a),h=e[1];if(0===l){if(0!==a)throw new Error(qf(a));return[C(n,0),[0,h],C(r,0),c,u]}let d=!0,p=0;const f=new Array(l).fill(0);for(let e=0;e<a;++e){const n=t[e*h];if(n<0)throw new Error(Xf(e,n));if(n>=l)throw new Error(Kf(e,n,l));++f[n],d=d&&n>=p,p=n}let m=!0;for(let t=0;t<l;++t){const e=0===f[t];c[t]=e,m=m&&!e,f[t]=Math.max(f[t],1),t>0&&(f[t]+=f[t-1])}if(m&&d){const e=t,n=i;for(let t=0;t<a;++t)u[t]=t;return[e,[a,h],n,c,u]}{const e=f[l-1],s=C(n,e*h),d=C(r,e),p=new Array(l).fill(0);for(let e=0;e<a;++e){const n=t[e*h],r=p[n],o=(0===n?0:f[n-1])+r;p[n]++;for(let n=0;n<h;++n)s[o*h+n]=t[e*h+n];d[o]=i[e],u[e]=o}for(let t=0;t<l;++t){if(0===p[t]){const e=0===t?0:f[t-1];s[e*h+0]=t;for(let t=1;t<h;++t)s[e*h+t]=0;d[e]=o}}return[s,[e,h],d,c,u]}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yy(t,e,n,i,r){const s=d(i),o=e[0],a=r.length,l=[];let c=1,u=-1;for(let t=0;t<a;++t){const e=r[t];if(-1===e){if(-1!==u)throw new Error(Yf(u,t));u=t,l.push(1)}else{if(e<0)throw new Error(Zf(t,e));c*=e,l.push(e)}}if(-1!==u){if(c<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const t=Math.trunc(s/c);if(c*t!==s)throw new Error(Qf(i,l));l[u]=t}if(d(l)!==s)throw new Error(tm(i,l));const h=i.length,p=[];if(h>0){p[h-1]=1;for(let t=h-2;t>=0;--t)p[t]=p[t+1]*i[t+1]}const f=[];if(a>0){f[a-1]=1;for(let t=a-2;t>=0;--t)f[t]=f[t+1]*l[t+1]}const m=C(n,o*a);for(let e=0;e<o;++e){let n=0;for(let i=0;i<h;++i)n+=t[e*h+i]*p[i];for(let t=0;t<a;++t)m[e*a+t]=Math.trunc(n/f[t]),n%=f[t]}return[m,[o,a],l]}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function by(t,e,n,i,r,s=!1,o=0){const a=i.length,l=[e[0],t.length/e[0]],c=l[1],u=a>0?r[a-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const h=e.slice();h[0]=u;const d=C(n,h.reduce(((t,e)=>t*e),1));if(0===a)return u>0&&d.fill(o),[d,h];if(u<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=r[p];for(;;){let e=0;if(f<a){if(e=r[f],g===e){++f;continue}if(g>=e)throw new Error("segment ids are not increasing")}if(g<0||g>=u)throw new Error(im(g,u));g>m&&d.fill(o,m*c,g*c);for(let e=p;e<f;++e){const n=i[e];if(n<0||n>=l[0])throw new Error(rm(e,i[e],l[0]));for(let e=0;e<c;e++)d[g*c+e]+=t[n*c+e]}if(s)for(let t=0;t<c;t++)d[g*c+t]/=f-p;if(p=f,++f,m=g+1,g=e,f>a)break}return m<u&&d.fill(o,m*c,u*c),[d,h]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vy=Um((t=>Math.sqrt(t))),xy=Vm(On,(t=>Math.sqrt(t))),wy={kernelName:On,backendName:"cpu",kernelFunc:xy},Sy=vm(((t,e)=>{const n=t-e;return n*n})),ky=Im(jn,Sy),Cy={kernelName:jn,backendName:"cpu",kernelFunc:ky},Ty=Um(((t,e)=>{const{pattern:n,replaceGlobal:i,rewrite:r}=e;return t.replace(new RegExp(n,i?"g":""),r)})),_y=Wm(qn,Ty),Ey={kernelName:qn,backendName:"cpu",kernelFunc:_y};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function My(t,e,n,i){const r=bo(t,e.dtype);for(let t=0;t<r.size;t++){const s=r.indexToLoc(t),o=new Array(s.length);for(let t=0;t<o.length;t++)o[t]=s[t]*n[t]+i[t];r.set(e.get(...o),...s)}return r}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $y{constructor(t,e,n,i,r,s){this.separator=gr(t),this.nGramWidths=e,this.leftPad=gr(n),this.rightPad=gr(i),this.padWidth=r,this.preserveShort=s}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,i,r,s){for(let o=0;o<r;++o){const a=this.getPadWidth(s),l=Math.max(0,a-o),c=Math.max(0,a-(r-(o+1))),u=s-(l+c),h=e+(l>0?0:o-a);let d=0;d+=l*this.leftPad.length;for(let e=0;e<u;++e)d+=t[h+e].length;d+=c*this.rightPad.length;d+=(l+c+u-1)*this.separator.length,n[i+o]=new Uint8Array(d);const p=n[i+o];let f=0;const m=t=>t.forEach((t=>p[f++]=t));for(let t=0;t<l;++t)m(this.leftPad),m(this.separator);for(let e=0;e<u-1;++e)m(t[h+e]),m(this.separator);if(u>0){m(t[h+u-1]);for(let t=0;t<c;++t)m(this.separator),m(this.rightPad)}else{for(let t=0;t<c-1;++t)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(t,e){const n=t.length,i=e.length;if(i>0){let t=e[0];if(0!==t)throw new Error(`First split value must be 0, got ${t}`);for(let r=1;r<i;++r){let i=e[r]>=t;if(i=i&&e[r]<=n,!i)throw new Error(`Invalid split value ${e[r]}, must be in [${t}, ${n}]`);t=e[r]}if(t!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${t}`)}const r=i-1,s=C("int32",i);if(0===n||0===i){const t=new Array(n);for(let t=0;t<=r;++t)s[t]=0;return[t,s]}s[0]=0;for(let t=1;t<=r;++t){const n=e[t]-e[t-1];let i=0;this.nGramWidths.forEach((t=>{i+=this.getNumNGrams(n,t)})),this.preserveShort&&n>0&&0===i&&(i=1),s[t]=s[t-1]+i}const o=new Array(s[r]);for(let n=0;n<r;++n){const i=e[n];let r=s[n];if(this.nGramWidths.forEach((s=>{const a=e[n+1]-e[n],l=this.getNumNGrams(a,s);this.createNGrams(t,i,o,r,l,s),r+=l})),this.preserveShort&&r===s[n]){const s=e[n+1]-e[n];if(0===s)continue;const a=s+2*this.padWidth,l=1;this.createNGrams(t,i,o,r,l,a)}}return[o,s]}}function Iy(t,e,n,i,r,s,o,a){return new $y(n,i,r,s,o,a).compute(t,e)}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ay(t,e,n,i){if(!t.length)return;if(0===e.length){for(let e=0;e<t.length;++e)i.push(t.subarray(e,e+1));return}if(1===e.length){const r=e[0];let s=t.indexOf(r);for(;-1!==s;){const e=t.subarray(0,s);n&&0===e.length||i.push(e),s=(t=t.subarray(s+1)).indexOf(r)}return void(n&&0===t.length||i.push(t))}let r=0;for(let s=0;s<t.length+1;s++)if(s===t.length||-1!==e.indexOf(t[s])){const e=t.subarray(r,s);n&&0===e.length||i.push(e),r=s+1}}function Ny(t,e,n){const i=t.length,r=[];let s=0,o=0;const a=new Array(i);for(let l=0;l<i;++l){const i=r.length;Ay(t[l],e,n,r);const c=r.length-i;a[l]=c,s+=c,o=Math.max(o,c)}const l=C("int32",2*s),c=new Array(s),u=[i,o];let h=0;for(let t=0;t<i;++t)for(let e=0;e<a[t];++e)l[2*h]=t,l[2*h+1]=e,c[h]=r[h],++h;return[l,c,u]}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ry(t,e){const n=C("int32",t.length);for(let i=0;i<t.length;++i)n[i]=dr(t[i]).modulo(e).getLowBitsUnsigned();return n}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Py=vm(((t,e)=>t-e)),Oy=Am(((t,e,n,i)=>({real:t-n,imag:e-i}))),Ly=Im(Jn,Py,Oy),Dy={kernelName:Jn,backendName:"cpu",kernelFunc:Ly};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fy(t,e){const n=new Array(t.rank);for(let i=0;i<n.length;i++)n[i]=t.shape[i]*e[i];const i=bo(n,t.dtype);for(let e=0;e<i.values.length;++e){const n=i.indexToLoc(e),r=new Array(t.rank);for(let e=0;e<r.length;e++)r[e]=n[e]%t.shape[e];const s=t.locToIndex(r);i.values[e]=t.values[s]}return i}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zy=(t,e)=>{const n=e.value-t.value;return 0===n?t.index-e.index:n};function By(t,e,n=0,i=t.length-1){for(;i>n;){if(i-n>600){const r=i-n+1,s=e-n+1,o=Math.log(r),a=.5*Math.exp(2*o/3),l=.5*Math.sqrt(o*a*(r-a)/r)*Math.sign(s-r/2);By(t,e,Math.max(n,Math.floor(e-s*a/r+l)),Math.min(i,Math.floor(e+(r-s)*a/r+l)))}const r=t[e];let s=n,o=i;for(a(t,n,e),zy(t[i],r)>0&&a(t,n,i);s<o;){for(a(t,s,o),s++,o--;zy(t[s],r)<0;)s+=1;for(;zy(t[o],r)>0;)o-=1}0===zy(t[n],r)?a(t,n,o):(o+=1,a(t,o,i)),o<=e&&(n=o+1),e<=o&&(i=o-1)}}function Uy(t,e,n,i,r){const s=e[e.length-1],[o,a]=[t.length/s,s],l=k(n,o*i),c=k("int32",o*i);for(let e=0;e<o;e++){const n=e*a,s=t.subarray(n,n+a);let o=new Array(s.length);s.forEach(((t,e)=>o[e]={value:t,index:e})),i<o.length&&(By(o,i),o=o.slice(0,i)),r&&o.sort(zy);const u=e*i,h=l.subarray(u,u+i),d=c.subarray(u,u+i);for(let t=0;t<i;t++)h[t]=o[t].value,d[t]=o[t].index}const u=e.slice();return u[u.length-1]=i,[bo(u,n,l),bo(u,"int32",c)]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vy(t,e,n,i){const r=w(e,n)[0],s=[1,n[0],1];for(let t=0;t<r;t++)s[0]*=n[t];s[1]=n[r];for(let t=r+1;t<n.length;t++)s[2]*=n[t];const o=new Map,a=new Int32Array(n[r]),l=new Nr(s,i,t),c=[],u=1===s[0]&&1===s[2];for(let e=0;e<n[r];e++){let n;if(u)n=t[e].toString();else{const t=[];for(let n=0;n<s[0];n++)for(let i=0;i<s[2];i++)t.push(l.get(n,e,i));n=t.join(",")}const i=o.get(n);if(null!=i)a[e]=i;else{const t=o.size;o.set(n,t),a[e]=t,c.push(e)}}const h=s.slice();h[1]=o.size;const d=new Nr(h,i);c.forEach(((t,e)=>{for(let n=0;n<s[0];n++)for(let i=0;i<s[2];i++)d.set(l.get(n,t,i),n,e,i)}));const p=n.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:a}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Wy=Object.freeze({__proto__:null,addImpl:Nm,bincountImpl:Lm,bincountReduceImpl:Dm,bitwiseAndImpl:Fm,castImpl:Em,ceilImpl:Hm,concatImpl:qm,equalImpl:Xm,expImpl:Zm,expm1Impl:tg,floorDivImpl:og,floorImpl:ig,gatherNdImpl:cg,gatherV2Impl:ug,greaterEqualImpl:fg,greaterImpl:hg,lessEqualImpl:xg,lessImpl:yg,linSpaceImpl:kg,logImpl:Cg,maxImpl:Eg,maximumImpl:Mg,minimumImpl:Ag,multiplyImpl:Pg,negImpl:Fg,notEqualImpl:Bg,prodImpl:Gg,raggedGatherImpl:Zg,raggedRangeImpl:Qg,raggedTensorToTensorImpl:ry,rangeImpl:sy,rsqrtImpl:oy,scatterImpl:cy,sigmoidImpl:uy,simpleAbsImpl:ym,sliceImpl:py,sparseFillEmptyRowsImpl:gy,sparseReshapeImpl:yy,sparseSegmentReductionImpl:by,sqrtImpl:vy,squaredDifferenceImpl:Sy,staticRegexReplaceImpl:Ty,stridedSliceImpl:My,stringNGramsImpl:Iy,stringSplitImpl:Ny,stringToHashBucketFastImpl:Ry,subImpl:Py,tileImpl:Fy,topKImpl:Uy,transposeImpl:Wg,uniqueImpl:Vy});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */$o("cpu",(()=>new gm),1);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Hy=Vm(te,(t=>t>=0?t:Math.exp(t)-1)),jy={kernelName:te,backendName:"cpu",kernelFunc:Hy};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Gy(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{alpha:s}=i;fm([r],"leakyRelu");const o=d(r.shape),a=n.data.get(r.dataId).values,l=k("float32",o);for(let t=0;t<a.length;t++)l[t]=a[t]<0?s*a[t]:a[t];return n.makeTensorInfo(r.shape,"float32",l)}const qy={kernelName:ke,backendName:"cpu",kernelFunc:Gy},Xy=vm(((t,e)=>t<0?e*t:t));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ky(t){const{inputs:e,backend:n}=t,{x:i,alpha:r}=e;fm([i,r],"prelu");const s=n.data.get(i.dataId).values,o=n.data.get(r.dataId).values,[a,l]=Xy(i.shape,r.shape,s,o,"float32");return n.makeTensorInfo(l,"float32",a)}const Yy={kernelName:on,backendName:"cpu",kernelFunc:Ky},Zy=Vm(fn,(t=>Math.max(0,t))),Jy={kernelName:fn,backendName:"cpu",kernelFunc:Zy},Qy=Vm(xn,(t=>Math.min(Math.max(0,t),6))),tb={kernelName:xn,backendName:"cpu",kernelFunc:Qy};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eb(t,e,n,i,r){if("linear"===n)return km({inputs:{x:e},backend:t});if("relu"===n)return Zy({inputs:{x:e},backend:t});if("elu"===n)return Hy({inputs:{x:e},backend:t});if("relu6"===n)return Qy({inputs:{x:e},backend:t});if("prelu"===n)return Ky({inputs:{x:e,alpha:i},backend:t});if("leakyrelu"===n)return Gy({inputs:{x:e},backend:t,attrs:{alpha:r}});if("sigmoid"===n)return hy({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nb(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{shape:s}=i,o=d(r.shape),a=x(s,o),l=d(a);c(o===l,(()=>`The new shape (${a}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(r.dataId);const u=n.data.get(r.dataId);if(null!=u.complexTensorInfos){const t=u.complexTensorInfos.real,e=u.complexTensorInfos.imag;t.shape=a,e.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const ib={kernelName:mn,backendName:"cpu",kernelFunc:nb};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rb(t){const{inputs:e,backend:n,attrs:i}=t,{a:r,b:s}=e,{transposeA:o,transposeB:a}=i;fm([r,s],"matMul");const l=r.shape.length,u=s.shape.length,h=o?r.shape[l-2]:r.shape[l-1],p=a?s.shape[u-1]:s.shape[u-2],f=o?r.shape[l-1]:r.shape[l-2],m=a?s.shape[u-2]:s.shape[u-1],g=r.shape.slice(0,-2),y=s.shape.slice(0,-2),b=d(g),v=d(y),x=Ja(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([f,m]);c(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${o} and transposeB=${a} must match.`));const w=a?[v,m,p]:[v,p,m],S=nb({inputs:{x:r},backend:n,attrs:{shape:o?[b,h,f]:[b,f,h]}}),k=nb({inputs:{x:s},backend:n,attrs:{shape:w}}),C=o?S.shape[1]:S.shape[2],T=o?S.shape[2]:S.shape[1],_=a?k.shape[1]:k.shape[2],E=Math.max(b,v),M=n.data.get(S.dataId).values,$=n.data.get(k.dataId).values,I=L(S.shape),A=L(k.shape),[N,R,P]=o?[I[0],1,I[1]]:[I[0],I[1],1],[O,D,F]=a?[1,A[1],A[0]]:[A[1],1,A[0]],z=T*_,B=bo([E,T,_],S.dtype),U=B.values,V=n.blockSize;for(let t=0;t<E;t++){const e=t%b,n=t%v;for(let i=0;i<T;i+=V){const r=Math.min(i+V,T);for(let s=0;s<_;s+=V){const o=Math.min(s+V,_);for(let a=0;a<C;a+=V){const l=Math.min(a+V,C);for(let c=i;c<r;c++)for(let i=s;i<o;i++){let r=0;for(let t=a;t<l;t++){r+=M[e*N+c*R+t*P]*$[t*O+i*D+n*F]}U[t*z+(c*_+i)]+=r}}}}}return n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(k),n.makeTensorInfo(x,B.dtype,B.values)}const sb={kernelName:vt,backendName:"cpu",kernelFunc:rb};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ob={kernelName:di,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{a:r,b:s,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=i;let d,p,f;const m=[];d=rb({inputs:{a:r,b:s},attrs:{transposeA:l,transposeB:c},backend:n}),o&&(p=Pm({inputs:{a:d,b:o},backend:n}),m.push(d),d=p),u&&(f=eb(n,d,u,a,h),m.push(d),d=f);for(const t of m)n.disposeIntermediateTensorInfo(t);return d}},ab=Vm(nt,(t=>Math.acos(t))),lb={kernelName:nt,backendName:"cpu",kernelFunc:ab},cb=Vm(it,(t=>Math.acosh(t))),ub={kernelName:it,backendName:"cpu",kernelFunc:cb};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hb={kernelName:st,backendName:"cpu",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n}=t,i=e;fm(e,"addN");const r=i.map((t=>n.data.get(t.dataId).values)),s=bo(i[0].shape,i[0].dtype),o=s.values;for(let t=0;t<i.length;t++){const e=r[t];for(let t=0;t<o.length;t++)o[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const db={kernelName:ot,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,keepDims:o}=i;fm(r,"all");const a=w(s,r.shape);let l=a;const c=fl(l,r.shape.length);let u=r;null!=c&&(u=Hg({inputs:{x:r},backend:n,attrs:{perm:c}}),l=gl(l.length,r.shape.length)),pl("all",l,u.shape.length);const[h,p]=hl(u.shape,l),f=d(p),m=U(d(h),u.dtype),g=n.data.get(u.dataId).values;for(let t=0;t<m.length;++t){const e=t*f;let n=g[e];for(let t=0;t<f;++t){const i=g[e+t];n=n&&i}m[t]=n}null!=c&&n.disposeIntermediateTensorInfo(u);const y=n.makeTensorInfo(h,u.dtype,m);if(o){const t=nb({inputs:{x:y},backend:n,attrs:{shape:dl(h,a)}});return n.disposeIntermediateTensorInfo(y),t}return y}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pb={kernelName:at,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,keepDims:o}=i;fm(r,"any");const a=w(s,r.shape);let l=a;const c=fl(l,r.shape.length);let u=r;null!=c&&(u=Hg({inputs:{x:r},backend:n,attrs:{perm:c}}),l=gl(l.length,r.shape.length)),pl("any",l,u.shape.length);const[h,p]=hl(u.shape,l),f=d(p),m=U(d(h),u.dtype),g=n.data.get(u.dataId).values;for(let t=0;t<m.length;++t){const e=t*f;let n=g[e];for(let t=0;t<f;++t){const i=g[e+t];n=n||i}m[t]=n}null!=c&&n.disposeIntermediateTensorInfo(u);const y=n.makeTensorInfo(h,u.dtype,m);if(o){const t=nb({inputs:{x:y},backend:n,attrs:{shape:dl(h,a)}});return n.disposeIntermediateTensorInfo(y),t}return y}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fb={kernelName:lt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s}=i;fm(r,"argMax");let o=w(s,r.shape);const a=fl(o,r.shape.length);let l=r;const c=[];null!=a&&(l=Hg({inputs:{x:r},backend:n,attrs:{perm:a}}),c.push(l),o=gl(o.length,l.shape.length)),o=[o[0]],pl("argMax",o,l.shape.length);const[u,h]=hl(l.shape,o),p=U(d(u),"int32"),f=d(h),m=n.data.get(l.dataId).values;for(let t=0;t<p.length;++t){const e=t*f;let n=m[e],i=0;for(let t=0;t<f;++t){const r=m[e+t];r>n&&(n=r,i=t)}p[t]=i}return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(u,"int32",p)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mb={kernelName:ct,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s}=i;fm(r,"argMin");let o=w(s,r.shape);const a=fl(o,r.shape.length);let l=r;const c=[];null!=a&&(l=Hg({inputs:{x:r},backend:n,attrs:{perm:a}}),c.push(l),o=gl(o.length,l.shape.length)),o=[o[0]],pl("argMin",o,l.shape.length);const[u,h]=hl(l.shape,o),p=U(d(u),"int32"),f=d(h),m=n.data.get(l.dataId).values;for(let t=0;t<p.length;++t){const e=t*f;let n=m[e],i=0;for(let t=0;t<f;++t){const r=m[e+t];r<n&&(n=r,i=t)}p[t]=i}return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(u,"int32",p)}},gb=Vm(ut,(t=>Math.asin(t))),yb={kernelName:ut,backendName:"cpu",kernelFunc:gb},bb=Vm(ht,(t=>Math.asinh(t))),vb={kernelName:ht,backendName:"cpu",kernelFunc:bb},xb=Vm(dt,(t=>Math.atan(t))),wb={kernelName:dt,backendName:"cpu",kernelFunc:xb},Sb=vm(((t,e)=>Math.atan2(t,e))),kb=Im(ft,Sb),Cb={kernelName:ft,backendName:"cpu",kernelFunc:kb},Tb=Vm(pt,(t=>Math.atanh(t))),_b={kernelName:pt,backendName:"cpu",kernelFunc:Tb};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Eb(t,e,n,i,r,s){const o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,u=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=bo(r.outShape,n),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],v=r.outShape[3];for(let e=0;e<r.batchSize;++e){const n=e*y,m=e*i[0];for(let e=0;e<r.inChannels;++e)for(let y=0;y<r.outHeight;++y){const x=y*o-d,w=Math.max(0,x),S=Math.min(r.inHeight,u+x),k=n+y*b;for(let n=0;n<r.outWidth;++n){const o=n*a-p,u=Math.max(0,o),d=Math.min(r.inWidth,h+o);let y=f,b=0,x=0;for(let n=w;n<S;n+=l){const r=m+n*i[1];for(let n=u;n<d;n+=c){const o=t[r+n*i[2]+e];"max"===s&&o>y?y=o:"avg"===s&&(b+=o,x++)}if(isNaN(y))break}g[k+n*v+e]="avg"===s?b/x:y}}}return m}function Mb(t,e,n,i,r=!1,s=!1){const o=bo(i.outShape,"int32"),a=i.strideHeight,l=i.strideWidth,c=i.dilationHeight,u=i.dilationWidth,h=i.effectiveFilterHeight,d=i.effectiveFilterWidth,p=i.padInfo.top,f=i.padInfo.left,m=bo(e,n,t);for(let t=0;t<i.batchSize;++t)for(let e=0;e<i.inChannels;++e)for(let n=0;n<i.outHeight;++n){const g=n*a-p;let y=g;for(;y<0;)y+=c;const b=Math.min(i.inHeight,h+g);for(let a=0;a<i.outWidth;++a){const h=a*l-f;let p=h;for(;p<0;)p+=u;const v=Math.min(i.inWidth,d+h);let x=Number.NEGATIVE_INFINITY,w=-1;for(let n=y;n<b;n+=c){const o=n-g;for(let a=p;a<v;a+=u){const l=a-h,c=m.get(t,n,a,e);c>x&&(x=c,w=r?s?((t*i.inHeight+n)*i.inWidth+a)*i.inChannels+e:(n*i.inWidth+a)*i.inChannels+e:o*d+l)}}o.set(w,t,n,a,e)}}return o}function $b(t,e,n,i,r,s){const o=r.strideDepth,a=r.strideHeight,l=r.strideWidth,c=r.dilationDepth,u=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=bo(r.outShape,n),x=v.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],S=r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[3]*r.outShape[4],C=r.outShape[4];for(let e=0;e<r.batchSize;++e){const n=e*w,v=e*i[0];for(let e=0;e<r.inChannels;++e)for(let w=0;w<r.outDepth;++w){const T=w*o-m;let _=T;for(;_<0;)_+=c;const E=Math.min(r.inDepth,d+T),M=n+w*S;for(let n=0;n<r.outHeight;++n){const o=n*a-g;let d=o;for(;d<0;)d+=u;const m=Math.min(r.inHeight,p+o),w=M+n*k;for(let n=0;n<r.outWidth;++n){const o=n*l-y;let a=o;for(;a<0;)a+=h;const p=Math.min(r.inWidth,f+o),g=w+n*C;let S=b,k=0,T=0;for(let n=_;n<E;n+=c){const r=v+n*i[1];for(let n=d;n<m;n+=u){const o=r+n*i[2];for(let n=a;n<p;n+=h){const r=t[o+n*i[3]+e];if("max"===s&&r>S?S=r:"avg"===s&&(k+=r,T++),isNaN(S))break}if(isNaN(S))break}if(isNaN(S))break}x[g+e]="avg"===s?k/Math.max(T,1):S}}}}return v}const Ib={kernelName:mt,backendName:"cpu",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e;fm(r,"avgPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i;c(sa(o,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const u=Ko(r.shape,s,o,1,a,l);let h;if(1===u.filterWidth&&1===u.filterHeight&&m(u.inShape,u.outShape))h=km({inputs:{x:r},backend:n});else{const t=n.data.get(r.dataId).values,e=L(r.shape),i=Eb(t,r.shape,r.dtype,e,u,"avg");h=n.makeTensorInfo(u.outShape,r.dtype,i.values)}return h}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ab={kernelName:yt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=i;fm(r,"avgPool3d");const u=Yo(r.shape,s,o,1,a,l,c),h=$b(n.data.get(r.dataId).values,r.shape,r.dtype,L(r.shape),u,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nb={kernelName:bt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=i;fm([r,s],"avgPool3DGrad");const u=Yo(s.shape,o,a,1,l,c),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,v=u.dilationWidth,x=u.effectiveFilterDepth,w=u.effectiveFilterHeight,S=u.effectiveFilterWidth,k=x-1-u.padInfo.front,C=S-1-u.padInfo.left,T=w-1-u.padInfo.top,_=bo(s.shape,"float32"),E=1/(f*m*g),M=n.bufferSync(r);for(let t=0;t<u.batchSize;++t)for(let e=0;e<u.inChannels;++e)for(let n=0;n<u.inDepth;++n)for(let i=0;i<u.inHeight;++i)for(let r=0;r<u.inWidth;++r){const s=n-k,o=i-T,a=r-C;let l=0;for(let n=0;n<x;n+=y){const i=(s+n)/h;if(!(i<0||i>=u.outDepth||Math.floor(i)!==i))for(let n=0;n<w;n+=b){const r=(o+n)/d;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let n=0;n<S;n+=v){const s=(a+n)/p;if(s<0||s>=u.outWidth||Math.floor(s)!==s)continue;l+=M.get(t,i,r,s,e)}}}_.set(l*E,t,n,i,r,e)}return n.makeTensorInfo(_.shape,_.dtype,_.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rb={kernelName:gt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,o=s;fm([r,s],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=i,u=Ko(o.shape,a,l,1,c),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,v=b-1-u.padInfo.left,x=y-1-u.padInfo.top,w=bo(o.shape,"float32"),S=1/(p*f),k=n.data.get(r.dataId).values,C=bo(r.shape,"float32",k);for(let t=0;t<u.batchSize;++t)for(let e=0;e<u.inChannels;++e)for(let n=0;n<u.inHeight;++n)for(let i=0;i<u.inWidth;++i){const r=n-x,s=i-v;let o=0;for(let n=0;n<y;n+=m){const i=(r+n)/h;if(!(i<0||i>=u.outHeight||Math.floor(i)!==i))for(let n=0;n<b;n+=g){const r=(s+n)/d;if(r<0||r>=u.outWidth||Math.floor(r)!==r)continue;o+=C.get(t,i,r,e)}}w.set(o*S,t,n,i,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pb={kernelName:de,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,scale:s,offset:o,mean:a,variance:l}=e;c(a.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),c(null==o||a.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),c(null==s||a.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),fm([r,a,l,s,o],"batchNorm");let{varianceEpsilon:u}=i;null==u&&(u=.001);const h=n.data.get(r.dataId).values,d=n.data.get(a.dataId).values,p=n.data.get(l.dataId).values,f=s?n.data.get(s.dataId).values:new Float32Array([1]),m=o?n.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(h.length),y=m.length,b=f.length,v=p.length,x=d.length;let w=0,S=0,k=0,C=0;for(let t=0;t<h.length;++t)g[t]=m[w++]+(h[t]-d[S++])*f[k++]/Math.sqrt(p[C++]+u),w>=y&&(w=0),S>=x&&(S=0),k>=b&&(k=0),C>=v&&(C=0);return n.makeTensorInfo(r.shape,r.dtype,g)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ob={kernelName:xt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{blockShape:s,crops:o}=i;fm([r],"batchToSpaceND");const a=s.reduce(((t,e)=>t*e)),l=mf(r.shape,s,a),c=gf(l.length,s.length),u=yf(r.shape,s,a),h=bf(o,s.length),d=vf(u,o,s.length),p=nb({inputs:{x:r},backend:n,attrs:{shape:l}}),f=Hg({inputs:{x:p},backend:n,attrs:{perm:c}}),m=nb({inputs:{x:f},backend:n,attrs:{shape:u}}),g=fy({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lb={kernelName:wt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,weights:s}=e,{size:o}=i,a=Lm(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,a)}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Db={kernelName:Ct,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{s0:i,s1:r}=e,s=n.data.get(i.dataId).values,o=n.data.get(r.dataId).values,a=Ja(Array.from(s),Array.from(o));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},Fb=Vm(Et,((t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t})),zb={kernelName:Et,backendName:"cpu",kernelFunc:Fb},Bb={kernelName:$t,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend,i=new Float32Array(d(e.shape)),r=n.data.get(e.dataId),s=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,a=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values;for(let t=0;t<a.length;t++){const e=a[t],n=l[t];i[t]=Math.hypot(e,n)}return n.makeOutput(i,e.shape,"float32")}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ub(t){const{inputs:e,backend:n}=t,{input:i}=e,r=n.data.get(i.dataId).complexTensorInfos.imag,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}const Vb={kernelName:ve,backendName:"cpu",kernelFunc:Ub};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wb(t){const{inputs:e,backend:n,attrs:i}=t,{axis:r}=i,s=w(r,e[0].shape)[0],o=e.map((t=>t.shape));sf(o,s);let a=of(e.map((t=>t.shape)),s);if(0===d(a))return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter((t=>d(t.shape)>0));if(1===l.length)return km({inputs:{x:l[0]},backend:n});if("complex64"===l[0].dtype){const t=l.map((t=>Tm({inputs:{input:t},backend:n}))),e=l.map((t=>Ub({inputs:{input:t},backend:n}))),i=Wb({inputs:t,backend:n,attrs:{axis:s}}),r=Wb({inputs:e,backend:n,attrs:{axis:s}}),o=xm({inputs:{real:i,imag:r},backend:n});return t.forEach((t=>n.disposeIntermediateTensorInfo(t))),e.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(r),o}const c=l.map((t=>{const e=d(t.shape.slice(s));return nb({inputs:{x:t},backend:n,attrs:{shape:[-1,e]}})})),u=c.map((t=>({vals:n.data.get(t.dataId).values,shape:t.shape})));a=of(c.map((t=>t.shape)),1);const h=1===c[0].shape[0],p=qm(u,a,e[0].dtype,h),f=of(l.map((t=>t.shape)),s),m=n.makeTensorInfo(f,e[0].dtype,p);return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),m}const Hb={kernelName:It,backendName:"cpu",kernelFunc:Wb};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jb(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=i;fm([r,s],"conv2d");const h=aa(l),d=Zo(r.shape,s.shape,o,c,a,u,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,v="channelsLast"===d.dataFormat,x=new Nr(d.outShape,r.dtype),w=L(r.shape),S=L(s.shape),k=w[0],C=v?w[1]:w[2],T=v?w[2]:1,_=v?1:w[1],E=x.strides[0],M=v?x.strides[1]:x.strides[2],$=v?x.strides[2]:1,I=v?1:x.strides[1],A=n.data.get(r.dataId).values,N=n.data.get(s.dataId).values,R=x.values;for(let t=0;t<d.batchSize;++t){const e=t*k,n=t*E;for(let t=0;t<d.outHeight;++t){const i=n+t*M,r=t*d.strideHeight-b;for(let t=0;t<p;++t){const n=r+t*m;if(n<0||n>=d.inHeight)continue;const s=t*S[0],o=e+n*C;for(let t=0;t<d.outWidth;++t){const e=i+t*$,n=t*d.strideWidth-y;for(let t=0;t<f;++t){const i=n+t*g;if(i<0||i>=d.inWidth)continue;const r=o+i*T;let a=s+t*S[1];for(let t=0;t<d.inChannels;++t){const n=A[r+t*_];for(let t=0;t<d.outChannels;++t)R[e+t*I]+=n*N[a+t];a+=d.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,R)}const Gb={kernelName:At,backendName:"cpu",kernelFunc:jb};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qb={kernelName:Nt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,dy:s}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=i;fm([r,s],"conv2dBackpropFilter");const h=aa(l),d=Zo(r.shape,u,o,1,a,c,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,b=new Nr(d.filterShape,"float32"),v=d.padInfo.left,x=d.padInfo.top,w=n.data.get(r.dataId).values,S=n.data.get(s.dataId).values,k=new Nr(r.shape,r.dtype,w),C=new Nr(s.shape,s.dtype,S);for(let t=0;t<m;++t){const e=Math.max(0,Math.ceil((x-t)/p)),n=Math.min(d.outHeight,(d.inHeight+x-t)/p);for(let i=0;i<g;++i){const r=Math.max(0,Math.ceil((v-i)/f)),s=Math.min(d.outWidth,(d.inWidth+v-i)/f);for(let o=0;o<d.inChannels;++o)for(let a=0;a<d.outChannels;++a){let l=0;for(let c=0;c<d.batchSize;++c)for(let u=e;u<n;++u){const e=t+u*p-x;for(let t=r;t<s;++t){const n=i+t*f-v;l+=y?k.get(c,e,n,o)*C.get(c,u,t,a):k.get(c,o,e,n)*C.get(c,a,u,t)}}b.set(l,t,i,o,a)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xb={kernelName:Rt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,filter:s}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=i;fm([r,s],"conv2dBackpropInput");const h=L(s.shape),d=L(r.shape);let p=aa(c);const f=Zo(o,s.shape,a,1,l,u,!1,p),m=new Nr(f.inShape,"float32"),g=m.values,y=n.data.get(r.dataId).values,b=n.data.get(s.dataId).values,[v,x,w]=h,{batchSize:S,filterHeight:k,filterWidth:C,inChannels:T,inHeight:_,inWidth:E,outChannels:M,outHeight:$,outWidth:I,strideHeight:A,strideWidth:N}=f;p=f.dataFormat;const R=k-1-f.padInfo.top,P=C-1-f.padInfo.left,O="channelsLast"===p,D=m.strides[0],F=O?m.strides[1]:m.strides[2],z=O?m.strides[2]:1,B=O?1:m.strides[1],U=d[0],V=O?d[1]:d[2],W=O?d[2]:1,H=O?1:d[1];for(let t=0;t<S;++t)for(let e=0;e<T;++e)for(let n=0;n<_;++n){const i=n-R,r=Math.max(0,Math.ceil(i/A)),s=Math.min($,(k+i)/A);for(let o=0;o<E;++o){const a=o-P,l=Math.max(0,Math.ceil(a/N)),c=Math.min(I,(C+a)/N);let u=0;for(let n=r;n<s;++n){const r=n*A-i;for(let i=l;i<c;++i){const s=U*t+V*n+W*i,o=v*(k-1-r)+x*(C-1-(i*N-a))+w*e;for(let t=0;t<M;++t){u+=y[s+H*t]*b[o+t]}}}g[D*t+F*n+z*o+B*e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kb={kernelName:Pt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l}=i;fm([r,s],"conv3d");const c=Jo(r.shape,s.shape,o,l,a),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=c,y=g.front,b=g.left,v=g.top,x=new Nr(c.outShape,r.dtype),w=n.data.get(r.dataId).values,S=n.data.get(s.dataId).values,k=x.values,C=L(r.shape),T=L(s.shape);for(let t=0;t<c.batchSize;++t){const e=t*C[0],n=t*x.strides[0];for(let t=0;t<c.outDepth;++t){const i=n+t*x.strides[1],r=t*c.strideDepth-y;for(let t=0;t<u;++t){const n=r+t*p;if(n<0||n>=c.inDepth)continue;const s=t*T[0],o=e+n*C[1];for(let t=0;t<c.outHeight;++t){const e=i+t*x.strides[2],n=t*c.strideHeight-v;for(let t=0;t<h;++t){const i=n+t*f;if(i<0||i>=c.inHeight)continue;const r=s+t*T[1],a=o+i*C[2];for(let t=0;t<c.outWidth;++t){const n=e+t*c.outChannels,i=t*c.strideWidth-b;for(let t=0;t<d;++t){const e=i+t*m;if(e<0||e>=c.inWidth)continue;const s=r+t*T[2],o=a+e*c.inChannels;let l=s;for(let t=0;t<c.inChannels;++t){const e=w[o+t];for(let t=0;t<c.outChannels;++t)k[n+t]+=e*S[l+t];l+=c.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yb={kernelName:Ot,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,dy:s}=e,{strides:o,pad:a,filterShape:l}=i;fm([r,s],"conv3dBackpropFilterV2");const c=L(r.shape),u=L(s.shape),h=Jo(r.shape,l,o,1,a),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new Nr(h.filterShape,"float32"),v=b.values,[x,w,S,k]=b.strides,C=n.data.get(s.dataId).values,[T,_,E,M]=u,$=n.data.get(r.dataId).values,[I,A,N,R]=c,P=h.padInfo.front,O=h.padInfo.left,D=h.padInfo.top;for(let t=0;t<m;++t){const e=Math.max(0,Math.ceil((P-t)/d)),n=Math.min(h.outDepth,(h.inDepth+P-t)/d),i=t*x;for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((D-r)/p)),o=Math.min(h.outHeight,(h.inHeight+D-r)/p),a=r*w+i;for(let i=0;i<y;++i){const l=Math.max(0,Math.ceil((O-i)/f)),c=Math.min(h.outWidth,(h.inWidth+O-i)/f),u=i*S+a;for(let a=0;a<h.inChannels;++a){const m=a*k+u;for(let u=0;u<h.outChannels;++u){let g=0;for(let m=0;m<h.batchSize;++m){const h=m*I,y=m*T;for(let m=e;m<n;++m){const e=(t+m*d-P)*A+h,n=m*_+y;for(let t=s;t<o;++t){const s=(r+t*p-D)*N+e,o=t*E+n;for(let t=l;t<c;++t){const e=t*M+o;g+=$[(i+t*f-O)*R+s+a]*C[e+u]}}}}v[m+u]=g}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zb={kernelName:Lt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,filter:s}=e,{pad:o,strides:a,inputShape:l}=i;fm([r],"conv3dBackpropInputV2");const c=L(r.shape),u=L(s.shape),h=Jo(l,s.shape,a,1,o),d=new Nr(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,b=n.data.get(r.dataId).values,[v,x,w,S]=c,k=n.data.get(s.dataId).values,[C,T,_,E]=u,{batchSize:M,filterDepth:$,filterHeight:I,filterWidth:A,inChannels:N,inDepth:R,inHeight:P,inWidth:O,outChannels:D,outDepth:F,outHeight:z,outWidth:B,strideDepth:U,strideHeight:V,strideWidth:W}=h,H=$-1-h.padInfo.front,j=I-1-h.padInfo.top,G=A-1-h.padInfo.left;for(let t=0;t<M;++t)for(let e=0;e<N;++e)for(let n=0;n<R;++n){const i=n-H,r=Math.max(0,Math.ceil(i/U)),s=Math.min(F,($+i)/U);for(let o=0;o<P;++o){const a=o-j,l=Math.max(0,Math.ceil(a/V)),c=Math.min(z,(I+a)/V);for(let u=0;u<O;++u){const h=u-G,d=Math.max(0,Math.ceil(h/W)),M=Math.min(B,(A+h)/W);let N=0;for(let n=r;n<s;++n){const r=n*U-i;for(let i=l;i<c;++i){const s=i*V-a;for(let o=d;o<M;++o){const a=v*t+x*n+w*i+S*o,l=C*($-1-r)+T*(I-1-s)+_*(A-1-(o*W-h))+E*e;for(let t=0;t<D;++t){N+=b[a+t]*k[l+t]}}}}p[f*t+m*n+g*o+y*u+e]=N}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},Jb=Vm(Dt,(t=>Math.cos(t))),Qb={kernelName:Dt,backendName:"cpu",kernelFunc:Jb},tv=Vm(Ft,(t=>Math.cosh(t))),ev={kernelName:Ft,backendName:"cpu",kernelFunc:tv};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nv={kernelName:Ut,backendName:"cpu",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{image:r,boxes:s,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=i,[u,h,d,p]=r.shape,f=s.shape[0],[m,g]=a,y=bo([f,m,g,p],"float32"),b=n.data.get(s.dataId).values,v=n.data.get(o.dataId).values,x=n.data.get(r.dataId).values,w=L(r.shape),S=L(y.shape);for(let t=0;t<f;t++){const e=4*t,n=b[e],i=b[e+1],r=b[e+2],s=b[e+3],o=v[t];if(o>=u)continue;const a=m>1?(r-n)*(h-1)/(m-1):0,f=g>1?(s-i)*(d-1)/(g-1):0;for(let e=0;e<m;e++){const u=m>1?n*(h-1)+e*a:.5*(n+r)*(h-1);if(u<0||u>h-1)for(let n=0;n<g;n++)for(let i=0;i<p;i++){const r=i+n*S[2]+e*S[1]+t*S[0];y.values[r]=c}else if("bilinear"===l){const n=Math.floor(u),r=Math.ceil(u),a=u-n;for(let l=0;l<g;l++){const u=g>1?i*(d-1)+l*f:.5*(i+s)*(d-1);if(u<0||u>d-1){for(let n=0;n<p;n++){const i=n+l*S[2]+e*S[1]+t*S[0];y.values[i]=c}continue}const h=Math.floor(u),m=Math.ceil(u),b=u-h;for(let i=0;i<p;i++){let s=i+h*w[2]+n*w[1]+o*w[0];const c=x[s];s=i+m*w[2]+n*w[1]+o*w[0];const u=x[s];s=i+h*w[2]+r*w[1]+o*w[0];const d=x[s];s=i+m*w[2]+r*w[1]+o*w[0];const p=c+(u-c)*b,f=d+(x[s]-d)*b;s=i+l*S[2]+e*S[1]+t*S[0],y.values[s]=p+(f-p)*a}}}else for(let n=0;n<g;++n){const r=g>1?i*(d-1)+n*f:.5*(i+s)*(d-1);if(r<0||r>d-1){for(let i=0;i<p;i++){const r=i+n*S[2]+e*S[1]+t*S[0];y.values[r]=c}continue}const a=Math.round(r),l=Math.round(u);for(let i=0;i<p;i++){const r=i+a*w[2]+l*w[1]+o*w[0],s=i+n*S[2]+e*S[1]+t*S[0];y.values[s]=x[r]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iv={kernelName:zt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,exclusive:o,reverse:a}=i;fm(r,"cumprod");const l=fl([s],r.shape.length);let c=r;null!=l&&(c=Hg({inputs:{x:r},backend:n,attrs:{perm:l}}));const u=gl(1,r.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=Hr(c.dtype,"int32"),p=B(d(c.shape),h),f=n.data.get(c.dataId).values,m=c.shape[c.shape.length-1],g=a?(t,e)=>t+m-e-1:(t,e)=>t+e;for(let t=0;t<f.length;t+=m)for(let e=0;e<m;e++){const n=g(t,e);if(0===e)p[n]=o?1:f[n];else{const i=g(t,e-1);p[n]=o?f[i]*p[i]:f[n]*p[i]}}const y=n.makeTensorInfo(c.shape,h,p);if(null!=l){const t=Hg({inputs:{x:y},backend:n,attrs:{perm:ml(l)}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(c),t}return y}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rv={kernelName:Bt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,exclusive:o,reverse:a}=i;fm(r,"cumsum");const l=fl([s],r.shape.length);let c=r;null!=l&&(c=Hg({inputs:{x:r},backend:n,attrs:{perm:l}}));const u=gl(1,r.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=Hr(c.dtype,"int32"),p=U(d(c.shape),h),f=n.data.get(c.dataId).values,m=c.shape[c.shape.length-1],g=a?(t,e)=>t+m-e-1:(t,e)=>t+e;for(let t=0;t<f.length;t+=m)for(let e=0;e<m;e++){const n=g(t,e);if(0===e)p[n]=o?0:f[n];else{const i=g(t,e-1);p[n]=o?f[i]+p[i]:f[n]+p[i]}}const y=n.makeTensorInfo(c.shape,h,p);if(null!=l){const t=Hg({inputs:{x:y},backend:n,attrs:{perm:ml(l)}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(c),t}return y}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sv={kernelName:Vt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,weights:s}=e,{size:o,binaryOutput:a}=i;if(1===r.shape.length){const t=Lm(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,t)}if(2===r.shape.length){const t=Dm(n.bufferSync(r),n.bufferSync(s),o,a);return n.makeTensorInfo(t.shape,s.dtype,t.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ov={kernelName:Wt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{blockSize:s,dataFormat:o}=i;c("NHWC"===o,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`));const a=r.shape[0],l=r.shape[1],u=r.shape[2],h=r.shape[3],d=l*s,p=u*s,f=h/(s*s),m=n.data.get(r.dataId).values,g=new Float32Array(a*d*p*f);let y=0;for(let t=0;t<a;++t)for(let e=0;e<d;++e){const n=Math.floor(e/s),i=e%s;for(let e=0;e<p;++e){const r=Math.floor(e/s),o=(i*s+e%s)*f;for(let e=0;e<f;++e){const i=e+o+h*(r+u*(n+l*t));g[y++]=m[i]}}}return n.makeTensorInfo([a,d,p,f],r.dtype,g)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function av(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=i;fm([r,s],"depthwiseConv2DNative");const h=L(r.shape),d=L(s.shape);let p=l;null==p&&(p=[1,1]),c(sa(o,p),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`));const f=Zo(r.shape,s.shape,o,p,a,u,!0),{filterHeight:m,filterWidth:g,dilationHeight:y,dilationWidth:b,padInfo:v}=f,x=v.left,w=v.top,S=f.outChannels/f.inChannels,k=new Nr(f.outShape,r.dtype),C=n.data.get(r.dataId).values,T=n.data.get(s.dataId).values,_=k.values;for(let t=0;t<f.batchSize;++t){const e=t*h[0],n=t*k.strides[0];for(let t=0;t<f.outHeight;++t){const i=n+t*k.strides[1],r=t*f.strideHeight-w;for(let t=0;t<m;++t){const n=r+t*y;if(n<0||n>=f.inHeight)continue;const s=t*d[0],o=e+n*h[1];for(let t=0;t<f.outWidth;++t){const e=i+t*k.strides[2],n=t*f.strideWidth-x;for(let t=0;t<g;++t){const i=n+t*b;if(i<0||i>=f.inWidth)continue;const r=s+t*d[1],a=o+i*f.inChannels;let l=e,c=r;for(let t=0;t<f.inChannels;++t){const e=C[a+t];for(let t=0;t<S;++t)_[l+t]+=e*T[c+t];l+=S,c+=S}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const lv={kernelName:Ht,backendName:"cpu",kernelFunc:av};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cv={kernelName:jt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,dy:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=i;fm([r,s],"depthwiseConv2dNativeBackpropFilter");const h=Zo(r.shape,u,o,a,l,c,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new Nr(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,v=h.outChannels/h.inChannels,x=n.data.get(r.dataId).values,w=new Nr(r.shape,r.dtype,x),S=n.data.get(s.dataId).values,k=new Nr(s.shape,s.dtype,S);for(let t=0;t<f;++t){const e=Math.max(0,Math.ceil((b-t)/d)),n=Math.min(h.outHeight,(h.inHeight+b-t)/d);for(let i=0;i<m;++i){const r=Math.max(0,Math.ceil((y-i)/p)),s=Math.min(h.outWidth,(h.inWidth+y-i)/p);for(let o=0;o<h.outChannels;++o){const a=Math.trunc(o/v),l=o%v;let c=0;for(let l=0;l<h.batchSize;++l)for(let u=e;u<n;++u){const e=t+u*d-b;for(let t=r;t<s;++t){const n=i+t*p-y;c+=w.get(l,e,n,a)*k.get(l,u,t,o)}}g.set(c,t,i,a,l)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uv={kernelName:Gt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,filter:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=i;fm([r,s],"depthwiseConv2DNativeBackpropInput");const h=L(r.shape),d=L(s.shape),p=Zo(u,s.shape,o,a,l,c,!0),f=new Nr(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(r.dataId).values,[x,w,S]=h,k=n.data.get(s.dataId).values,[C,T,_]=d,{batchSize:E,filterHeight:M,filterWidth:$,inChannels:I,inHeight:A,inWidth:N,outChannels:R,outHeight:P,outWidth:O,strideHeight:D,strideWidth:F}=p,z=M-1-p.padInfo.top,B=$-1-p.padInfo.left,U=R/I;for(let t=0;t<E;++t)for(let e=0;e<I;++e)for(let n=0;n<A;++n){const i=n-z,r=Math.max(0,Math.ceil(i/D)),s=Math.min(P,(M+i)/D);for(let o=0;o<N;++o){const a=o-B,l=Math.max(0,Math.ceil(a/F)),c=Math.min(O,($+a)/F);let u=0;for(let n=r;n<s;++n){const r=n*D-i;for(let i=l;i<c;++i){const s=x*t+w*n+S*i,o=C*(M-1-r)+T*($-1-(i*F-a))+_*e;for(let t=0;t<U;++t){u+=v[s+(e*U+t)]*k[o+t]}}}m[g*t+y*n+b*o+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hv={kernelName:qt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:i}=e,r=d(i.shape),s=n.data.get(i.dataId).values,o=bo([r,r],i.dtype),a=o.values;for(let t=0;t<s.length;t++)a[t*r+t]=s[t];const l=[...i.shape,...i.shape];return n.makeTensorInfo(l,o.dtype,o.values)}},dv={kernelName:Xt,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:i,filter:r}=t,{strides:s,pad:o,dilations:a}=n,l=e,c=l.data.get(i.dataId).values,u=i.shape.length,h=l.data.get(r.dataId).values,p=r.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:x,strideHeight:w,strideWidth:S,filterHeight:k,filterWidth:T,dilationHeight:_,dilationWidth:E,outShape:M}=Xo(i.shape,r.shape,s,o,"NHWC",a),$=d(M),I=M.length,A=C(i.dtype,$);for(let t=0;t<f;++t)for(let e=0;e<b;++e){const n=e*w-x.top;for(let s=0;s<v;++s){const o=s*S-x.left;for(let a=0;a<y;++a){let l=Number.MIN_SAFE_INTEGER;for(let e=0;e<k;++e){const s=n+e*_;if(s>=0&&s<m)for(let n=0;n<T;++n){const d=o+n*E;if(d>=0&&d<g){const o=H([t,s,d,a],u,L(i.shape)),f=H([e,n,a],p,L(r.shape)),m=c[o]+h[f];m>l&&(l=m)}}}A[H([t,e,s,a],I,L(M))]=l}}}return{dataId:l.write(fr(A,i.dtype),M,i.dtype),shape:M,dtype:i.dtype}}},pv={kernelName:Yt,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:i,filter:r,dy:s}=t,{strides:o,pad:a,dilations:l}=n,u=e,h=F(i.shape,u.data.get(i.dataId).values),d=F(r.shape,u.data.get(r.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:S,filterWidth:k,dilationHeight:C,dilationWidth:T,outShape:_}=Xo(i.shape,r.shape,o,a,"NHWC",l);c(s.rank===_.length,(()=>`Error in ${Yt}, dy must have the same rank as output ${_.length}, but got ${s.rank}`));const E=F(_,u.data.get(s.dataId).values),M=V(r.shape,r.dtype);for(let t=0;t<p;++t)for(let e=0;e<y;++e){const n=e*x-v.top;for(let i=0;i<b;++i){const r=i*w-v.left;for(let s=0;s<g;++s){let o=Number.MIN_SAFE_INTEGER,a=0,l=0;for(let e=0;e<S;++e){const i=n+e*C;if(i>=0&&i<f)for(let n=0;n<k;++n){const c=r+n*T;if(c>=0&&c<m){const r=h[t][i][c][s]+d[e][n][s];r>o&&(o=r,a=e,l=n)}}}M[a][l][s]+=E[t][e][i][s]}}}return{dataId:u.write(fr(M,i.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},fv={kernelName:Kt,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:i,filter:r,dy:s}=t,{strides:o,pad:a,dilations:l}=n,u=e,h=F(i.shape,u.data.get(i.dataId).values),d=F(r.shape,u.data.get(r.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:S,filterWidth:k,dilationHeight:C,dilationWidth:T,outShape:_}=Xo(i.shape,r.shape,o,a,"NHWC",l);c(s.rank===_.length,(()=>`Error in ${Kt}, dy must have the same rank as output ${_.length}, but got ${s.rank}`));const E=F(_,u.data.get(s.dataId).values),M=V(i.shape,i.dtype);for(let t=0;t<p;++t)for(let e=0;e<y;++e){const n=e*x-v.top;for(let i=0;i<b;++i){const r=i*w-v.left;for(let s=0;s<g;++s){let o=Number.MIN_SAFE_INTEGER,a=n<0?0:n,l=r<0?0:r;for(let e=0;e<S;++e){const i=n+e*C;if(i>=0&&i<f)for(let n=0;n<k;++n){const c=r+n*T;if(c>=0&&c<m){const r=h[t][i][c][s]+d[e][n][s];r>o&&(o=r,a=i,l=c)}}}M[t][a][l][s]+=E[t][e][i][s]}}}return{dataId:u.write(fr(M,i.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mv={kernelName:Zt,backendName:"cpu",kernelFunc:
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{image:r}=e,{canvas:s,options:o}=i,{contextOptions:a,imageOptions:l}=o||{},c=(null==l?void 0:l.alpha)||1,u=(null==a?void 0:a.contextType)||"2d";if("2d"!==u)throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=s.getContext(u,(null==a?void 0:a.contextAttributes)||{});if(null==h)throw new Error(`Could not get the context with ${u} type.`);const[d,p]=r.shape.slice(0,2),f=2===r.shape.length?1:r.shape[2],m=n.data.get(r.dataId).values,g="float32"===r.dtype?255:1,y=new Uint8ClampedArray(p*d*4);for(let t=0;t<d*p;++t){const e=[0,0,0,255*c];for(let n=0;n<f;n++){const i=m[t*f+n];if("float32"===r.dtype){if(i<0||i>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${i}.`)}else if("int32"===r.dtype&&(i<0||i>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${i}.`);1===f?(e[0]=i*g,e[1]=i*g,e[2]=i*g):e[n]=i*g}const n=4*t;y[n+0]=Math.round(e[0]),y[n+1]=Math.round(e[1]),y[n+2]=Math.round(e[2]),y[n+3]=Math.round(e[3])}s.width=p,s.height=d;const b=new ImageData(y,p,d);return h.putImageData(b,0,0),r}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gv(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,keepDims:o}=i;let a;fm(r,"sum"),a="bool"===r.dtype?Mm({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):km({inputs:{x:r},backend:n});const l=a.shape.length,c=w(s,a.shape),u=fl(c,l);let h=c,p=a;null!=u&&(p=Hg({inputs:{x:a},backend:n,attrs:{perm:u}}),h=gl(h.length,l)),pl("sum",h,p.shape.length);const[f,m]=hl(p.shape,h);let g=Sm(n,f,Hr(p.dtype,"int32"));const y=d(m),b=n.data.get(g.dataId).values,v=n.data.get(p.dataId).values;for(let t=0;t<b.length;++t){const e=t*y;let n=0;for(let t=0;t<y;++t)n+=v[e+t];b[t]=n}if(o){const t=g;g=nb({inputs:{x:g},backend:n,attrs:{shape:dl(g.shape,c)}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(a),null!=u&&n.disposeIntermediateTensorInfo(p),g}const yv={kernelName:Ln,backendName:"cpu",kernelFunc:gv};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bv={kernelName:Qt,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{equation:r}=i,s=e,{allDims:o,summedDims:a,idDims:l}=Bf(r,s.length);Vf(o.length,l,s);const{path:c,steps:u}=Wf(a,l),h=u.length;let d=null,p=o.length;const f=[];for(let t=0;t<h;++t){for(const e of u[t]){const{permutationIndices:t,expandDims:i}=Uf(p,l[e]);let r;Hf(t)?r=s[e]:(r=Hg({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(r));const o=r.shape.slice();for(let t=0;t<i.length;++t)o.splice(i[t],0,1);m(r.shape,o)||(r=nb({inputs:{x:r},backend:n,attrs:{shape:o}}),f.push(r)),null===d?d=r:(d=Lg({inputs:{a:r,b:d},backend:n}),f.push(d))}t<h-1&&(c[t]>=0&&(d=gv({inputs:{x:d},backend:n,attrs:{axis:c[t]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const t of f)t!==d&&n.disposeIntermediateTensorInfo(t);return d}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vv={kernelName:ee,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{dy:i,y:r}=e;fm([i,r],"eluGrad");const s=new Float32Array(d(r.shape)),o=n.data.get(r.dataId).values,a=n.data.get(i.dataId).values;for(let t=0;t<o.length;++t){const e=o[t];s[t]=e>=0?a[t]:a[t]*(e+1)}return n.makeTensorInfo(r.shape,"float32",s)}},xv=Vm(ne,(t=>{const e=Math.sign(t),n=Math.abs(t),i=1/(1+.3275911*n);return e*(1-((((1.061405429*i-1.453152027)*i+1.421413741)*i-.284496736)*i+.254829592)*i*Math.exp(-n*n))})),wv={kernelName:ne,backendName:"cpu",kernelFunc:xv};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sv(t){const{inputs:e,backend:n,attrs:i}=t,{input:r}=e,{dim:s}=i,o=r.shape.length,a=r.shape.slice();let l=s;return s<0&&(c(-(o+1)<=s,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+s+1),a.splice(l,0,1),nb({inputs:{x:r},backend:n,attrs:{shape:a}})}const kv={kernelName:se,backendName:"cpu",kernelFunc:Sv},Cv=vm(((t,e)=>t/e)),Tv=Im(Jt,Cv),_v={kernelName:Jt,backendName:"cpu",kernelFunc:Tv};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ev(t,e,n){const i=t.shape,r=i[0],s=i[1],o=n.data.get(t.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[r,s],u=d(c),h=k("float32",u),p=k("float32",u);for(let t=0;t<r;t++){const i=fy({inputs:{x:a},backend:n,attrs:{begin:[t,0],size:[1,s]}}),r=fy({inputs:{x:l},backend:n,attrs:{begin:[t,0],size:[1,s]}}),o=xm({inputs:{real:i,imag:r},backend:n}),{real:c,imag:u}=Mv(o,e,n),d=Mf(c,u);for(let e=0;e<s;e++){const n=Nf(d,e);h[t*s+e]=n.real,p[t*s+e]=n.imag}n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o)}const f=n.makeTensorInfo(c,"float32",h),m=n.makeTensorInfo(c,"float32",p),g=xm({inputs:{real:f,imag:m},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}function Mv(t,e,n){const i=d(t.shape),r=n.data.get(t.dataId),s=n.data.get(r.complexTensorInfos.real.dataId).values,o=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0==((a=i)&a-1)){const r=$v(s,o,i,e,n),a=[t.shape[0],t.shape[1]];if(e){const t=n.makeTensorInfo(a,"float32",r.real),e=n.makeTensorInfo(a,"float32",r.imag),s=n.makeTensorInfo([],"float32",pr(i,"float32")),o=km({inputs:{x:s},backend:n}),l=_v.kernelFunc({inputs:{a:t,b:s},backend:n}),c=_v.kernelFunc({inputs:{a:e,b:o},backend:n}),u=n.data.get(l.dataId).values,h=n.data.get(c.dataId).values;return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),{real:u,imag:h}}return r}{const t=function(t,e,n){const i=new Float32Array(2*e);for(let r=0;r<e;r++){let s=0,o=0;for(let i=0;i<e;i++){const a=Of(r*i,e,n),l=Nf(t,i);s+=l.real*a.real-l.imag*a.imag,o+=l.real*a.imag+l.imag*a.real}n&&(s/=e,o/=e),Rf(i,s,o,r)}return i}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(Mf(s,o),i,e);return $f(t)}var a}function $v(t,e,n,i,r){if(1===n)return{real:t,imag:e};const s=Mf(t,e),o=n/2,a=If(s),l=a.real,c=a.imag,u=[l.length],h=r.makeTensorInfo(u,"float32",l),d=r.makeTensorInfo(u,"float32",c),p=xm({inputs:{real:h,imag:d},backend:r}),f=Af(s),m=f.real,g=f.imag,y=[m.length],b=r.makeTensorInfo(y,"float32",m),v=r.makeTensorInfo(y,"float32",g),x=xm({inputs:{real:b,imag:v},backend:r}),w=$v(l,c,o,i,r),S=w.real,k=w.imag,C=[S.length],T=r.makeTensorInfo(C,"float32",S),_=r.makeTensorInfo(C,"float32",k),E=xm({inputs:{real:T,imag:_},backend:r}),M=$v(m,g,o,i,r),$=M.real,I=M.imag,A=[$.length],N=r.makeTensorInfo(A,"float32",$),R=r.makeTensorInfo(A,"float32",I),P=xm({inputs:{real:N,imag:R},backend:r}),O=Pf(n,i),L=[O.real.length],D=r.makeTensorInfo(L,"float32",O.real),F=r.makeTensorInfo(L,"float32",O.imag),z=xm({inputs:{real:D,imag:F},backend:r}),B=Lg({inputs:{a:z,b:P},backend:r}),U=Pm({inputs:{a:E,b:B},backend:r}),V=Ly({inputs:{a:E,b:B},backend:r}),W=Tm({inputs:{input:U},backend:r}),H=Tm({inputs:{input:V},backend:r}),j=Ub({inputs:{input:U},backend:r}),G=Ub({inputs:{input:V},backend:r}),q=Wb({inputs:[W,H],backend:r,attrs:{axis:0}}),X=Wb({inputs:[j,G],backend:r,attrs:{axis:0}}),K=r.data.get(q.dataId).values,Y=r.data.get(X.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(R),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(X),{real:K,imag:Y}}const Iv={kernelName:ae,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:i}=e,r=d(i.shape),s=i.shape[i.shape.length-1],o=nb({inputs:{x:i},backend:n,attrs:{shape:[r/s,s]}}),a=Ev(o,!1,n),l=nb({inputs:{x:a},backend:n,attrs:{shape:i.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Av(t){const{backend:e,attrs:n}=t,{shape:i,value:r,dtype:s}=n,o=s||R(r),a=C(o,d(i));return function(t,e,n){t.fill(e)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(a,r),e.makeTensorInfo(i,o,a)}const Nv={kernelName:le,backendName:"cpu",kernelFunc:Av};const Rv={kernelName:ce,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:i}=t,r=n,s=k(i.dtype,d(i.shape)),[o,a,l,c]=i.shape,u=r.data.get(i.dataId).values;for(let t=0;t<o;t++){const e=t*l*a*c;for(let t=0;t<a;t++){const n=t*(l*c);for(let t=0;t<l;t++){const i=t*c;for(let r=0;r<c;r++){const o=Math.round(l-t-1),a=e+n+i+r;let h=u[a];if(o>=0&&o<l){h=u[e+n+o*c+r]}s[a]=h}}}}return{dataId:r.write(s,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pv={kernelName:pi,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=i;let m=jb({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const t=m;if("NCHW"===u&&1===o.shape.length&&1!==o.shape[0]){const t=nb({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=Pm({inputs:{a:m,b:t},backend:n}),n.disposeIntermediateTensorInfo(t)}else m=Pm({inputs:{a:m,b:o},backend:n});n.disposeIntermediateTensorInfo(t)}if(p){const t=m;if("NCHW"===u&&"prelu"===p&&1===a.shape.length&&1!==a.shape[0]){const t=nb({inputs:{x:a},backend:n,attrs:{shape:[a.shape[0],1,1]}});m=eb(n,m,p,t,f),n.disposeIntermediateTensorInfo(t)}else m=eb(n,m,p,a,f);n.disposeIntermediateTensorInfo(t)}return m}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ov={kernelName:fi,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=i;let m=av({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const t=m;m=Pm({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=m;m=eb(n,m,p,a,f),n.disposeIntermediateTensorInfo(t)}return m}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lv={kernelName:fe,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:i,indices:r}=e,s=d(i.shape),o=r.shape,a=o[o.length-1],[l,c,u,h]=Pp(i,r);if(0===c)return n.makeTensorInfo(l,i.dtype,[]);const p=cg(n.data.get(r.dataId).values,n.bufferSync(i),i.dtype,c,a,u,h,i.shape,s);return n.makeTensorInfo(l,i.dtype,p.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dv={kernelName:pe,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,indices:s}=e,{axis:o,batchDims:a}=i;fm([r,s],"gatherV2");const l=w(o,r.shape)[0],u=n.data.get(s.dataId).values,h=r.shape[l];for(let t=0;t<u.length;++t){const e=u[t];c(e<=h-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${h-1}]`))}let p=a;null==a&&(p=0);const f=d(s.shape),m=am(r,s,l,p),g=nb({inputs:{x:r},backend:n,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),y=nb({inputs:{x:s},backend:n,attrs:{shape:[m.batchSize,f/m.batchSize]}}),b=[m.batchSize,m.outerSize,f/m.batchSize,m.sliceSize],v=n.bufferSync(y),x=ug(n.bufferSync(g),v,b);return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.makeTensorInfo(m.outputShape,x.dtype,x.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fv={kernelName:be,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:i}=e,r=d(i.shape),s=i.shape[i.shape.length-1],o=nb({inputs:{x:i},backend:n,attrs:{shape:[r/s,s]}}),a=Ev(o,!0,n),l=nb({inputs:{x:a},backend:n,attrs:{shape:i.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}},zv=Vm(xe,(t=>Number.isFinite(t)?1:0),"bool"),Bv={kernelName:xe,backendName:"cpu",kernelFunc:zv},Uv=Vm(we,(t=>Math.abs(t)===1/0?1:0),"bool"),Vv={kernelName:we,backendName:"cpu",kernelFunc:Uv},Wv=Vm(Se,(t=>Number.isNaN(t)?1:0),"bool"),Hv={kernelName:Se,backendName:"cpu",kernelFunc:Wv};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jv={kernelName:_e,backendName:"cpu",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{backend:e,attrs:n}=t,{start:i,stop:r,num:s}=n,o=kg(i,r,s);return e.makeTensorInfo([o.length],"float32",o)}},Gv=Vm(Me,(t=>Math.log1p(t))),qv={kernelName:Me,backendName:"cpu",kernelFunc:Gv},Xv=vm(((t,e)=>t&&e)),Kv=Im($e,Xv,null,"bool"),Yv={kernelName:$e,backendName:"cpu",kernelFunc:Kv},Zv=Vm(Ie,(t=>t?0:1),"bool"),Jv={kernelName:Ie,backendName:"cpu",kernelFunc:Zv},Qv=vm(((t,e)=>t||e)),tx=Im(Ae,Qv,null,"bool"),ex={kernelName:Ae,backendName:"cpu",kernelFunc:tx};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nx={kernelName:Re,backendName:"cpu",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{depthRadius:s,bias:o,alpha:a,beta:l}=i;fm(r,"LRN");const c=r.shape[3],u=c-1,h=n.data.get(r.dataId).values,p=d(r.shape),f=new Float32Array(p);function m(t){const e=t%c;let n=t-e+Math.max(0,e-s);const i=t-e+Math.min(e+s,u);let r=0;for(;n<=i;n++){const t=h[n];r+=t*t}return r}for(let t=0;t<p;t++){const e=m(t),n=h[t]*Math.pow(o+a*e,-l);f[t]=n}return n.makeTensorInfo(r.shape,r.dtype,f)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ix={kernelName:Pe,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,y:s,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=i;fm(o,"LRNGrad");const h=d(o.shape),p=o.shape[3],f=n.data.get(o.dataId).values,m=n.data.get(r.dataId).values,g=n.data.get(s.dataId).values,y=new Float32Array(h),b=h;for(let t=0;t<b;t++){const e=t%p,n=t-e+Math.max(0,e-a),i=t-e+Math.min(p,e+a+1);let r=0;for(let t=n;t<i;t++)r+=Math.pow(m[t],2);r=c*r+l;for(let e=n;e<i;e++){let n=-2*c*u*m[e]*g[t]/r;t===e&&(n+=Math.pow(r,-u)),n*=f[t],y[e]+=n}}return n.makeTensorInfo(o.shape,r.dtype,y)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rx(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{reductionIndices:s,keepDims:o}=i,a=n;let l=r.shape;const c=l.length,u=w(s,l);let h=u;const p=fl(h,c);let f=a.data.get(r.dataId).values;if(null!=p){const t=new Array(c);for(let e=0;e<t.length;e++)t[e]=l[p[e]];f=Wg(f,l,r.dtype,p,t),h=gl(h.length,c),l=t}fm(r,"max"),pl("max",h,c);const[m,g]=hl(l,h),y=Eg(f,d(g),m,r.dtype),b=a.write(y,m,r.dtype);let v=m;if(o){v=dl(m,u)}return{dataId:b,shape:v,dtype:r.dtype}}const sx={kernelName:Oe,backendName:"cpu",kernelFunc:rx};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ox={kernelName:De,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e;fm(r,"maxPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i;c(sa(o,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const u=Ko(r.shape,s,o,1,a,l);let h;if(1===u.filterWidth&&1===u.filterHeight&&m(u.inShape,u.outShape))h=km({inputs:{x:r},backend:n});else{const t=n.data.get(r.dataId).values,e=L(r.shape),i=Eb(t,r.shape,r.dtype,e,u,"max");h=n.makeTensorInfo(u.outShape,r.dtype,i.values)}return h}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ax={kernelName:ze,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=i;fm(r,"maxPool3d");const u=Yo(r.shape,s,o,1,a,l,c),h=$b(n.data.get(r.dataId).values,r.shape,r.dtype,L(r.shape),u,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lx={kernelName:Be,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=i;fm([r,s],"maxPool3DGrad");const u=Yo(s.shape,o,a,1,l,c),h=function(t,e){const n=bo(e.outShape,"int32"),i=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const b=y*i-d;let v=b;for(;v<0;)v+=o;const x=Math.min(e.inDepth,c+b);for(let i=0;i<e.outHeight;++i){const c=i*r-p;let d=c;for(;d<0;)d+=a;const w=Math.min(e.inHeight,u+c);for(let r=0;r<e.outWidth;++r){const p=r*s-f;let S=p;for(;S<0;)S+=l;const k=Math.min(e.inWidth,h+p);let C=Number.NEGATIVE_INFINITY,T=-1;for(let e=v;e<x;e+=o){const n=e-b;for(let i=d;i<w;i+=a){const r=i-c;for(let s=S;s<k;s+=l){const o=s-p,a=t.get(m,e,i,s,g);a>=C&&(C=a,T=n*u*h+r*u+o)}}}n.set(T,m,y,i,r,g)}}}return n}(n.bufferSync(s),u),d=u.strideDepth,p=u.strideHeight,f=u.strideWidth,m=u.dilationDepth,g=u.dilationHeight,y=u.dilationWidth,b=u.effectiveFilterDepth,v=u.effectiveFilterHeight,x=u.effectiveFilterWidth,w=b-1-u.padInfo.front,S=x-1-u.padInfo.left,k=v-1-u.padInfo.top,C=bo(s.shape,"float32"),T=n.bufferSync(r);for(let t=0;t<u.batchSize;++t)for(let e=0;e<u.inChannels;++e)for(let n=0;n<u.inDepth;++n)for(let i=0;i<u.inHeight;++i)for(let r=0;r<u.inWidth;++r){const s=n-w,o=i-k,a=r-S;let l=0;for(let n=0;n<b;n+=m){const i=(s+n)/d;if(!(i<0||i>=u.outDepth||Math.floor(i)!==i))for(let r=0;r<v;r+=g){const s=(o+r)/p;if(!(s<0||s>=u.outHeight||Math.floor(s)!==s))for(let o=0;o<x;o+=y){const c=(a+o)/f;if(c<0||c>=u.outWidth||Math.floor(c)!==c)continue;const d=b*v*x-1-h.get(t,i,s,c,e)===n*v*x+r*x+o?1:0;if(0===d)continue;l+=T.get(t,i,s,c,e)*d}}}C.set(l,t,n,i,r,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cx={kernelName:Fe,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s,output:o}=e,a=s;fm([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=i,d=Ko(a.shape,l,c,1,u,h),p=n.data.get(a.dataId).values,f=bo(d.outShape,a.dtype,Mb(p,a.shape,a.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,v=d.effectiveFilterHeight,x=d.effectiveFilterWidth,w=x-1-d.padInfo.left,S=v-1-d.padInfo.top,k=bo(a.shape,"float32"),C=n.data.get(r.dataId).values,T=bo(r.shape,"float32",C);for(let t=0;t<d.batchSize;++t)for(let e=0;e<d.inChannels;++e)for(let n=0;n<d.inHeight;++n)for(let i=0;i<d.inWidth;++i){const r=n-S,s=i-w;let o=0;for(let n=0;n<v;n+=y){const i=(r+n)/m;if(!(i<0||i>=d.outHeight||Math.floor(i)!==i))for(let r=0;r<x;r+=b){const a=(s+r)/g;if(a<0||a>=d.outWidth||Math.floor(a)!==a)continue;const l=v*x-1-f.get(t,i,a,e)===n*x+r?1:0;if(0===l)continue;o+=T.get(t,i,a,e)*l}}k.set(o,t,n,i,e)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ux={kernelName:Ue,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:i}=t,{filterSize:r,strides:s,pad:o,includeBatchInIndex:a}=e,l=n;fm(i,"MaxPoolWithArgmax");const c=l.data.get(i.dataId).values,u=Ko(i.shape,r,s,[1,1],o),[h,d]=function(t,e,n,i,r){const s=Eb(t,0,n,L(e),r,"max"),o=Mb(t,e,n,r,!0,i);return[s.values,o.values]}(c,i.shape,i.dtype,a,u),p=l.write(h,u.outShape,i.dtype),f=l.write(d,u.outShape,i.dtype);return[{dataId:p,shape:u.outShape,dtype:i.dtype},{dataId:f,shape:u.outShape,dtype:"int32"}]}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hx={kernelName:Ve,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,keepDims:o}=i,a=w(s,r.shape),l=d(hl(r.shape,a)[1]),c=[],u=n.makeTensorInfo([],"float32",new Float32Array([l]));c.push(u);const h=Mm({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});c.push(h);const p=Tv({inputs:{a:h,b:u},backend:n});c.push(p);const f=gv({inputs:{x:p},backend:n,attrs:{axis:s,keepDims:o}});return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),f}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dx={kernelName:We,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,keepDims:o}=i;fm(r,"min");const a=w(s,r.shape);let l=a;const c=fl(l,r.shape.length);let u=r;null!=c&&(u=Hg({inputs:{x:r},backend:n,attrs:{perm:c}}),l=gl(l.length,r.shape.length)),pl("min",l,u.shape.length);const[h,p]=hl(u.shape,l),f=d(p),m=U(d(h),u.dtype),g=n.data.get(u.dataId).values;for(let t=0;t<m.length;++t){const e=t*f;let n=g[e];for(let t=0;t<f;++t){const i=g[e+t];(Number.isNaN(i)||i<n)&&(n=i)}m[t]=n}null!=c&&n.disposeIntermediateTensorInfo(u);const y=n.makeTensorInfo(h,u.dtype,m);if(o){const t=nb({inputs:{x:y},backend:n,attrs:{shape:dl(h,a)}});return n.disposeIntermediateTensorInfo(y),t}return y}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const px={kernelName:je,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{paddings:s,mode:o}=i;fm(r,"mirrorPad");const a=s.map(((t,e)=>t[0]+r.shape[e]+t[1])),l=s.map((t=>t[0])),c=s.map(((t,e)=>t[0]+r.shape[e])),u="reflect"===o?0:1,h=n.data.get(r.dataId).values,p=r.shape.length,f=L(r.shape),m=d(a),g=a.length,y=L(a),b=k(r.dtype,m);for(let t=0;t<m;t++){let e=j(t,g,y);for(let t=0;t<g;t++)e[t]<l[t]?e[t]=2*l[t]-e[t]-u:e[t]>=c[t]&&(e[t]=2*(c[t]-1)-e[t]+u);e=e.map(((t,e)=>t-l[e]));const n=H(e,p,f);b[t]=h[n]}return{dataId:n.write(b,a,r.dtype),shape:a,dtype:r.dtype}}},fx=vm(((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e})),mx=Im(Ge,fx),gx={kernelName:Ge,backendName:"cpu",kernelFunc:mx};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yx(t){const{inputs:e,backend:n,attrs:i}=t,{logits:r}=e,{dim:s}=i,o=r.shape.length;let a=s;if(-1===a&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=w([a],r.shape),c=rx({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),u=dl(c.shape,l),h=nb({inputs:{x:c},backend:n,attrs:{shape:u}}),d=Ly({inputs:{a:r,b:h},backend:n}),p=Jm({inputs:{x:d},backend:n}),f=gv({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=nb({inputs:{x:f},backend:n,attrs:{shape:u}}),g=Tv({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const bx={kernelName:zn,backendName:"cpu",kernelFunc:yx};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vx={kernelName:qe,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{logits:r}=e,{numSamples:s,seed:o,normalized:a}=i;fm(r,"multinomial");const l=a?r:yx({inputs:{logits:r},backend:n,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=n.data.get(l.dataId).values,p=[c,s],f=U(d(p),"int32");for(let t=0;t<c;++t){const e=t*u,n=new Float32Array(u-1);n[0]=h[e];for(let t=1;t<n.length;++t)n[t]=n[t-1]+h[e+t];const i=lu.alea(o.toString()),r=t*s;for(let t=0;t<s;++t){const e=i();f[r+t]=n.length;for(let i=0;i<n.length;i++)if(e<n[i]){f[r+t]=i;break}}}return a||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(p,"int32",f)}},xx=id;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wx={kernelName:Ze,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=i;fm(r,"NonMaxSuppression");const c=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:h}=xx(c,u,o,a,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},Sx=rd;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kx={kernelName:Je,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=i;fm(r,"NonMaxSuppressionPadded");const u=n.data.get(r.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:p}=Sx(u,h,o,a,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},Cx=sd;
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tx={kernelName:Qe,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=i;fm(r,"NonMaxSuppressionWithScore");const u=n.data.get(r.dataId).values,h=n.data.get(s.dataId).values,d=o,p=a,f=l,m=c,{selectedIndices:g,selectedScores:y}=Cx(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _x={kernelName:en,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{indices:r}=e,{dtype:s,depth:o,onValue:a,offValue:l}=i;fm(r,"oneHot");const c=d(r.shape),u=new Float32Array(c*o);u.fill(l);const h=n.data.get(r.dataId).values;for(let t=0;t<c;++t)h[t]>=0&&h[t]<o&&(u[t*o+h[t]]=a);return n.makeTensorInfo([...r.shape,o],s,u)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ex(t){const{inputs:e,backend:n}=t,{x:i}=e;if("string"===i.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===i.dtype){const t=Tm({inputs:{input:i},backend:n}),e=Ex({inputs:{x:t},backend:n}),r=Ub({inputs:{input:i},backend:n}),s=Ex({inputs:{x:r},backend:n}),o=xm({inputs:{real:e,imag:s},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return Av({backend:n,attrs:{shape:i.shape,value:0,dtype:i.dtype}})}const Mx={kernelName:li,backendName:"cpu",kernelFunc:Ex};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $x={kernelName:tn,backendName:"cpu",kernelFunc:function t(e){const{inputs:n,backend:i}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const e=Tm({inputs:{input:r},backend:i}),n=t({inputs:{x:e},backend:i}),s=Ub({inputs:{input:r},backend:i}),o=Ex({inputs:{x:s},backend:i}),a=xm({inputs:{real:n,imag:o},backend:i});return i.disposeIntermediateTensorInfo(e),i.disposeIntermediateTensorInfo(n),i.disposeIntermediateTensorInfo(s),i.disposeIntermediateTensorInfo(o),a}return Av({backend:i,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ix(t){const{inputs:e,backend:n,attrs:i}=t,{axis:r}=i;if(1===e.length)return Sv({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const s=e[0].shape,o=e[0].dtype;e.forEach((t=>{u(s,t.shape,"All tensors passed to stack must have matching shapes"),c(o===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const a=[],l=e.map((t=>{const e=Sv({inputs:{input:t},backend:n,attrs:{dim:r}});return a.push(e),e})),h=Wb({inputs:l,backend:n,attrs:{axis:r}});return a.forEach((t=>n.disposeIntermediateTensorInfo(t))),h}const Ax={kernelName:nn,backendName:"cpu",kernelFunc:Ix};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nx={kernelName:rn,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{paddings:s,constantValue:o}=i;fm(r,"pad");const a=s.map(((t,e)=>t[0]+r.shape[e]+t[1])),l=s.map((t=>t[0])),c=n.data.get(r.dataId).values,u=d(r.shape),h=r.shape.length,p=L(r.shape),f=d(a),m=a.length,g=L(a),y=k(r.dtype,f);0!==o&&y.fill(o);for(let t=0;t<u;t++){const e=j(t,h,p).map(((t,e)=>t+l[e]));y[H(e,m,g)]=c[t]}return{dataId:n.write(y,a,r.dtype),shape:a,dtype:r.dtype}}},Rx=vm(((t,e)=>Math.pow(t,e))),Px=Im(sn,Rx),Ox={kernelName:sn,backendName:"cpu",kernelFunc:Px};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lx={kernelName:ln,backendName:"cpu",kernelFunc:
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{paramsNestedSplits:r,paramsDenseValues:s,indices:o}=e,a=r.map((t=>n.data.get(t.dataId).values)),l=r.map((t=>t.shape)),c=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values,[h,d,p]=Zg(a,l,c,s.shape,s.dtype,u,o.shape),f=h.map((t=>n.makeTensorInfo([t.length],"int32",t))),m=n.makeTensorInfo(p,s.dtype,d);return f.concat([m])}};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dx={kernelName:cn,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{starts:i,limits:r,deltas:s}=e,o=n.data.get(i.dataId).values,a=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[c,u]=Qg(o,i.shape,i.dtype,a,r.shape,l,s.shape);return[n.makeTensorInfo([c.length],"int32",c),n.makeTensorInfo([u.length],i.dtype,u)]}};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fx={kernelName:un,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{shape:r,values:s,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=i,c=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=a.map((t=>n.data.get(t.dataId).values)),p=a.map((t=>t.shape)),[f,m]=ry(c,r.shape,u,s.shape,s.dtype,h,o.shape,d,p,l);return n.makeTensorInfo(f,s.dtype,m)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zx={kernelName:hn,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:i,stop:r,dtype:s,step:o}=n,a=sy(i,r,o,s);return e.makeTensorInfo([a.length],s,a)}},Bx=Vm(pn,(t=>1/t)),Ux={kernelName:pn,backendName:"cpu",kernelFunc:Bx};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vx={kernelName:bn,backendName:"cpu",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r}=e,{alignCorners:s,halfPixelCenters:o,size:a}=i;fm(r,"resizeBilinear");const l=L(r.shape),[c,u]=a,[h,p,f,m]=r.shape,g=n.data.get(r.dataId).values,y=new Float32Array(d([h,c,u,m])),b=[s&&c>1?p-1:p,s&&u>1?f-1:f],v=[s&&c>1?c-1:c,s&&u>1?u-1:u];let x=0;const w=b[0]/v[0],S=b[1]/v[1];for(let t=0;t<h;t++)for(let e=0;e<c;e++){let n;n=o?w*(e+.5)-.5:w*e;const i=Math.max(0,Math.floor(n)),r=n-i,s=Math.min(p-1,Math.ceil(n)),a=t*l[0]+i*l[1],c=t*l[0]+s*l[1];for(let t=0;t<u;t++){let e;e=o?S*(t+.5)-.5:S*t;const n=Math.max(0,Math.floor(e)),i=e-n,s=Math.min(f-1,Math.ceil(e)),u=a+n*l[2],h=c+n*l[2],d=a+s*l[2],p=c+s*l[2];for(let t=0;t<m;t++){const e=g[u+t],n=g[h+t],s=e+(g[d+t]-e)*i,o=s+(n+(g[p+t]-n)*i-s)*r;y[x++]=o}}}return n.makeTensorInfo([h,c,u,m],"float32",y)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wx={kernelName:vn,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r,dy:s}=e,{alignCorners:o}=i;fm([s,r],"resizeBilinearGrad");const a=L(r.shape),[l,c,u,h]=r.shape,[,d,p]=s.shape,f=new Float32Array(l*c*u*h),m=[o&&d>1?c-1:c,o&&p>1?u-1:u],g=[o&&d>1?d-1:d,o&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(s.dataId).values;let x=0;for(let t=0;t<l;t++){const e=t*a[0];for(let t=0;t<d;t++){const n=t*y,i=Math.floor(n),r=Math.min(Math.ceil(n),c-1),s=e+i*a[1],o=e+r*a[1],l=n-i,d=1-l;for(let t=0;t<p;t++){const e=t*b,n=Math.floor(e),i=Math.min(Math.ceil(e),u-1),r=e-n,c=1-r,p=s+n*a[2],m=s+i*a[2],g=o+n*a[2],y=o+i*a[2],w=d*c,S=d*r,k=l*c,C=l*r;for(let t=0;t<h;t++){const e=v[x++];f[p+t]+=e*w,f[m+t]+=e*S,f[g+t]+=e*k,f[y+t]+=e*C}}}}return n.makeTensorInfo([l,u,c,h],"float32",f)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hx={kernelName:gn,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r}=e,{alignCorners:s,halfPixelCenters:o,size:a}=i;fm(r,"resizeNearestNeighbor");const l=L(r.shape),[c,u]=a,[h,d,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(h*c*u*f),y=[s&&c>1?d-1:d,s&&u>1?p-1:p],b=[s&&c>1?c-1:c,s&&u>1?u-1:u],v=y[0]/b[0],x=y[1]/b[1];let w=0;for(let t=0;t<h;t++){const e=t*l[0];for(let t=0;t<c;t++){const n=o?v*(t+.5):v*t;let i=Math.min(d-1,s?Math.round(n):Math.floor(n));o&&(i=Math.max(0,i));const r=e+i*l[1];for(let t=0;t<u;t++){const e=o?x*(t+.5):x*t;let n=Math.min(p-1,s?Math.round(e):Math.floor(e));o&&(n=Math.max(0,n));const i=r+n*l[2];for(let t=0;t<f;t++){const e=m[i+t];g[w++]=e}}}}return n.makeTensorInfo([h,c,u,f],r.dtype,g)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jx={kernelName:yn,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r,dy:s}=e,{alignCorners:o}=i;fm([s,r],"resizeNearestNeighborGrad");const a=L(r.shape),l=L(s.shape),[c,u,h,d]=r.shape,[,p,f]=s.shape,m=new Float32Array(c*u*h*d),g=n.data.get(s.dataId).values,y=[o&&p>1?u-1:u,o&&f>1?h-1:h],b=[o&&p>1?p-1:p,o&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,S=1/x,k=2*Math.ceil(w)+2,C=2*Math.ceil(S)+2;for(let t=0;t<c;t++){const e=t*a[0];for(let t=0;t<u;t++){const n=e+t*a[1],i=Math.floor(t*w),r=Math.floor(i-k/2);for(let i=0;i<h;i++){const s=n+i*a[2],c=Math.floor(i*S),y=Math.floor(c-C/2);for(let n=0;n<d;n++){let a=0;for(let s=0;s<k;s++){const c=s+r;if(c<0||c>=p)continue;const d=e+c*l[1],m=c*v;if(t===Math.min(u-1,o?Math.round(m):Math.floor(m)))for(let t=0;t<C;t++){const e=t+y;if(e<0||e>=f)continue;const r=d+e*l[2],s=e*x;i===Math.min(h-1,o?Math.round(s):Math.floor(s))&&(a+=g[r+n])}}m[s+n]=a}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gx={kernelName:wn,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{dims:s}=i;fm(r,"reverse");const o=r.shape.length,a=w(s,r.shape);if(0===o)return km({inputs:{x:r},backend:n});const l=new Nr(r.shape,r.dtype),c=n.bufferSync(r);for(let t=0;t<l.size;t++){const e=l.indexToLoc(t),n=e.slice();a.forEach((t=>n[t]=r.shape[t]-1-n[t])),l.set(c.get(...n),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},qx={kernelName:hi,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:i}=t,{radians:r,fillValue:s,center:o}=e,a=n,l=k(i.dtype,d(i.shape)),[c,u,h,p]=i.shape,[f,m]=ff(o,u,h),g=Math.sin(r),y=Math.cos(r),b=a.data.get(i.dataId).values;for(let t=0;t<c;t++){const e=t*h*u*p;for(let t=0;t<u;t++){const n=t*(h*p);for(let i=0;i<h;i++){const r=i*p;for(let o=0;o<p;o++){const a=[c,t,i,o],d=a[2],v=a[1];let x=(d-f)*y-(v-m)*g,w=(d-f)*g+(v-m)*y;x=Math.round(x+f),w=Math.round(w+m);let S=s;if("number"!=typeof s&&(S=3===o?255:s[o]),x>=0&&x<h&&w>=0&&w<u){S=b[e+w*(h*p)+x*p+o]}l[e+n+r+o]=S}}}}return{dataId:a.write(l,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},Xx=Vm(Sn,(t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2==0?e:e+1})),Kx={kernelName:Sn,backendName:"cpu",kernelFunc:Xx};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yx={kernelName:Cn,backendName:"cpu",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{indices:r,updates:s}=e,{shape:o}=i,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=hh(0,r,o),d=cy(n.bufferSync(r),n.bufferSync(s),o,h,c,l,a,u,0,!0);return n.makeTensorInfo(o,d.dtype,d.values)}};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zx(t,e){let n=0,i=t.length,r=0;for(;n<i;)r=Math.floor((n+i)/2),t[r]<e?n=r+1:i=r;return i}function Jx(t,e){let n=0,i=t.length,r=0;for(;n<i;)r=Math.floor((n+i)/2),t[r]<=e?n=r+1:i=r;return i}const Qx={kernelName:_n,backendName:"cpu",kernelFunc:
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{sortedSequence:r,values:s}=e,{side:o}=i,a=function(t,e,n,i,r,s){const o=C("int32",n*r);for(let a=0;a<n;++a){const n=t.slice(a*i,(a+1)*i),l=a*r;for(let t=0;t<r;++t)o[l+t]="left"===s?Zx(n,e[t+l]):Jx(n,e[t+l])}return o}(n.data.get(r.dataId).values,n.data.get(s.dataId).values,r.shape[0],r.shape[1],s.shape[1],o);return n.makeTensorInfo(s.shape,"int32",a)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tw={kernelName:En,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:i,t:r,e:s}=e;fm([i,r,s],"select");const o=i.shape.length,a=n.data.get(i.dataId).values,l=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,u=Hr(r.dtype,s.dtype),h=U(d(r.shape),u);let p=0;const f=0===o||o>1||1===r.shape.length?1:d(r.shape.slice(1));for(let t=0;t<a.length;t++)for(let e=0;e<f;e++)1===a[t]?h[p++]=l[t]:h[p++]=c[t];return n.makeTensorInfo(r.shape,u,h)}},ew=Vm(Mn,(t=>t>=0?1.0507009873554805*t:1.7580993408473768*(Math.exp(t)-1))),nw={kernelName:Mn,backendName:"cpu",kernelFunc:ew},iw=Vm(Nn,(t=>t<0?-1:t>0?1:0)),rw={kernelName:Nn,backendName:"cpu",kernelFunc:iw},sw=Vm(In,(t=>Math.sin(t))),ow={kernelName:In,backendName:"cpu",kernelFunc:sw},aw=Vm(An,(t=>Math.sinh(t))),lw={kernelName:An,backendName:"cpu",kernelFunc:aw},cw=Math.log(1.1920928955078125e-7)+2,uw=Vm(Pn,(t=>{const e=t>-cw,n=t<cw,i=Math.exp(t);let r;return r=n?i:e?t:Math.log(1+i),r})),hw={kernelName:Pn,backendName:"cpu",kernelFunc:uw};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dw={kernelName:Dn,backendName:"cpu",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{blockShape:s,paddings:o}=i;fm([r],"spaceToBatchND");const a=d(s),l=[[0,0]];l.push(...o);for(let t=1+s.length;t<r.shape.length;++t)l.push([0,0]);const c=Nx.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),u=mf(c.shape,s,a,!1),h=gf(u.length,s.length,!1),p=yf(c.shape,s,a,!1),f=nb({inputs:{x:c},backend:n,attrs:{shape:u}}),m=Hg({inputs:{x:f},backend:n,attrs:{perm:h}}),g=nb({inputs:{x:m},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pw={kernelName:Bn,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:i,values:r,denseShape:s,defaultValue:o}=e;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==i.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${i.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=n.data.get(i.dataId).values,l=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values[0],[h,d,p,f,m]=gy(a,i.shape,i.dtype,l,r.dtype,c,u);return[n.makeTensorInfo(d,i.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((t=>Number(t))))),n.makeTensorInfo([m.length],i.dtype,new Int32Array(m))]}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fw={kernelName:Un,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:i,inputShape:r,newShape:s}=e;if(2!==i.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${i.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(n.data.get(r.dataId).values),a=n.data.get(i.dataId).values,l=Array.from(n.data.get(s.dataId).values),[c,u,h]=yy(a,i.shape,i.dtype,o,l);return[n.makeTensorInfo(u,i.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mw={kernelName:Vn,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:i,indices:r,segmentIds:s}=e;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(i.dataId).values,a=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[c,u]=by(o,i.shape,i.dtype,a,l,!0);return n.makeTensorInfo(u,i.dtype,c)}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gw={kernelName:Wn,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:i,indices:r,segmentIds:s}=e;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(i.dataId).values,a=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[c,u]=by(o,i.shape,i.dtype,a,l);return n.makeTensorInfo(u,i.dtype,c)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yw={kernelName:Hn,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{sparseIndices:r,sparseValues:s,defaultValue:o}=e,{outputShape:a}=i,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=hh(0,r,a),p=!1,f=n.bufferSync(r);let m;switch(s.dtype){case"bool":m=cy(f,n.bufferSync(s),a,d,u,c,l,h,Boolean(n.data.get(o.dataId).values[0]),p);break;case"float32":m=cy(f,n.bufferSync(s),a,d,u,c,l,h,n.data.get(o.dataId).values[0],p);break;case"int32":m=cy(f,n.bufferSync(s),a,d,u,c,l,h,n.data.get(o.dataId).values[0],p);break;case"string":m=cy(f,n.bufferSync(s),a,d,u,c,l,h,yr(n.data.get(o.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(a,m.dtype,m.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bw={kernelName:Fn,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{numOrSizeSplits:s,axis:o}=i,a=w(o,r.shape)[0],l=Gf(r,s,a),c=new Array(r.shape.length).fill(0),u=r.shape.slice();return l.map((t=>{const e=[...u];e[a]=t;const i=fy({inputs:{x:r},backend:n,attrs:{begin:c,size:e}});return c[a]+=t,i}))}},vw={kernelName:Gn,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,i=e;fm(n,"square");const r=i.data.get(n.dataId).values,s=new Float32Array(r.length);for(let t=0;t<r.length;++t){const e=r[t];s[t]=e*e}return{dataId:i.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},xw=Vm(ci,((t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha})),ww={kernelName:ci,backendName:"cpu",kernelFunc:xw};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sw={kernelName:Xn,backendName:"cpu",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{begin:s,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=i;fm(r,"stridedSlice");const{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=Zp(r.shape,s,o,a,l,u,h,d,p);let S;if(g)S=nb({inputs:{x:r},backend:n,attrs:{shape:m}});else if(y||b){c(r.shape.length>=1,(()=>`Input must have rank at least 1, got: ${r.shape.length}`));const t=zp(v,x,w),e=fy({inputs:{x:r},backend:n,attrs:{begin:v,size:t}});S=nb({inputs:{x:e},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(e)}else{const t=My(f,n.bufferSync(r),w,v);S=n.makeTensorInfo(m,t.dtype,t.values)}return S}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kw={kernelName:Kn,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{separator:r,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=i,{data:u,dataSplits:h}=e,d=n.data.get(u.dataId).values,p=n.data.get(h.dataId).values,[f,m]=Iy(d,p,r,s,o,a,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cw={kernelName:Yn,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{skipEmpty:r}=i,{input:s,delimiter:o}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values[0],[c,u,h]=Ny(a,l,r),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tw={kernelName:Zn,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{numBuckets:r}=i,{input:s}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=Ry(n.data.get(s.dataId).values,r);return n.makeTensorInfo(s.shape,"int32",o)}},_w=Vm(Qn,(t=>Math.tan(t))),Ew={kernelName:Qn,backendName:"cpu",kernelFunc:_w},Mw=Vm(ti,(t=>Math.tanh(t)));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $w={kernelName:Tn,backendName:"cpu",kernelFunc:
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n}=t,{tensor:i,indices:r,updates:s}=e,{sliceRank:o,numUpdates:a,sliceSize:l,strides:c,outputSize:u}=hh(0,r,i.shape),h=n.bufferSync(r),d=n.bufferSync(s),p=n.bufferSync(i),f=cy(h,d,i.shape,u,l,a,o,c,p,!1);return n.makeTensorInfo(i.shape,f.dtype,f.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iw={kernelName:ei,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{reps:s}=i;fm(r,"tile");const o=Fy(n.bufferSync(r),s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aw={kernelName:ni,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{k:s,sorted:o}=i;fm(r,"topk");const a=n.data.get(r.dataId).values,[l,c]=Uy(a,r.shape,r.dtype,s,o);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nw={kernelName:ii,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:i}=t,{image:r,transforms:s}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=n,[u,h,p,f]=r.shape,[m,g]=null!=c?c:[h,p],y=[u,m,g,f],b=L(r.shape),v=b[0],x=b[1],w=b[2],S=L(y),C=S[0],T=S[1],_=S[2],E=k(r.dtype,d(y));E.fill(l);const M=i.data.get(r.dataId).values,$=i.data.get(s.dataId).values;for(let t=0;t<u;++t){const e=1===s.shape[0]?$:$.subarray(8*t,8*t+8);for(let n=0;n<m;++n)for(let i=0;i<g;++i)for(let r=0;r<f;++r){let s;const c=e[6]*i+e[7]*n+1;if(0===c)continue;const u=(e[0]*i+e[1]*n+e[2])/c,d=(e[3]*i+e[4]*n+e[5])/c,f=Rw(u,p,a),m=Rw(d,h,a);switch(o){case"nearest":s=Ow(M,h,p,v,x,w,t,m,f,r,l);break;case"bilinear":s=Lw(M,h,p,v,x,w,t,m,f,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}E[t*C+n*T+i*_+r]=s}return i.makeTensorInfo(y,r.dtype,E)}return{dataId:i.write(E,y,r.dtype),shape:r.shape,dtype:r.dtype}}};function Rw(t,e,n){switch(n){case"reflect":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=2*e;n<t&&(n=t*Math.trunc(-n/t)+n),n=n<-e?n+t:-n-1}else if(n>e-1)if(e<=1)n=0;else{const t=2*e;n-=t*Math.trunc(n/t),n>=e&&(n=t-n-1)}return s(0,n,e-1)}(t,e);case"wrap":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=e-1;n+=e*(Math.trunc(-n/t)+1)}else if(n>e-1)if(e<=1)n=0;else{const t=e-1;n-=e*Math.trunc(n/t)}return s(0,n,e-1)}(t,e);case"nearest":return function(t,e){return s(0,t,e-1)}(t,e);default:return function(t,e){return t}(t)}}function Pw(t,e,n,i,r,s,o,a,l,c,u){return 0<=a&&a<e&&0<=l&&l<n?t[o*i+a*r+l*s+c]:u}function Ow(t,e,n,i,r,s,o,a,l,c,u){return Pw(t,e,n,i,r,s,o,Math.round(a),Math.round(l),c,u)}function Lw(t,e,n,i,r,s,o,a,l,c,u){const h=Math.floor(a),d=Math.floor(l),p=h+1,f=d+1;return(p-a)*((f-l)*Pw(t,e,n,i,r,s,o,h,d,c,u)+(l-d)*Pw(t,e,n,i,r,s,o,h,f,c,u))+(a-h)*((f-l)*Pw(t,e,n,i,r,s,o,p,d,c,u)+(l-d)*Pw(t,e,n,i,r,s,o,p,f,c,u))}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dw={kernelName:si,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:i}=t,{axis:r}=n,{x:s}=e;fm(s,"unique");const o=i.data.get(s.dataId).values,{outputValues:a,outputShape:l,indices:c}=Vy(o,r,s.shape,s.dtype);return[i.makeTensorInfo(l,s.dtype,a),i.makeTensorInfo([c.length],"int32",c)]}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fw={kernelName:oi,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{value:r}=e;let{axis:s}=i;s<0&&(s+=r.shape.length);const o=r.shape.length,a=r.shape[s],l=new Array(o-1);let c=0;for(let t=0;t<o;t++)t!==s&&(l[c++]=r.shape[t]);const u=new Array(o).fill(0),h=r.shape.slice();h[s]=1;const d=new Array(a);for(let t=0;t<d.length;t++){u[s]=t;const e=fy({inputs:{x:r},backend:n,attrs:{begin:u,size:h}});d[t]=nb({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return d}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zw={kernelName:ai,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,segmentIds:s}=e,{numSegments:o}=i;fm(r,"unsortedSegmentSum");const a=[],l=[],c=r.shape.length-s.shape.length;let u=s;for(let t=0;t<c;++t){const e=Sv({inputs:{input:u},backend:n,attrs:{dim:t+1}});u=e,l.push(e)}for(let t=0;t<o;++t){const e=pr(t,"int32"),i=n.makeTensorInfo([],"int32",e),s=Km({inputs:{a:i,b:u},backend:n}),o=Mm({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),c=Lg({inputs:{a:o,b:r},backend:n}),h=gv({inputs:{x:c},backend:n,attrs:{axis:0,keepDims:!1}});a.push(h),l.push(i),l.push(s),l.push(o),l.push(c),l.push(h)}const h=Ix({inputs:a,backend:n,attrs:{axis:0}});return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),h}},Bw=[ob,bm,lb,ub,Om,hb,db,pb,fb,mb,yb,vb,wb,Cb,_b,Ib,Ab,Nb,Rb,sb,Pb,Ob,Lb,Bm,Db,$m,Gm,zb,wm,Bb,Hb,Gb,qb,Xb,Kb,Yb,Zb,Qb,ev,nv,iv,rv,sv,ov,lv,cv,uv,hv,dv,pv,fv,mv,bv,jy,vv,Ym,wv,Qm,kv,ng,Iv,Nv,Rv,sg,lg,Pv,Ov,Lv,Dv,pg,gg,Cm,Fv,Vb,Bv,Vv,Hv,qy,vg,Sg,jv,_g,qv,Yv,Jv,ex,nx,ix,sx,Ig,ox,ax,lx,cx,ux,hx,dx,Rg,px,gx,vx,Dg,zg,wx,kx,Tx,Vg,_x,$x,Ax,Nx,Ox,Yy,qg,Lx,Dx,Fx,zx,_m,_v,Ux,Jy,tb,ib,Vx,Wx,Hx,jx,Gx,qx,Kx,ly,Yx,Qx,tw,nw,dy,rw,ow,lw,my,bx,hw,dw,pw,fw,mw,gw,yw,bw,wy,vw,Cy,Ey,ww,Sw,kw,Cw,Tw,Dy,yv,Ew,{kernelName:ti,backendName:"cpu",kernelFunc:Mw},$w,Iw,Aw,Nw,jg,Dw,Fw,zw,Mx];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */for(const t of Bw)wi(t);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uw={},Vw={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Ww(t,e){if(!(t in Uw)||null!=e){const n=function(t,e){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==e?function(t){if(Y().getBool("IS_SAFARI")||"undefined"==typeof OffscreenCanvas||2!==t){if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(t):e;n.addEventListener("webglcontextlost",(e=>{e.preventDefault(),delete Uw[t]}),!1),Y().getBool("SOFTWARE_WEBGL_ENABLED")&&(Vw.failIfMajorPerformanceCaveat=!1);if(1===t)return n.getContext("webgl",Vw)||n.getContext("experimental-webgl",Vw);return n.getContext("webgl2",Vw)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(t,e);if(null===n)return console.log("Could not get context for WebGL version",t),null;Uw[t]=n}const n=Uw[t];return null==n||n.isContextLost()?(delete Uw[t],Ww(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Uw[t])}var Hw,jw,Gw;function qw(t,e){return[e,t]}function Xw(t){const e=d(t);return y(Math.ceil(e/4))}function Kw(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function Yw(t,e){const n=t;let i,r,s,o,a,l,c,u,h,d;return 2===Y().getNumber("WEBGL_VERSION")?(i=n.R32F,r=n.R16F,s=n.RGBA16F,o=n.RGBA32F,a=n.RED,c=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(i=t.RGBA,r=t.RGBA,s=t.RGBA,o=n.RGBA,a=t.RGBA,c=4,u=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT,l=t.RGBA),{internalFormatFloat:i,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zw(t,e){const n=e();return Y().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}(t,e))}(t),n}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(Hw||(Hw={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(jw||(jw={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(Gw||(Gw={}));function Jw(t){return!!(Y().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function Qw(t,e){return lS(t,(()=>t.getExtension(e)),'Extension "'+e+'" not supported on this browser.')}const tS=/ERROR: [0-9]+:([0-9]+):/g;function eS(t,e){const n=tS.exec(e);if(null==n)return console.log(`Couldn't parse line number in error: ${e}`),void console.log(t);const i=+n[1],r=t.split("\n"),s=r.length.toString().length+2,o=r.map(((t,e)=>b((e+1).toString(),s)+t));let a=0;for(let t=0;t<o.length;t++)a=Math.max(o[t].length,a);const l=o.slice(0,i-1),c=o.slice(i-1,i),u=o.slice(i);console.log(l.join("\n")),console.log(e.split("\n")[0]),console.log(`%c ${b(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function nS(t,e){if(Zw(t,(()=>t.validateProgram(e))),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function iS(t,e,n,i,r,s,o){const a=t.getAttribLocation(e,n);return-1!==a&&(Zw(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,i))),Zw(t,(()=>t.vertexAttribPointer(a,r,t.FLOAT,!1,s,o))),Zw(t,(()=>t.enableVertexAttribArray(a))),!0)}function rS(t,e,n){!function(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,i=e+t.TEXTURE0;if(i<t.TEXTURE0||i>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}(t,n),Zw(t,(()=>t.activeTexture(t.TEXTURE0+n))),Zw(t,(()=>t.bindTexture(t.TEXTURE_2D,e)))}function sS(t,e,n){Zw(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,n))),Zw(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0)))}function oS(t,e){Zw(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,e))),Zw(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)))}function aS(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}(t,e))}function lS(t,e,n){const i=Zw(t,(()=>e()));if(null==i)throw new Error(n);return i}function cS(t,e=2){return d(t.slice(0,t.length-e))}function uS(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function hS(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[cS(t),...uS(t)]),e}function dS(t){return t%2==0}function pS(t,e){if(m(t=t.slice(-2),e=e.slice(-2)))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t[t.length-1],i=e[e.length-1];if(n===i)return!0;if(dS(n)&&dS(i)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&dS(t[0])&&dS(e[0])}let fS,mS;function gS(t,e){return null!=t.getExtension(e)}function yS(t){try{if(null!=Ww(t))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function bS(t){if(0===t)return!1;const e=Ww(t);if(1!==t){if(gS(e,"EXT_color_buffer_float"))return vS(e);const t="EXT_color_buffer_half_float";if(gS(e,t)){const n=e.getExtension(t);return function(t,e){const n=Yw(t,e),i=t.createTexture();t.bindTexture(t.TEXTURE_2D,i);const r=1,s=1;t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,r,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,i,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(i),t.deleteFramebuffer(o),a}(e,n)}return!1}if(!gS(e,"OES_texture_float"))return!1;if(!gS(e,"WEBGL_color_buffer_float"))return!1;return vS(e)}function vS(t){const e=Yw(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n);t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const r=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(i),r}function xS(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&c("complex64"!==t.dtype,(()=>`${e} does not support complex64 tensors in the WebGL backend.`))}))}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wS=Y();
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SS(){let t,e,n,i,r,s,o,a,l,c;return 2===Y().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",i="in",r="texture",s="outputColor",o="out vec4 outputColor;",a=Y().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",i="varying",r="texture2D",s="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:i,texture2D:r,output:s,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kS(t,e,n="index"){const i=L(e);return i.map(((e,r)=>`${`int ${t[r]} = ${n} / ${e}`}; ${r===i.length-1?`int ${t[r+1]} = ${n} - ${t[r]} * ${e}`:`index -= ${t[r]} * ${e}`};`)).join("")}function CS(t,e,n="index"){const i=L(e);return i.map(((e,r)=>`${`int ${t[r]} = ${n} / outShapeStrides[${r}]`}; ${r===i.length-1?`int ${t[r+1]} = ${n} - ${t[r]} * outShapeStrides[${r}]`:`index -= ${t[r]} * outShapeStrides[${r}]`};`)).join("")}function TS(t,e,n="index"){const i=t.map(((t,e)=>e)),r=function(t,e){const n=t.length,i=t.map((t=>`${e}[${t}]`)),r=new Array(n-1);r[n-2]=i[n-1];for(let t=n-3;t>=0;--t)r[t]=`(${r[t+1]} * ${i[t+1]})`;return r}(i,e);return r.map(((e,i)=>`${`int ${t[i]} = ${n} / ${r[i]}`}; ${i===r.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${r[i]}`:`index -= ${t[i]} * ${r[i]}`};`)).join("")}function _S(t){const e=L(t).map((t=>t.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}wS.registerFlag("HAS_WEBGL",(()=>wS.getNumber("WEBGL_VERSION")>0)),wS.registerFlag("WEBGL_VERSION",(()=>yS(2)?2:yS(1)?1:0)),wS.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),wS.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===wS.get("WEBGL_VERSION"))),wS.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),wS.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),wS.registerFlag("WEBGL_PACK",(()=>wS.getBool("HAS_WEBGL"))),wS.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>wS.getBool("WEBGL_PACK"))),wS.registerFlag("WEBGL_PACK_CLIP",(()=>wS.getBool("WEBGL_PACK"))),wS.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>wS.getBool("WEBGL_PACK"))),wS.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>wS.getBool("WEBGL_PACK"))),wS.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>wS.getBool("WEBGL_PACK"))),wS.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>wS.getBool("WEBGL_PACK"))),wS.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>wS.getBool("WEBGL_PACK"))),wS.registerFlag("WEBGL_PACK_REDUCE",(()=>wS.getBool("WEBGL_PACK"))),wS.registerFlag("WEBGL_LAZILY_UNPACK",(()=>wS.getBool("WEBGL_PACK"))),wS.registerFlag("WEBGL_CONV_IM2COL",(()=>wS.getBool("WEBGL_PACK"))),wS.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>wS.getBool("WEBGL_PACK"))),wS.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(t){if(null==fS){const e=Ww(t);fS=e.getParameter(e.MAX_TEXTURE_SIZE)}return fS}(wS.getNumber("WEBGL_VERSION")))),wS.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(t){if(null==mS){const e=Ww(t);mS=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,mS)}(wS.getNumber("WEBGL_VERSION")))),wS.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const t=wS.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=Ww(t);return e=gS(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:gS(n,"EXT_disjoint_timer_query")?1:0,e}(t)})),wS.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>wS.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!as())),wS.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(t){if(0===t)return!1;const e=Ww(t);if(1===t){if(!gS(e,"OES_texture_float"))return!1}else if(!gS(e,"EXT_color_buffer_float"))return!1;return vS(e)}(wS.getNumber("WEBGL_VERSION")))),wS.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!wS.getBool("WEBGL_FORCE_F16_TEXTURES")&&wS.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),wS.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>bS(wS.getNumber("WEBGL_VERSION")))),wS.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(t=wS.getNumber("WEBGL_VERSION"))&&null!=Ww(t).fenceSync;var t})),wS.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>wS.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),wS.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(t=>{if("number"!=typeof t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)})),wS.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>as()?1:-1),(t=>{if("number"!=typeof t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)})),wS.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),wS.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),wS.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),wS.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),wS.registerFlag("WEBGL_EXP_CONV",(()=>!1)),wS.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>wS.getBool("IS_TEST"))),wS.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),wS.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),wS.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),wS.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const ES="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:MS}=hm;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $S(t,e,n){const i=[];if(t.forEach((t=>{const e=d(t.shapeInfo.logicalShape);if(t.shapeInfo.isUniform?i.push(`uniform float ${t.name}${e>1?`[${e}]`:""};`):(i.push(`uniform sampler2D ${t.name};`),i.push(`uniform int offset${t.name};`)),n.enableShapeUniforms){const{uniformShape:e}=BS(n.packedInputs,t.shapeInfo.logicalShape,t.shapeInfo.texShape);switch(e.length){case 1:i.push(`uniform int ${t.name}Shape;`);break;case 2:i.push(`uniform ivec2 ${t.name}Shape;`);break;case 3:i.push(`uniform ivec3 ${t.name}Shape;`);break;case 4:i.push(`uniform ivec4 ${t.name}Shape;`)}i.push(`uniform ivec2 ${t.name}TexShape;`)}})),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:i.push("uniform int outShape;");break;case 2:i.push("uniform ivec2 outShape;"),i.push("uniform int outShapeStrides;");break;case 3:i.push("uniform ivec3 outShape;"),i.push("uniform ivec2 outShapeStrides;");break;case 4:i.push("uniform ivec4 outShape;"),i.push("uniform ivec3 outShapeStrides;")}i.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((t=>{i.push(`uniform ${t.type} ${t.name}${t.arrayIndex?`[${t.arrayIndex}]`:""};`)}));const r=i.join("\n"),s=t.map((t=>function(t,e,n=!1,i){let r="";r+=n?AS(t,i):IS(t,i);const s=t.shapeInfo.logicalShape,o=e.logicalShape;s.length<=o.length&&(r+=n?function(t,e){const n=t.name,i=n.charAt(0).toUpperCase()+n.slice(1),r="get"+i+"AtOutCoords",s=t.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=MS(t.shapeInfo.logicalShape,e.logicalShape),l=zS(o),c=o-s;let u;const h=["x","y","z","w","u","v"];u=0===s?"":o<2&&a.length>=1?"coords = 0;":a.map((t=>`coords.${h[t+c]} = 0;`)).join("\n");let p="";p=o<2&&s>0?"coords":t.shapeInfo.logicalShape.map(((t,e)=>`coords.${h[e+c]}`)).join(", ");let f="return outputValue;";const m=1===d(t.shapeInfo.logicalShape),g=d(e.logicalShape),y=1===g;if(1!==s||m||y){if(m&&!y)f=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const t=s-2,e=s-1;a.indexOf(t)>-1&&a.indexOf(e)>-1?f="return vec4(outputValue.x);":a.indexOf(t)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(e)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${r}() {\n      ${l} coords = getOutputCoords();\n      ${u}\n      vec4 outputValue = get${i}(${p});\n      ${f}\n    }\n  `}(t,e):function(t,e){const n=t.name,i=n.charAt(0).toUpperCase()+n.slice(1),r="get"+i+"AtOutCoords",s=e.texShape,o=t.shapeInfo.texShape,a=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&a===l&&null==t.shapeInfo.flatOffset&&m(o,s))return`\n      float ${r}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const c=zS(l),u=MS(t.shapeInfo.logicalShape,e.logicalShape),h=l-a;let d;const p=["x","y","z","w","u","v"];d=0===a?"":l<2&&u.length>=1?"coords = 0;":u.map((t=>`coords.${p[t+h]} = 0;`)).join("\n");let f="";f=l<2&&a>0?"coords":t.shapeInfo.logicalShape.map(((t,e)=>`coords.${p[e+h]}`)).join(", ");return`\n    float ${r}() {\n      ${c} coords = getOutputCoords();\n      ${d}\n      return get${i}(${f});\n    }\n  `}(t,e));return r}(t,e,n.packedInputs,n.enableShapeUniforms))).join("\n"),o=e.texShape,a=SS(),l=function(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let c,u,h=function(t){const e=`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${NS}\n    ${RS}\n    ${PS}\n  `;return e}(a);e.isPacked?(c=function(t,e,n){switch(t.length){case 0:return LS();case 1:return function(t,e,n){const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(1===i[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${i[1]}.0);\n      }\n    `;if(1===i[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${i[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n      return 2 * (resTexRC.x * ${i[1]} + resTexRC.y);\n    }\n  `}(0,e,n);case 2:return function(t,e,n){const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(m(t,e))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${i[0]}, ${i[1]}));\n      }\n    `;const r=Math.ceil(t[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n\n      int index = resTexRC.x * ${i[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,e,n);case 3:return function(t,e,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[2]/2),s=r*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n      int index = resTexRC.x * ${i[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,e,n);default:return function(t,e,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),s=r*Math.ceil(t[t.length-2]/2);let o=s,a="",l="b, r, c";for(let e=2;e<t.length-1;e++)o*=t[t.length-e-1],a=`\n      int b${e} = index / ${o};\n      index -= b${e} * ${o};\n    `+a,l=`b${e}, `+l;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n      int index = resTexRC.x * ${i[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${t.length}(${l});\n    }\n  `}(t,e,n)}}(e.logicalShape,o,n.enableShapeUniforms),u=function(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(a)):(c=function(t,e,n){switch(t.length){case 0:return LS();case 1:return function(t,e,n){if(1===e[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${e[1]}.0);\n      }\n    `;if(1===e[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${e[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      return resTexRC.x * ${e[1]} + resTexRC.y;\n    }\n  `}(0,e,n);case 2:return function(t,e,n){if(m(t,e))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `;if(1===t[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===t[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,e,n);case 3:return function(t,e,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${CS(["r","c","d"],t)}\n    return ivec3(r, c, d);\n  }\n`}const i=kS(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${i}\n      return ivec3(r, c, d);\n    }\n  `}(t,e,n);case 4:return function(t,e,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${CS(["r","c","d","d2"],t)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const i=kS(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${i}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,e,n);case 5:return function(t,e){const n=kS(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,e);case 6:return function(t,e){const n=kS(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}(e.logicalShape,o,n.enableShapeUniforms),u=function(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),n.packedInputs&&(h+=OS);return[h,l,u,r,c,s,n.userCode].join("\n")}function IS(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return function(t,e){const n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${i}() {return ${n};}`;const[r,s]=t.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${i}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=DS(n);if(e)return`\n    float ${i}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[a,l]=t.shapeInfo.texShape;return`\n    float ${i}() {\n      vec2 uv = uvFromFlat(${a}, ${l}, ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t,e);case 1:return function(t,e){const n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${i}(int index) {\n        ${FS(t)}\n      }\n    `;const r=t.shapeInfo.texShape,s=r[0],o=r[1];if(1===o&&1===s)return`\n      float ${i}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const a=DS(n);if(1===o)return e?`\n      float ${i}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${i}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===s)return e?`\n      float ${i}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${i}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(e)return`\n    float ${i}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${a});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${i}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${a});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t,e);case 2:return function(t,e){const n=t.shapeInfo.logicalShape,i=t.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=t.shapeInfo.texShape;if(null!=s&&m(n,s)){if(e)return`\n      float ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `;const t=s[0];return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${t}.0);\n      return sampleTexture(${i}, uv);\n    }\n  `}const{newShape:o,keptDims:a}=S(n),l=o;if(l.length<n.length){const n=["row","col"];return`\n      ${IS(US(t,l),e)}\n      float ${r}(int row, int col) {\n        return ${r}(${VS(n,a)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${FS(t)}\n      }\n    `;const c=s[0],u=s[1],h=DS(i);if(1===u)return e?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${i}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${i}TexShape[0]));\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${i}, uv);\n    }\n  `;if(1===c)return e?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${i}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${i}TexShape[1]), 0.5);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${i}, uv);\n    }\n  `;if(e)return`\n      float ${r}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index);\n        return sampleTexture(${i}, uv);\n      }\n    `;return`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${c}, ${u}, index);\n    return sampleTexture(${i}, uv);\n  }\n`}(t,e);case 3:return function(t,e){const n=t.shapeInfo.logicalShape,i=t.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=n[1]*n[2],o=n[2],{newShape:a,keptDims:l}=S(n),c=a;if(c.length<n.length){const n=["row","col","depth"];return`\n        ${IS(US(t,c),e)}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${VS(n,l)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${FS(t)}\n      }\n    `;const u=t.shapeInfo.texShape,h=u[0],d=u[1],p=t.shapeInfo.flatOffset;if(d===s&&null==p)return e?`\n      float ${r}(int row, int col, int depth) {\n        int stride1 = ${i}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${i}, uv);\n        }\n      `;if(d===o&&null==p)return e?`\n      float ${r}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${i}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${i}, uv);\n    }\n  `;const f=DS(i);if(e)return`\n    float ${r}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${i}Shape[1] * ${i}Shape[2];\n      int stride1 = ${i}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index);\n      return sampleTexture(${i}, uv);\n    }\n    `;return`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${f};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${i}, uv);\n      }\n  `}(t,e);case 4:return function(t,e){const n=t.shapeInfo.logicalShape,i=t.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=n[3],o=n[2]*s,a=n[1]*o,{newShape:l,keptDims:c}=S(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${IS(US(t,l),e)}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${VS(n,c)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${o}, ${s}, 1)));\n        ${FS(t)}\n      }\n    `;const u=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${i}Shape[3];`,m=`int stride1 = ${i}Shape[2] * stride2;`,g=`int stride0 = ${i}Shape[1] * stride1;`;if(p===a&&null==u)return e?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${i}, uv);\n      }\n    `;if(p===s&&null==u)return e?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${i}Shape[1] * ${i}Shape[2], ${i}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${i}, uv);\n      }\n    `;const y=DS(i);if(e)return`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index + ${y});\n      return sampleTexture(${i}, uv);\n    }\n  `;return`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${y});\n      return sampleTexture(${i}, uv);\n    }\n  `}(t,e);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e[4],s=e[3]*r,o=e[2]*s,a=e[1]*o,{newShape:l,keptDims:c}=S(e);if(l.length<e.length){const e=["row","col","depth","depth2","depth3"];return`\n      ${IS(US(t,l))}\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        return ${i}(${VS(e,c)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${o}, ${s}, ${r})) +\n          depth3;\n        ${FS(t)}\n      }\n    `;const u=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1];if(p===a&&null==u)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${s}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===r&&null==u)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]},\n               ${e[2]*e[3]}, ${e[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=DS(n);return`\n    float ${i}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} + depth * ${s} +\n          depth2 * ${r} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:s}=S(e);if(r.length<e.length){const e=["row","col","depth","depth2","depth3","depth4"];return`\n      ${IS(US(t,r))}\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${i}(${VS(e,s)});\n      }\n    `}const o=e[5],a=e[4]*o,l=e[3]*a,c=e[2]*l,u=e[1]*c;if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${c}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${FS(t)}\n      }\n    `;const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&null==h)return`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${l}, ${a}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===o&&null==h)return`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]*e[4]},\n               ${e[2]*e[3]*e[4]},\n               ${e[3]*e[4]},\n               ${e[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const m=DS(n);return`\n    float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${c} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${o} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function AS(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),i=SS();return`\n    vec4 ${n}() {\n      return ${i.texture2D}(${e}, halfCR);\n    }\n  `}(t);case 1:return function(t,e){const n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,s=SS();if(e)return`\n    vec4 ${i}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${i}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(t,e);case 2:return function(t,e){const n=t.shapeInfo.logicalShape,i=t.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=t.shapeInfo.texShape,o=s[0],a=s[1],l=SS();if(null!=s&&m(n,s))return e?`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);\n\n        return ${l.texture2D}(${i}, uv);\n      }\n    `:`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);\n\n        return ${l.texture2D}(${i}, uv);\n      }\n    `;if(e)return`\n    vec4 ${r}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${i}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${i}, uv);\n    }\n  `;const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(n[1]/2);return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);\n      return ${l.texture2D}(${i}, uv);\n    }\n  `}(t,e);case 3:return function(t,e){const n=t.shapeInfo.logicalShape,i=t.name,r="get"+i.charAt(0).toUpperCase()+i.slice(1),s=t.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const i=[1,2],s=["b","row","col"];return`\n        ${AS(US(t,n.slice(1)),e)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${VS(s,i)});\n        }\n      `}const a=SS();if(e)return`\n    vec4 ${r}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${i}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${i}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${i}, uv);\n    }\n  `;const l=o[0],c=o[1],u=Math.ceil(n[2]/2),h=u*Math.ceil(n[1]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${c}, ${h}, ${u}, b, row, col);\n      return ${a.texture2D}(${i}, uv);\n    }\n  `}(t,e);default:return function(t,e){const n=t.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=SS();if(e)return`\n    vec4 ${i}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);\n    }\n  `;const s=t.shapeInfo.logicalShape,o=s.length,a=t.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],h=Math.ceil(s[o-1]/2);let d=h*Math.ceil(s[o-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let t=2;t<o-1;t++)p=`int b${t}, `+p,d*=s[o-t-1],f=`b${t} * ${d} + `+f;return`\n    vec4 ${i}(${p}) {\n      int index = ${f};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});\n      return ${r.texture2D}(${n}, uv);\n    }\n  `}(t,e)}}const NS="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",RS="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",PS="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",OS="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function LS(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function DS(t){return`offset${t}`}function FS(t){const e=t.name,n=d(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${e}[i];\n      }\n    }\n  `}function zS(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function BS(t,e,n){const{newShape:i,keptDims:r}=S(e),s=e.length,o=t&&3===s&&1===e[0],a=o?e.slice(1):i,l=!t&&s>1&&!m(e,n)&&i.length<s||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:r}}function US(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function VS(t,e){return e.map((e=>t[e])).join(", ")}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WS(t,e,n,i){const r=n.map(((t,n)=>{const i={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(i.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:i}})),s=r.map((t=>t.shapeInfo)),o={logicalShape:i.shape,texShape:i.texData.texShape,isUniform:!1,isPacked:i.texData.isPacked,flatOffset:null},a=$S(r,o,e),l=function(t,e){const n=lS(t,(()=>t.createShader(t.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(Zw(t,(()=>t.shaderSource(n,e))),Zw(t,(()=>t.compileShader(n))),Y().get("ENGINE_COMPILE_ONLY"))return n;if(!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw eS(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(t.gl,a),c=t.createProgram(l);return Y().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(c),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:o},HS(t,e,c)))}function HS(t,e,n){const i=[],r=[];let s,o,a,l=null,c=null;c=t.getUniformLocation(n,"NAN",!1),1===Y().getNumber("WEBGL_VERSION")&&(l=t.getUniformLocation(n,"INFINITY",!1));const u=!1;for(const r of e.variableNames){const s={name:r,uniform:t.getUniformLocation(n,r,u),offset:t.getUniformLocation(n,`offset${r}`,u)};e.enableShapeUniforms&&(s.shape=t.getUniformLocation(n,`${r}Shape`,u),s.texShape=t.getUniformLocation(n,`${r}TexShape`,u)),i.push(s)}if(e.enableShapeUniforms&&(s=t.getUniformLocation(n,"outShape",u),a=t.getUniformLocation(n,"outShapeStrides",u),o=t.getUniformLocation(n,"outTexShape",u)),e.customUniforms)for(const i of e.customUniforms)r.push(t.getUniformLocation(n,i.name,u));return{variablesLocations:i,customUniformLocations:r,infLoc:l,nanLoc:c,outShapeLocation:s,outShapeStridesLocation:a,outTexShapeLocation:o}}function jS(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach(((t,n)=>{const i=t.logicalShape,r=e[n],s=r.shape;if(!m(i,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${s} must match`);if(t.isUniform&&r.isUniform)return;const o=t.texShape,a=r.isUniform?null:r.texData.texShape;if(!m(o,a))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${a} must match`)}))}function GS(t){return Y().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qS{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Hw.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=SS();this.outputShape=t,this.enableShapeUniforms=GS(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?CS(["r","c","d"],t):kS(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XS{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Hw.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=SS();this.outputShape=t,this.enableShapeUniforms=GS(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?CS(["r","c","d"],t):kS(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KS{constructor(t){this.variableNames=["A"],this.outTexUsage=jw.DOWNLOAD;const e=SS();this.outputShape=t,this.userCode=`\n      ${ES}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YS{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=jw.DOWNLOAD;const e=SS();this.outputShape=t,this.userCode=`\n      ${ES}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZS={R:0,G:1,B:2,A:3};class JS{constructor(t,e=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=SS();this.outputShape=t,this.enableShapeUniforms=GS(this.outputShape.length);let r="result";e&&(r="floor(result * 255. + 0.5)");let s="";for(let t=0;t<n.length;t++){const e=n[t];s+=`\n          if(offset == ${t}) {\n            result = values[${ZS[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":_S(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${i.texture2D}(A, uv);\n          ${s}\n        }\n        ${i.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QS{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=SS();this.outputShape=t,this.enableShapeUniforms=GS(this.outputShape.length);let i="",r="result";e&&(r="floor(result * 255. + 0.5)");for(let e=0;e<=1;e++)for(let r=0;r<=1;r++){const s=2*e+r;i+=`\n          localCoords = coords;\n          if(localCoords[2] + ${r} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${r};\n          if (localCoords[1] + ${e} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${e};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${s}] = values[0];\n            } else if (offset == 1) {\n              result[${s}] = values[1];\n            } else if (offset == 2) {\n              result[${s}] = values[2];\n            } else {\n              result[${s}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":_S(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${i}\n\n          ${n.output} = ${r};\n        }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tk(t){const e=SS();return function(t,e){const n=lS(t,(()=>t.createShader(t.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(Zw(t,(()=>t.shaderSource(n,e))),Zw(t,(()=>t.compileShader(n))),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,`${e.version}\n    precision highp float;\n    ${e.attribute} vec3 clipSpacePos;\n    ${e.attribute} vec2 uv;\n    ${e.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function ek(t){return function(t,e){const n=lS(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return Zw(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),Zw(t,(()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW))),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function nk(t){return function(t,e){const n=lS(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return Zw(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n))),Zw(t,(()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW))),n}(t,new Uint16Array([0,1,2,2,1,3]))}function ik(t,e,n,i,r,s){!function(t,e){const n=Y().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0)throw new Error(`Requested texture size [${t}x${e}] is invalid.`);if(t>n||e>n)throw new Error(`Requested texture size [${t}x${e}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(e,n);const o=function(t){return lS(t,(()=>t.createTexture()),"Unable to create WebGLTexture.")}(t),a=t.TEXTURE_2D;return Zw(t,(()=>t.bindTexture(a,o))),Zw(t,(()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE))),Zw(t,(()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE))),Zw(t,(()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST))),Zw(t,(()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST))),1===Y().getNumber("WEBGL_VERSION")?Zw(t,(()=>t.texImage2D(a,0,i,e,n,0,r,s,null))):Zw(t,(()=>t.texStorage2D(a,1,i,e,n))),Zw(t,(()=>t.bindTexture(t.TEXTURE_2D,null))),{texture:o,texShape:[n,e]}}function rk(t){return t.internalFormatFloat}function sk(t){return t.internalFormatHalfFloat}function ok(t){return t.downloadTextureFormat}function ak(t){return t.internalFormatPackedFloat}function lk(t){return t.internalFormatPackedHalfFloat}function ck(t,e,n,i,r,s,o,a){const l=t,c=new Float32Array(function(t,e){const[n,i]=Kw(t,e);return n*i*4}(s,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class uk{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=Y().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function(t,e){Uw[t]=e}(e,t)):this.gl=Ww(e),t=this.gl,2===Y().getNumber("WEBGL_VERSION")){const e=t;this.createVertexArray=()=>Zw(e,(()=>e.createVertexArray())),this.bindVertexArray=t=>Zw(e,(()=>e.bindVertexArray(t))),this.deleteVertexArray=t=>Zw(e,(()=>e.deleteVertexArray(t))),this.getVertexArray=()=>Zw(e,(()=>e.getParameter(e.VERTEX_ARRAY_BINDING)))}else if(null!=t){const e=t.getExtension("OES_vertex_array_object");if(null==e)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Zw(t,(()=>e.createVertexArrayOES())),this.bindVertexArray=n=>Zw(t,(()=>e.bindVertexArrayOES(n))),this.deleteVertexArray=n=>Zw(t,(()=>e.deleteVertexArrayOES(n))),this.getVertexArray=()=>Zw(t,(()=>t.getParameter(e.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Y().getNumber("WEBGL_VERSION")){const t="OES_texture_float",e="OES_texture_half_float";if(this.textureFloatExtension=Qw(this.gl,t),gS(this.gl,e))this.textureHalfFloatExtension=Qw(this.gl,e);else if(Y().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),gS(this.gl,i))this.colorBufferHalfFloatExtension=Qw(this.gl,i);else if(Y().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",gS(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!gS(this.gl,i))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(i)}this.vertexBuffer=ek(this.gl),this.indexBuffer=nk(this.gl),this.framebuffer=function(t){return lS(t,(()=>t.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=Yw(this.gl,this.textureHalfFloatExtension)}get debug(){return Y().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;Zw(t,(()=>t.finish())),Zw(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,null))),Zw(t,(()=>t.deleteFramebuffer(this.framebuffer))),Zw(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,null))),Zw(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null))),Zw(t,(()=>t.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,i){const[r,s]=qw(e,n);return ik(t,r,s,rk(i),i.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,i){const[r,s]=qw(e,n);return ik(t,r,s,sk(i),i.textureFormatFloat,i.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,i){const[r,s]=qw(e,n);return ik(t,r,s,ok(i),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){Zw(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),n.data instanceof Uint8Array?2===Y().getNumber("WEBGL_VERSION")?Zw(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data))):Zw(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data))):2===Y().getNumber("WEBGL_VERSION")?Zw(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n))):Zw(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n))),Zw(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,i){this.throwIfDisposed(),function(t,e,n,i,r,s){let o,a,l;Zw(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),r instanceof Uint8Array?(o=new Uint8Array(n*i*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(o=new Float32Array(n*i*4),a=t.FLOAT,l=s.internalFormatPackedFloat),o.set(r),2===Y().getNumber("WEBGL_VERSION")?Zw(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,i,t.RGBA,a,o))):Zw(t,(()=>t.texImage2D(t.TEXTURE_2D,0,l,n,i,0,t.RGBA,a,o))),Zw(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e,n,i,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,i){const[r,s]=Kw(e,n);return ik(t,r,s,lk(i),t.RGBA,i.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,i){const[r,s]=Kw(e,n);return ik(t,r,s,ak(i),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(oS(this.gl,this.framebuffer),this.outputTexture=null),Zw(this.gl,(()=>this.gl.deleteTexture(t)))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n,i){const[r,s]=qw(e,n),o=new Uint8Array(e*n*4);return Zw(t,(()=>t.readPixels(0,0,r,s,i.downloadTextureFormat,t.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}(this.gl,e,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(t,e,n,i,r,s){return ck(this.gl,t,0,0,0,r,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const i=t,r=new Float32Array(n);return i.bindBuffer(i.PIXEL_PACK_BUFFER,e),i.getBufferSubData(i.PIXEL_PACK_BUFFER,0,r),i.bindBuffer(i.PIXEL_PACK_BUFFER,null),r}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const i=function(t,e,n,i){const r=t.createBuffer();Zw(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,r)));const s=16*e*n;return Zw(t,(()=>t.bufferData(t.PIXEL_PACK_BUFFER,s,t.STREAM_READ))),Zw(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0))),Zw(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null))),r}(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(Y().getBool("WEBGL_FENCE_API_ENABLED")){const i=t,r=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=i.clientWaitSync(r,0,0);return t===i.ALREADY_SIGNALED||t===i.CONDITION_SATISFIED},e=r}else Y().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,Y().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n){const i=new Float32Array(e*n*4);return Zw(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,i))),i}(this.gl,e,n)))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=tk(e));const n=function(t){return lS(t,(()=>t.createProgram()),"Unable to create WebGLProgram.")}(e);Zw(e,(()=>e.attachShader(n,this.vertexShader))),Zw(e,(()=>e.attachShader(n,t))),function(t,e){if(Zw(t,(()=>t.linkProgram(e))),!Y().get("ENGINE_COMPILE_ONLY")&&!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,n);const i=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&nS(e,i),i}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;Zw(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(t,e,n){Zw(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),iS(t,e,"clipSpacePos",n,3,20,0)&&iS(t,e,"uv",n,2,20,12)}(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(Zw(this.gl,(()=>this.gl.deleteProgram(t))),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&nS(this.gl,this.program),Zw(this.gl,(()=>this.gl.useProgram(t)))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?function(t,e,n){return lS(t,(()=>t.getUniformLocation(e,n)),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),Zw(this.gl,(()=>this.gl.getAttribLocation(t,e)))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(t,e,n,i){Zw(t,(()=>rS(t,e,i))),Zw(t,(()=>t.uniform1i(n,i)))}(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[i,r]=Kw(e,n);this.setOutputMatrixTextureDriver(t,i,r)}setOutputMatrixWriteRegion(t,e,n,i){this.setOutputMatrixWriteRegionDriver(n,t,i,e)}setOutputPackedMatrixWriteRegion(t,e,n,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&nS(this.gl,this.program),aS(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Zw(t,(()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Zw(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Qw(this.gl,2===Y().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Y().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Y().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await v((()=>this.disposed||this.isQueryAvailable(t,Y().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(t,Y().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),i=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),i&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise((e=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>e()))}))}pollItems(){const t=function(t){let e=0;for(;e<t.length;++e){if(!t[e]())break}return e-1}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(this.itemsToPoll.map((t=>t.isDoneFn)));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Y().platform&&(n=Y().platform.setTimeoutCustom.bind(Y().platform)),v((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),sS(this.gl,t,this.framebuffer),this.debug&&aS(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(sS(this.gl,this.outputTexture,this.framebuffer),this.debug&&aS(this.gl)):oS(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const i=this.gl;sS(i,t,this.framebuffer),this.debug&&aS(i),this.outputTexture=t,Zw(i,(()=>i.viewport(0,0,e,n))),Zw(i,(()=>i.scissor(0,0,e,n)))}setOutputMatrixWriteRegionDriver(t,e,n,i){this.throwIfDisposed(),Zw(this.gl,(()=>this.gl.scissor(t,e,n,i)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:hk,bincountImpl:dk,bincountReduceImpl:pk,bitwiseAndImpl:fk,castImpl:mk,ceilImpl:gk,concatImpl:yk,equalImpl:bk,expImpl:vk,expm1Impl:xk,floorImpl:wk,gatherNdImpl:Sk,gatherV2Impl:kk,greaterImpl:Ck,greaterEqualImpl:Tk,lessImpl:_k,lessEqualImpl:Ek,linSpaceImpl:Mk,logImpl:$k,maxImpl:Ik,maximumImpl:Ak,minimumImpl:Nk,multiplyImpl:Rk,negImpl:Pk,notEqualImpl:Ok,prodImpl:Lk,raggedGatherImpl:Dk,raggedRangeImpl:Fk,raggedTensorToTensorImpl:zk,rangeImpl:Bk,rsqrtImpl:Uk,scatterImpl:Vk,sigmoidImpl:Wk,simpleAbsImpl:Hk,sliceImpl:jk,sparseFillEmptyRowsImpl:Gk,sparseReshapeImpl:qk,sparseSegmentReductionImpl:Xk,sqrtImpl:Kk,staticRegexReplaceImpl:Yk,stridedSliceImpl:Zk,stringNGramsImpl:Jk,stringSplitImpl:Qk,stringToHashBucketFastImpl:tC,subImpl:eC,tileImpl:nC,topKImpl:iC,transposeImpl:rC,uniqueImpl:sC}=Wy;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oC(t,e){return["x","y","z","w","u","v"].slice(0,e).map((e=>`${t}.${e}`))}function aC(t,e){return 1===e?[t]:oC(t,e)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class lC{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=GS(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const t=aC("rc",this.rank),e=zS(this.rank),n=this.getOutOfBoundsCondition(t),i=this.getSetup(t),r=this.getOutput(t);this.userCode=`\n        void main() {\n          ${e} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${r}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let n=0;n<=1;n++)for(let i=0;i<=1;i++){let r=`${0===n?"r":"rp1"}, ${0===i?"c":"cp1"}`;for(let e=2;e<this.rank;e++)r=`${t[t.length-1-e]},`+r;e.push(r)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let n=this.rank-2;n<this.rank;n++)e+=`${t[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],i=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${i};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cC{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=GS(this.outputShape.length);let n="";for(let t=0;t<4;t++){let e="thisRC = rc;";t%2==1&&(e+="thisRC.z += 1;"),t>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${t>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${t}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${t>0?"}":""}\n      `}var i,r;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */this.userCode=`\n      ${i=e,r=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${r?TS(["r","c","d"],"inputShape"):kS(["r","c","d"],i)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":_S(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}function uC(t,e,n,i,r){const s=function(t,e){switch(t){case Gw.PACKED_2X2_FLOAT32:return ak(e);case Gw.PACKED_2X2_FLOAT16:return lk(e);case Gw.UNPACKED_FLOAT32:return rk(e);case Gw.UNPACKED_FLOAT16:return sk(e);case Gw.PACKED_4X1_UNSIGNED_BYTE:return ok(e);default:throw new Error(`Unknown physical texture type ${t}`)}}(e,i);let o;if(r){const[e,n]=Kw(t[0],t[1]);o=e*n}else{const[e,n]=qw(t[0],t[1]);o=e*n}const a=function(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}(n,s);return o*a}function hC(t,e){if(t===jw.UPLOAD)return Gw.PACKED_2X2_FLOAT32;if(t===jw.RENDER||null==t)return function(t){return Y().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?Gw.PACKED_2X2_FLOAT32:Gw.UNPACKED_FLOAT32:t?Gw.PACKED_2X2_FLOAT16:Gw.UNPACKED_FLOAT16}(e);if(t===jw.DOWNLOAD||t===jw.PIXELS)return Gw.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function dC(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pC=class{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=GS(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}};const fC="if (isnan(x)) return x;",mC="return x;",gC="return abs(x);",yC="return (x >= 0.0) ? x : (exp(x) - 1.0);",bC=fC+"\n  return (x < 0.0) ? 0.0 : x;\n",vC=fC+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",xC="return x;",wC="return 1.0 / (1.0 + exp(-1.0 * x));",SC="return x;",kC="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",CC="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",TC="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",_C="return 1.0 / (1.0 + exp(-1.0 * x));";class EC{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=GS(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MC{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=GS(this.outputShape.length);const e=t.length,n=aC("rc",e),i=zS(e),r=function(t,e){if(1===t)return"rc";let n="";for(let i=0;i<t;i++)n+=e[i],i<t-1&&(n+=",");return n}(e,n),s=n.slice(-2),o=e<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${i} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $C=wh,IC={};const AC=Y().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class NC extends n{nextDataId(){return NC.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Y().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(null!=t){if(t instanceof uk)n=t;else{const e=Ww(Y().getNumber("WEBGL_VERSION"),t);n=new uk(e)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const t=Ww(Y().getNumber("WEBGL_VERSION"));n=new uk(t),this.binaryCache=((i=Y().getNumber("WEBGL_VERSION"))in IC||(IC[i]={}),IC[i]),this.gpgpuCreatedLocally=!0}var i;this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new class{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,n){const i=hC(e,n),r=dC(t,i,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const s=uC(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const t=this.freeTextures[r].pop();return this.usedTextures[r].push(t),t}let o;return i===Gw.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):i===Gw.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):i===Gw.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):i===Gw.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):i===Gw.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[r].push(o),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),o}releaseTexture(t,e,n,i){if(null==this.freeTextures)return;const r=hC(n,i),s=dC(e,r,i);s in this.freeTextures||(this.freeTextures[s]=[]);const o=uC(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,i),a=Y().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==a&&this._numBytesAllocated>a?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=o):(this.freeTextures[s].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[s],c=l&&l.indexOf(t);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[c]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}));for(const t in this.usedTextures)this.usedTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}(this.gpgpu),this.numMBBeforeWarning=null==Y().global.screen?1024:Y().global.screen.height*Y().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new e(this,So())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,e,n,i,r,s){const o=this.makeTensorInfo(e,n),a=this.texData.get(o.dataId);a.isPacked=!1,a.texture={texture:t,texShape:[i,r]},a.texShape=[i,r];const l=hS(e),c=new JS(l,!1,s),u=this.runWebGLProgram(c,[o],n,[[i,r]]);return u.shape=e,a.texture=null,this.disposeIntermediateTensorInfo(o),u.dataId}write(t,e,n){if((Y().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Y().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:e,dtype:n,values:t,usage:jw.UPLOAD,refCount:1}),i}refCount(t){if(this.texData.has(t)){return this.texData.get(t).refCount}return 0}incRef(t){this.texData.get(t).refCount++}decRef(t){if(this.texData.has(t)){this.texData.get(t).refCount--}}move(t,e,n,i,r){if(Y().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:i,values:e,usage:jw.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:n,dtype:i,complexTensorInfos:r,slice:s,shape:o,isPacked:a}=e;if(null!=s){let e;e=a?new EC(o,xC):new pC(o,xC);const n=this.runWebGLProgram(e,[{dataId:t,shape:o,dtype:i}],i),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===i)return n;const l=null!=this.activeTimers;let c,u;if(l&&(c=mr()),"complex64"===i){u=Mf(this.readSync(r.real.dataId),this.readSync(r.imag.dataId))}else u=this.getValuesFromTexture(t);return l&&(this.downloadWaitMs+=mr()-c),this.convertAndCacheOnCPU(t,u)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise((t=>e.push(t)))}const e=this.texData.get(t),{values:n,shape:i,slice:r,dtype:s,complexTensorInfos:o,isPacked:a}=e;if(null!=r){let e;e=a?new EC(i,xC):new pC(i,xC);const n=this.runWebGLProgram(e,[{dataId:t,shape:i,dtype:s}],s),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(t);if(Y().getBool("DEBUG")&&!Y().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Y().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,u=null;if("complex64"!==s&&Y().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(t);const e=this.texData.get(l.dataId);u=this.gpgpu.createBufferFromTexture(e.texture.texture,...Xw(i))}if(this.pendingRead.set(t,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const t=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]);c=Mf(t[0],t[1])}else if(null==u)c=this.getValuesFromTexture(t);else{const t=d(i);c=this.gpgpu.downloadFloat32MatrixFromBuffer(u,t)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=u){const t=this.gpgpu.gl;Zw(t,(()=>t.deleteBuffer(u)))}const h=this.convertAndCacheOnCPU(t,c),p=this.pendingRead.get(t);return this.pendingRead.delete(t),p.forEach((t=>t(h))),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&So().removeDataId(t,this),this.pendingDeletes--),h}readToGPU(t,e={}){const n=this.texData.get(t),{values:i,shape:r,slice:s,dtype:o,isPacked:a,texture:l}=n;if("complex64"===o)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=a?new EC(r,xC):new pC(r,xC);const i=this.runWebGLProgram(n,[{dataId:t,shape:r,dtype:o}],o),s=this.readToGPU(i,e);return this.disposeIntermediateTensorInfo(i),s}if(null==l)throw null!=i?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(t,e.customTexShape),u=So().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:u},h.texture)}bufferSync(t){const e=this.readSync(t.dataId);if("string"===t.dtype)try{const n=e.map((t=>yr(t)));return bo(t.shape,t.dtype,n)}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}return bo(t.shape,t.dtype,e)}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!Jw(n)){if(Y().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:i}=this.texData.get(t),r=d(e);if(Y().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),i=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(i.texture.texture,...Xw(e)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),s}const s=Y().getBool("WEBGL_PACK")&&!0===i,o=s?hS(e):e,a=s?new YS(o):new KS(o),l=this.runWebGLProgram(a,[{shape:o,dtype:n,dataId:t}],"float32"),c=this.texData.get(l.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(l),u}timerAvailable(){return Y().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,n=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=n,i=!0):this.activeTimers.push(n),this.activeTimers=n,t();const r=vr(this.activeTimers.map((t=>t.query))).filter((t=>null!=t)),s=vr(this.activeTimers.map((t=>t.name))).filter((t=>null!=t));this.activeTimers=e,i&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Y().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(r);o.kernelMs=l(t),o.getExtraProfileInfo=()=>t.map(((t,e)=>({name:s[e],ms:t}))).map((t=>`${t.name}: ${t.ms}`)).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Y().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:mr(),endMs:null}}endTimer(t){return Y().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=mr(),t)}async getQueryTime(t){if(Y().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:n}=this.texData.get(t);return null!=n&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:n,texShape:i,usage:r,isPacked:s,slice:o}=this.texData.get(t),a=o&&o.origDataId||t,l=this.dataRefCount.get(a);l>1?this.dataRefCount.set(a,l-1):(this.dataRefCount.delete(a),null!=e&&(this.numBytesInGPU-=this.computeBytes(i,n),this.textureManager.releaseTexture(e,i,r,s)));const c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=AC){return Y().getBool("WEBGL_CPU_FORWARD")&&t.every((t=>null==this.texData.get(t.dataId).texture&&d(t.shape)<e))}getGPGPUContext(){return this.gpgpu}where(t){mi("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return $C(t.shape,e)}packedUnaryOp(t,e,n){const i=new EC(t.shape,e),r=this.compileAndRun(i,[t],n);return So().makeTensorFromTensorInfo(r)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=Hk(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if(Y().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,gC,t.dtype);const e=new pC(t.shape,gC),n=this.compileAndRun(e,[t]);return So().makeTensorFromTensorInfo(n)}makeTensorInfo(t,e,n){let i;if("string"===e&&null!=n&&n.length>0&&I(n[0])){const r=n.map((t=>gr(t)));i=this.write(r,t,e)}else i=this.write(n,t,e);return this.texData.get(i).usage=null,{dataId:i,shape:t,dtype:e}}makeOutput(t,e,n){return So().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,n),this)}unpackTensor(t){const e=new MC(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new lC(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[cS(t.shape),...uS(t.shape)],i={dtype:t.dtype,shape:n,dataId:t.dataId},r=[cS(e),...uS(e)],s=new cC(r,n),o=[n],a=this.runWebGLProgram(s,[i],t.dtype,o,!0);return{dataId:a.dataId,shape:e,dtype:a.dtype}}decode(t,e){const n=this.texData.get(t),{isPacked:i,shape:r,dtype:s}=n;if(null!=e){c(d(r)<=e[0]*e[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const o=hS(r);let a;a=i?new XS(o):new qS(o);const l=[null!=e?e:Xw(o)];return{dtype:s,shape:r,dataId:this.runWebGLProgram(a,[{shape:o,dtype:s,dataId:t}],s,l,!0,e).dataId}}runWebGLProgram(t,e,n,i,r=!1,s){const o=this.makeTensorInfo(t.outputShape,n),a=this.texData.get(o.dataId);if(t.packedOutput&&(a.isPacked=!0),t.outPackingScheme===Hw.DENSE){const e=null!=s?s:Xw(t.outputShape);a.texShape=e.map((t=>2*t))}if(null!=t.outTexUsage&&(a.usage=t.outTexUsage),0===d(o.shape))return a.values=k(o.dtype,0),o;const l=[],c=e.map((e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&d(e.shape)<=Y().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}if(this.uploadToGPU(e.dataId),!!n.isPacked!=!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),l.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!pS(n.shape,e.shape)){const t=e,i=e.shape;e.shape=n.shape,e=this.packedReshape(e,i),l.push(e),n=this.texData.get(e.dataId),t.shape=i}return{shape:e.shape,texData:n,isUniform:!1}}));this.uploadToGPU(o.dataId);const u={shape:o.shape,texData:a,isUniform:!1},h=function(t,e,n){let i="";e.concat(n).forEach((e=>{const r=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!e.isUniform){const s=e.texData.texShape,{useSqueezeShape:o,uniformShape:a,keptDims:l}=BS(t.packedInputs,e.shape,s);let c="",u="",h="";if(1===a.length&&t.packedInputs){const t=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];c=`${t[0]>1}_${t[1]>1}`}else if(2!==a.length||t.packedInputs){if(a.length>2&&!t.packedInputs){const t=L(a);h=`${t[0]===s[1]}_${t[t.length-1]===s[1]}`}}else u=`${a[0]>1}_${a[1]>1}`;const p=e.shape.length,f=2===a.length&&m(e.shape,s),g=1===d(e.shape),y=Ya(e.shape,n.shape),b=!t.packedInputs&&p===n.shape.length&&m(s,n.texData.texShape),v=t.packedInputs||a.length>2?"":`${s[0]>1}_${s[1]>1}`;i+=`${p}_${b}_${o?l:""}_${a.length}_${g}_${y}_${f}_${c}_${u}_${h}_${v}_${r}`}else{const t=e.isUniform?"uniform":e.texData.texShape;i+=`${e.shape}_${t}_${r}`}}));const r=t.userCode;let s=t.constructor.name;return s+="_"+i+"_"+r+`${Y().getNumber("WEBGL_VERSION")}`,s}(t,c,u),p=this.getAndSaveBinary(h,(()=>WS(this.gpgpu,t,c,u))),f=null!=this.activeTimers;let g;f&&(g=this.startTimer()),Y().get("ENGINE_COMPILE_ONLY")||function(t,e,n,i,r){e.program.enableShapeUniforms||(jS(e.inShapeInfos,n),jS([e.outShapeInfo],[i]));const s=i.texData.texture,o=i.texData.texShape;i.texData.isPacked?t.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):t.setOutputMatrixTexture(s.texture,o[0],o[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),1===Y().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN);for(let i=0;i<n.length;++i){const r=n[i],{uniform:s,offset:o,shape:a,texShape:l}=e.variablesLocations[i];if(a){const{uniformShape:n}=BS(e.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:t.gl.uniform1iv(a,new Int32Array(n));break;case 2:t.gl.uniform2iv(a,new Int32Array(n));break;case 3:t.gl.uniform3iv(a,new Int32Array(n));break;case 4:t.gl.uniform4iv(a,new Int32Array(n))}}if(l&&t.gl.uniform2i(l,r.texData.texShape[0],r.texData.texShape[1]),null!=s)if(r.isUniform)if(d(r.shape)<2)t.gl.uniform1f(s,r.uniformValues[0]);else{let e=r.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(s,e)}else null!=r.texData.slice&&null!=o&&t.gl.uniform1i(o,r.texData.slice.flatOffset),t.setInputMatrixTexture(r.texData.texture.texture,s,i)}const a=e.outShapeLocation;if(a)switch(i.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(i.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(i.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(i.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(i.shape))}if(e.outShapeStridesLocation){const n=L(i.shape);switch(i.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(n));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(n));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(n))}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,i.texData.texShape[0],i.texData.texShape[1]),e.program.customUniforms&&r)for(let n=0;n<e.program.customUniforms.length;++n){const i=e.program.customUniforms[n],s=e.customUniformLocations[n],o=r[n];if("float"===i.type)t.gl.uniform1fv(s,o);else if("vec2"===i.type)t.gl.uniform2fv(s,o);else if("vec3"===i.type)t.gl.uniform3fv(s,o);else if("vec4"===i.type)t.gl.uniform4fv(s,o);else if("int"===i.type)t.gl.uniform1iv(s,o);else if("ivec2"===i.type)t.gl.uniform2iv(s,o);else if("ivec3"===i.type)t.gl.uniform3iv(s,o);else{if("ivec4"!==i.type)throw Error(`uniform type ${i.type} is not supported yet.`);t.gl.uniform4iv(s,o)}}t.executeProgram()}(this.gpgpu,p,c,u,i),l.forEach((t=>this.disposeIntermediateTensorInfo(t))),f&&(g=this.endTimer(g),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(g)}));const y=Y().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){const t=mr();t-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=t)}if(!Y().getBool("WEBGL_LAZILY_UNPACK")&&a.isPacked&&!1===r){const t=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),t}return o}compileAndRun(t,e,n,i,r=!1){n=n||e[0].dtype;return this.runWebGLProgram(t,e,n,i,r)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Y().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Co((()=>{if(!Y().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Y().getBool("DEBUG");Y().set("DEBUG",!1);const e=this.abs(xl(1e-8)).dataSync()[0];if(Y().set("DEBUG",t),e>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:i,values:r,texture:s,usage:a,isPacked:l}=e;if(null!=s)return;const c=null!=this.activeTimers;let u;c&&(u=mr());let h=e.texShape;if(null==h&&(h=function(t,e=!1){let n=Y().getNumber("WEBGL_MAX_TEXTURE_SIZE"),i=Y().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(i===1/0&&Y().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(i=n/2),e&&(n*=2,i*=2,t=t.map(((e,n)=>n>=t.length-2?o(t[n]):t[n])),1===t.length&&(t=[2,t[0]])),2!==t.length){const e=S(t);t=e.newShape}let r=d(t),s=null;t.length<=1&&r<=n?s=[1,r]:2===t.length&&t[0]<=n&&t[1]<=n?s=t:3===t.length&&t[0]*t[1]<=n&&t[2]<=n?s=[t[0]*t[1],t[2]]:3===t.length&&t[0]<=n&&t[1]*t[2]<=n?s=[t[0],t[1]*t[2]]:4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n?s=[t[0]*t[1]*t[2],t[3]]:4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(s=[t[0],t[1]*t[2]*t[3]]);const a=null!=s&&Math.max(...s)>i&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(null==s||a)if(e){const e=cS(t);let n=2,i=2;t.length&&([n,i]=uS(t)),r=e*(n/2)*(i/2),s=y(r).map((t=>2*t))}else s=y(r);return s}(n,l),e.texShape=h),null!=r){const t=hS(n);let s,o=h[1],a=h[0];const d=r instanceof Uint8Array||r instanceof Uint8ClampedArray;!l&&d||([o,a]=Kw(h[0],h[1])),s=l?new QS(t,d):new JS(t,d);const p=d?[a,o]:h,f=this.makeTensorInfo(p,i),m=this.texData.get(f.dataId);m.usage=d?jw.PIXELS:jw.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),o,a,r);const g=[[a,o]],y=!0,b=this.runWebGLProgram(s,[f],i,g,y),v=this.texData.get(b.dataId);e.texShape=v.texShape,e.isPacked=v.isPacked,e.usage=v.usage,Y().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(e.texture=v.texture,e.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),c&&(this.uploadWaitMs+=mr()-u)}else{const t=this.acquireTexture(h,a,i,l);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:i}=n;return null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error(`Unknown dtype ${e}`)}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(e,i)),n.values}acquireTexture(t,e,n,i){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${t} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,i)}computeBytes(t,e){return t[0]*t[1]*M(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}for(const[,e]of Object.entries(this.binaryCache)){const n=new Promise((t=>{try{this.checkCompletion_(e),t(!0)}catch(t){throw t}}));t.push(n)}return Promise.all(t)}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await rf(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(!1===this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw eS(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:e,customUniformLocations:n,infLoc:i,nanLoc:r,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:a}=HS(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=e,t.customUniformLocations=n,t.infLoc=i,t.nanLoc=r,t.outShapeLocation=s,t.outShapeStridesLocation=o,t.outTexShapeLocation=a}}createTensorFromGPUData(t,e,n){t.channels=t.channels||"RGBA";const{texture:i,height:r,width:s,channels:o}=t,a=So().backend;if(!a.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=a.writeTexture(i,e,n,r,s,o);return So().makeTensorFromDataId(l,e,n,a)}}NC.nextDataId=0,ls()&&$o("webgl",(()=>new NC),2)
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */;const RC="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";let PC=class{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=Ja(e,n),this.enableShapeUniforms=GS(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OC="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class LC{constructor(t,e,n,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ja(e,n);const r=this.outputShape.length;this.enableShapeUniforms=GS(r);let s="";if(i)if(0===r||1===d(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(s=`\n          ${zS(r)} coords = getOutputCoords();\n        `,1===r)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=aC("coords",r);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${t[r-2]} + 1) >= outShape[${r} - 2];\n            bool nextColOutOfBounds =\n              (${t[r-1]} + 1) >= outShape[${r} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${t[r-2]} + 1) >= ${this.outputShape[r-2]};\n            bool nextColOutOfBounds =\n              (${t[r-1]} + 1) >= ${this.outputShape[r-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DC(t){const{inputs:e,backend:n}=t,{x:i}=e;return n.incRef(i.dataId),{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}const FC={kernelName:ye,backendName:"webgl",kernelFunc:DC};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zC(t){const{inputs:e,backend:n}=t,{real:i,imag:r}=e,s=n.makeTensorInfo(i.shape,"complex64"),o=n.texData.get(s.dataId),a=DC({inputs:{x:i},backend:n}),l=DC({inputs:{x:r},backend:n});return o.complexTensorInfos={real:a,imag:l},s}const BC={kernelName:Mt,backendName:"webgl",kernelFunc:zC},UC="return (a < 0.) ? b * a : a;",VC="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WC={kernelName:ke,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{alpha:s}=i,o=n.makeTensorInfo([],"float32",pr(s,"float32")),a=Y().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new LC(VC,r.shape,o.shape):new PC(UC,r.shape,o.shape),l=n.runWebGLProgram(a,[r,o],"float32");return n.disposeIntermediateTensorInfo(o),l}},HC="return (a < 0.) ? b * a : a;",jC="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GC={kernelName:on,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:i,alpha:r}=e,s=Y().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new LC(jC,i.shape,r.shape):new PC(HC,i.shape,r.shape);return n.runWebGLProgram(s,[i,r],"float32")}},qC="if (isnan(x)) return x;";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XC({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:i}){return({inputs:r,backend:s})=>{const{x:o}=r,a=s,l=i||o.dtype;if(a.shouldExecuteOnCPU([o])&&null!=n){const t=a.texData.get(o.dataId),e=n(t.values,l);return a.makeTensorInfo(o.shape,l,e)}let c;return c=Y().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=e?new EC(o.shape,e):new pC(o.shape,t),a.runWebGLProgram(c,[o],l)}}function KC({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:i=!1,cpuKernelImpl:r,dtype:s}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(i&&"complex64"===l.dtype){const e=u.texData.get(l.dataId),n=u.texData.get(c.dataId),[i,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,i]=e,r={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:i.dataId,dtype:i.dtype,shape:c.shape},o=new PC(t,l.shape,c.shape);return u.runWebGLProgram(o,[r,s],Hr(n.dtype,i.dtype))})),s=zC({inputs:{real:i,imag:r},backend:u});return u.disposeIntermediateTensorInfo(i),u.disposeIntermediateTensorInfo(r),s}const h=s||Hr(l.dtype,c.dtype);if(("string"===l.dtype||"string"===c.dtype||u.shouldExecuteOnCPU([l,c]))&&null!=r){const t=u.texData.get(l.dataId).values,e=u.texData.get(c.dataId).values,n="string"===l.dtype?cm(t):t,i="string"===l.dtype?cm(e):e,[s,o]=r(l.shape,c.shape,n,i,h),a=u.makeTensorInfo(o,h);return u.texData.get(a.dataId).values=s,a}let d;return d=Y().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=e?new LC(e,l.shape,c.shape,n):new PC(t,l.shape,c.shape),u.runWebGLProgram(d,[l,c],h)}}function YC(t,e=!1){if("linear"===t)return e?SC:mC;if("relu"===t)return e?CC:bC;if("elu"===t)return e?kC:yC;if("relu6"===t)return e?TC:vC;if("prelu"===t)return e?jC:HC;if("leakyrelu"===t)return e?VC:UC;if("sigmoid"===t)return e?_C:wC;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ZC=class{constructor(t,e,n,i=!1,r=!1,s=!1,o=null,a=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=GS(this.outputShape.length);const c=i?t[1]:t[2],u=Math.ceil(c/2),h=i?"i * 2, rc.y":"rc.y, i * 2",d=r?"rc.z, i * 2":"i * 2, rc.z",p=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";o&&(m=a?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,g="result = activation(result);");const y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";t[0]<e[0]?b=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(v=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${u}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${v};\n        for (int i = 0; i < ${u}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JC={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let QC=class{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ja(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tT="return a * b;";function eT(t){const{inputs:e,backend:n}=t,{a:i,b:r}=e,s=Hr(i.dtype,r.dtype);if("complex64"===i.dtype){const t=n.texData.get(i.dataId),e=n.texData.get(r.dataId),s=new QC(JC.REAL,i.shape,r.shape),o=new QC(JC.IMAG,i.shape,r.shape),a=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:i.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape}],l=n.runWebGLProgram(s,a,"float32"),c=n.runWebGLProgram(o,a,"float32"),u=zC({inputs:{real:l,imag:c},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),u}if(n.shouldExecuteOnCPU([i,r])){const t=n.texData.get(i.dataId),e=n.texData.get(r.dataId),[o,a]=Rk(i.shape,r.shape,t.values,e.values,s),l=n.makeTensorInfo(a,s);return n.texData.get(l.dataId).values=o,l}let o;return o=Y().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new LC(tT,i.shape,r.shape):new PC(tT,i.shape,r.shape),n.runWebGLProgram(o,[i,r],s)}const nT={kernelName:Xe,backendName:"webgl",kernelFunc:eT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iT(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{shape:s}=i,o=n,a=d(r.shape),l=x(s,a),u=d(l);c(a===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`));const h=o.texData.get(r.dataId);return!h.isPacked||pS(r.shape,l)||null!==h.texture&&pS(h.shape,l)?(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype}):function(t,e,n){const i=[cS(t.shape),...uS(t.shape)],r={dtype:t.dtype,shape:i,dataId:t.dataId},s=[cS(e),...uS(e)],o=new cC(s,i),a=[i],l=n.runWebGLProgram(o,[r],t.dtype,a,!0);return{dataId:l.dataId,shape:e,dtype:l.dtype}}(r,l,o)}const rT={kernelName:mn,backendName:"webgl",kernelFunc:iT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sT{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:i,inSize:r,outSize:s}=t;this.outputShape=[i,s];const o=4*Math.floor(n/4),a=n%4;let l="sumValue += dot(values, ones);";if(null!=e){const t=1/e;l=`sumValue += dot(values * ${g(t)?t.toPrecision(2):t}, ones);`}let c="";r%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===a}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===a}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===a}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let oT=class{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:i,inSize:r,outSize:s}=t;this.outputShape=[i,s];let o="0.0",a="";"prod"===e?o="1.0":"min"===e?(o="1.0 / 1e-20",a="min"):"max"===e&&(o="-1.0 / 1e-20",a="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const c=4*Math.floor(n/4),u=n%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${a}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${a}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===e?(o="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(o="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";r%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aT(t,e,n,i){const r=function(t){const e=[];for(;0===e.length||1!==e[e.length-1].outSize;){const n=e.length?e[e.length-1].outSize:t[1],i=pf(n);e.push({inSize:n,windowSize:i,outSize:Math.ceil(n/i)})}return e}(t.shape);let s=t;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:l,outSize:c}=r[o];let u,h;u="mean"===n?0===o?new sT({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c},a):new sT({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c}):new oT({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c},n),h=s,s=i.runWebGLProgram(u,[s],e),h.dataId!==t.dataId&&i.disposeIntermediateTensorInfo(h)}return s}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lT=class{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.rank=n.length;const i=zS(this.rank),r=function(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],i=new Array(e);for(let e=0;e<t.length;e++)i[t[e]]=n[e];return i.join()}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(e);this.userCode=`\n    void main() {\n      ${i} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}};class cT{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=zS(this.rank),r=oC("rc",this.rank),s=new Array(this.rank);for(let t=0;t<e.length;t++)s[e[t]]=r[t];const o=`vec2(${s.slice(-2).join()})`,a=`++${r[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${i} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${a}) {\n        result[1] = ${l};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${a}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uT(t,e,n){const i=Y().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cT(t.shape,e):new lT(t.shape,e);return n.runWebGLProgram(i,[t],t.dtype)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hT(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,keepDims:o}=i;return function(t,e,n,i){const r=e,s=t.shape.length,o=w(r,t.shape);let a=o;const l=fl(a,s),c=null!=l;let u=t;c&&(u=uT(t,l,i),a=gl(a.length,s)),pl("sum",a,s);const[h,p]=hl(u.shape,a);let f=h;n&&(f=dl(h,o));const m=d(p),g=iT({inputs:{x:u},attrs:{shape:[d(t.shape)/m,m]},backend:i}),y=aT(g,jr(t.dtype),"sum",i),b=iT({inputs:{x:y},attrs:{shape:f},backend:i});return i.disposeIntermediateTensorInfo(g),i.disposeIntermediateTensorInfo(y),c&&i.disposeIntermediateTensorInfo(u),b}(r,s,o,n)}const dT={kernelName:Ln,backendName:"webgl",kernelFunc:hT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pT(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{perm:s}=i,o=n,a=r.shape.length,l=new Array(a);for(let t=0;t<l.length;t++)l[t]=r.shape[s[t]];let c;if(o.shouldExecuteOnCPU([r])){const t=o.texData.get(r.dataId).values,e=rC(t,r.shape,r.dtype,s,l);c=o.makeTensorInfo(l,r.dtype);o.texData.get(c.dataId).values=e}else c=uT(r,s,o);return c}const fT={kernelName:ri,backendName:"webgl",kernelFunc:pT},mT=1e3;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gT({a:t,b:e,transposeA:n,transposeB:i,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const u=t.shape.length,h=e.shape.length,p=n?t.shape[u-2]:t.shape[u-1],f=i?e.shape[h-1]:e.shape[h-2],m=n?t.shape[u-1]:t.shape[u-2],g=i?e.shape[h-2]:e.shape[h-1],y=t.shape.slice(0,-2),b=e.shape.slice(0,-2),v=d(y),x=d(b),w=Ja(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([m,g]);c(p===f,(()=>`Error in matMul: inner shapes (${p}) and (${f}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${i} must match.`));const S=n?[v,p,m]:[v,m,p],k=i?[x,g,f]:[x,f,g],C=iT({inputs:{x:t},backend:r,attrs:{shape:S}}),T=iT({inputs:{x:e},backend:r,attrs:{shape:k}}),_=[C,T],E=Math.max(v,x),M=n?C.shape[1]:C.shape[2],$=null!=s,I=null!=o,A="leakyrelu"===l,N=null!=l?YC(l,!0):null;let R;if((1===m||1===g)&&M>mT&&!1===($||I||A||null!=N)){let t=C,e=T;n&&(t=pT({inputs:{x:C},backend:r,attrs:{perm:[0,2,1]}}),_.push(t)),i&&(e=pT({inputs:{x:T},backend:r,attrs:{perm:[0,2,1]}}),_.push(e));const s=1===g;let o=t;1!==g&&(o=iT({inputs:{x:t},backend:r,attrs:{shape:[E,M,1]}}),_.push(o));const a=1===g?2:1;let l=e;s&&(l=iT({inputs:{x:e},backend:r,attrs:{shape:[E,1,M]}}),_.push(l));const c=eT({inputs:{a:o,b:l},backend:r});R=hT({inputs:{x:c},backend:r,attrs:{axis:a,keepDims:!0}}),_.push(c)}else{const l=Hr(t.dtype,e.dtype),c=new ZC(S,k,[E,m,g],n,i,$,N,I,A),u=[C,T];if(null!=s&&u.push(s),I&&u.push(o),A){const t=r.makeTensorInfo([],"float32",pr(a,"float32"));u.push(t),_.push(t)}R=r.runWebGLProgram(c,u,l)}const P=iT({inputs:{x:R},backend:r,attrs:{shape:w}});_.push(R);for(const t of _)r.disposeIntermediateTensorInfo(t);return P}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yT={kernelName:di,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{a:r,b:s,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=i;return gT({a:r,b:s,transposeA:l,transposeB:c,backend:n,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}},bT="return abs(x);";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vT={kernelName:et,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:i}=e;if(n.shouldExecuteOnCPU([i])&&"complex64"!==i.dtype){const t=n.texData.get(i.dataId),e=Hk(t.values);return n.makeTensorInfo(i.shape,i.dtype,e)}let r;return r=Y().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new EC(i.shape,bT):new pC(i.shape,bT),n.runWebGLProgram(r,[i],i.dtype)}},xT=XC({opSnippet:fC+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),wT={kernelName:nt,backendName:"webgl",kernelFunc:xT},ST=XC({opSnippet:fC+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),kT={kernelName:it,backendName:"webgl",kernelFunc:ST},CT="return a + b;",TT=KC({opSnippet:CT,packedOpSnippet:CT,supportsComplex:!0,cpuKernelImpl:hk}),_T={kernelName:rt,backendName:"webgl",kernelFunc:TT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ET{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map(((t,e)=>`T${e}`));const n=[];this.variableNames.forEach((t=>{n.push(`float v${t} = get${t}AtOutCoords();`)}));const i=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${i};\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MT={kernelName:st,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function t(e){const{inputs:n,backend:i}=e,r=n;if(1===r.length)return DC({inputs:{x:r[0]},backend:i});if(r.length>Y().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(r.length/2),n=t({inputs:r.slice(0,e),backend:i}),s=t({inputs:r.slice(e),backend:i});return t({inputs:[n,s],backend:i})}const s=r.map((t=>t.dtype)).reduce(((t,e)=>Hr(t,e))),o=r.map((t=>t.shape)),a=Y().getBool("WEBGL_PACK")?new class{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map(((t,e)=>`T${e}`));const n=[];this.variableNames.forEach((t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)}));const i=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${i};\n        setOutput(result);\n      }\n    `}}(r[0].shape,o):new ET(r[0].shape,o);return i.runWebGLProgram(a,r,s)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $T={kernelName:ot,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,keepDims:o}=i,a=r.shape.length,l=w(s,r.shape);let c=l;const u=fl(c,a);let h=r;null!=u&&(h=pT({inputs:{x:r},backend:n,attrs:{perm:u}}),c=gl(c.length,a)),pl("all",c,a);const[p,f]=hl(h.shape,c),m=iT({inputs:{x:h},backend:n,attrs:{shape:[-1,d(f)]}}),g=aT(m,m.dtype,"all",n);let y;if(o){y=iT({inputs:{x:g},backend:n,attrs:{shape:dl(p,l)}})}else y=iT({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),y}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IT={kernelName:at,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,keepDims:o}=i,a=r.shape.length,l=w(s,r.shape);let c=l;const u=fl(c,a);let h=r;null!=u&&(h=pT({inputs:{x:r},backend:n,attrs:{perm:u}}),c=gl(c.length,a)),pl("any",c,a);const[p,f]=hl(h.shape,c),m=iT({inputs:{x:h},backend:n,attrs:{shape:[-1,d(f)]}}),g=aT(m,m.dtype,"any",n);let y;if(o){y=iT({inputs:{x:g},backend:n,attrs:{shape:dl(p,l)}})}else y=iT({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),y}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let AT=class{constructor(t,e,n){this.variableNames=["A"];const{windowSize:i,batchSize:r,outSize:s}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,s];const o="max"===e?">":"<",a=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${i}; i++) {\n          int inIdx = ${a};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${o} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NT{constructor(t,e,n,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,c(t.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const r=t[t.length-1],s=Math.ceil(r/e);this.outputShape=t.slice(0,-1),s>1&&this.outputShape.push(s),i||this.variableNames.push("bestIndicesA");const o=this.outputShape,a=o.length,l=zS(a),u=aC("coords",a);let h,d;if(1===s){d=a+1;const t=zS(d);h=`\n        ${t} sourceLocR = ${t}(${u.join()}, 0);\n        ++${u[a-1]};\n        ${t} sourceLocG = ${t}(${u.join()}, 0);\n        ++${u[a-2]};\n        ${t} sourceLocA = ${t}(${u.join()}, 0);\n        --${u[a-1]};\n        ${t} sourceLocB = ${t}(${u.join()}, 0);\n        --${u[a-2]};`}else d=a,h=`\n        ${l} sourceLocR = coords;\n        ++${u[a-1]};\n        ${l} sourceLocG = coords;\n        ++${u[a-2]};\n        ${l} sourceLocA = coords;\n        --${u[a-1]};\n        ${l} sourceLocB = coords;\n        --${u[a-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),f="."+p[d-1],m=p.map((t=>"int "+t)),g=aC("sourceLocR",d-1).concat("inIdx.r"),y=aC("sourceLocG",d-1).concat("inIdx.g"),b=aC("sourceLocB",d-1).concat("inIdx.b"),v=aC("sourceLocA",d-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",w=i?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,S=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${y.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,k=i?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[a-1]} < ${o[a-1]-1};\n        bool hasNextRow = ${u[a-2]} < ${o[a-2]-1};\n        ${h}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${S};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${S};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RT(t,e,n,i=null){let r=e.shape[0],s=e.shape[1];null!=i&&(r=i.shape[0],s=i.shape[1]);const o=pf(s),a={windowSize:o,inSize:s,batchSize:r,outSize:Math.ceil(s/o)},l=new AT(a,n,null==i),c=[e];null!=i&&c.push(i);const u=t.runWebGLProgram(l,c,"int32");if(1===u.shape[1])return u;const h=RT(t,e,n,u);return t.disposeIntermediateTensorInfo(u),h}function PT(t,e,n,i=null){const r=null!=i?i.shape:e.shape,s=pf(r[r.length-1]),o=new NT(r,s,n,null==i),a=null==i?[e]:[e,i],l=t.runWebGLProgram(o,a,"int32");if(l.shape.length===e.shape.length){const i=PT(t,e,n,l);return t.disposeIntermediateTensorInfo(l),i}return l}function OT(t,e,n,i){const r=[n];if(pl("arg"+i.charAt(0).toUpperCase()+i.slice(1),r,e.shape.length),!Y().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const n=[],s=t.texData.get(e.dataId);let o=e;null!==s&&s.isPacked&&(o=t.unpackTensor(e),n.push(o));const[a,l]=hl(o.shape,r),c=d(l),u=iT({inputs:{x:o},backend:t,attrs:{shape:[-1,c]}});n.push(u);const h=RT(t,u,i);n.push(h);const p=iT({inputs:{x:h},backend:t,attrs:{shape:a}});return n.forEach((e=>t.disposeIntermediateTensorInfo(e))),p}return PT(t,e,i)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LT={kernelName:lt,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s}=i;let o=w(s,r.shape);const a=fl(o,r.shape.length);let l=r;const c=[];null!=a&&(l=pT({inputs:{x:r},backend:n,attrs:{perm:a}}),c.push(l),o=gl(o.length,l.shape.length)),pl("argMax",[o[0]],l.shape.length);const u=OT(n,l,o[0],"max");return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),u}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DT={kernelName:ct,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s}=i;let o=w(s,r.shape);const a=fl(o,r.shape.length);let l=r;const c=[];null!=a&&(l=pT({inputs:{x:r},backend:n,attrs:{perm:a}}),c.push(l),o=gl(o.length,l.shape.length)),pl("argMin",[o[0]],l.shape.length);const u=OT(n,l,o[0],"min");return c.forEach((t=>n.disposeIntermediateTensorInfo(t))),u}},FT=XC({opSnippet:fC+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),zT={kernelName:ut,backendName:"webgl",kernelFunc:FT},BT=XC({opSnippet:fC+"return log(x + sqrt(x * x + 1.0));"}),UT={kernelName:ht,backendName:"webgl",kernelFunc:BT},VT=XC({opSnippet:fC+"\n  return atan(x);\n"}),WT={kernelName:dt,backendName:"webgl",kernelFunc:VT},HT=KC({opSnippet:RC+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+OC+"\n  return result;\n"}),jT={kernelName:ft,backendName:"webgl",kernelFunc:HT},GT=XC({opSnippet:fC+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),qT={kernelName:pt,backendName:"webgl",kernelFunc:GT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let XT=class{constructor(t,e,n,i=!1,r=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,o=t.strideHeight,a=t.strideWidth,l=t.dilationHeight,c=t.dilationWidth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e,m=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,g=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${a});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${u};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${e} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${i?r?m:g:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(b="avgValue / max(count, 1.0)");const v=4*Math.floor(s/4),x=s%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${a});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${u};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${b});\n      }\n    `}},KT=class{constructor(t,e,n,i=!1,r=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,o=t.strideDepth,a=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,u=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;const b="avg"===e;let v="0.0";if(b||(v="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${a}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${u}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${e} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${i?r?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(x="avgValue / max(count, 1.0)");const w=4*Math.floor(s/4),S=s%4,k=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${a}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${k}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${2===S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${3===S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${k}\n            }\n          }\n        }\n        setOutput(${x});\n      }\n    `}};const YT={kernelName:mt,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e;xS(r,"avgPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i;c(sa(o,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const u=Ko(r.shape,s,o,1,a,l);if(1===u.filterWidth&&1===u.filterHeight&&m(u.inShape,u.outShape))return DC({inputs:{x:r},backend:n});const h=new XT(u,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZT={kernelName:yt,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=i,u=Yo(r.shape,s,o,[1,1,1],a,l,c),h=new KT(u,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JT={kernelName:bt,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=i,h=Yo(o.shape,a,l,[1,1,1],c,u),d=new class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,i=t.filterWidth,r=t.strideDepth,s=t.strideHeight,o=t.strideWidth,a=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,u=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=u-1-t.padInfo.front,f=h-1-t.padInfo.top,m=d-1-t.padInfo.left,g=1/(e*n*i);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${u};\n            wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${r}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${c}) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(h);return n.runWebGLProgram(d,[r],o.dtype)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QT={kernelName:gt,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,o=s;xS([r,s],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=i,u=Ko(o.shape,a,l,1,c),h=new class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,i=t.strideHeight,r=t.strideWidth,s=t.dilationHeight,o=t.dilationWidth,a=t.effectiveFilterHeight,l=t.effectiveFilterWidth,c=a-1-t.padInfo.top,u=l-1-t.padInfo.left,h=1/(e*n);this.userCode=`\n      const ivec2 pads = ivec2(${c}, ${u});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${i}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${o}) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(u);return n.runWebGLProgram(h,[r],o.dtype)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t_={kernelName:vt,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{a:r,b:s}=e,{transposeA:o,transposeB:a}=i;return gT({a:r,b:s,transposeA:o,transposeB:a,backend:n})}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class e_{constructor(t,e,n,i,r,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ja(t,e),Ja(t,n);let o="vec4(0.0)";null!=i&&(Ja(t,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let a="vec4(1.0)";null!=r&&(Ja(t,r),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${a};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n_={kernelName:de,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:i,mean:r,variance:s,offset:o,scale:a}=t;c(r.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),c(null==o||r.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),c(null==a||r.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);const u=[i,r,s];let h=null;null!=o&&(h=o.shape,u.push(o));let d=null;null!=a&&(d=a.shape,u.push(a));const p=Y().getBool("WEBGL_PACK_NORMALIZATION")?new e_(i.shape,r.shape,s.shape,h,d,l):new class{constructor(t,e,n,i,r,s){this.outputShape=[],this.variableNames=["x","mean","variance"],Ja(t,e),Ja(t,n);let o="0.0";null!=i&&(Ja(t,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let a="1.0";null!=r&&(Ja(t,r),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${a};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}(i.shape,r.shape,s.shape,h,d,l);return e.runWebGLProgram(p,u,u[0].dtype)}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let i_=class{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=zS(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(t){if(1===t)return"sourceLoc";if(t<=6)return r_.slice(0,t).map((t=>"sourceLoc."+t)).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(this.rank);let i;const r=t.map(((t,e)=>`sourceLoc.${r_[e]} = start[${e}] + coords.${r_[e]};`));i=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${r.join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${i}\n        setOutput(getSource(${n}));\n      }\n    `}};const r_=["x","y","z","w","u","v"];class s_{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=zS(this.rank),n=aC("coords",this.rank),i=aC("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":`vec2(${i.slice(-2).join()})`,s=`getChannel(getSource(${i.join()}), ${r})`,o=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${i[this.rank-1]};\n        result.y = ${s};\n        --${i[this.rank-1]};\n      }\n    `,a=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${i[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${i[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map(((t,e)=>`start[${e}]`)).join()});`:t.map(((t,e)=>`${i[e]} = ${n[e]} + start[${e}];`)).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${o}\n        ${a}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o_(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{begin:s,size:o}=i,[a,l]=Yp(r,s,o);if(Fp(r,a,l),0===d(l))return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const t=n.texData.get(r.dataId),e=jk(t.values,a,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,e)}const{isPacked:c}=n.texData.get(r.dataId),u=Xp(r.shape,a,l);if(c||!u){const t=Y().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new s_(l):new i_(l),e=[a];return n.runWebGLProgram(t,[r],r.dtype,e)}return n.uploadToGPU(r.dataId),function(t,e,n,i){const r=i.texData.get(t.dataId),s=i.makeTensorInfo(n,t.dtype),o=i.texData.get(s.dataId);Object.assign(o,r),o.refCount=1,o.shape=n,o.dtype=t.dtype;let a=Kp(e,L(t.shape));r.slice&&(a+=r.slice.flatOffset),o.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||t.dataId};const l=i.dataRefCount.get(o.slice.origDataId)||1;return i.dataRefCount.set(o.slice.origDataId,l+1),s}(r,a,l,n)}const a_={kernelName:$n,backendName:"webgl",kernelFunc:o_},l_={kernelName:xt,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{blockShape:s,crops:o}=i;c(r.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const a=s.reduce(((t,e)=>t*e)),l=mf(r.shape,s,a),u=gf(l.length,s.length),h=yf(r.shape,s,a),d=bf(o,s.length),p=vf(h,o,s.length),f=[],m=iT({inputs:{x:r},backend:n,attrs:{shape:l}}),g=pT({inputs:{x:m},backend:n,attrs:{perm:u}}),y=iT({inputs:{x:g},backend:n,attrs:{shape:h}}),b=o_({inputs:{x:y},backend:n,attrs:{begin:d,size:p}});return f.push(m),f.push(g),f.push(y),f.forEach((t=>n.disposeIntermediateTensorInfo(t))),b}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c_={kernelName:wt,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,weights:s}=e,{size:o}=i,a=n.readSync(r.dataId),l=n.readSync(s.dataId),c=dk(a,l,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,c)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u_={kernelName:St,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{a:i,b:r}=e,s=Y().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=Y().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([i,r])||1===o){const t=n.texData.get(i.dataId).values,e=n.texData.get(r.dataId).values,[s,o]=fk(i.shape,r.shape,t,e,i.dtype),a=n.makeTensorInfo(o,i.dtype);return n.texData.get(a.dataId).values=s,a}let a;return a=s?new LC("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",i.shape,r.shape,!1):new PC("\n  return float(int(a.r) & int(b.r));\n",i.shape,r.shape),n.runWebGLProgram(a,[i,r],i.dtype)}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h_={kernelName:Ct,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{s0:i,s1:r}=e,s=n.readSync(i.dataId),o=n.readSync(r.dataId),a=Ja(Array.from(s),Array.from(o));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},d_=KC({opSnippet:"return float(a != b);",cpuKernelImpl:Ok,dtype:"bool"}),p_={kernelName:Ye,backendName:"webgl",kernelFunc:d_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function f_(t){const{inputs:e,backend:n}=t,{input:i}=e;return DC({inputs:{x:n.texData.get(i.dataId).complexTensorInfos.real},backend:n})}const m_={kernelName:dn,backendName:"webgl",kernelFunc:f_},g_="return float(int(x));";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y_={kernelName:Tt,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function t(e){const{inputs:n,backend:i,attrs:r}=e,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return DC({inputs:{x:s},backend:i});const e=fc(s.shape),n=t({inputs:{x:s},backend:i,attrs:{dtype:"float32"}}),r=zC({inputs:{real:n,imag:e},backend:i});return e.dispose(),i.disposeIntermediateTensorInfo(n),r}if("complex64"===s.dtype){const e=f_({inputs:{input:s},backend:i}),n=t({inputs:{x:e},backend:i,attrs:{dtype:o}});return i.disposeIntermediateTensorInfo(e),n}if(!E(s.dtype,o)){const t=DC({inputs:{x:s},backend:i});return{dataId:t.dataId,shape:t.shape,dtype:o}}if(i.shouldExecuteOnCPU([s])){const t=i.texData.get(s.dataId).values,[e,n,r]=mk(t,s.shape,s.dtype,o);return i.makeTensorInfo(e,n,r)}if("int32"===o)return function(t,e){const n=new pC(t.shape,g_),i=e.runWebGLProgram(n,[t],"int32");return{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}(s,i);if("bool"===o){const t=i.makeTensorInfo([],"bool",k("bool",1)),e=d_({inputs:{a:s,b:t},backend:i});return i.disposeIntermediateTensorInfo(t),e}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},b_="return ceil(x);",v_=XC({opSnippet:b_,packedOpSnippet:b_,cpuKernelImpl:gk}),x_={kernelName:_t,backendName:"webgl",kernelFunc:v_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class w_{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S_={kernelName:Et,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{clipValueMin:s,clipValueMax:o}=i;let a;a=Y().getBool("WEBGL_PACK_CLIP")?new w_(r.shape):new class{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}(r.shape);const l=[[s],[o]];return n.runWebGLProgram(a,[r],r.dtype,l)}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function k_(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}const C_={kernelName:$t,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:i}=e,r=n.texData.get(i.dataId),s=new class{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}(i.shape),o=[k_(i,r.complexTensorInfos.real),k_(i,r.complexTensorInfos.imag)];return n.runWebGLProgram(s,o,o[0].dtype)}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let T_=class{constructor(t){this.outputShape=[],this.outputShape=of(t,1),this.variableNames=t.map(((t,e)=>`T${e}`));const e=new Array(t.length-1);e[0]=t[0][1];for(let n=1;n<e.length;n++)e[n]=e[n-1]+t[n][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let t=1;t<e.length;t++){const i=e[t-1];n.push(`else if (yC < ${e[t]}) setOutput(getT${t}(yR, yC-${i}));`)}const i=e.length,r=e[e.length-1];n.push(`else setOutput(getT${i}(yR, yC-${r}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class __{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=of(t,e);const n=this.outputShape,i=n.length,r=zS(i),s=aC("coords",i),o=["x","y","z","w","u","v"].slice(0,i);this.variableNames=t.map(((t,e)=>`T${e}`));const a=new Array(t.length-1);a[0]=t[0][e];for(let n=1;n<a.length;n++)a[n]=a[n-1]+t[n][e];const l=o[e],c=o.slice(-2),u=o.join();let h=`if (${l} < ${a[0]}) {\n        return getChannel(\n            getT0(${u}), vec2(${c.join()}));\n        }`;for(let t=1;t<a.length;t++){const e=a[t-1];h+=`\n        if (${l} < ${a[t]}  && ${l} >= ${a[t-1]}) {\n          return getChannel(\n            getT${t}(${E_(o,l,e)}),\n            vec2(${E_(c,l,e)}));\n        }`}const d=a.length,p=a[a.length-1];h+=`\n        return getChannel(\n          getT${d}(${E_(o,l,p)}),\n          vec2(${E_(c,l,p)}));`,this.userCode=`\n      float getValue(${o.map((t=>"int "+t))}) {\n        ${h}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[i-1]} = ${s[i-1]} + 1;\n        if (${s[i-1]} < ${n[i-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[i-2]} = ${s[i-2]} + 1;\n        if (${s[i-2]} < ${n[i-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[i-1]} = ${s[i-1]} - 1;\n        if (${s[i-2]} < ${n[i-2]} &&\n            ${s[i-1]} < ${n[i-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function E_(t,e,n){const i=t.indexOf(e),r=t.map(((t,e)=>e===i?`${t} - ${n}`:t));return r.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M_(t){const{inputs:e,backend:n}=t,{input:i}=e;return DC({inputs:{x:n.texData.get(i.dataId).complexTensorInfos.imag},backend:n})}const $_={kernelName:ve,backendName:"webgl",kernelFunc:M_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I_(t,e,n){const i=t[0].dtype;if("complex64"===i){const i=t.map((t=>f_({inputs:{input:t},backend:n}))),r=t.map((t=>M_({inputs:{input:t},backend:n}))),s=I_(i,e,n),o=I_(r,e,n),a=zC({inputs:{real:s,imag:o},backend:n});return i.forEach((t=>n.disposeIntermediateTensorInfo(t))),r.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),a}let r=n.shouldExecuteOnCPU(t);if("string"===i&&(r=!0),r){const r=t.map((t=>{const i=d(t.shape.slice(e));return iT({inputs:{x:t},backend:n,attrs:{shape:[-1,i]}})})),s=r.map((t=>({vals:n.readSync(t.dataId),shape:t.shape}))),o=of(r.map((t=>t.shape)),1),a=1===r[0].shape[0],l=yk(s,o,i,a),c=of(t.map((t=>t.shape)),e),u=n.makeTensorInfo(c,i,l);return r.forEach((t=>n.disposeIntermediateTensorInfo(t))),u}const s=t.filter((t=>d(t.shape)>0)),o=Y().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){const e=o?new pC(t[0].shape,xC):new EC(t[0].shape,xC);return n.runWebGLProgram(e,t,i)}const a=Y().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){const t=[];for(let i=0;i<s.length;i+=a){const r=s.slice(i,i+a);t.push(I_(r,e,n))}const i=I_(t,e,n);for(const e of t)n.disposeIntermediateTensorInfo(e);return i}if(o){const t=new __(s.map((t=>t.shape)),e);return n.runWebGLProgram(t,s,i)}const{tensors2D:l,outShape:c}=function(t,e,n){const i=of(t.map((t=>t.shape)),e),r=t.map((t=>iT({inputs:{x:t},attrs:{shape:[-1,d(t.shape.slice(e))]},backend:n})));return{tensors2D:r,outShape:i}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(s,e,n),u=new T_(l.map((t=>t.shape))),h=n.runWebGLProgram(u,l,i);l.forEach((t=>n.disposeIntermediateTensorInfo(t)));const p=iT({inputs:{x:h},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(h),p}function A_(t){const{inputs:e,backend:n,attrs:i}=t,{axis:r}=i,s=w(r,e[0].shape)[0],o=e.map((t=>t.shape));sf(o,s);const a=of(e.map((t=>t.shape)),s);if(0===d(a))return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter((t=>d(t.shape)>0));return 1===l.length?DC({inputs:{x:l[0]},backend:n}):I_(l,s,n)}const N_={kernelName:It,backendName:"webgl",kernelFunc:A_};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R_{constructor(t,e=!1,n=null,i=!1,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const s=t.padInfo.top,o=t.padInfo.left,a=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,u=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4,m="channelsLast"===t.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let v="",x="";n&&(v=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${u};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}}class P_{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,i=t.padInfo.left,r=t.strideDepth,s=t.strideHeight,o=t.strideWidth,a=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,u=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${s}, ${o});\n      const ivec3 pads = ivec3(${e}, ${n}, ${i});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${u}; wF++) {\n          int xF = xFCorner + wF * ${a};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${c};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O_{constructor(t,e=!1,n=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=GS(this.outputShape.length);const s=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,u=t.filterWidth,h=u;let d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let t=0;t<u;t++)d+=`\n           vec4 xTexelC${2*t};\n           int xTexelC${2*t}Ready;\n           vec4 xTexelC${2*t+1};\n           int xTexelC${2*t+1}Ready;\n           vec4 xC${t};`;d+=`\n     for (int r = 0; r < ${c}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let t=0;t<u;t++)d+=`\n           xTexelC${2*t} = vec4(0.0);\n           xTexelC${2*t}Ready = 0;\n           xTexelC${2*t+1} = vec4(0.0);\n           xTexelC${2*t+1}Ready = 0;\n           xC${t} = vec4(0.0);`;d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let e=0;e<(h+1)/2;e++){const n=2*e;if(d+=`\n           xC = xCCorner + ${n*l};\n           `,1===a){if(n<u&&(s%2==1?(d+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n               `,d+=1===l&&n>0?`\n                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                   } else {\n                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                   }\n                   `):d+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xC${n} = xTexelC${n};\n                 `,n+1<u)){const t=s%2==0?o(l):l;l%2==0&&s%2==1||l%2!=0&&s%2!=1?(d+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${n+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${n+1}Ready = 1;\n                   }\n                   `,d+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                     } else {\n                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                     }\n                     `:`\n                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                     `):d+=1===t?`\n                     xC${n+1} = xTexelC${n};\n                     `:`\n                     xCOffset = xC + ${t};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${n+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${n+1}Ready = 1;\n                     }\n\n                     xC${n+1} = xTexelC${n+1};\n                     `}}else n<u&&(s%2==1?(d+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n               `,n+1<u&&(d+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                 `)):(d+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(\n                   xTexelC${n}.xy, xTexelC${n+1}.xy);\n               `,n+1<u&&(d+=`\n                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                 `)));n<u&&(d+=`\n             wTexel = getW(r, ${n}, d1, d2);\n             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,n+1<u&&(d+=`\n               wTexel = getW(r, ${n+1}, d1, d2);\n               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let p="",f="";n&&(p=i?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:r?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,f="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${p}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${d}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${f}\n         setOutput(result);\n       }\n     `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class L_{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=GS(this.outputShape.length);const{dataFormat:n}=e,i=SS(),r="channelsLast"===n,s=r?1:2,o=r?2:3,a=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let l="";for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${t};\n\n          ${a}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${o}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${r}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*t+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*t+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${i.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D_(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&1===n&&t[0]>1?[t[0],1]:null}function F_({x:t,filter:e,convInfo:n,backend:i,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const l=t.shape,u=i.texData.get(t.dataId),h=n.inChannels,d=l[0]*l[1]*l[2],p=n.outChannels,f="channelsLast"===n.dataFormat;let g;const y=[];if(null!=s){const t=D_(s.shape,f);null!=t&&(s=iT({inputs:{x:s},backend:i,attrs:{shape:t}}),y.push(s))}if(null!=r){const t=D_(r.shape,f);null!=t&&(r=iT({inputs:{x:r},backend:i,attrs:{shape:t}}),y.push(r))}if(!((1===d||1===p)&&h>mT)&&u.isPacked&&f&&null!=u.texture&&l[2]%2!=0&&m(u.shape.slice(-3),l.slice(-3))){const h=l[0]*l[1]*(l[2]+1),d={dataId:t.dataId,shape:[1,h,n.inChannels],dtype:t.dtype},p=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,c(pS(u.shape,d.shape),(()=>`packed reshape ${u.shape} to ${d.shape} isn't free`));const f=iT({inputs:{x:e},backend:i,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(f);const m=gT({a:d,b:f,backend:i,transposeA:false,transposeB:false,bias:r,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),b=i.texData.get(m.dataId);c(b.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=p,b.shape=n.outShape,g=DC({inputs:{x:m},backend:i}),g.shape=n.outShape,y.push(m)}else{const l=n.outHeight*n.outWidth,c=iT({inputs:{x:t},backend:i,attrs:{shape:f?[n.batchSize,l,n.inChannels]:[n.batchSize,n.inChannels,l]}}),u=iT({inputs:{x:e},backend:i,attrs:{shape:[1,n.inChannels,n.outChannels]}}),h=gT({a:f?c:u,b:f?u:c,transposeA:!f,transposeB:false,backend:i,bias:r,activation:a,preluActivationWeights:s,leakyreluAlpha:o});g=iT({inputs:{x:h},backend:i,attrs:{shape:n.outShape}}),y.push(c),y.push(u),y.push(h)}for(const t of y)i.disposeIntermediateTensorInfo(t);return g}function z_({x:t,filter:e,convInfo:n,backend:i,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:p,dataFormat:f}=n,m="channelsLast"===f,g=l*c*u,y=p*h,b=[n.batchSize,g,y],v=[];if(null!=s){const t=D_(s.shape,m);null!=t&&(s=iT({inputs:{x:s},backend:i,attrs:{shape:t}}),v.push(s))}if(null!=r){const t=D_(r.shape,m);null!=t&&(r=iT({inputs:{x:r},backend:i,attrs:{shape:t}}),v.push(r))}const x=iT({inputs:{x:e},backend:i,attrs:{shape:[1,g,d(e.shape)/g]}});v.push(x);const w=new L_(b,n),S=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],k=i.runWebGLProgram(w,[t],"float32",S),C=iT({inputs:{x:k},backend:i,attrs:{shape:b}});v.push(k),v.push(C);const T=null!=r,_=null!=s,E="leakyrelu"===a,M=a?YC(a,!0):null,$=new ZC(m?C.shape:x.shape,m?x.shape:C.shape,m?[n.batchSize,y,n.outChannels]:[n.batchSize,n.outChannels,y],!0,!1,T,M,_,E),I=m?[C,x]:[x,C];if(r&&I.push(r),_&&I.push(s),E){const t=i.makeTensorInfo([],"float32",pr(o,"float32"));I.push(t),v.push(t)}const A=i.runWebGLProgram($,I,"float32"),N=iT({inputs:{x:A},backend:i,attrs:{shape:n.outShape}});v.push(A);for(const t of v)i.disposeIntermediateTensorInfo(t);return N}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B_={kernelName:At,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=i,h=aa(l),d=Zo(r.shape,s.shape,o,c,a,u,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&Y().getBool("WEBGL_EXP_CONV")){const t=new O_(d),e=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(t,[r,s],"float32",e)}else if(Y().getBool("WEBGL_CONV_IM2COL"))p=z_({x:r,filter:s,convInfo:d,backend:n});else{const t=new R_(d);p=n.runWebGLProgram(t,[r,s],"float32")}else p=F_({x:r,filter:s,convInfo:d,backend:n});const f=iT({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U_={kernelName:Nt,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,dy:s}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=i,h=aa(l),d=Zo(r.shape,u,o,1,a,c,!1,h),p=new class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,i=t.padInfo.top,r=t.padInfo.left,s="channelsLast"===t.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${i};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              ${s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(d);return n.runWebGLProgram(p,[r,s],"float32")}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V_{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=GS(this.outputShape.length);const e=t.filterHeight,n=t.filterWidth,i=e-1-t.padInfo.top,r=n-1-t.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${r});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W_={kernelName:Rt,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,filter:s}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=i,h=aa(c),d=Zo(o,s.shape,a,1,l,u,!1,h);if(Y().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const t=[[d.strideHeight,d.strideWidth]],e=new V_(d);return n.runWebGLProgram(e,[r,s],"float32",t)}{const t=new class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,i=t.strideHeight,r=t.strideWidth,s="channelsLast"===t.dataFormat,o=e-1-t.padInfo.top,a=n-1-t.padInfo.left,l=s?1:2,c=s?2:3,u=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${u}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${i}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(d);return n.runWebGLProgram(t,[r,s],"float32")}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H_={kernelName:Pt,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l}=i,c=Jo(r.shape,s.shape,o,l,a),u=new P_(c);return n.runWebGLProgram(u,[r,s],"float32")}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j_={kernelName:Ot,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,dy:s}=e,{strides:o,pad:a,filterShape:l}=i,c=Jo(r.shape,l,o,1,a),u=new class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,n=t.strideHeight,i=t.strideWidth,r=t.padInfo.front,s=t.padInfo.top,o=t.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${e} - ${r};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${i} - ${o};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(c);return n.runWebGLProgram(u,[r,s],"float32")}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G_={kernelName:Lt,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,filter:s}=e,{pad:o,strides:a,inputShape:l}=i,c=Jo(l,s.shape,a,1,o),u=new class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,i=t.filterWidth,r=t.strideDepth,s=t.strideHeight,o=t.strideWidth,a=e-1-t.padInfo.front,l=n-1-t.padInfo.top,c=i-1-t.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${a}, ${l}, ${c});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${r}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${i}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${i} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(c);return n.runWebGLProgram(u,[r,s],"float32")}},q_=XC({opSnippet:qC+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${OC}\n  return result;\n`}),X_={kernelName:Dt,backendName:"webgl",kernelFunc:q_},K_=XC({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Y_={kernelName:Ft,backendName:"webgl",kernelFunc:K_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Z_={kernelName:Ut,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:i}=t,{image:r,boxes:s,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=i,u=new class{constructor(t,e,n,i,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,o,a,l]=t,[c]=e,[u,h]=n;this.outputShape=[c,u,h,l];const d="bilinear"===i?1:0,[p,f]=[o-1+".0",a-1+".0"],[m,g,y]=u>1?[""+(o-1)/(u-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,v,x]=h>1?[""+(a-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}(r.shape,s.shape,a,l,c);return n.runWebGLProgram(u,[r,s,o],"float32")}};var J_;!function(t){t.Prod="*",t.Sum="+"}(J_||(J_={}));let Q_=class{constructor(t,e,n,i){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,s=this.op===J_.Prod?"1.0":"0.0",o=n?s:`getX(${tE(r,"coords",this.op)})`,a=this.outputShape[this.outputShape.length-1];let l="",c="";n?(l=i?"end != "+(a-1):"end != 0",c=i?"end + 1":"end - 1"):(l=i?`end + pow2 < ${a}`:"end >= pow2",c=i?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${zS(r)} coords = getOutputCoords();\n        int end = ${eE(r,"coords",this.op)};\n        float val = ${o};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${c};\n          ${eE(r,"coords",this.op)} = idx;\n          val ${this.op}= getX(${tE(r,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}};function tE(t,e,n){if(1===t)return`${e}`;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function eE(t,e,n){if(1===t)return`${e}`;if(2===t)return`${e}.y`;if(3===t)return`${e}.z`;if(4===t)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nE(t,e,n,i,r,s){const o=e.shape.length,a=fl([i],o);let l=e;null!=a&&(l=pT({inputs:{x:e},backend:n,attrs:{perm:a}}));const c=gl(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${i}`);const u=l.shape[c];let h=DC({inputs:{x:l},backend:n});for(let e=0;e<=Math.ceil(Math.log2(u))-1;e++){const i=new Q_(t,l.shape,!1,s),r=[[e]],o=h;h=n.runWebGLProgram(i,[h],h.dtype,r),n.disposeIntermediateTensorInfo(o)}if(r){const e=new Q_(t,l.shape,r,s),i=h;h=n.runWebGLProgram(e,[h],h.dtype),n.disposeIntermediateTensorInfo(i)}if(null!=a){const t=pT({inputs:{x:h},backend:n,attrs:{perm:ml(a)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),t}return h}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iE={kernelName:zt,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,exclusive:o,reverse:a}=i;return nE(J_.Prod,r,n,s,o,a)}};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rE={kernelName:Bt,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,exclusive:o,reverse:a}=i;return nE(J_.Sum,r,n,s,o,a)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sE={kernelName:Vt,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,weights:s}=e,{size:o,binaryOutput:a}=i;if(1===r.shape.length){const t=n.readSync(r.dataId),e=n.readSync(s.dataId),i=dk(t,e,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,i)}if(2===r.shape.length){const t=n.bufferSync(r),e=n.bufferSync(s),i=pk(t,e,o,a);return n.makeTensorInfo(i.shape,s.dtype,i.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oE={kernelName:Wt,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{blockSize:s,dataFormat:o}=i,a=r.shape[0],l=("NHWC"===o?r.shape[1]:r.shape[2])*s,c=("NHWC"===o?r.shape[2]:r.shape[3])*s,u=("NHWC"===o?r.shape[3]:r.shape[1])/(s*s),h="NHWC"===o?[a,l,c,u]:[a,u,l,c],d=new class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}(h,s,o);return n.runWebGLProgram(d,[r],r.dtype)}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let aE=class{constructor(t,e=!1,n=null,i=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=GS(this.outputShape.length);const s=t.filterHeight,o=t.filterWidth,a=t.outChannels/t.inChannels;let l="",c="";n&&(l=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,c="result = activation(result);");const u=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${u}\n        ${c}\n        setOutput(result);\n      }\n    `}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lE{constructor(t,e=!1,n=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=GS(this.outputShape.length);const s=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,u=t.filterHeight,h=t.filterWidth,d=h;let p="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let t=0;t<h;t++)p+=`\n          vec4 xTexelC${2*t};\n          int xTexelC${2*t}Ready;\n          vec4 xTexelC${2*t+1};\n          int xTexelC${2*t+1}Ready;\n          vec4 xC${t};`;p+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let t=0;t<h;t++)p+=`\n          xTexelC${2*t} = vec4(0.0);\n          xTexelC${2*t}Ready = 0;\n          xTexelC${2*t+1} = vec4(0.0);\n          xTexelC${2*t+1}Ready = 0;\n          xC${t} = vec4(0.0);`;p+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let t=0;t<(d+1)/2;t++){const e=2*t;if(p+=`\n          xC = xCCorner + ${e*c};\n          `,1===l){if(e<h&&(a%2==1?(p+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,p+=1===c&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):p+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<h)){const t=a%2==0?o(c):c;c%2==0&&a%2==1||c%2!=0&&a%2!=1?(p+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,p+=c>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):p+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<h&&(a%2==1?(p+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<h&&(p+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(p+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<h&&(p+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<h&&(p+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<h&&(p+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}p+="\n    }\n  ",p+="\n      }\n    ";let f="",m="";n&&(f=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,m="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${f}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${p}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${m}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cE={kernelName:Ht,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=i;let h=l;null==h&&(h=[1,1]),c(sa(o,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`));const d=Zo(r.shape,s.shape,o,h,a,u,!0);let p;p=Y().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new lE(d):new aE(d);const f=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(p,[r,s],"float32",f)}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uE={kernelName:jt,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,dy:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=i,h=Zo(r.shape,u,o,a,l,c,!0),d=new class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,i=t.padInfo.top,r=t.padInfo.left,s=t.outChannels/t.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${i};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(h);return n.runWebGLProgram(d,[r,s],"float32")}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hE={kernelName:Gt,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,filter:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=i,h=Zo(u,s.shape,o,a,l,c,!0),d=new class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,i=t.strideHeight,r=t.strideWidth,s=e-1-t.padInfo.top,o=n-1-t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${i}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${a}; dm++) {\n              int d2 = d1 * ${a} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(h);return n.runWebGLProgram(d,[r,s],"float32")}};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dE={kernelName:qt,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n}=t,{x:i}=e,r=[...i.shape,...i.shape],s=d(i.shape),o=iT({inputs:{x:i},backend:n,attrs:{shape:[s]}}),a=new class{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}(s),l=n.runWebGLProgram(a,[o],o.dtype),c=iT({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pE={kernelName:Xt,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l}=i,c=Xo(r.shape,s.shape,o,a,"NHWC",l);let u;const h=new class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:n,padInfo:i,strideHeight:r,strideWidth:s,filterHeight:o,filterWidth:a,dilationHeight:l,dilationWidth:c}=t,{top:u,left:h}=i;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${s});\n      const ivec2 pads = ivec2(${u}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${o}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${a}; w++) {\n              int wIn = wBeg + w * ${c};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}(c);u=n.runWebGLProgram(h,[r,s],"float32");const d=iT({inputs:{x:u},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(u),d}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fE={kernelName:Qt,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{equation:r}=i,s=e,{allDims:o,summedDims:a,idDims:l}=Bf(r,s.length);Vf(o.length,l,s);const{path:c,steps:u}=Wf(a,l),h=u.length;let d=null,p=o.length;const f=[];for(let t=0;t<h;++t){for(const e of u[t]){const{permutationIndices:t,expandDims:i}=Uf(p,l[e]);let r;Hf(t)?r=s[e]:(r=pT({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(r));const o=r.shape.slice();for(let t=0;t<i.length;++t)o.splice(i[t],0,1);m(r.shape,o)||(r=iT({inputs:{x:r},backend:n,attrs:{shape:o}}),f.push(r)),null===d?d=r:(d=eT({inputs:{a:r,b:d},backend:n}),f.push(d))}t<h-1&&(c[t]>=0&&(d=hT({inputs:{x:d},backend:n,attrs:{axis:c[t]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const t of f)t!==d&&n.disposeIntermediateTensorInfo(t);return d}},mE=XC({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),gE={kernelName:te,backendName:"webgl",kernelFunc:mE},yE={kernelName:ee,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n}=t,{dy:i,y:r}=e,s=Y().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new LC("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",i.shape,r.shape):new PC("return (b >= 0.0) ? a : a * (b + 1.0);",i.shape,r.shape);return n.runWebGLProgram(s,[i,r],i.dtype)}},bE=KC({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:bk}),vE={kernelName:ie,backendName:"webgl",kernelFunc:bE},xE=XC({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Sf};\n  float a1 = ${kf};\n  float a2 = ${Cf};\n  float a3 = ${Tf};\n  float a4 = ${_f};\n  float a5 = ${Ef};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),wE={kernelName:ne,backendName:"webgl",kernelFunc:xE},SE=XC({opSnippet:qC+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:vk,dtype:"float32"}),kE={kernelName:re,backendName:"webgl",kernelFunc:SE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function CE(t){const{inputs:e,attrs:n,backend:i}=t,{dim:r}=n,{input:s}=e,o=s.shape.length,a=s.shape.slice();let l=r;return r<0&&(c(-(o+1)<=r,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+r+1),a.splice(l,0,1),iT({inputs:{x:s},backend:i,attrs:{shape:a}})}const TE={kernelName:se,backendName:"webgl",kernelFunc:CE},_E="return exp(x) - 1.0;",EE=XC({opSnippet:_E,packedOpSnippet:_E,cpuKernelImpl:xk}),ME={kernelName:oe,backendName:"webgl",kernelFunc:EE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let $E=class{constructor(t,e,n){this.variableNames=["real","imag"];const i=e[1];this.outputShape=e;const r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${i}.0`:"1.0";let o;if("real"===t)o="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);o="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${o}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${i});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${i}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IE(t,e,n){const i=n.texData.get(t.dataId),r=d(t.shape),s=t.shape[t.shape.length-1],o=iT({inputs:{x:t},backend:n,attrs:{shape:[r/s,s]}}),a=o.shape,l=new $E("real",a,e),c=new $E("imag",a,e),u=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:a},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:a}],h=n.runWebGLProgram(l,u,"float32"),p=n.runWebGLProgram(c,u,"float32"),f=zC({inputs:{real:h,imag:p},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p);const m=iT({inputs:{x:f},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AE={kernelName:ae,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:i}=e;return IE(i,!1,n)}};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let NE=class{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RE(t){const{backend:e,attrs:n}=t,{shape:i,value:r}=n;let{dtype:s}=n;if(s=s||R(r),"string"===s){const t=C(s,d(i));return t.fill(r),e.makeTensorInfo(i,s,t)}{const t=new NE(i,r),n=[[r]];return e.runWebGLProgram(t,[],s,n)}}const PE={kernelName:le,backendName:"webgl",kernelFunc:RE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const OE={kernelName:ce,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,i=e,r=new class{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}(n.shape);return i.runWebGLProgram(r,[n],n.dtype)}},LE="return floor(x);",DE=XC({opSnippet:LE,packedOpSnippet:LE,cpuKernelImpl:wk}),FE={kernelName:ue,backendName:"webgl",kernelFunc:DE},zE=KC({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),BE={kernelName:he,backendName:"webgl",kernelFunc:zE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class UE{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=SS(),[n,i]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${i}.0, ${n}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VE={kernelName:ui,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t;let{pixels:r}=e;const{numChannels:s}=i,o="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,a="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[c,l],h=[c,l,s];if(a||o){const t=Y().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=WE&&t===HE||(HE=t,WE=document.createElement("canvas").getContext("2d",{willReadFrequently:HE})),WE.canvas.width=l,WE.canvas.height=c,WE.drawImage(r,0,0,l,c),r=WE.canvas}const d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=jw.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);const p=Y().getBool("WEBGL_PACK")?new UE(h):new class{constructor(t){this.variableNames=["A"];const e=SS(),[n,i]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${n}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */};let WE,HE=Y().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const jE={kernelName:pi,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=i,m=aa(u),g=Zo(r.shape,s.shape,l,h,c,d,!1,m);let y;const b=[],v=null!=o,x=null!=a,w="leakyrelu"===p,S=()=>{const t=[r,s],e=(t,e)=>{if("NCHW"===e&&1===t.shape.length&&1!==t.shape[0]){const e=iT({inputs:{x:t},backend:n,attrs:{shape:[t.shape[0],1,1]}});return b.push(e),e}return t};if(v&&t.push(e(o,u)),x&&t.push(e(a,u)),w){const e=n.makeTensorInfo([],"float32",pr(f,"float32"));t.push(e),b.push(e)}return t};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&Y().getBool("WEBGL_EXP_CONV")){const t=p?YC(p,!0):null,e=new O_(g,v,t,x,w),i=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],r=S();y=n.runWebGLProgram(e,r,"float32",i)}else if(Y().getBool("WEBGL_CONV_IM2COL"))y=z_({x:r,filter:s,convInfo:g,backend:n,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const t=p?YC(p,!1):null,e=new R_(g,v,t,x,w),i=S();y=n.runWebGLProgram(e,i,"float32")}else y=F_({x:r,filter:s,convInfo:g,backend:n,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});const k=iT({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach((t=>n.disposeIntermediateTensorInfo(t))),k}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GE={kernelName:fi,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=i,m=[];let g=h;null==g&&(g=[1,1]),c(sa(l,g),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`));const y=Zo(r.shape,s.shape,l,g,u,d,!0),b=Y().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels==1,v=p?YC(p,b):null,x=[r,s],w=null!=o,S=null!=a,k="leakyrelu"===p;if(w&&x.push(o),S&&x.push(a),k){const t=n.makeTensorInfo([],"float32",pr(f,"float32"));x.push(t),m.push(t)}let C;C=b?new lE(y,w,v,S,k):new aE(y,w,v,S,k);const T=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],_=n.runWebGLProgram(C,x,"float32",T);return m.forEach((t=>n.disposeIntermediateTensorInfo(t))),_}};const qE={kernelName:fe,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n}=t,{params:i,indices:r}=e,s=r.shape,o=s[s.length-1],a=d(i.shape),[l,c,u,h]=Pp(i,r),p=iT({inputs:{x:r},backend:n,attrs:{shape:[c,o]}}),f=iT({inputs:{x:i},backend:n,attrs:{shape:[d(i.shape)/u,u]}});if(n.shouldExecuteOnCPU([i,r])||"string"===i.dtype){const t=n.readSync(r.dataId),e=n.bufferSync(i),s=Sk(t,e,i.dtype,c,o,u,h,i.shape,a);return n.makeTensorInfo(l,i.dtype,s.values)}const m=new class{constructor(t,e,n,i){this.sliceDim=t,this.strides=e,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=n;const r=zS(n.length);let s="\n    int index;";for(let t=0;t<this.sliceDim;t++)s+=`\n          index = round(getIndices(coords[0], ${t}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[t]};\n          flattenIndex += index * ${this.strides[t]};`;this.userCode=`\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}(o,h,[c,u],i.shape),g=n.runWebGLProgram(m,[f,p],f.dtype),y=iT({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),y}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let XE=class{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const n=zS(this.rank),i=function(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[];for(let e=0;e<t.length;e++)2===e?i.push("index"):i.push(`${n[e]}`);return i.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(t);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${i}));\n      }\n    `}};function KE(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,indices:s}=e,{axis:o,batchDims:a}=i,l=w(o,r.shape)[0];if(Y().get("DEBUG")){const t=n.readSync(s.dataId),e=r.shape[l];for(let n=0;n<t.length;++n){const i=t[n];c(i<=e-1&&i>=0,(()=>`GatherV2: the index value ${i} is not in [0, ${e-1}]`))}}const u=am(r,s,l,a),h=d(s.shape),p=[],f=iT({inputs:{x:r},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),m=iT({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,h/u.batchSize]}});p.push(f),p.push(m);const g=[u.batchSize,u.outerSize,h/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const t=n.bufferSync(m),e=n.bufferSync(f),i=kk(e,t,g);return p.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(u.outputShape,i.dtype,i.values)}const y=new XE(f.shape,g),b=n.runWebGLProgram(y,[f,m],f.dtype);p.push(b);const v=iT({inputs:{x:b},backend:n,attrs:{shape:u.outputShape}});return p.forEach((t=>n.disposeIntermediateTensorInfo(t))),v}const YE={kernelName:pe,backendName:"webgl",kernelFunc:KE},ZE=KC({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Ck,dtype:"bool"}),JE={kernelName:me,backendName:"webgl",kernelFunc:ZE},QE=KC({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Tk}),tM={kernelName:ge,backendName:"webgl",kernelFunc:QE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eM={kernelName:be,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n}=t,{input:i}=e;return IE(i,!0,n)}},nM=XC({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),iM={kernelName:xe,backendName:"webgl",kernelFunc:nM},rM=XC({opSnippet:"return float(isinf(x));",dtype:"bool"}),sM={kernelName:we,backendName:"webgl",kernelFunc:rM},oM=XC({opSnippet:"return float(isnan(x));",dtype:"bool"}),aM={kernelName:Se,backendName:"webgl",kernelFunc:oM},lM=KC({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:_k,dtype:"bool"}),cM={kernelName:Ce,backendName:"webgl",kernelFunc:lM},uM=KC({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Ek,dtype:"bool"}),hM={kernelName:Te,backendName:"webgl",kernelFunc:uM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dM={kernelName:_e,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{backend:e,attrs:n}=t,{start:i,stop:r,num:s}=n,o=Mk(i,r,s);return e.makeTensorInfo([o.length],"float32",o)}},pM=XC({opSnippet:qC+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:$k}),fM={kernelName:Ee,backendName:"webgl",kernelFunc:pM},mM=XC({opSnippet:qC+"\n  return log(1.0 + x);\n"}),gM={kernelName:Me,backendName:"webgl",kernelFunc:mM},yM=KC({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),bM={kernelName:$e,backendName:"webgl",kernelFunc:yM},vM=XC({opSnippet:"return float(!(x >= 1.0));"}),xM={kernelName:Ie,backendName:"webgl",kernelFunc:vM},wM=KC({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),SM={kernelName:Ae,backendName:"webgl",kernelFunc:wM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class kM{constructor(t,e,n,i,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=e,o=t[3]-1;let a;this.outputShape=t;const l=`float(${n}) + float(${i}) * sum`;a=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${a};\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CM={kernelName:Re,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{depthRadius:s,bias:o,alpha:a,beta:l}=i,c=Y().getBool("WEBGL_PACK_NORMALIZATION")?new kM(r.shape,s,o,a,l):new class{constructor(t,e,n,i,r){this.variableNames=["x"],this.outputShape=[];const s=e,o=t[3]-1;let a;this.outputShape=t;const l=`float(${n}) + float(${i}) * sum`;a=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${a};\n        setOutput(val);\n      }\n    `}}(r.shape,s,o,a,l);return n.runWebGLProgram(c,[r],r.dtype)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const TM={kernelName:Pe,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:i}=t,{x:r,y:s,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=i,h=new class{constructor(t,e,n,i,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=i,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${i}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${i})\n                * float(${r})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}(r.shape,a,l,c,u);return n.runWebGLProgram(h,[r,s,o],r.dtype)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _M(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{reductionIndices:s,keepDims:o}=i,a=r.shape.length,l=w(s,r.shape);let c=l;const u=fl(c,a),h=null!=u,p=n.shouldExecuteOnCPU([r]);let f=r;if(h){if(p){const t=n.texData.get(f.dataId).values,e=new Array(a);for(let t=0;t<e.length;t++)e[t]=r.shape[u[t]];const i=rC(t,r.shape,r.dtype,u,e);f=n.makeTensorInfo(e,r.dtype);n.texData.get(f.dataId).values=i}else f=uT(r,u,n);c=gl(c.length,a)}pl("max",c,a);const[m,g]=hl(f.shape,c);let y,b=m;if(o&&(b=dl(m,l)),p){const t=n.texData.get(f.dataId).values,e=Ik(t,d(g),b,r.dtype);y=n.makeTensorInfo(b,r.dtype);n.texData.get(y.dataId).values=e}else y=
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t,e,n,i){const r=d(e),s=iT({inputs:{x:t},attrs:{shape:[d(t.shape)/r,r]},backend:i}),o=aT(s,t.dtype,"max",i),a=iT({inputs:{x:o},attrs:{shape:n},backend:i});return i.disposeIntermediateTensorInfo(s),i.disposeIntermediateTensorInfo(o),a}(f,g,b,n);return h&&n.disposeIntermediateTensorInfo(f),y}const EM={kernelName:Oe,backendName:"webgl",kernelFunc:_M},MM=KC({opSnippet:RC+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+OC+"\n  return result;\n",cpuKernelImpl:Ak}),$M={kernelName:Le,backendName:"webgl",kernelFunc:MM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IM={kernelName:De,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e;xS(r,"maxPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i;c(sa(o,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const u=Ko(r.shape,s,o,1,a,l);if(1===u.filterWidth&&1===u.filterHeight&&m(u.inShape,u.outShape))return DC({inputs:{x:r},backend:n});const h=new XT(u,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AM={kernelName:ze,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{filterSize:s,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=i,u=Yo(r.shape,s,o,[1,1,1],a,c,l),h=new KT(u,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NM={kernelName:Be,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=i,h=Yo(o.shape,a,l,[1,1,1],c,u),d=new KT(h,"max",!0),p=n.runWebGLProgram(d,[o],o.dtype),f=new class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,n=t.strideHeight,i=t.strideWidth,r=t.dilationDepth,s=t.dilationHeight,o=t.dilationWidth,a=t.effectiveFilterDepth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,u=a-1-t.padInfo.front,h=l-1-t.padInfo.top,d=c-1-t.padInfo.left,p=a*l*c-1;this.userCode=`\n      const ivec3 pads = ivec3(${u}, ${h}, ${d});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${a};\n           wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${e}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${o}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${c} +\n                  wR * ${c} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(h),m=n.runWebGLProgram(f,[r,p],o.dtype);return n.disposeIntermediateTensorInfo(p),m}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RM={kernelName:Fe,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s,output:o}=e,a=s;xS([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=i,d=Ko(a.shape,l,c,1,u,h),p=new XT(d,"max",!0),f=n.runWebGLProgram(p,[a],a.dtype),m=new class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,n=t.strideWidth,i=t.dilationHeight,r=t.effectiveFilterHeight,s=t.effectiveFilterWidth,o=r-1-t.padInfo.top,a=s-1-t.padInfo.left,l=r*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n          wR += ${i}) {\n          float dyR = float(dyRCorner + wR) / ${e}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(d),g=n.runWebGLProgram(m,[r,f],a.dtype);return n.disposeIntermediateTensorInfo(f),g}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const PM={kernelName:Ue,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:i}=t,{filterSize:r,strides:s,pad:o,includeBatchInIndex:a}=e,l=n;c(4===i.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.shape.length}.`));const u=[1,1];c(sa(s,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`));const h=Ko(i.shape,r,s,u,o),[d,p]=function(t,e,n,i){let r=new XT(n,"max",!1);const s=i.runWebGLProgram(r,[t],"float32");return r=new XT(n,"max",!0,!0,e),[s,i.runWebGLProgram(r,[t],"float32")]}(i,a,h,l);return[d,p]}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const OM={kernelName:Ve,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:i}=t,{keepDims:r,axis:s}=e,o=n,a=i.shape.length,l=w(s,i.shape);let c=l;const u=fl(c,a),h=null!=u,p=o.shouldExecuteOnCPU([i]),f=[];let m=i;if(h){if(p){const t=o.texData.get(m.dataId).values,e=new Array(a);for(let t=0;t<e.length;t++)e[t]=i.shape[u[t]];const n=rC(t,i.shape,i.dtype,u,e);m=o.makeTensorInfo(e,i.dtype);o.texData.get(m.dataId).values=n}else m=uT(i,u,o);f.push(m),c=gl(c.length,a)}pl("sum",c,a);const[g,y]=hl(m.shape,c);let b=g;r&&(b=dl(g,l));const v=function(t,e,n,i){const r=d(e),s=iT({inputs:{x:t},attrs:{shape:[d(t.shape)/r,r]},backend:i}),o=aT(s,"float32","mean",i),a=iT({inputs:{x:o},attrs:{shape:n},backend:i});return i.disposeIntermediateTensorInfo(s),i.disposeIntermediateTensorInfo(o),a}(m,y,b,o);for(const t of f)o.disposeIntermediateTensorInfo(t);return v}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LM={kernelName:We,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,keepDims:o}=i,a=r.shape.length,l=w(s,r.shape);let c=l;const u=fl(c,a);let h=r;null!=u&&(h=pT({inputs:{x:r},backend:n,attrs:{perm:u}}),c=gl(c.length,r.shape.length)),pl("min",c,a);const[p,f]=hl(h.shape,c),m=iT({inputs:{x:h},backend:n,attrs:{shape:[-1,d(f)]}}),g=aT(m,m.dtype,"min",n);let y;if(o){y=iT({inputs:{x:g},backend:n,attrs:{shape:dl(p,l)}})}else y=iT({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(h),y}},DM=KC({opSnippet:RC+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+OC+"\n  return result;\n",cpuKernelImpl:Nk}),FM={kernelName:He,backendName:"webgl",kernelFunc:DM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class zM{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const i=t.length,r=zS(i),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),a=aC("rc",i),l=aC("source",i),c=`${a[i-1]} < ${this.outputShape[i-1]}`,u=1===i?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===i){const t=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${u});\n        ${a[i-1]} += 1;\n        if(${c}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${u});\n        }\n      `}else{const t=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${u});\n        ${a[i-1]} += 1;\n        if(${c}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${u});\n        }\n        rc = outputLoc;\n        ${a[i-2]} += 1;\n        if(${a[i-2]} < ${this.outputShape[i-2]}) {\n          ${t}\n          result[2] = getChannel(getX(${l.join()}), ${u});\n          ${a[i-1]} += 1;\n          if(${c}) {\n            ${t}\n            result[3] = getChannel(getX(${l.join()}), ${u});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${s});\n      const ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BM={kernelName:je,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:i}=t,{paddings:r,mode:s}=n,o=Y().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zM(i.shape,r,s):new class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const i=t.length,r=zS(i),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),a=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),l="reflect"===n?0:1;this.userCode=1!==i?`\n      ${r} start = ${r}(${s});\n      ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${i}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${a}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}(i.shape,r,s);return e.runWebGLProgram(o,[i],i.dtype)}},UM=KC({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+OC+"\n  return result;\n"}),VM={kernelName:Ge,backendName:"webgl",kernelFunc:UM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const WM=KC({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),HM={kernelName:Jt,backendName:"webgl",kernelFunc:WM},jM="return a - b;",GM=KC({opSnippet:jM,packedOpSnippet:jM,supportsComplex:!0,cpuKernelImpl:eC}),qM={kernelName:Jn,backendName:"webgl",kernelFunc:GM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XM(t){const{inputs:e,backend:n,attrs:i}=t,{logits:r}=e,{dim:s}=i,o=w([s],r.shape),a=_M({inputs:{x:r},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=dl(a.shape,o),c=iT({inputs:{x:a},backend:n,attrs:{shape:l}}),u=GM({inputs:{a:r,b:c},backend:n}),h=SE({inputs:{x:u},backend:n}),d=hT({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:!1}}),p=iT({inputs:{x:d},backend:n,attrs:{shape:l}}),f=WM({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const KM={kernelName:zn,backendName:"webgl",kernelFunc:XM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YM={kernelName:qe,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{logits:r}=e,{numSamples:s,seed:o,normalized:a}=i,l=a?r:XM({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new class{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}(c,u,s),d=[[o]],p=n.runWebGLProgram(h,[l],"int32",d);return a||n.disposeIntermediateTensorInfo(l),p}},ZM=fC+"\n  return -x;\n";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JM={kernelName:Ke,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:i}=e;if(n.shouldExecuteOnCPU([i])){const t=n.texData.get(i.dataId),[e,r]=Pk(t.values,i.shape,i.dtype);return n.makeTensorInfo(r,i.dtype,e)}let r;return r=Y().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new EC(i.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new pC(i.shape,ZM),n.runWebGLProgram(r,[i],i.dtype)}},QM=id;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t$={kernelName:Ze,backendName:"webgl",kernelFunc:function(t){mi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:i}=t,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=i,c=n.readSync(r.dataId),u=n.readSync(s.dataId),{selectedIndices:h}=QM(c,u,o,a,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},e$=rd;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n$={kernelName:Je,backendName:"webgl",kernelFunc:function(t){mi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:i}=t,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=i,u=n.readSync(r.dataId),h=n.readSync(s.dataId),{selectedIndices:d,validOutputs:p}=e$(u,h,o,a,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},i$=sd;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r$={kernelName:Qe,backendName:"webgl",kernelFunc:function(t){mi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:i}=t,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=i,u=n.readSync(r.dataId),h=n.readSync(s.dataId),d=o,p=a,f=l,m=c,{selectedIndices:g,selectedScores:y}=i$(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const s$={kernelName:en,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:i}=t,{indices:r}=e,{dtype:s,depth:o,onValue:a,offValue:l}=i,c=d(r.shape),u=new class{constructor(t,e,n,i){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${i}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}(c,o,a,l),h=iT({inputs:{x:r},backend:n,attrs:{shape:[c]}}),p=n.runWebGLProgram(u,[h],s);n.disposeIntermediateTensorInfo(h);const f=iT({inputs:{x:p},backend:n,attrs:{shape:[...r.shape,o]}});return n.disposeIntermediateTensorInfo(p),f}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o$(t){const{inputs:e,backend:n}=t,{x:i}=e;if("complex64"===i.dtype){const t=f_({inputs:{input:i},backend:n}),e=o$({inputs:{x:t},backend:n}),r=M_({inputs:{input:i},backend:n}),s=o$({inputs:{x:r},backend:n}),o=zC({inputs:{real:e,imag:s},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return RE({attrs:{shape:i.shape,dtype:i.dtype,value:"string"===i.dtype?"":0},backend:n})}const a$={kernelName:li,backendName:"webgl",kernelFunc:o$};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l$={kernelName:tn,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:i}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const e=f_({inputs:{input:r},backend:i}),n=t({inputs:{x:e},backend:i}),s=M_({inputs:{input:r},backend:i}),o=o$({inputs:{x:s},backend:i}),a=zC({inputs:{real:n,imag:o},backend:i});return i.disposeIntermediateTensorInfo(e),i.disposeIntermediateTensorInfo(n),i.disposeIntermediateTensorInfo(s),i.disposeIntermediateTensorInfo(o),a}return RE({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:i})}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c$={kernelName:nn,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{axis:r}=i;if(1===e.length)return CE({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const s=e[0].shape,o=e[0].dtype;e.forEach((t=>{u(s,t.shape,"All tensors passed to stack must have matching shapes"),c(o===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const a=[],l=e.map((t=>{const e=CE({inputs:{input:t},backend:n,attrs:{dim:r}});return a.push(e),e})),h=A_({inputs:l,backend:n,attrs:{axis:r}});return a.forEach((t=>n.disposeIntermediateTensorInfo(t))),h}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class u${constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const i=t.length,r=zS(i),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),a=aC("rc",i),l=aC("source",i),c=`${a[i-1]} < ${this.outputShape[i-1]}`,u=1===i?"source":`vec2(${l.slice(-2).join()})`,h=[`${r} rc = outputLoc;`,`${a[i-1]} += 1;\n       if(${c}) {\n      `,1===i?"":`}\n       rc = outputLoc;\n       ${a[i-2]} += 1;\n       if(${a[i-2]} < ${this.outputShape[i-2]}) {`,1===i?"":`  ${a[i-1]} += 1;\n         if(${c}) {`],d=1===i?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let t=0,e=1===i?2:4;t<e;t++)p+=`\n        ${h[t]}\n        if (${d}) {\n          result[${t}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${t}] = getChannel(getX(${l.join()}), ${u});\n        }\n      `;p+=1===i?"} ":"}}",this.userCode=`\n      const ${r} start = ${r}(${s});\n      const ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h$=t=>{const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{paddings:s,constantValue:o}=i;if(0===d(r.shape)){const t=s.map(((t,e)=>t[0]+r.shape[e]+t[1]));return RE({backend:n,attrs:{shape:t,value:o,dtype:r.dtype}})}const a=Y().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new u$(r.shape,s,o):new class{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const i=t.length,r=zS(i),s=e.map((t=>t[0])).join(","),o=e.map(((e,n)=>e[0]+t[n])).join(","),a=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);this.userCode=1!==i?`\n      ${r} start = ${r}(${s});\n      ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${a}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}(r.shape,s,o),l=[[o]];return n.runWebGLProgram(a,[r],r.dtype,l)},d$={kernelName:rn,backendName:"webgl",kernelFunc:h$},p$=KC({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+OC+"\n  return result;\n"}),f$={kernelName:sn,backendName:"webgl",kernelFunc:p$};const m$={kernelName:an,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,keepDims:o}=i,a=r.shape.length,l=[],c=w(s,r.shape);let u=c;const h=fl(u,a);let p,f=r;if(null!=h&&(f=pT({inputs:{x:r},backend:n,attrs:{perm:h}}),u=gl(u.length,a),l.push(f)),pl("prod",u,a),n.shouldExecuteOnCPU([f])){const t=n.texData.get(f.dataId).values,{outVals:e,outShape:i,outDtype:r}=Lk(f.shape,f.dtype,t,u);p=n.makeTensorInfo(i,r,e)}else{const[t,e]=hl(f.shape,u),i=d(e),s=iT({inputs:{x:f},backend:n,attrs:{shape:[-1,i]}}),o=aT(s,jr(r.dtype),"prod",n);p=iT({inputs:{x:o},backend:n,attrs:{shape:t}}),l.push(s),l.push(o)}if(o){l.push(p);const t=dl(p.shape,c);p=iT({inputs:{x:p},backend:n,attrs:{shape:t}})}return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),p}};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g$={kernelName:ln,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{paramsNestedSplits:r,paramsDenseValues:s,indices:o}=e,{outputRaggedRank:a}=i,l=r.map((t=>n.readSync(t.dataId))),c=r.map((t=>t.shape)),u=n.readSync(s.dataId),h=n.readSync(o.dataId),[d,p,f]=Dk(l,c,u,s.shape,s.dtype,h,o.shape,a),m=d.map((t=>n.makeTensorInfo([t.length],"int32",t))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y$={kernelName:cn,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{starts:i,limits:r,deltas:s}=e,o=n.readSync(i.dataId),a=n.readSync(r.dataId),l=n.readSync(s.dataId),[c,u]=Fk(o,i.shape,i.dtype,a,r.shape,l,s.shape);return[n.makeTensorInfo([c.length],"int32",c),n.makeTensorInfo([u.length],i.dtype,u)]}};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b$={kernelName:un,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{shape:r,values:s,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=i,c=n.readSync(r.dataId),u=n.readSync(s.dataId),h=n.readSync(o.dataId),d=a.map((t=>n.readSync(t.dataId))),p=a.map((t=>t.shape)),[f,m]=zk(c,r.shape,u,s.shape,s.dtype,h,o.shape,d,p,l);return n.makeTensorInfo(f,s.dtype,m)}},v$=t=>{const{backend:e,attrs:n}=t,{start:i,stop:r,step:s,dtype:o}=n,a=Bk(i,r,s,o);return e.makeTensorInfo([a.length],o,a)},x$={kernelName:hn,backendName:"webgl",kernelFunc:v$},w$=XC({opSnippet:"return 1.0 / x;"}),S$={kernelName:pn,backendName:"webgl",kernelFunc:w$},k$=XC({opSnippet:fC+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),C$={kernelName:fn,backendName:"webgl",kernelFunc:k$},T$=XC({opSnippet:fC+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),_$={kernelName:xn,backendName:"webgl",kernelFunc:T$};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class E${constructor(t,e,n,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,a,l]=t;this.outputShape=[s,e,n,l];const c=[i&&e>1?o-1:o,i&&n>1?a-1:a],u=[i&&e>1?e-1:e,i&&n>1?n-1:n];let h;h=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/u[0]},\n          ${c[1]/u[1]},\n          ${c[1]/u[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${a}.0,\n                                     ${a}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M$={kernelName:bn,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r}=e,{alignCorners:s,halfPixelCenters:o,size:a}=i,[l,c]=a,u=Y().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new E$(r.shape,l,c,s,o):new class{constructor(t,e,n,i,r){this.variableNames=["A"],this.outputShape=[];const[s,o,a,l]=t;this.outputShape=[s,e,n,l];const c=[i&&e>1?o-1:o,i&&n>1?a-1:a],u=[i&&e>1?e-1:e,i&&n>1?n-1:n];let h;h=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/u[0]},\n          ${c[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}(r.shape,l,c,s,o);return n.runWebGLProgram(u,[r],"float32")}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $$={kernelName:vn,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r,dy:s}=e,{alignCorners:o}=i,a=new class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,r]=e,[,s,o]=t,a=[n&&s>1?i-1:i,n&&o>1?r-1:r],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],c=a[0]/l[0],u=a[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${u});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}(s.shape,r.shape,o);return n.runWebGLProgram(a,[s],s.dtype)}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class I${constructor(t,e,n,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,a,l]=t;this.outputShape=[s,e,n,l];const c=[i&&e>1?o-1:o,i&&n>1?a-1:a],u=[i&&e>1?e-1:e,i&&n>1?n-1:n],h=i?"0.5":"0.0";let d;d=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/u[0]},\n          ${c[1]/u[1]},\n          ${c[1]/u[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${a}.0,\n                                     ${a}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A$={kernelName:gn,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r}=e,{alignCorners:s,halfPixelCenters:o,size:a}=i,[l,c]=a,u=Y().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new I$(r.shape,l,c,s,o):new class{constructor(t,e,n,i,r){this.variableNames=["A"],this.outputShape=[];const[s,o,a,l]=t;this.outputShape=[s,e,n,l];const c=[i&&e>1?o-1:o,i&&n>1?a-1:a],u=[i&&e>1?e-1:e,i&&n>1?n-1:n],h=i?"0.5":"0.0";let d;d=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/u[0]},\n          ${c[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}(r.shape,l,c,s,o);return n.runWebGLProgram(u,[r],r.dtype)}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N$={kernelName:yn,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r,dy:s}=e,{alignCorners:o}=i,a=new class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,r]=e,[,s,o]=t,a=[n&&s>1?i-1:i,n&&o>1?r-1:r],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],c=a[0]/l[0],u=a[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${u});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${a[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${a[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${i}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}(s.shape,r.shape,o);return n.runWebGLProgram(a,[s],s.dtype)}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class R${constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const i=aC("rc",n),r=`${i[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${i[n-2]} + 1 < ${this.outputShape[n-2]}`,o=zS(n);function a(n){const i=t.map(((i,r)=>function(n,i){return-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - ${i[n]} - 1`:`${i[n]}`}(r,n)));return`getChannel(getX(${i.join(",")}), vec2(${i.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(t){return a(t)}(i.slice())};\n          if(${r}){\n            result.g = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",a(t)}(i.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(t){return t[n-2]="("+t[n-2]+" + 1)",a(t)}(i.slice())};\n            if(${r}) {\n              result.a = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",a(t)}(i.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P$={kernelName:wn,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{dims:s}=i,o=r.shape.length,a=w(s,r.shape);if(0===o)return DC({inputs:{x:r},backend:n});const l=Y().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new R$(r.shape,a):new class{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const i=t.map(((n,i)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - coords[${n}] - 1`:`coords[${n}]`)(i))).join(","),r=zS(n);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}(r.shape,a);return n.runWebGLProgram(l,[r],r.dtype)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const O$={kernelName:hi,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:i}=t,{radians:r,fillValue:s,center:o}=e,a=n,l=new class{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=t[1],i=t[2];this.outputShape=t;let r="";r="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}(i.shape,s),[c,u]=ff(o,i.shape[1],i.shape[2]),h=[[c,u,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[i],i.dtype,h)}},L$=XC({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),D$={kernelName:Sn,backendName:"webgl",kernelFunc:L$},F$=XC({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Uk}),z$={kernelName:kn,backendName:"webgl",kernelFunc:F$};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let B$=class{constructor(t,e,n,i,r,s,o=!0,a=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const l=zS(r.length),c=zS(s.length);let u="";1===n?u="i":2===n&&(u="i, j");const h=`getIndices(${u})`;let d="";1===i?d="i":2===i&&(d="i, coords[1]");const p=`getUpdates(${d})`;let f="";a&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,g=e>1?"strides[j]":"strides";this.userCode=`\n        ${l} strides = ${l}(${r});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(${h});\n              flattenedIndex += index * ${g};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(${m}, sum, float(found)));\n        }\n      `}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U${constructor(t,e,n,i,r,s,o=!0,a=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;const l=zS(r.length),c=zS(s.length);let u="";1===n?u="i":2===n&&(u="i, j");const h=`getIndices(${u})`;let d="";1===i?d="i":2===i&&(d="i, coords[1]");const p=`getUpdates(${d})`;let f="";a&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,g=e>1?"strides[j]":"strides",y=e>1?"strides[j + 1]":"strides";this.userCode=`\n        ${l} strides = ${l}(${r});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${t}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(${h});\n              flattenedIndex += index.xz * ${g};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${y};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${p};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${m}, sum, found));\n        }\n      `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V$={kernelName:Cn,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{indices:r,updates:s}=e,{shape:o}=i,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=hh(0,r,o),d=[h/c,c];if(0===h)return n.makeTensorInfo(o,r.dtype);const p=iT({inputs:{x:r},backend:n,attrs:{shape:[l,a]}}),f=iT({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=Y().getBool("WEBGL_PACK")?new U$(l,a,p.shape.length,f.shape.length,u,d):new B$(l,a,p.shape.length,f.shape.length,u,d);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=iT({inputs:{x:y},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W$={kernelName:_n,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{sortedSequence:r,values:s}=e,{side:o}=i,a=new class{constructor(t,e,n,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,n];const r=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,s=2===Y().getNumber("WEBGL_VERSION")?"while (left < right) {":r,o="left"===i?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${o} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}(r.shape[0],r.shape[1],s.shape[1],o),l=[[r.shape[1]]];return n.runWebGLProgram(a,[r,s],"int32",l)}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H$={kernelName:En,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n}=t,{condition:i,t:r,e:s}=e,o=new class{constructor(t,e,n){let i,r;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)r="resRC",i="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],o=[];for(let i=0;i<e.length;i++)o.push(`${n[i]}`),i<t&&s.push(`${n[i]}`);i=s.join(),r=o.join()}const s=zS(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${i});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}}(i.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(o,[i,r,s],Hr(r.dtype,s.dtype))}},j$=XC({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = ${wf};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),G$={kernelName:Mn,backendName:"webgl",kernelFunc:j$},q$=XC({opSnippet:qC+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Wk}),X$={kernelName:Rn,backendName:"webgl",kernelFunc:q$},K$=XC({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Y$={kernelName:Nn,backendName:"webgl",kernelFunc:K$},Z$=XC({opSnippet:qC+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${OC}\n  return result;\n`}),J$={kernelName:In,backendName:"webgl",kernelFunc:Z$},Q$=XC({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),tI={kernelName:An,backendName:"webgl",kernelFunc:Q$},eI=XC({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),nI={kernelName:Pn,backendName:"webgl",kernelFunc:eI},iI={kernelName:Dn,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{blockShape:s,paddings:o}=i;c(r.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const a=s.reduce(((t,e)=>t*e)),l=[[0,0]];l.push(...o);for(let t=1+s.length;t<r.shape.length;++t)l.push([0,0]);const u=[],h=h$({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),d=mf(h.shape,s,a,!1),p=gf(d.length,s.length,!1),f=yf(h.shape,s,a,!1),m=iT({inputs:{x:h},backend:n,attrs:{shape:d}}),g=pT({inputs:{x:m},backend:n,attrs:{perm:p}}),y=iT({inputs:{x:g},backend:n,attrs:{shape:f}});return u.push(h),u.push(m),u.push(g),u.forEach((t=>n.disposeIntermediateTensorInfo(t))),y}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rI={kernelName:Bn,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n}=t,{indices:i,values:r,denseShape:s,defaultValue:o}=e;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==i.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${i.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=n.readSync(i.dataId),l=n.readSync(r.dataId),c=n.readSync(s.dataId),u=n.readSync(o.dataId)[0],[h,d,p,f,m]=Gk(a,i.shape,i.dtype,l,r.dtype,c,u);return[n.makeTensorInfo(d,i.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((t=>Number(t))))),n.makeTensorInfo([m.length],i.dtype,new Int32Array(m))]}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sI={kernelName:Un,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:i,inputShape:r,newShape:s}=e;if(2!==i.shape.length)throw new Error(`Input indices should be a matrix but received shape ${i.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(n.readSync(r.dataId)),a=n.readSync(i.dataId),l=Array.from(n.readSync(s.dataId)),[c,u,h]=qk(a,i.shape,i.dtype,o,l);return[n.makeTensorInfo(u,i.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oI={kernelName:Vn,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:i,indices:r,segmentIds:s}=e;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const o=n.readSync(i.dataId),a=n.readSync(r.dataId),l=n.readSync(s.dataId),[c,u]=Xk(o,i.shape,i.dtype,a,l,!0);return n.makeTensorInfo(u,i.dtype,c)}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aI={kernelName:Wn,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:i,indices:r,segmentIds:s}=e;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const o=n.readSync(i.dataId),a=n.readSync(r.dataId),l=n.readSync(s.dataId),[c,u]=Xk(o,i.shape,i.dtype,a,l);return n.makeTensorInfo(u,i.dtype,c)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lI={kernelName:Hn,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{sparseIndices:r,sparseValues:s,defaultValue:o}=e,{outputShape:a}=i,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=hh(0,r,a);if("string"===s.dtype){const t=n.bufferSync(r),e=n.bufferSync(s),i=yr(n.readSync(o.dataId)[0]),p=Vk(t,e,a,d,u,c,l,h,i,false);return n.makeTensorInfo(a,p.dtype,p.values)}const p=new B$(c,l,r.shape.length,s.shape.length,h,[d,1],false),f=n.runWebGLProgram(p,[s,r,o],s.dtype),m=iT({inputs:{x:f},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(f),m}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cI={kernelName:Fn,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{numOrSizeSplits:s,axis:o}=i,a=w(o,r.shape)[0],l=Gf(r,s,a),c=r.shape.length,u=new Array(c).fill(0),h=r.shape.slice();return l.map((t=>{const e=[...h];e[a]=t;const i=o_({inputs:{x:r},backend:n,attrs:{begin:u,size:e}});return u[a]+=t,i}))}},uI="return sqrt(x);",hI=XC({opSnippet:uI,packedOpSnippet:uI,cpuKernelImpl:Kk}),dI={kernelName:On,backendName:"webgl",kernelFunc:hI},pI={kernelName:Gn,backendName:"webgl",kernelFunc:XC({opSnippet:"return x * x;"})},fI="return (a - b) * (a - b);",mI=KC({opSnippet:fI,packedOpSnippet:fI}),gI={kernelName:jn,backendName:"webgl",kernelFunc:mI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yI={kernelName:qn,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e;if("string"!==r.dtype)throw new Error("Input must be of datatype string");const s=cm(n.readSync(r.dataId)),o=Yk(s,"string",i);return n.makeTensorInfo(r.shape,"string",o)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bI={kernelName:ci,backendName:"webgl",kernelFunc:function({inputs:t,attrs:e,backend:n}){const{x:i}=t,r=fC+`\n    return x > 0.0 ? 1.0 : float(${e.alpha});\n  `,s=new pC(i.shape,r);return n.runWebGLProgram(s,[i],i.dtype)}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vI={kernelName:Xn,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{begin:s,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=i,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=Zp(r.shape,s,o,a,l,u,h,d,p);let S;if(g)S=iT({inputs:{x:r},backend:n,attrs:{shape:m}});else if(y||b){c(r.shape.length>=1,(()=>`Input must have rank at least 1, got: ${r.shape.length}`));const t=zp(v,x,w),e=o_({inputs:{x:r},backend:n,attrs:{begin:v,size:t}});S=iT({inputs:{x:e},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(e)}else{if(n.shouldExecuteOnCPU([r])){const t=n.readSync(r.dataId),e=bo(r.shape,r.dtype,t),i=Zk(f,e,w,v);S=n.makeTensorInfo(m,r.dtype,i.values)}else{const t=new class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const i=n.length,r=zS(n.length),s=zS(n.length);let o="";if(1===i)o="coords * strides + begin";else{let t=0;o=n.map(((e,i)=>(t++,1===n.length?`coords * strides[${i}] + begin[${i}]`:`coords[${t-1}] * strides[${i}] + begin[${i}]`))).join(",")}this.userCode=`\n      ${r} begin = ${r}(${t});\n      ${r} strides = ${r}(${e});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}(v,w,f);S=n.runWebGLProgram(t,[r],r.dtype)}}const k=iT({inputs:{x:S},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(S),k}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xI={kernelName:Kn,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{separator:r,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=i,{data:u,dataSplits:h}=e,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,m]=Jk(d,p,r,s,o,a,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wI={kernelName:Yn,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{skipEmpty:r}=i,{input:s,delimiter:o}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=n.readSync(s.dataId),l=n.readSync(o.dataId)[0],[c,u,h]=Qk(a,l,r),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SI={kernelName:Zn,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{numBuckets:r}=i,{input:s}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(s.dataId),a=tC(o,r);return n.makeTensorInfo(s.shape,"int32",a)}},kI=XC({opSnippet:"return tan(x);"}),CI={kernelName:Qn,backendName:"webgl",kernelFunc:kI},TI=XC({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),_I={kernelName:ti,backendName:"webgl",kernelFunc:TI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EI={kernelName:Tn,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{tensor:r,indices:s,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=hh(0,s,r.shape),d=[h/c,c];if(0===h)return n.makeTensorInfo(r.shape,s.dtype);const p=iT({inputs:{x:s},backend:n,attrs:{shape:[l,a]}}),f=iT({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),m=iT({inputs:{x:r},backend:n,attrs:{shape:d}}),g=new B$(l,a,p.shape.length,f.shape.length,u,d,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=iT({inputs:{x:y},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MI=class{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*e[i];this.outputShape=n,this.rank=n.length;const i=zS(this.rank),r=function(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],i=[];for(let e=0;e<t.length;e++)i.push(`imod(${n[e]}, ${t[e]})`);return i.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(t);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}};function $I(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{reps:s}=i;if("string"===r.dtype||r.shape.length>5){const t=n.readSync(r.dataId),e="string"===r.dtype?t.map((t=>yr(t))):t,i=bo(r.shape,r.dtype,e),o=nC(i,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new MI(r.shape,s);return n.runWebGLProgram(o,[r],r.dtype)}const II={kernelName:ei,backendName:"webgl",kernelFunc:$I};let AI=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function NI(t,e){null!==e&&t.disposeIntermediateTensorInfo(e)}function RI(t){let e=1;for(;e<t;)e*=2;return e}const PI={kernelName:ni,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{k:s,sorted:o}=i,a=Y().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Y().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,u=c[c.length-1];if(n.shouldExecuteOnCPU([r])||u<a||s>l){const t=n.readSync(r.dataId),[e,i]=iC(t,c,r.dtype,s,o);return[n.makeTensorInfo(e.shape,e.dtype,e.values),n.makeTensorInfo(i.shape,i.dtype,i.values)]}if(0===s)return c[c.length-1]=0,[n.makeTensorInfo(c,r.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(1===u)return[r,RE({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const h=n.texData.get(r.dataId),p=null!==h&&h.isPacked,f=p?n.unpackTensor(r):r,m=d(c)/u,g=iT({inputs:{x:f},attrs:{shape:[m,u]},backend:n});p&&NI(n,f);const y=RI(s),b=RI(u);let v=null;const x=()=>null===v?[g,g]:[g,v],w=(t,e,i)=>{const r=x(),s=new class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}(i),o=[[u],[null===v?1:0],[Number.NEGATIVE_INFINITY],[t],[e]],a=v;v=n.runWebGLProgram(s,r,"int32",o),NI(n,a)};for(let t=1;t<y;t*=2){const e=2*t;for(let n=t;n>=1;n/=2)w(e,n,[m,b])}for(let t=b;t>y;t/=2){const e=x(),i=new AI([m,t/2]),r=[[u],[null===v?1:0],[y]],s=v;v=n.runWebGLProgram(i,e,"int32",r),NI(n,s);const o=y/2,a=2*o;for(let t=o;t>=1;t/=2)w(a,t,v.shape)}let S=v;v=o_({inputs:{x:v},backend:n,attrs:{begin:0,size:[m,s]}}),NI(n,S);let k=KE({inputs:{x:g,indices:v},backend:n,attrs:{axis:1,batchDims:1}});NI(n,g);const C=c.slice(0,-1);C.push(s),S=v,v=iT({inputs:{x:v},attrs:{shape:C},backend:n}),NI(n,S);const T=k;return k=iT({inputs:{x:k},attrs:{shape:C},backend:n}),NI(n,T),[k,v]}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OI={kernelName:ii,backendName:"webgl",kernelFunc:
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{image:r,transforms:s}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=i,[u,h,d,p]=r.shape,[f,m]=null!=c?c:[h,d],g=[u,f,m,p],y=new class{constructor(t,e,n,i,r,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const o="nearest"===n?1:2;let a;switch(i){case"constant":default:a=1;break;case"reflect":a=2;break;case"wrap":a=3;break;case"nearest":a=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${a} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}(h,d,o,a,l,g);return n.runWebGLProgram(y,[r,s],"float32")}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LI={kernelName:si,backendName:"webgl",kernelFunc:function(t){const{inputs:e,attrs:n,backend:i}=t,{axis:r}=n,{x:s}=e;xS(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=i.readSync(s.dataId),{outputValues:a,outputShape:l,indices:c}=sC(o,r,s.shape,s.dtype);return[i.makeTensorInfo(l,s.dtype,a),i.makeTensorInfo([c.length],"int32",c)]}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DI={kernelName:oi,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{value:r}=e;let{axis:s}=i;s<0&&(s+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[s],c=new Array(a-1);let u=0;for(let t=0;t<a;t++)t!==s&&(c[u++]=o.shape[t]);const h=[],d=new Array(a).fill(0),p=o.shape.slice();p[s]=1;const f=new Array(l);for(let t=0;t<f.length;t++){d[s]=t;const e=o_({inputs:{x:o},backend:n,attrs:{begin:d,size:p}}),i=iT({inputs:{x:e},backend:n,attrs:{shape:c}});f[t]=i,h.push(e)}return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),f}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FI{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,i=t.batchSize,r=t.inSize,s=t.numSegments,o=s*Math.ceil(r/n);this.outputShape=[i,o];const a=4*Math.floor(n/4),l=n%4,c="\n        sumValue += dot(values, segFilter);\n    ";let u="";r%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let h="";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${c}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${c}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zI={kernelName:ai,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,segmentIds:s}=e,{numSegments:o}=i,a=r.shape.length,l=[];let c=0;const u=fl([c],a);let h=r;null!=u&&(h=pT({inputs:{x:r},backend:n,attrs:{perm:u}}),l.push(h),c=gl(1,a)[0]);const p=om(h.shape,c,o),f=d([h.shape[c]]),m=iT({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}});l.push(m);const g=jr(r.dtype),y=(t,e,i,r,s)=>{const o=t.shape[0],a=t.shape[1],c=sm(a,s),u=new FI({windowSize:c,inSize:a,batchSize:o,numSegments:s},e),h=n.compileAndRun(u,[t,i],r);if(l.push(h),h.shape[1]===s)return h;const d=v$({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=$I({inputs:{x:d},backend:n,attrs:{reps:[a/c]}});l.push(d),l.push(p);return y(h,e,p,r,s)},b=iT({inputs:{x:y(m,"unsortedSegmentSum",s,g,o)},backend:n,attrs:{shape:p}});let v=b;if(null!=u){l.push(b);const t=ml(u);v=pT({inputs:{x:v},backend:n,attrs:{perm:t}})}return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),v}},BI=[yT,vT,wT,kT,_T,MT,$T,IT,LT,DT,zT,UT,WT,jT,qT,YT,ZT,JT,QT,t_,n_,l_,c_,u_,h_,y_,x_,S_,BC,C_,N_,B_,U_,W_,H_,j_,G_,X_,Y_,Z_,iE,rE,sE,oE,cE,uE,hE,dE,pE,fE,gE,yE,vE,wE,kE,TE,ME,AE,PE,OE,FE,BE,VE,jE,GE,qE,YE,JE,tM,FC,eM,$_,iM,sM,aM,WC,cM,hM,dM,fM,gM,bM,xM,SM,CM,TM,EM,$M,IM,AM,NM,RM,PM,OM,LM,FM,BM,VM,YM,nT,JM,t$,n$,r$,p_,s$,l$,c$,d$,f$,GC,m$,g$,y$,b$,x$,m_,HM,S$,C$,_$,rT,M$,$$,A$,N$,P$,O$,D$,z$,V$,W$,H$,G$,X$,Y$,J$,tI,a_,KM,nI,iI,rI,sI,oI,aI,lI,cI,dI,pI,gI,yI,bI,vI,xI,wI,SI,qM,dT,CI,_I,EI,II,PI,OI,fT,LI,DI,zI,a$];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */for(const t of BI)wi(t);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UI=Y();UI.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(()=>15)),UI.registerFlag("WEBGPU_CPU_FORWARD",(()=>!0)),UI.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",(()=>-1)),UI.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(()=>!0)),UI.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(()=>!1)),UI.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e3)),UI.registerFlag("WEBGPU_USE_PROFILE_TOOL",(()=>!1)),UI.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",(()=>!0)),UI.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",(()=>!1)),UI.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",(()=>-1)),UI.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",(()=>!1)),UI.registerFlag("WEBGPU_PRINT_SHADER",(()=>"")),UI.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",(()=>!1));
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class VI{constructor(t){t&&(this.vendor=t.vendor,this.architecture=t.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return"intel"===this.vendor}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WI{constructor(t){this.device=t,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(t,e,n=!1,i=!0){let r;const s=HI(t,e);return i?(this.freeBuffers.has(s)||this.freeBuffers.set(s,[]),this.freeBuffers.get(s).length>0?(r=this.freeBuffers.get(s).pop(),this.numFreeBuffers--):(r=this.device.createBuffer({size:t,usage:e,mappedAtCreation:n}),this.numBytesAllocated+=t)):(r=this.device.createBuffer({size:t,usage:e,mappedAtCreation:n}),this.numBytesAllocated+=t),this.usedBuffers.has(s)||this.usedBuffers.set(s,[]),this.usedBuffers.get(s).push(r),this.numUsedBuffers++,this.numBytesUsed+=t,r}releaseBuffer(t,e=!0){if(0===this.freeBuffers.size)return;const n=t.size,i=HI(n,t.usage),r=this.usedBuffers.get(i),s=r.indexOf(t);if(s<0)throw new Error("Cannot find the buffer in buffer manager");r[s]=r[r.length-1],r.pop(),this.numUsedBuffers--,this.numBytesUsed-=n,e?(this.freeBuffers.get(i).push(t),this.numFreeBuffers++):(t.destroy(),this.numBytesAllocated-=n)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach(((t,e)=>{t.forEach((t=>{t.destroy()}))})),this.usedBuffers.forEach(((t,e)=>{t.forEach((t=>{t.destroy()}))})),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function HI(t,e){return`${t}_${e}`}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jI{constructor(t){this.device=t,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(t,e,n,i){const r=t*e*qI(n),s=GI(t,e,n,i);if(this.freeTextures.has(s)||this.freeTextures.set(s,[]),this.usedTextures.has(s)||this.usedTextures.set(s,[]),this.numBytesUsed+=r,this.numUsedTextures++,this.freeTextures.get(s).length>0){this.numFreeTextures--;const t=this.freeTextures.get(s).shift();return this.usedTextures.get(s).push(t),t}this.numBytesAllocated+=r;const o=this.device.createTexture({size:[t,e],format:n,usage:i});return this.usedTextures.get(s).push(o),o}releaseTexture(t){if(0===this.freeTextures.size)return;const e=t.width,n=t.height,i=t.format,r=GI(e,n,i,t.usage);this.freeTextures.has(r)||this.freeTextures.set(r,[]),this.freeTextures.get(r).push(t),this.numFreeTextures++,this.numUsedTextures--;const s=this.usedTextures.get(r),o=s.indexOf(t);if(o<0)throw new Error("Cannot release a texture that was never provided by this texture manager");s.splice(o,1);const a=e*n*qI(i);this.numBytesUsed-=a}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach(((t,e)=>{t.forEach((t=>{t.destroy()}))})),this.usedTextures.forEach(((t,e)=>{t.forEach((t=>{t.destroy()}))})),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function GI(t,e,n,i){return`${t}_${e}_${n}_${i}`}function qI(t){if("rgba8unorm"===t)return 16;throw new Error(`${t} is not supported!`)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XI(t,e){if(Math.max(...t)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const n=t.length,i=t.map((t=>`${e}.${"xyzwuv"[t]}`)),r=new Array(n-1);r[n-2]=i[n-1];for(let t=n-3;t>=0;--t)r[t]=`(${r[t+1]} * ${i[t+1]})`;return r}const KI=(t,e,n)=>"int32"===n?`atomicAdd(${t}, bitcast<i32>(${e}));`:`\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (${e});\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(${t}, oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }`;
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var YI;!function(t){t[t.FROM_PIXELS=0]="FROM_PIXELS",t[t.DRAW=1]="DRAW"}(YI||(YI={}));const ZI=(t,e,n,i,r)=>{const s=function(t,e,n){const i=[],r=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(n.outputComponent=n.outputComponent?n.outputComponent:1,i.push(`\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${aA(n)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${r}u +\n                localIndex);\n        `}\n      }\n    `),null!=n.pixelsOpType){const r=n.pixelsOpType===YI.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${lA(e.dtype,n.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${lA(t[0].dtype,n.outputComponent)}>;`,s=3===e.shape.length?"vec2<i32>":"i32";i.push(`\n        struct Uniform {\n          outShapeStrides : ${s},\n          size            : i32,\n          numChannels     : i32,\n          alpha           : f32,\n        };\n\n        ${r}\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `);const o=cA(n);return[iA,i.join("\n"),sA(e.shape),n.getUserCode(),nA(o,n)].join("\n")}let s,o,a="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach(((e,n)=>{const i=QI(t[n].shape.length);a+=`${e.charAt(0).toLowerCase()+e.slice(1)}Shape : ${i}, `,s=t[n].shape.length-1,o=QI(s),a+=`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides: ${o}, `}));const l=QI(e.shape.length);a+=`outShape : ${l}, `,s=e.shape.length-1,o=QI(s),a+=`\n         outShapeStrides: ${o}, `,n.size&&(a+="size : i32, ");n.uniforms&&(a+=n.uniforms);a+="};",a=function(t){const e=/(\w+)\s*:\s*vec(5|6)/g;t=t.replace(e,(t=>"@align(16) "+t));const n=/vec(5|6)\s*,\s*(\w+)/g;return t=t.replace(n,((t,e,n)=>`vec${e}, @align(16) ${n}`))}(a),i.push(a),n.atomic?i.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):i.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${lA(e.dtype,n.outputComponent)}>;\n    `);n.variableNames.forEach(((e,r)=>{i.push(`\n      @group(0) @binding(${1+r}) var<storage, read> ${e}: array<${n.variableComponents?lA(t[r].dtype,n.variableComponents[r]):lA(t[r].dtype,n.outputComponent)}>;\n        `)})),""!==a&&i.push(`\n      @group(0) @binding(${1+n.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);const c=function(t,e){const{x:n,y:i=[],z:r=[]}=e,s=t.length,o=n.length+i.length+r.length;if(o!==s)return"";if(n.length===s){return`fn getOutputCoords() -> ${QI(s)}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `}let a="";const l=[n,i,r];for(let t=0;t<l.length;t++){const e=l[t];if(0!==e.length)if(1===e.length)a+=`let d${e[0]} = i32(globalId[${t}]);`;else{const n=XI(e,"uniforms.outShape");a+=`var index${t} = i32(globalId[${t}]);`;for(let i=0;i<n.length;i++)a+=`let d${e[i]} = index${t} / ${n[i]};`,i===n.length-1?a+=`let d${e[i+1]} = index${t} - d${e[i]} * ${n[i]};`:a+=`index${t} = index${t} - d${e[i]} * ${n[i]};`}}const c=[];for(let t=0;t<o;t++)c.push(`d${t}`);const u=QI(o);let h=`fn getOutputCoords() -> ${u} {\n  ${a}\n`;0===c.length?h+=`return ${u}(0); }`:h+=`return ${u}(${c.join(",")}); }`;return h}(e.shape,n.dispatchLayout),u=[iA,i.join("\n")+rA,sA(e.shape),c,oA(e.shape.length)];n.atomic||u.push(function(t,e,n){const i=t.length,r=lA(e,n);let s=`fn setOutputAtIndex(flatIndex : i32, value : ${JI(n)}) {\n      result[flatIndex] = ${r}(value);\n    }\n\n    fn setOutputAtIndexI32(flatIndex : i32, value : ${JI(n,"i32")}) {\n      result[flatIndex] = ${r}(value);\n    }\n    `;if(i>=2){const t=["d0","d1","d2","d3","d4","d5"].slice(0,i),e=QI(i);s+=`\n      fn setOutputAtCoords(${t.map((t=>`${t} : i32`)).join(", ")}, value : ${JI(n)}) {\n        let flatIndex = getOutputIndexFromCoords(${e}(${t.join(", ")}));\n        setOutputAtIndex(flatIndex${1===n?"":` / ${n}`}, value);\n      }\n      fn setOutputAtCoordsI32(${t.map((t=>`${t} : i32`)).join(", ")}, value : ${JI(n,"i32")}) {\n        let flatIndex = getOutputIndexFromCoords(${e}(${t.join(", ")}));\n        setOutputAtIndexI32(flatIndex${1===n?"":` / ${n}`}, value);\n      }\n    `}return s}(e.shape,e.dtype,n.outputComponent));n.variableNames.forEach(((e,n)=>{u.push(`${sA(t[n].shape,e)}`)}));const h=t.map(((t,i)=>function(t,e,n,i){let r=function(t,e){const n=t.name,i=t.shape.length,r=QI(i),s="get"+n.charAt(0).toUpperCase()+n.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,i),a=o.map((t=>`${t} : i32`)).join(", ");if(i<1)return`\n      fn ${s}() -> ${JI(e)} {\n        return ${JI(e)}(${n}[0]);\n      }\n    `;const l=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let c=`${i}D`;0===i&&(c="1D");return`\n    fn ${s}(${a}) -> ${JI(e)} {\n      return ${JI(e)}(${n}[getIndexFromCoords${c}(${r}(${o.join(",")}),\n        ${l})${1===e?"":` / ${e}`}]);\n    }\n   `}(t,n);const s=t.shape;s.length<=e.length&&(r+=function(t,e,n,i){const r=t.name,s=r.charAt(0).toUpperCase()+r.slice(1),o="get"+s+"ByOutput",a=t.shape.length,l=e.length,c=QI(l);if(m(t.shape,e)&&i)return`\n    fn ${o}Index(globalIndex : i32) -> ${JI(n)} {\n      return ${JI(n)}(${r}[globalIndex]);\n    }\n\n    fn ${o}Coords(coords : ${c}) -> ${JI(n)} {\n      return ${JI(n)}(${r}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${1===n?"":` / ${n}`}]);\n    }\n    `;const u=Ya(t.shape,e),h=l-a;let d="";if(0===a)return`\n    fn ${o}Index(globalIndex : i32) -> ${JI(n)}{\n      return get${s}();\n    }\n\n    fn ${o}Coords(coords : ${c}) -> ${JI(n)}{\n      return get${s}();\n    }\n  `;d=l<2&&u.length>=1?"coords = 0;":u.map((t=>`coords.${tA(t+h)} = 0;`)).join("\n");let p="";if(l<2&&a>0)p="coords";else if(l>1){const e=QI(a),n=t.shape.map(((t,e)=>`coords.${tA(e+h)}`)).join(", ");p=`${e}(${n})`}else p="coords";const f=`uniforms.${r.charAt(0).toLowerCase()+r.slice(1)}Shape`,g=`${a}D`;return`\n  fn ${o}Index(globalIndex : i32) -> ${JI(n)} {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${d}\n    return ${JI(n)}(${r}[getIndexFromCoords${g}(${p}, ${f})${1===n?"":` / ${n}`}]);\n  }\n\n  fn ${o}Coords(coordsIn : ${c}) -> ${JI(n)} {\n    var coords = coordsIn;\n    ${d}\n    return ${JI(n)}(${r}[getIndexFromCoords${g}(${p}, ${f})${1===n?"":` / ${n}`}]);\n  }\n`}(t,e,n,i));return r}(t,e.shape,n.variableComponents?n.variableComponents[i]:n.outputComponent,n.dispatchLayout.x.length===e.shape.length))).join("\n");u.push(h),u.push(n.getUserCode());const d=cA(n);u.push(nA(d,n));const p=u.join("\n");return p}(n,{dtype:i.dtype,shape:i.shape},e),o=t.createShaderModule({code:s,label:e.constructor.name});let a=Y().get("WEBGPU_PRINT_SHADER");if(""!==a){a=a.toLowerCase();const t=a.split(",");("all"===a||t.some((t=>e.shaderKey.toLowerCase().includes(t))))&&(console.group(e.shaderKey),console.debug(s),console.groupEnd())}return r?t.createComputePipelineAsync({compute:{module:o,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):t.createComputePipeline({compute:{module:o,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},JI=(t,e="f32")=>{switch(t){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${t}-component ${e} is not supported.`)}};function QI(t){if(t<=1)return"i32";if(2===t)return"vec2<i32>";if(3===t)return"vec3<i32>";if(4===t)return"vec4<i32>";if(5===t)return"vec5";if(6===t)return"vec6";throw Error(`GPU for rank ${t} is not yet supported`)}function tA(t){if(0===t)return"x";if(1===t)return"y";if(2===t)return"z";if(3===t)return"w";if(4===t)return"u";if(5===t)return"v";throw Error(`Index ${t} is not yet supported`)}function eA(...t){let e;switch(t.length){case 0:e="\n        fn main()\n      ";break;case 1:e=`\n        fn main(${t[0]} : i32)\n      `;break;default:throw Error("Unreachable")}return e}function nA(t,e){let n;return n=`\n     ${function(t){return`\n  @compute @workgroup_size(${t.workgroupSize[0]}, ${t.workgroupSize[1]}, ${t.workgroupSize[2]})\n`}(e)}\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ${t?"main(getGlobalIndex());":"main();"};\n      }\n    `,n}const iA="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n",rA="\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n";function sA(t,e=""){const n=t.length,i=""!==e?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",r=""!==e?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(n<=1)return`fn ${i}(index : i32) -> i32 { return index; }`;const s=L(t),o=QI(n),a=[];for(let t=0;t<n;t++)a.push(`d${t}`);if(1===s.length)return`    fn ${i}(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.${r}; let d1 = index - d0 * uniforms.${r};\n      return vec2<i32>(d0, d1);\n    }`;let l;return l="var index2 = index;"+s.map(((t,e)=>`${`let ${a[e]} = index2 / uniforms.${r}.${tA(e)}`}; ${e===s.length-1?`let ${a[e+1]} = index2 - ${a[e]} * uniforms.${r}.${tA(e)}`:`index2 = index2 - ${a[e]} * uniforms.${r}.${tA(e)}`};`)).join(""),`\n    fn ${i}(index : i32) -> ${o} {\n      ${l}\n      return ${o}(${a.join(",")});\n    }\n  `}function oA(t){let e="";switch(t){case 0:case 1:e+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:e+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:e+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:e+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:e+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:e+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:c(!1,(()=>`Unsupported ${t}D shape`))}return e}function aA(t){return 1===t.dispatch[1]&&1===t.dispatch[2]}function lA(t,e=1){if("float32"===t)return JI(e,"f32");if("int32"===t||"bool"===t)return JI(e,"i32");throw new Error(`type ${t} is not supported.`)}function cA(t){return(!t.dispatchLayout.hasOwnProperty("y")||0===t.dispatchLayout.y.length)&&(!t.dispatchLayout.hasOwnProperty("z")||0===t.dispatchLayout.z.length)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uA=t=>{let e=1;for(let n=0;n<t.length;n++)e*=t[n];return e};function hA(t,e,n=[1,1,1],i=[1,1,1]){const[r,s,o]=[Math.ceil(uA(t.x.map((t=>e[t])))/(n[0]*i[0])),t.y?Math.ceil(uA(t.y.map((t=>e[t])))/(n[1]*i[1])):1,t.z?Math.ceil(uA(t.z.map((t=>e[t])))/(n[2]*i[2])):1];return[r,s,o]}function dA(t,e,n=!1){if(n)return[8,8,1];const i=uA(t.x.map((t=>e[t]))),r=uA(t.y.map((t=>e[t])));return i<=4?[4,16,1]:r<=4?[16,4,1]:[16,16,1]}function pA(t,e,n=!1){if(n)return[4,4,1];const i=uA(t.x.map((t=>e[t]))),r=uA(t.y.map((t=>e[t])));return i<=4?[1,2,1]:r<=4?[2,1,1]:[2,2,1]}function fA(t){return{x:t.map(((t,e)=>e))}}function mA(t){if("float32"===t||"int32"===t||"bool"===t||"string"===t)return 4;if("complex64"===t)return 8;throw new Error(`Unknown dtype ${t}`)}function gA(){return("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope)&&!!navigator.gpu}function yA(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&c("complex64"!==t.dtype,(()=>`${e} does not support complex64 tensors in the WebGPU backend.`))}))}var bA;!function(t){t[t.MatMulReduceProgram=0]="MatMulReduceProgram",t[t.MatMulSplitKProgram=1]="MatMulSplitKProgram",t[t.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",t[t.MatMulPackedProgram=3]="MatMulPackedProgram",t[t.MatMulMax=4]="MatMulMax"}(bA||(bA={}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const vA=Y().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class xA extends n{nextDataId(){return xA.nextDataId++}constructor(t,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!gA())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=t,this.queue=t.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new VI(n),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new WI(this.device),this.textureManager=new jI(this.device),this.tensorMap=new e(this,So()),Y().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:t,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(t,e=!1){if(!this.tensorMap.has(t))return!0;const n=this.tensorMap.get(t);return e?n.refCount=0:n.refCount--,!(n.refCount>0)&&(null!=n.complexTensorInfos&&(this.disposeData(n.complexTensorInfos.real.dataId),this.disposeData(n.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(t)?(this.tensorDataPendingDisposal.push(t),!0):(this.releaseResource(t),this.tensorMap.delete(t),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(t){const e=this.tensorMap.get(t);e&&e.resource&&(e.external||(e.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(e.resource):e.resource instanceof GPUTexture&&this.textureManager.releaseTexture(e.resource)),e.resource=null)}refCount(t){if(this.tensorMap.has(t)){return this.tensorMap.get(t).refCount}return 0}incRef(t){this.tensorMap.get(t).refCount++}decRef(t){if(this.tensorMap.has(t)){this.tensorMap.get(t).refCount--}}write(t,e,n){if("complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.tensorMap.set(i,{dtype:n,shape:e,values:t,refCount:1}),i}move(t,e,n,i,r){if("complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(t,{dtype:i,shape:n,values:e,refCount:r})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach((t=>{this.releaseResource(t),this.tensorMap.delete(t)})),this.uniformPendingDisposal.forEach((t=>this.bufferManager.releaseBuffer(t))),this.stagingPendingDisposal.forEach((t=>this.bufferManager.releaseBuffer(t,!1))),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let t;try{t=await Promise.all(Object.values(this.pipelineCache))}catch(t){throw new Error(t.message)}Object.keys(this.pipelineCache).map(((e,n)=>{this.pipelineCache[e]=t[n]}))}async getBufferData(t){if(Y().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const e=t.size,n=this.bufferManager.acquireBuffer(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(t,0,n,0,e),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const i=n.getMappedRange().slice(0);return n.unmap(),null!=n&&this.bufferManager.releaseBuffer(n),Y().getBool("WEBGPU_USE_PROFILE_TOOL")&&(c(void 0!==this.dummyContext,(()=>"Fail to get context for profiling tool")),this.dummyContext.getCurrentTexture()),i}convertAndCacheOnCPU(t,e){const n=this.tensorMap.get(t);return n.values=e,n.values}readSync(t){const e=this.tensorMap.get(t),{values:n,complexTensorInfos:i}=e;if(null!=n||"string"===e.dtype)return n;if("complex64"===e.dtype){const e=z(Mf(this.readSync(i.real.dataId),this.readSync(i.imag.dataId)).buffer,"float32");return this.convertAndCacheOnCPU(t,e),e}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const r=["opaque","premultiplied"],s=e.resource,o=s.size;c(o%4==0,(()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4."));const a=o/4,l=new ArrayBuffer(o),u=256,h=256,d=r.map((t=>new OffscreenCanvas(u,h))),p=new OffscreenCanvas(u,h);this.endComputePassEncoder(),d.map(((t,e)=>{const n=t.getContext("webgpu");return n.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:r[e]}),n.getCurrentTexture()})).map(((t,e)=>{const n=(n,i,o)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:s,bytesPerRow:1024,offset:o},{texture:t},{width:n,height:i}),this.submitQueue();const a=p.getContext("2d",{willReadFrequently:!0});a.clearRect(0,0,n,i),a.drawImage(d[e],0,0);const c=a.getImageData(0,0,n,i).data,u=r[e],h=new Uint8ClampedArray(l,o,n*i*4);for(let t=0;t<h.length;t+=4)if("premultiplied"===u)h[t+3]=c[t+3];else{const e=c[t];h[t]=c[t+2],h[t+1]=c[t+1],h[t+2]=e}},i=Math.floor(a/65536);let o=u,c=h,f=0;for(let t=0;t<i;t++)n(o,c,f),f+=262144;const m=a%65536;c=Math.floor(m/u),c>0&&(n(o,c,f),f+=1024*c),o=m%u,o>0&&n(o,1,f)}));const f=z(l,e.dtype);return this.convertAndCacheOnCPU(t,f),f}async read(t){if(!this.tensorMap.has(t))throw new Error(`Tensor ${t} was not registered!`);const e=this.tensorMap.get(t),{values:n}=e;if(null!=n)return n;let i;if("complex64"===e.dtype){const t=await Promise.all([this.read(e.complexTensorInfos.real.dataId),this.read(e.complexTensorInfos.imag.dataId)]);i=Mf(t[0],t[1])}else{i=z(await this.getBufferData(e.resource),e.dtype)}return this.convertAndCacheOnCPU(t,i),i}copyBuffer(t){const e=t.size,n=t.usage,i=this.bufferManager.acquireBuffer(e,n);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(t,0,i,0,e),this.submitQueue(),i}createTensorFromGPUData(t,e,n){let i=t.buffer;if("complex64"===n)throw new Error("Cannot write to a complex64 dtype. ");const r={id:this.nextDataId()};this.tensorMap.set(r,{dtype:n,shape:e,values:null,refCount:1,external:t.zeroCopy});const s=this.tensorMap.get(r),o=mA(s.dtype)*d(s.shape);if(t.buffer.size<o)throw new Error(`GPUBuffer size(${t.buffer.size}) is smaller than tensor size(${o})!`);if((t.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!=(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==t.zeroCopy&&(i=this.copyBuffer(i)),s.resource=i,So().makeTensorFromDataId(r,e,n,this)}readToGPU(t){const e=this.tensorMap.get(t),{values:n,dtype:i,shape:r,resource:s}=e;if("complex64"===i)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==s)throw null!=n?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=s,a=o.size,l=o.usage,c=this.bufferManager.acquireBuffer(a,l);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(s,0,c,0,a),this.submitQueue();const u=this.makeTensorInfo(r,i),h=So().makeTensorFromTensorInfo(u);return this.tensorMap.get(u.dataId).resource=c,{tensorRef:h,buffer:c}}bufferSync(t){const e=this.readSync(t.dataId);if("string"===t.dtype)try{const n=e.map((t=>yr(t)));return bo(t.shape,t.dtype,n)}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}return bo(t.shape,t.dtype,e)}async time(t){this.supportTimestampQuery||this.hasTimestampQueryWarned||(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const e=this.activeTimers,n=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=n,i=!0):this.activeTimers.push(n),this.activeTimers=n,t();const r=vr(this.activeTimers.map((t=>t.query))).filter((t=>null!=t)),s=vr(this.activeTimers.map((t=>t.name))).filter((t=>null!=t));this.activeTimers=e,i&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},a=await Promise.all(r);return o.kernelMs=l(a),o.getExtraProfileInfo=()=>a.map(((t,e)=>({name:s[e],ms:t}))).map((t=>`${t.name}: ${t.ms}`)).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}makeTensorInfo(t,e,n){"string"===e&&null!=n&&n.length>0&&I(n[0])&&(n=n.map((t=>gr(t))));return{dataId:this.write(n,t,e),shape:t,dtype:e}}tensorToBinding(t){if(!t)return null;const e=this.tensorMap.get(t.dataId).resource;return e instanceof GPUBuffer?{buffer:e}:e instanceof GPUTexture?e.createView():e}uploadToGPU(t){const e=this.tensorMap.get(t);if(null!=e.resource)return;const n=mA(e.dtype)*d(e.shape);let i;const r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(e.values){if(i=this.bufferManager.acquireBuffer(n,r,!0),"unmapped"===i.mapState){const t=this.bufferManager.acquireBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),r=t.getMappedRange();"int32"===e.dtype||"bool"===e.dtype?new Int32Array(r).set(e.values):new Float32Array(r).set(e.values),t.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(t,0,i,0,n),this.stagingPendingDisposal.push(t)}else{const t=i.getMappedRange();"int32"===e.dtype||"bool"===e.dtype?new Int32Array(t).set(e.values):new Float32Array(t).set(e.values),i.unmap()}e.values=null}else i=this.bufferManager.acquireBuffer(n,r);e.resource=i}makeUniforms(t){let e=0,n=0;const i=[];let r=1;t.forEach((t=>{let s;switch(0===t.data.length&&(t.data=[1]),t.data.length){case 1:s=4;break;case 2:s=8;break;case 3:case 4:case 5:case 6:s=16;break;default:c(!1,(()=>`Unsupported ${t.data.length}D shape`))}5!==n&&6!==n||(s=16),s>r&&(r=s),e=Math.ceil(e/s)*s,n=t.data.length,i.push(e),e+=4*t.data.length})),e=Math.ceil(e/r)*r;const s=new ArrayBuffer(e);t.forEach(((t,e)=>{const n=i[e];"int32"===t.type?new Int32Array(s,n,t.data.length).set(t.data):"uint32"===t.type?new Uint32Array(s,n,t.data.length).set(t.data):new Float32Array(s,n,t.data.length).set(t.data)}));const o=this.bufferManager.acquireBuffer(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(o,0,s,0,e),this.uniformPendingDisposal.push(o),{offset:0,size:e,buffer:o}}runWebGPUProgram(t,e,n,i,r){if(r||(r=this.makeTensorInfo(t.outputShape,n)),0===d(r.shape))return this.tensorMap.get(r.dataId).values=k(r.dtype,0),r;this.uploadToGPU(r.dataId),t.dispatch=((t,e)=>{const n=t.limits.maxComputeWorkgroupsPerDimension,i=e.dispatchLayout,r=e.dispatch;if(r.every((t=>t<=n)))return r;c(r[0]>n&&void 0===i.y&&void 0===i.z,(()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension."));let s=Math.ceil(Math.sqrt(r[0]));return s>n?(s=Math.ceil(Math.cbrt(r[0])),c(s<=n,(()=>"Total dispatch size exceeds WebGPU maximum.")),[s,s,s]):[s,s,1]})(this.device,t);const s=e.map(((e,n)=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(e.dataId),{dtype:this.tensorMap.get(e.dataId).dtype,shape:e.shape,name:t.variableNames[n]}}));t.shaderKey=function(t,e,n){let i=t.shaderKey;if(null!=t.pixelsOpType)return i;const r=[],s=[];e.forEach((t=>{r.push(t.shape),s.push(t.dtype)})),r.push(n.shape),s.push(n.dtype);const o=e.map((t=>Ya(t.shape,n.shape))),a=e.map((t=>m(t.shape,n.shape))).join("_"),l=o.map((t=>t.join("_"))).join(";"),c=aA(t)?"flatDispatch":"";return i+="_"+(t.workgroupSize?t.workgroupSize.join(","):"")+r.map((t=>t.length)).join(",")+s.join(",")+t.variableNames.join(",")+l+a+c,i}(t,s,r);const o=Y().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return t.shaderKey in this.pipelineCache||(this.pipelineCache[t.shaderKey]=ZI(this.device,t,s,r,o)),t.pipeline=this.pipelineCache[t.shaderKey],o||this.recordAndSubmit(t,r,e,i),r}recordAndSubmit(t,e,n,i){if(t.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let r=[],s=[];const o="int32";if(null==t.pixelsOpType){r.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),s=n.concat(e).map((t=>t.shape));const t="int32";s.map((e=>{r.push({type:t,data:e});const n=L(e);r.push({type:t,data:n})}))}else{const t=L(e.shape);r.push({type:o,data:t})}if(t.size){const e=d(t.outputShape);r.push({type:o,data:[t.outputComponent?e/t.outputComponent:e]})}i&&(r=[...r,...i]);const a=[this.tensorToBinding(e),...n.map((t=>this.tensorToBinding(t))),this.makeUniforms(r)];n.forEach((t=>{this.commandQueueOwnedIds.add(t.dataId)})),this.commandQueueOwnedIds.add(e.dataId);const l=this.device.createBindGroup({layout:t.pipeline.getBindGroupLayout(0),entries:a.map(((t,e)=>({binding:e,resource:t})))}),c=null!=this.activeTimers;this.ensureCommandEncoderReady();const u={};c&&this.supportTimestampQuery?(this.endComputePassEncoder(),null==this.querySet&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),u.timestampWrites=[{querySet:this.querySet,queryIndex:0,location:"beginning"},{querySet:this.querySet,queryIndex:1,location:"end"}],this.computePassEncoder=this.commandEncoder.beginComputePass(u)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(u)),this.computePassEncoder.setPipeline(t.pipeline),this.computePassEncoder.setBindGroup(0,l),this.computePassEncoder.dispatchWorkgroups(t.dispatch[0],t.dispatch[1],t.dispatch[2]),this.dispatchCountInPass++,(c||Y().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||t.pixelsOpType===YI.DRAW)&&(this.endComputePassEncoder(),c?this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;null==this.queryResolveBuffer&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const t=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,8*this.querySetCount),this.submitQueue(),await t.mapAsync(GPUMapMode.READ);const e=new BigUint64Array(t.getMappedRange()),n=Number(e[1]-e[0])/1e6;return t.unmap(),this.bufferManager.releaseBuffer(t),n}shouldExecuteOnCPU(t,e=vA){return Y().getBool("WEBGPU_CPU_FORWARD")&&t.every((t=>null==this.tensorMap.get(t.dataId).resource&&d(t.shape)<e))}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(null!=this.querySet&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var wA;xA.nextDataId=0,
/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
gA()&&$o("webgpu",(async()=>{const t={powerPreference:Y().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(t),n={},i=[];e.features.has("timestamp-query")&&i.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&i.push(["bgra8unorm-storage"]),n.requiredFeatures=i;const r=e.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize,maxBufferSize:r.maxBufferSize,maxComputeWorkgroupSizeX:r.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:r.maxComputeInvocationsPerWorkgroup};const s=await e.requestDevice(n),o=await e.requestAdapterInfo();return new xA(s,o)}),3),function(t){t[t.ADD=0]="ADD",t[t.ATAN2=1]="ATAN2",t[t.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",t[t.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",t[t.DIV=4]="DIV",t[t.ELU_DER=5]="ELU_DER",t[t.EQUAL=6]="EQUAL",t[t.FLOOR_DIV=7]="FLOOR_DIV",t[t.GREATER=8]="GREATER",t[t.GREATER_EQUAL=9]="GREATER_EQUAL",t[t.LESS=10]="LESS",t[t.LESS_EQUAL=11]="LESS_EQUAL",t[t.LOGICAL_AND=12]="LOGICAL_AND",t[t.LOGICAL_OR=13]="LOGICAL_OR",t[t.MAX=14]="MAX",t[t.MIN=15]="MIN",t[t.MOD=16]="MOD",t[t.MUL=17]="MUL",t[t.NOT_EQUAL=18]="NOT_EQUAL",t[t.POW=19]="POW",t[t.PRELU=20]="PRELU",t[t.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",t[t.SUB=22]="SUB"}(wA||(wA={}));const SA="let resultTemp = a + b;",kA="let resultTemp = atan2(a, b);",CA="let resultTemp = areal * breal - aimag * bimag;",TA="let resultTemp = areal * bimag + aimag * breal;",_A="let resultTemp = a / b;",EA="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",MA="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a == b);\n",$A="\n  let remainder =\n      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));\n  let quotient = (a - remainder) / b;\n  let resultTemp =\n      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));\n",IA="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a > b);\n",AA="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a >= b);\n",NA="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a < b);\n",RA="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a <= b);\n",PA="return f32(a >= 1.0 && b >= 1.0);",OA="return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));",LA="return f32(a >= 1.0 || b >= 1.0);",DA="return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));",FA="let resultTemp = max(a, b);",zA="let resultTemp = min(a, b);",BA="\n  let isNaN = b == 0.;\n  var resultTemp = a % b;\n  resultTemp = select((resultTemp + b) % b, resultTemp,\n      (a < 0. && b < 0.) || (a >= 0. && b > 0.));\n",UA="\n  let isNaN = !vec4<bool>(b);\n  var resultTemp = vec4<f32>(a % b);\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n",VA="let resultTemp = a * b;",WA="\n  var resultTemp = f32(a != b);\n  let valueForNaN = 1.0;\n",HA="\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n",jA="\n  let isNaN = a < 0.0 && floor(b) < b;\n  if (b == 0.0) {\n    return 1.0;\n  }\n  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),\n      round(abs(b) % 2.0) != 1.0);\n",GA="\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n",qA="if (a < 0.0) { return b * a; }  return a;",XA="\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n",KA="let resultTemp = (a - b) * (a - b);",YA="let resultTemp = a - b;";function ZA(t,e){let n;do{switch(t){case wA.ATAN2:n=kA;break;case wA.MAX:n=FA;break;case wA.MIN:n=zA;break;case wA.MOD:n=e?UA:BA;break;case wA.NOT_EQUAL:n=e?HA:WA;break;case wA.POW:n=e?GA:jA;break;default:continue}let i,r,s;return e?(i="isnanVec4",r="vec4<f32>",s="vec4<bool>"):(i="isnan",r="f32",s="bool"),`\n      let aIsNaN = ${i}(a);\n      let aPostLegalization = select(a, ${r}(42), aIsNaN);\n      let bIsNaN = ${i}(b);\n      let bPostLegalization = select(b, ${r}(42), bIsNaN);\n      let isNaN = false;\n      let valueForNaN = uniforms.NAN;\n      {\n        let a = aPostLegalization;\n        let b = bPostLegalization;\n        ${n}\n        return select(\n            resultTemp, ${r}(valueForNaN),\n            ${s}(isNaN) | aIsNaN | bIsNaN);\n      }\n    `}while(0);switch(t){case wA.ADD:n=SA;break;case wA.COMPLEX_MULTIPLY_IMAG:n=TA;break;case wA.COMPLEX_MULTIPLY_REAL:n=CA;break;case wA.DIV:n=_A;break;case wA.ELU_DER:n=EA;break;case wA.EQUAL:n=MA;break;case wA.FLOOR_DIV:n=$A;break;case wA.GREATER:n=IA;break;case wA.GREATER_EQUAL:n=AA;break;case wA.LESS:n=NA;break;case wA.LESS_EQUAL:n=RA;break;case wA.LOGICAL_AND:return e?OA:PA;case wA.LOGICAL_OR:return e?DA:LA;case wA.MUL:n=VA;break;case wA.PRELU:return e?XA:qA;case wA.SQUARED_DIFFERENCE:n=KA;break;case wA.SUB:n=YA}return`\n    ${n}\n    return resultTemp;\n  `}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var JA;!function(t){t[t.ABS=0]="ABS",t[t.ACOS=1]="ACOS",t[t.ACOSH=2]="ACOSH",t[t.ASIN=3]="ASIN",t[t.ASINH=4]="ASINH",t[t.ATAN=5]="ATAN",t[t.ATANH=6]="ATANH",t[t.CEIL=7]="CEIL",t[t.COS=8]="COS",t[t.COSH=9]="COSH",t[t.ELU=10]="ELU",t[t.ERF=11]="ERF",t[t.EXP=12]="EXP",t[t.EXPM1=13]="EXPM1",t[t.FLOOR=14]="FLOOR",t[t.IS_FINITE=15]="IS_FINITE",t[t.IS_INF=16]="IS_INF",t[t.IS_NAN=17]="IS_NAN",t[t.LINEAR=18]="LINEAR",t[t.LOG=19]="LOG",t[t.LOG1P=20]="LOG1P",t[t.LOGICAL_NOT=21]="LOGICAL_NOT",t[t.NEG=22]="NEG",t[t.RELU=23]="RELU",t[t.RELU6=24]="RELU6",t[t.LEAKYRELU=25]="LEAKYRELU",t[t.RECIPROCAL=26]="RECIPROCAL",t[t.ROUND=27]="ROUND",t[t.RSQRT=28]="RSQRT",t[t.SELU=29]="SELU",t[t.SIGMOID=30]="SIGMOID",t[t.SIGN=31]="SIGN",t[t.SIN=32]="SIN",t[t.SINH=33]="SINH",t[t.SOFTPLUS=34]="SOFTPLUS",t[t.SQRT=35]="SQRT",t[t.SQUARE=36]="SQUARE",t[t.STEP=37]="STEP",t[t.TAN=38]="TAN",t[t.TANH=39]="TANH",t[t.TO_INT=40]="TO_INT"}(JA||(JA={}));const QA="return abs(a);",tN="\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n",eN="\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n",nN="\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n",iN="return asinh(a);",rN="\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n",sN="\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n",oN="return ceil(a);",aN="return cos(a);",lN="\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n",cN="return exp(a) - 1.0;",uN="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",hN="\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n",dN=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  let p = ${Sf};\n  let a1 = ${kf};\n  let a2 = ${Cf};\n  let a3 = ${Tf};\n  let a4 = ${_f};\n  let a5 = ${Ef};\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n`,pN="return exp(a);",fN="return floor(a);",mN="return f32(!isnan(a) && !isinf(a));",gN="return f32(isinf(a));",yN="return f32(isnan(a));",bN="return a;",vN="if (a < 0.0) { return uniforms.NAN; }\n  return log(a);",xN="\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n",wN="return f32(!(a >= 1.0));",SN="return -a;",kN="if (a < 0.0) { return uniforms.alpha * a; } return a;",CN="\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n",TN="return 1.0 / a;",_N="return select(a, 0.0, a < 0.0);",EN="return clamp(a, 0.0, 6.0);",MN="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",$N="\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n",IN="return round(a);",AN="return inverseSqrt(a);",NN=`\n  if (a >= 0.0) {\n    return ${wf} * a;\n  } else {\n    return 1.7580993408473768 * (exp(a) - 1.0);\n  }\n`,RN="return 1.0 / (1.0 + exp(-1.0 * a));",PN="return sign(a);",ON="return sin(a);",LN="\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n",DN="\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n",FN="return sqrt(a);",zN="return a * a;",BN="\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n",UN="return tan(a);",VN="\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n",WN="return f32(i32((a)));";function HN(t,e){switch(t){case JA.ABS:return QA;case JA.ACOS:return tN;case JA.ACOSH:return eN;case JA.ASIN:return nN;case JA.ASINH:return iN;case JA.ATAN:return rN;case JA.ATANH:return sN;case JA.COS:return aN;case JA.COSH:return lN;case JA.CEIL:return oN;case JA.ELU:return e?hN:uN;case JA.ERF:return dN;case JA.EXP:return pN;case JA.EXPM1:return cN;case JA.FLOOR:return fN;case JA.IS_FINITE:return mN;case JA.IS_INF:return gN;case JA.IS_NAN:return yN;case JA.LINEAR:return bN;case JA.LOG:return vN;case JA.LOG1P:return xN;case JA.LOGICAL_NOT:return wN;case JA.NEG:return SN;case JA.LEAKYRELU:return e?CN:kN;case JA.RECIPROCAL:return TN;case JA.RELU:return e?$N:_N;case JA.RELU6:return e?MN:EN;case JA.ROUND:return IN;case JA.RSQRT:return AN;case JA.SELU:return NN;case JA.SIGMOID:return RN;case JA.SIGN:return PN;case JA.SIN:return ON;case JA.SINH:return LN;case JA.SOFTPLUS:return DN;case JA.SQRT:return FN;case JA.SQUARE:return zN;case JA.STEP:return BN;case JA.TAN:return UN;case JA.TANH:return VN;case JA.TO_INT:return WN;default:throw new Error(`BinaryType ${t} is not implemented!`)}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jN(t,e=!1,n=!1,i=3){if(null===t)return"";let r="";if("linear"===t)r=HN(JA.LINEAR);else if("relu"===t)r=HN(JA.RELU,n);else if("elu"===t)r=HN(JA.ELU,n);else if("relu6"===t)r=HN(JA.RELU6,n);else if("prelu"===t)r=ZA(wA.PRELU,n);else if("sigmoid"===t)r=HN(JA.SIGMOID,n);else{if("leakyrelu"!==t)throw new Error(`Activation ${t} has not been implemented for the WebGPU backend.`);r=HN(JA.LEAKYRELU,n)}const s=JI(n?4:1);let o="";return o=e?`\n      fn activation(a : ${s}, coords : vec${i}<i32>) -> ${s} {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ${r}\n      }`:`\n      fn activation(a : ${s}, coords : vec${i}<i32>) -> ${s} {\n        ${r}\n      }`,o}function GN(t,e){return`\n      ${t?"value = value + getBiasByOutputCoords(coords);":""}\n      ${e?"value = activation(value, coords);":""}\n      `}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qN(t,e,n=!1,i=!1,r=!1,s=1){c(t&&1===s||!t,(()=>`transposeA ${t} is not compatible with component size ${s}`));const o=`\n      ${t?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}\n\n    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`\n  fn mm_readA(batch: i32, row: i32, col: i32) -> ${JI(s)} {\n    var value = ${JI(s)}(0.0);\n    ${n&&r?o:`\n    ${t?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}\n    {\n      ${o}\n    }\n    `}\n    return value;\n  }\n\n  fn mm_readB(batch: i32, row: i32, col: i32) -> ${JI(s)} {\n    var value = ${JI(s)}(0.0);\n    ${a}\n    return value;\n  }\n  `}function XN(t,e,n,i,r=!1,s=!1,o=!1,a=1){return`\n  ${qN(n,i,r,s,o,a)}\n  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${JI(a)}) {\n    ${r&&s?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ${GN(t,e)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  `}function KN(t,e,n=!1,i=32,r=!1,s=32,o=!1){const a=e[1]*t[1],l=e[0]*t[0],u=n?a:i,h=n?i:a,d=u/e[0],p=i/e[1],f=t[1],m=t[0];return c((n&&4===d&&4===t[1]||!n&&(3===d||4===d))&&u%e[0]==0&&i%e[1]==0&&4===t[0],(()=>`If transposeA ${n} is true, innerElementSize ${d} and workPerThread[1] ${t[1]} must be 4.\n          Otherwise, innerElementSize ${d} must be 3 or 4.\n      tileAWidth ${u} must be divisible by workgroupSize[0]${e[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`)),`\n  var<workgroup> mm_Asub : array<array<vec${d}<f32>, ${u/d}>, ${h}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/t[0]}>, ${i}>;\n\n  ${eA()} {\n    let localRow = i32(localId.y);\n    let tileRow = localRow * ${f};\n    let tileCol = i32(localId.x);\n\n    let globalRow = i32(globalId.y) * ${f};\n    let globalCol = i32(globalId.x) * ${m};\n    let batch = ${r?"0":"i32(globalId.z)"};\n    let batchA = ${r||!o?"batch":"batch % uniforms.aShape[0]"};\n    let batchB = ${r||!o?"batch":"batch % uniforms.bShape[0]"};\n    let globalRowStart = i32(workgroupId.y) * ${a};\n\n    let numTiles = ${r?`${Math.ceil(s/i)}`:`(uniforms.dimInner - 1) / ${i} + 1`};\n    var kStart = ${r?`i32(globalId.z) * ${s}`:"0"};\n\n    var acc: array<vec4<f32>, ${f}>;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ${p};\n    for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ${f}; innerRow++) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ${((t,e)=>t?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol * ${e});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRow + innerRow,\n          kStart + inputCol * ${e});\n        `)(n,d)}\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ${p}; innerRow++) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + ${i};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        ${((t,e,n,i)=>{if(t)return`\n      for (var k = 0; k < ${i}; k++) {\n        let BCached0 = mm_Bsub[k][tileCol];\n        let ACached0 = mm_Asub[k][localRow];\n        for (var i = 0; i < ${n}; i++) {\n          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);\n        }\n      }`;{let t="",r="";for(let n=0;n<e;n++)t+=`let BCached${n} = mm_Bsub[k * ${e} + ${n}][tileCol];`,r+=`acc[i] = fma(BCached${n}, vec4<f32>(ACached[${n}]), acc[i]);`;return`\n      for (var k = 0; k < ${i/e}; k++) {\n        ${t}\n        for (var i = 0; i < ${n}; i++) {\n          let ACached = mm_Asub[tileRow + i][k];\n          ${r}\n        }\n      }`}})(n,d,f,i)}\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < ${f}; innerRow++) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }`}const YN=t=>t?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";function ZN(t,e,n=!1,i=32,r=!1,s=32,o=!1,a=!1){const l=t[1]*e[1],u=t[0]*e[0],h=n?l:i,d=n?i:l;c(d%e[1]==0&&h%e[0]==0&&i%e[1]==0,(()=>`tileAHight ${d} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${h} must be divisible by workgroupSize[0]${e[0]}, tileInner ${i} must be divisible by workgroupSize[1]${e[1]}`));const p=d/e[1],f=h/e[0],m=i/e[1],g=t[1],y=t[0],b=o?`\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ${l};\n      let globalColStart = i32(workgroupId.x) * ${u};\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ${d}; inputRow = inputRow + ${e[1]}) {\n          for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${e[0]}) {\n            ${YN(n)}\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${e[1]}) {\n              for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + ${i};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ${y}>;\n        for (var k = 0; k < ${i}; k++) {\n          for (var inner = 0; inner < ${y}; inner++) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];\n          }\n          for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}\n            for (var innerCol = 0; innerCol < ${y}; innerCol++) {\n              acc[innerRow][innerCol] =\n                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        let gRow = globalRowStart + localRow + innerRow * ${e[1]};\n        for (var innerCol = 0; innerCol < ${y}; innerCol++) {\n          let gCol = globalColStart + localCol + innerCol * ${e[0]};\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      `:`\n  let tileRow = i32(localId.y) * ${g};\n  let tileCol = i32(localId.x) * ${y};\n\n  let globalRow = i32(globalId.y) * ${g};\n  let globalCol = i32(globalId.x) * ${y};\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let tileRowA = i32(localId.y) * ${p};\n  let tileColA = i32(localId.x) * ${f};\n  let tileRowB = i32(localId.y) * ${m};\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t++) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ${p}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${f}; innerCol++) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ${YN(n)}\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${y}; innerCol++) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + ${i};\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ${y}>;\n    for (var k = 0; k < ${i}; k++) {\n      for (var inner = 0; inner < ${y}; inner++) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        ${(t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(n)}\n        for (var innerCol = 0; innerCol < ${y}; innerCol++) {\n          acc[innerRow][innerCol] =\n              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n    for (var innerCol = 0; innerCol < ${y}; innerCol++) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  `;return`\n    var<workgroup> mm_Asub : array<array<f32, ${h}>, ${d}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${u}>, ${i}>;\n\n    ${eA()} {\n      let batch = ${r?"0":"i32(globalId.z)"};\n      let batchA = ${r||!a?"batch":"batch % uniforms.aShape[0]"};\n      let batchB = ${r||!a?"batch":"batch % uniforms.bShape[0]"};\n      let numTiles = ${r?`${Math.ceil(s/i)}`:`(uniforms.dimInner - 1) / ${i} + 1`};\n      var kStart = ${r?`i32(globalId.z) * ${s}`:"0"};\n\n      var acc : array<array<f32, ${y}>, ${g}>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        for (var innerCol = 0; innerCol < ${y}; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ${b}\n    }\n  `}class JN{constructor(t,e,n=!1,i=!1,r=null,s=null,o=null,a=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0]};const l=n?t[1]:t[2];if(this.isVec4=(l%4==0&&!n||e[1]%4==0&&n)&&e[2]%4==0&&!i,this.outputComponent=this.isVec4?4:1,this.isVectorA=1===e[1]&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const t=function(t,e,n,i=!1){const r=[8,8,1],s=[4,4,1];return i||(t<=8&&(s[1]=1),e<=16&&n<=16&&(r[0]=4)),{workgroupSize:r,elementsPerThread:s}}(e[1],l,e[2],n);this.workgroupSize=t.workgroupSize,this.elementsPerThread=t.elementsPerThread}this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const c=null!=r,u=null!=o;c&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=a,this.transposeA=n,this.transposeB=i,this.addBias=c,this.activation=s,this.hasPreluActivationWeights=u,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(e[1],e[2],l),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${n}_${i}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(t,e,n){const i=this.workgroupSize[1]*this.elementsPerThread[1],r=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=r;return[t%i==0,e%r==0,n%this.tileInner==0]}getUserCode(){const t=`\n      ${jN(this.activation,this.hasPreluActivationWeights,this.isVec4)}\n      ${XN(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}\n      ${this.isVec4?KN(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?function(t,e=!1){c(1===t[1]&&1===t[2],(()=>`A linear work group size is required. But got ${t}.`));const n=4*t[0];return`\n    var<workgroup> mm_Asub : array<vec4<f32>, ${t[0]}>;\n\n    ${eA()} {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;\n      let batch = i32(globalId.z);\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        let colA = t * ${n} + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(${(t=>t?"\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  ":"\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  ")(e)});\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${n/4}; k++) {\n          let rowB = t * ${n} + k * 4;\n          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),\n                              mm_readB(batchB, rowB + 1, globalCol),\n                              mm_readB(batchB, rowB + 2, globalCol),\n                              mm_readB(batchB, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  `}(this.workgroupSize,this.transposeA):ZN(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}\n    `;return t}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QN{constructor(t,e=!1,n=!1,i=null,r=null,s=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=t,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize);const o=null!=i,a=null!=s;o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.transposeA=e,this.transposeB=n,this.addBias=o,this.activation=r,this.hasPreluActivationWeights=a,this.shaderKey=`matMulReduce_${this.activation}_${e}_${n}`}getUserCode(){var t;return`\n      ${jN(this.activation,this.hasPreluActivationWeights)}\n      ${XN(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${t=this.workgroupSize[0],`\n    var<workgroup> sumValues : array<f32, ${t}>;\n    ${eA()} {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ${t}) {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ${t/2}u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  `}\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tR{constructor(t,e,n,i=!1,r=!1,s=null,o=null,a=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];const l=null!=s;l&&this.variableNames.push("bias");const c=null!=a;c&&this.variableNames.push("preluActivationWeights"),this.transposeA=i,this.transposeB=r,this.addBias=l,this.activation=o,this.hasPreluActivationWeights=c,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${i}_${r}`}getUserCode(){return`\n      ${jN(this.activation,this.hasPreluActivationWeights)}\n      ${XN(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${function(t){const e=t[1],n=t[0],i=e>n?e:n;return`\n  var<workgroup> mm_Asub : array<array<f32, ${i}>, ${e}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${i}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ${eA()} {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let batchA = batch % uniforms.aShape[0];\n    let batchB = batch % uniforms.bShape[0];\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ${i} + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batchA, globalRow, globalColA);\n    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ${i};\n    globalRowB = globalRowB + ${i};\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batchA, globalRow, globalColA);\n      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ${i};\n      globalRowB = globalRowB + ${i};\n\n      for (var k = 0; k < ${i}; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  `}(this.workgroupSize)}\n    `}}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eR{constructor(t,e,n=!1,i=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,c(1===t[0],(()=>"MatMulSplitKProgram only supports batch = 1.")),this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const r=(n&&this.outputShape[1]%4==0||!n&&e%4==0)&&this.outputShape[2]%4==0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=r?4:1,r||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=hA(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],e],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=i,this.shaderKey=`matMulSplitK_${n}_${i}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const t=this.outputComponent;return`\n      ${qN(!1,this.transposeB,!1,!1,!1,t)}\n      fn mm_write(batch: i32, row : i32, col : i32, value : ${JI(t)}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ${t}; i = i + 1) {\n            ${KI("&result[flatIndex + i]",""+(t>1?"value[i]":"value"),"float32")}\n          }\n        }\n      }\n      ${4===t?KN(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):ZN(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}\n    `}}class nR{constructor(t,e=null,n=null,i=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=e,this.hasPreluActivationWeights=null!=i,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${n}`}getUserCode(){return`\n    ${jN(this.activation,this.hasPreluActivationWeights)}\n    ${eA("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${GN(this.addBias,this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iR{constructor(t){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`\n    ${eA("index")} {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rR(t){const{backend:e,attrs:n}=t,{shape:i,value:r}=n;let{dtype:s}=n;if(s=s||R(r),"string"===s){const t=C(s,d(i));return t.fill(r),e.makeTensorInfo(i,s,t)}{const t=new iR(i),n=[{type:"float32",data:[r]}];return e.runWebGPUProgram(t,[],s,n)}}const sR={kernelName:le,backendName:"webgpu",kernelFunc:rR};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oR(t){const{inputs:e,attrs:n}=t,{x:i}=e,{shape:r}=n,s=d(i.shape),o=x(r,s),a=d(o);return c(s===a,(()=>`The new shape (${o}) has ${a} elements and the old shape (${i.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`)),t.backend.incRef(i.dataId),{dataId:i.dataId,shape:o,dtype:i.dtype}}const aR={kernelName:mn,backendName:"webgpu",kernelFunc:oR};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lR({a:t,b:e,transposeA:n,transposeB:i,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const u=t.shape.length,h=e.shape.length,p=n?t.shape[u-2]:t.shape[u-1],f=i?e.shape[h-1]:e.shape[h-2],m=n?t.shape[u-1]:t.shape[u-2],g=i?e.shape[h-2]:e.shape[h-1],y=t.shape.slice(0,-2),b=e.shape.slice(0,-2),v=d(y),x=d(b),w=Ja(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([m,g]);c(p===f,(()=>`Error in matMul: inner shapes (${p}) and (${f}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${i} must match.`));const S=n?[v,p,m]:[v,m,p],k=i?[x,g,f]:[x,f,g],C=oR({inputs:{x:t},backend:r,attrs:{shape:S}}),T=oR({inputs:{x:e},backend:r,attrs:{shape:k}}),_=[C,T],E=Math.max(v,x),M=[C,T],$=[{type:"int32",data:[m]},{type:"int32",data:[g]},{type:"int32",data:[p]}];let I,A;const N=[E,m,g];let R=Y().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(R<0){const t=Y().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),e=t>0?t:r.thresholdToIncreaseWorkgroups,n=E*Math.ceil(m/32)*Math.ceil(g/32);R=n<=e||m<=8&&n<=2*e?E*m*g<=128?bA.MatMulReduceProgram:1===E&&f>=2e3?bA.MatMulSplitKProgram:bA.MatMulSmallOutputSizeProgram:bA.MatMulPackedProgram}switch(R){case bA.MatMulReduceProgram:I=new QN(N,n,i,s,l,o);break;case bA.MatMulSplitKProgram:if(A=rR({backend:r,attrs:{shape:N,value:0,dtype:t.dtype}}),I=new eR(N,f,n,i),s||l){A=r.runWebGPUProgram(I,M,t.dtype,$,A);const e=new nR(A.shape,s,l,o);let n=null;const i=[A];s&&i.push(s),o&&i.push(o),"leakyrelu"===l&&(n=[{type:"float32",data:[a]}],e.uniforms+=" alpha : f32,");const c=r.runWebGPUProgram(e,i,A.dtype,n);_.push(A);const u=oR({inputs:{x:c},backend:r,attrs:{shape:w}});_.push(c);for(const t of _)r.disposeData(t.dataId);return u}break;case bA.MatMulSmallOutputSizeProgram:I=new tR(S,k,N,n,i,s,l,o);break;case bA.MatMulPackedProgram:const e=r.adapterInfo.isIntel();I=new JN(S,N,n,i,s,l,o,e);break;default:throw new Error(`Unsupported MatMulProgramType ${R}.`)}s&&M.push(s),o&&M.push(o),"leakyrelu"===l&&($.push({type:"float32",data:[a]}),I.uniforms+=" alpha : f32,"),A=r.runWebGPUProgram(I,M,t.dtype,$,A);const P=oR({inputs:{x:A},backend:r,attrs:{shape:w}});_.push(A);for(const t of _)r.disposeData(t.dataId);return P}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cR={kernelName:di,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{a:r,b:s,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=i;return lR({a:r,b:s,transposeA:l,transposeB:c,backend:n,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uR{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=Ja(e,n),this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${t}`,this.op=t}getUserCode(){return`\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${ZA(this.op,!1)}\n      }\n\n      ${eA("index")} {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hR{constructor(t,e,n){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=Ja(e,n),this.dispatchLayout=fA(this.outputShape),this.op=t,this.useSharedMemoryWithA=e.length<=1&&n.length>1&&e[0]<128,this.useSharedMemoryWithB=n.length<=1&&e.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:e[0],this.shaderKey=`binary_${t}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const i=e.length>0&&e[e.length-1]%4==0,r=n.length>0&&n[n.length-1]%4==0;i&&r?(this.outputComponent=4,this.variableComponents=[4,4]):i&&(p(n)||1===n[n.length-1])||r&&(p(e)||1===e[e.length-1])?(this.outputComponent=4,this.variableComponents=i?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${t}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let t;const e=4===this.outputComponent?"vec4<f32>":"f32",n=`\n    fn binaryOperation(a : ${e}, b : ${e}) -> ${e} {\n      ${ZA(this.op,4===this.outputComponent)}\n    };\n    `;if("shared"===this.type){const e=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",i=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);\n          let b = sharedBuf[${e}];`:`let a = sharedBuf[${e}];\n          let b = getBByOutputIndex(index);`;t=`\n        ${n}\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${eA("index")} {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ${this.lastDimensionSize}) {\n            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ${i}\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        `}else t=`\n       ${n}\n       ${eA("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index * ${this.outputComponent});\n           let a = ${e}(getAByOutputCoords(coords));\n           let b = ${e}(getBByOutputCoords(coords));\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       `;return t}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dR(t){const{inputs:e}=t,{x:n}=e;return t.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const pR={kernelName:ye,backendName:"webgpu",kernelFunc:dR};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fR(t){const{inputs:e,backend:n}=t,{real:i,imag:r}=e,s=n.makeTensorInfo(i.shape,"complex64"),o=n.tensorMap.get(s.dataId),a=dR({inputs:{x:i},backend:n}),l=dR({inputs:{x:r},backend:n});return o.complexTensorInfos={real:a,imag:l},s}const mR={kernelName:Mt,backendName:"webgpu",kernelFunc:fR};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gR{constructor(t,e,n=""){this.variableNames=["A"],this.size=!0;this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=e,""!==n&&(this.uniforms=n),this.shaderKey=`unary_${e}`}getUserCode(){return`\n      fn unaryOperation(a : f32) -> f32 {\n        ${HN(this.op,!1)}\n      }\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yR({opType:t,cpuKernelImpl:e,dtype:n}){return({inputs:i,backend:r})=>{const{x:s}=i,o=r,a=n||s.dtype;if(o.shouldExecuteOnCPU([s])&&null!=e){const t=o.tensorMap.get(s.dataId),n=e(t.values,a);return o.makeTensorInfo(s.shape,a,n)}const l=new gR(s.shape,t);return o.runWebGPUProgram(l,[s],a)}}function bR({opType:t,cpuKernelImpl:e,supportsComplex:n=!1,dtype:i}){return({inputs:r,backend:s})=>{const{a:o,b:a}=r,l=s;if(n&&"complex64"===o.dtype){const e=l.tensorMap.get(o.dataId),n=l.tensorMap.get(a.dataId);let i,r;if(t!==wA.MUL)[i,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,i]=e,r={dataId:n.dataId,dtype:n.dtype,shape:o.shape},s={dataId:i.dataId,dtype:i.dtype,shape:a.shape},c=new hR(t,o.shape,a.shape);return l.runWebGPUProgram(c,[r,s],Hr(n.dtype,i.dtype))}));else{const t=new uR(wA.COMPLEX_MULTIPLY_REAL,o.shape,a.shape),s=new uR(wA.COMPLEX_MULTIPLY_IMAG,o.shape,a.shape),c=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:o.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:a.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:a.shape}];i=l.runWebGPUProgram(t,c,"float32"),r=l.runWebGPUProgram(s,c,"float32")}const s=fR({inputs:{real:i,imag:r},backend:l});return l.disposeData(i.dataId),l.disposeData(r.dataId),s}const c=i||Hr(o.dtype,a.dtype);if(("string"===o.dtype||"string"===a.dtype||l.shouldExecuteOnCPU([o,a]))&&null!=e){const t=l.tensorMap.get(o.dataId).values,n=l.tensorMap.get(a.dataId).values,i="string"===o.dtype?cm(t):t,r="string"===o.dtype?cm(n):n,[s,u]=e(o.shape,a.shape,i,r,c);return l.makeTensorInfo(u,c,s)}const u=new hR(t,o.shape,a.shape);return l.runWebGPUProgram(u,[o,a],c)}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:vR,castImpl:xR,ceilImpl:wR,concatImpl:SR,equalImpl:kR,expImpl:CR,expm1Impl:TR,floorImpl:_R,floorDivImpl:ER,gatherNdImpl:MR,gatherV2Impl:$R,greaterEqualImpl:IR,greaterImpl:AR,lessEqualImpl:NR,lessImpl:RR,logImpl:PR,maxImpl:OR,maximumImpl:LR,minimumImpl:DR,multiplyImpl:FR,negImpl:zR,notEqualImpl:BR,prodImpl:UR,rangeImpl:VR,rsqrtImpl:WR,scatterImpl:HR,simpleAbsImpl:jR,sliceImpl:GR,stridedSliceImpl:qR,stringNGramsImpl:XR,subImpl:KR,tileImpl:YR,topKImpl:ZR,transposeImpl:JR,uniqueImpl:QR}=Wy,tP=yR({opType:JA.ABS,cpuKernelImpl:jR}),eP={kernelName:et,backendName:"webgpu",kernelFunc:tP},nP=yR({opType:JA.ACOS}),iP={kernelName:nt,backendName:"webgpu",kernelFunc:nP},rP=yR({opType:JA.ACOSH}),sP={kernelName:it,backendName:"webgpu",kernelFunc:rP},oP=bR({opType:wA.ADD,cpuKernelImpl:vR,supportsComplex:!0}),aP={kernelName:rt,backendName:"webgpu",kernelFunc:oP};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class lP{constructor(t){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t[0],this.variableNames=t.map(((t,e)=>`T${e}`)),this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const t=[];this.variableNames.forEach((e=>{t.push(`let v${e} = get${e}ByOutputCoords(coords);`)}));const e=this.variableNames.map((t=>`v${t}`)).join(" + ");return`\n      ${eA("index")} {\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ${t.join("\n        ")}\n            setOutputAtIndex(flatIndex, ${e});\n          }\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cP={kernelName:st,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,i=e;if(1===i.length)return dR({inputs:{x:i[0]},backend:n});const r=i.map((t=>t.dtype)).reduce(((t,e)=>Hr(t,e))),s=i.map((t=>t.shape)),o=new lP(s);return n.runWebGPUProgram(o,i,r)}};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uP{constructor(t,e){this.variableNames=["A"],this.workgroupSize=[16,16,1];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){c(this.workgroupSize[0]===this.workgroupSize[1],(()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`));const t=this.workgroupSize[0];return`\n      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;\n      ${eA()} {\n        var x = i32(workgroupId.x) * ${t} + i32(localId.x);\n        var y = i32(workgroupId.y) * ${t} + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = f32(A[y * width + x]);\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * ${t} + i32(localId.x);\n        y = i32(workgroupId.x) * ${t} + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hP{constructor(t,e){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=e,this.shaderKey=`transpose_${e}`}getUserCode(){const t=QI(this.outputShape.length),e=dP(this.newDim);return`\n      ${eA("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(\n              ${t}(${e}), uniforms.aShape)]);\n          }\n        }\n      }\n    `}}function dP(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=new Array(e);for(let e=0;e<t.length;e++)n[t[e]]=`coords.${tA(e)}`;return n.join()}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pP(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{perm:s}=i,o=n,a=r.shape.length,l=new Array(a);for(let t=0;t<l.length;t++)l[t]=r.shape[s[t]];if(n.shouldExecuteOnCPU([r])){const t=o.tensorMap.get(r.dataId).values,e=JR(t,r.shape,r.dtype,s,l);return n.makeTensorInfo(l,r.dtype,e)}if(2===r.shape.length&&m(s,[1,0])){const t=new uP(r.shape,s);return o.runWebGPUProgram(t,[r],r.dtype)}const c=new hP(r.shape,s);return o.runWebGPUProgram(c,[r],r.dtype)}const fP={kernelName:ri,backendName:"webgpu",kernelFunc:pP};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mP{constructor(t,e,n){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[t.batchSize,t.inSize];const[i]=hl(this.inputShape,[1]);this.outputShape=0===i.length?[1]:i,t.inSize>=32768&&n>=512?this.workgroupSize=[512,1,1]:t.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=e,this.shaderKey=`reduce_${e}`}getUserCode(){let t="",e="0.0";const n=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(t=`\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ${"min"===this.reduceType?"<":">"} bestValue)\n           {  bestValue = candidate; }`,e="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?t=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(t=" bestValue = bestValue * candidate; ",e="1.0"):"all"===this.reduceType?(t=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",e="1.0"):"any"===this.reduceType&&(t=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",e="0.0");const i="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       ${`\n         var<workgroup> xBestValues : array<f32, ${n}>;\n       `}\n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;\n          return offset;\n       }\n       ${eA("index")} {\n         let outputIndex = index / ${n};\n         let offset = getOffset(outputIndex);\n         var bestValue = ${e};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), ${n}u);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + ${n}) {\n           let candidate = f32(x[offset + k]);\n           ${t}\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), ${n}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ${t}\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ${i}\n        }\n       }\n     `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gP={mean:"float32",all:"bool",any:"bool"};function yP(t,e,n,i,r){const s=t.shape.length,o=[],a=w(e,t.shape);let l=a;const c=fl(l,s);let u=t;null!=c&&(u=pP({inputs:{x:t},attrs:{perm:c},backend:r}),l=gl(l.length,s),o.push(u)),pl(i,l,s);const[h,p]=hl(u.shape,l);let f,m=h;if(n&&(m=dl(h,a)),"max"!==i&&"prod"!==i||!r.shouldExecuteOnCPU([u])){const e=d(p),n={windowSize:e,inSize:e,batchSize:d(u.shape)/e,outSize:1},s=gP[i]||jr(t.dtype),a=[{type:"int32",data:[e]}],l=new mP(n,i,r.device.limits.maxComputeWorkgroupSizeX),c=r.runWebGPUProgram(l,[u],s,a);o.push(c),f=oR({inputs:{x:c},attrs:{shape:m},backend:r})}else{const e=r.tensorMap.get(u.dataId).values;switch(i){case"max":const n=OR(e,d(p),m,t.dtype);f=r.makeTensorInfo(m,t.dtype,n);break;case"prod":const{outVals:s,outShape:o,outDtype:a}=UR(u.shape,u.dtype,e,l);f=r.makeTensorInfo(o,a,s);break;default:throw new Error(`${i} CPU implementation is not yet supported.`)}}return o.forEach((t=>r.disposeData(t.dataId))),f}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bP={kernelName:ot,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{keepDims:s,axis:o}=i;return yP(r,o,s,"all",n)}};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vP={kernelName:at,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{keepDims:s,axis:o}=i;return yP(r,o,s,"any",n)}};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xP{constructor(t,e,n){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const i=[e];this.op="min"===n?"<":">";const[r,s]=hl(t,i);this.outputShape=0===r.length?[1]:r,this.dispatchLayout=fA(this.outputShape),d(s)<32?(this.type="plain",this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=hA(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=t,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const t=this.workgroupSize[0],e=()=>1===this.inputShape.length?"uniforms.xShape":`uniforms.xShape.${tA(this.inputShape.length-1)}`,n=()=>{let t="";if(1===this.outputShape.length)1!==this.inputShape.length&&(t+="outputCoords,");else for(let e=0;e<this.outputShape.length;e++)t+=`outputCoords.${tA(e)},`;return t};if("shared"===this.type){return`\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ${`\n      var<workgroup> xBestIndices : array<i32, ${t}>;\n      var<workgroup> xBestValues : array<f32, ${t}>;\n    `}\n\n      ${eA("index")} {\n        let outputIndex = index / ${t};\n        let reduceLength = ${e()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ${t}) {\n          let candidate = getX(${n()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ${t}u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `}return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(${n()} 0);\n          let reduceLength = ${e()};\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(${n()} i);\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wP={kernelName:lt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s}=i;let o=w(s,r.shape);const a=fl(o,r.shape.length);let l=r;const c=[];null!=a&&(l=pP({inputs:{x:r},backend:n,attrs:{perm:a}}),c.push(l),o=gl(o.length,l.shape.length)),pl("argMax",[o[0]],l.shape.length);const u=new xP(l.shape,o[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],d=n.runWebGPUProgram(u,[l],"int32",h);return c.forEach((t=>n.disposeData(t.dataId))),d}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SP={kernelName:ct,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s}=i;let o=w(s,r.shape);const a=fl(o,r.shape.length);let l=r;const c=[];null!=a&&(l=pP({inputs:{x:r},backend:n,attrs:{perm:a}}),c.push(l),o=gl(o.length,l.shape.length)),pl("argMin",[o[0]],l.shape.length);const u=new xP(l.shape,o[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],d=n.runWebGPUProgram(u,[l],"int32",h);return c.forEach((t=>n.disposeData(t.dataId))),d}},kP=yR({opType:JA.ASIN}),CP={kernelName:ut,backendName:"webgpu",kernelFunc:kP},TP=yR({opType:JA.ASINH}),_P={kernelName:ht,backendName:"webgpu",kernelFunc:TP},EP=yR({opType:JA.ATAN}),MP={kernelName:dt,backendName:"webgpu",kernelFunc:EP},$P=bR({opType:wA.ATAN2}),IP={kernelName:ft,backendName:"webgpu",kernelFunc:$P},AP=yR({opType:JA.ATANH}),NP={kernelName:pt,backendName:"webgpu",kernelFunc:AP};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class RP{constructor(t){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.strides;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PP{constructor(t,e,n=!1,i=!1,r=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=t.outShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=e,this.computePositions=n,this.flattenPositions=i,this.includeBatchIndex=r,this.shaderKey=`pool2D_${e}_${n}_${i}_${r}`}getUserCode(){let t;if("avg"===this.poolType)t="resultValue = resultValue + value; count = count + 1.0;";else if(this.computePositions){t=`let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};\n      }`}else t="resultValue = max(value, resultValue);";let e="resultValue";"avg"===this.poolType&&(e="resultValue / max(count, 1.0)");return`\n      ${eA("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          ${this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":`var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};`}\n\n          var count = 0.0;\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, d);\n              ${t}\n            }\n          }\n\n          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${e});`}\n        }\n      }\n    `}}class OP{constructor(t,e,n=!1,i=!1,r=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=t.outShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=e,this.computePositions=n,this.flattenPositions=i,this.includeBatchIndex=r,this.shaderKey=`pool3D_${e}_${n}_${i}_${r}`}getUserCode(){let t;if("avg"===this.poolType)t="resultValue += value; count += 1.0;";else if(this.computePositions){t=`let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};\n      }`}else t="resultValue = max(value, resultValue);";let e="resultValue";"avg"===this.poolType&&(e="resultValue / max(count, 1.0)");return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords.x;\n          let ch = coords.u;\n\n          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n          let xDCorner = xCorner.x;\n          let xRCorner = xCorner.y;\n          let xCCorner = xCorner.z;\n\n          ${this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":`var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};`}\n\n          var count = 0.0;\n          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {\n            let xD = xDCorner + wD;\n            if (xD < 0 || xD >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {\n              let xR = xRCorner + wR;\n              if (xR < 0 || xR >= uniforms.convDims.y) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {\n                let xC = xCCorner + wC;\n                if (xC < 0 || xC >= uniforms.convDims.z) {\n                  continue;\n                }\n\n                let value = getX(batch, xD, xR, xC, ch);\n                ${t}\n              }\n            }\n          }\n\n          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${e});`}\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LP(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{reductionIndices:s,keepDims:o}=i;return yP(r,s,o,"max",n)}const DP={kernelName:Oe,backendName:"webgpu",kernelFunc:LP};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FP(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{keepDims:s,axis:o}=i;return yP(r,o,s,"mean",n)}const zP={kernelName:Ve,backendName:"webgpu",kernelFunc:FP};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BP(t,e,n,i){if(1===e.filterWidth&&1===e.filterHeight&&m(e.inShape,e.outShape))return dR({inputs:{x:t},backend:i});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&1===e.batchSize&&"VALID"===e.padInfo.type){const r=t.shape.length,s=oR({inputs:{x:t},backend:i,attrs:{shape:[t.shape[r-3]*t.shape[r-2],t.shape[r-1]]}});let o;"avg"===n?o=FP({inputs:{x:s},backend:i,attrs:{axis:0,keepDims:!1}}):(c("max"===n,(()=>`Invalid pool type ${n}`)),o=LP({inputs:{x:s},backend:i,attrs:{reductionIndices:0,keepDims:!1}}));const a=oR({inputs:{x:o},backend:i,attrs:{shape:e.outShape}});return i.disposeData(s.dataId),i.disposeData(o.dataId),a}let r;const s=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return 1===e.filterHeight&&1===e.filterWidth?r=new RP(e):("avg"===n?r=new PP(e,"avg"):(c("max"===n,(()=>`Invalid pool type ${n}`)),r=new PP(e,"max")),s.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),i.runWebGPUProgram(r,[t],t.dtype,s)}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UP={kernelName:mt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i;return BP(r,Ko(r.shape,s,o,1,a,l),"avg",n)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VP={kernelName:yt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{filterSize:s,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=i,u=Yo(r.shape,s,o,[1,1,1],a,c,l),h=new OP(u,"avg"),d=[{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.front,u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.inDepth,u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth]}];return n.runWebGPUProgram(h,[r],r.dtype,d)}};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WP{constructor(t){this.variableNames=["dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`\n      ${eA("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n\n            dotProd = dotProd + dyValue * uniforms.avgMultiplier;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class HP{constructor(t){this.variableNames=["dy"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`\n      ${eA("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              dotProd += dyValue * uniforms.avgMultiplier;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jP={kernelName:bt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=i,h=Yo(o.shape,a,l,1,c,u),d=new HP(h),p=1/(h.filterDepth*h.filterHeight*h.filterWidth),f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[p]}];return n.runWebGPUProgram(d,[r],o.dtype,f)}};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GP={kernelName:gt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,o=s;yA([r,s],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=i,u=Ko(o.shape,a,l,1,c),h=new WP(u),d=1/(u.filterHeight*u.filterWidth),p=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.effectiveFilterHeight-1-u.padInfo.top,u.effectiveFilterWidth-1-u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"float32",data:[d]}];return n.runWebGPUProgram(h,[r],o.dtype,p)}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qP={kernelName:vt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{a:r,b:s}=e,{transposeA:o,transposeB:a}=i;return lR({a:r,b:s,transposeA:o,transposeB:a,backend:n})}};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XP{constructor(t,e){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.rank=e.length,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=t,this.uniforms=`start : ${QI(t.length)}, `,this.shaderKey="slice"}getUserCode(){const t=QI(this.rank),e=function(t){if(1===t)return"sourceLoc";if(t<=6)return KP.slice(0,t).map((t=>`sourceLoc.${t}`)).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(this.rank);let n;n=1===this.start.length?this.outputShape.map(((t,e)=>"sourceLoc = uniforms.start + coords;")):this.outputShape.map(((t,e)=>`sourceLoc.${KP[e]} = uniforms.start.${tA(e)} + coords.${KP[e]};`));return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          var sourceLoc : ${t};\n          let coords = getCoordsFromIndex(index);\n          ${n.join("\n")}\n          setOutputAtIndex(index, getSource(${e}));\n        }\n      }\n    `}}const KP=["x","y","z","w","u","v"];function YP(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{begin:s,size:o}=i,[a,l]=Yp(r,s,o);if(Fp(r,a,l),n.shouldExecuteOnCPU([r])||"string"===r.dtype){const t=n.tensorMap.get(r.dataId),e=GR(t.values,a,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,e)}if(0===d(l))return n.makeTensorInfo(l,r.dtype,[]);const c=new XP(a,l),u=[{type:"int32",data:a}];return n.runWebGPUProgram(c,[r],r.dtype,u)}const ZP={kernelName:$n,backendName:"webgpu",kernelFunc:YP},JP={kernelName:xt,backendName:"webgpu",kernelFunc:t=>{const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{blockShape:s,crops:o}=i;c(r.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"));const a=s.reduce(((t,e)=>t*e)),l=mf(r.shape,s,a),u=gf(l.length,s.length),h=yf(r.shape,s,a),d=bf(o,s.length),p=vf(h,o,s.length),f=[],m=oR({inputs:{x:r},backend:n,attrs:{shape:l}}),g=pP({inputs:{x:m},backend:n,attrs:{perm:u}}),y=oR({inputs:{x:g},backend:n,attrs:{shape:h}}),b=YP({inputs:{x:y},backend:n,attrs:{begin:d,size:p}});return f.push(m),f.push(g),f.push(y),f.forEach((t=>n.disposeData(t.dataId))),b}},QP=`\n  fn bincount_write(index: i32, value: f32) {\n    ${KI("&result[index]","value","float32")}\n  }\n`;
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tO{constructor(t,e,n=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=t,this.rank=t.length,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=e,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`\n    ${this.binaryOutput?"\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n":QP}\n  ${eA("index")} {\n    ${1===this.rank?`if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};\n        bincount_write(indexVal, value);\n      }\n    }`:`let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }`}\n  }\n  `}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eO={kernelName:wt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,weights:s}=e,{size:o}=i,a=d(r.shape),l=d(s.shape)>0,c=[o],u=s.dtype,h=rR({backend:n,attrs:{shape:c,value:0,dtype:u}}),p=new tO([a],l),f=[{type:"int32",data:[o]}],m=l?[r,s]:[r];return n.runWebGPUProgram(p,m,u,f,h)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nO{constructor(t){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t],this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`\n  ${eA("index")} {\n    if (index < uniforms.size) {\n      var s0 = 1.0;\n      var s1 = 1.0;\n      let indexS0 = index - uniforms.size + uniforms.s0Size;\n      let indexS1 = index - uniforms.size + uniforms.s1Size;\n      if (indexS0 >= 0) {\n        s0 = getS0(indexS0);\n      }\n      if (indexS1 >= 0) {\n        s1 = getS1(indexS1);\n      }\n\n      if (s0 == 1.0) {\n        setOutputAtIndex(index, s1);\n      } else if (s1 == 1.0) {\n        setOutputAtIndex(index, s0);\n      } else if (s0 != s1) {\n        setOutputAtIndex(index, uniforms.NAN);\n      } else {\n        setOutputAtIndex(index, s0);\n      }\n    }\n  }\n  `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iO={kernelName:Ct,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{s0:i,s1:r}=e;if(n.shouldExecuteOnCPU([i,r])){const t=n.tensorMap.get(i.dataId),e=n.tensorMap.get(r.dataId),s=t.values,o=e.values,a=Ja(Array.from(s),Array.from(o));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const s=d(i.shape),o=d(r.shape),a=Math.max(s,o),l=new nO(a),c=[{type:"int32",data:[s]},{type:"int32",data:[o]}];return n.runWebGPUProgram(l,[i,r],"int32",c)}},rO=bR({opType:wA.NOT_EQUAL,dtype:"bool",cpuKernelImpl:BR}),sO={kernelName:Ye,backendName:"webgpu",kernelFunc:rO};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oO(t){const{inputs:e,backend:n}=t,{input:i}=e;return dR({inputs:{x:n.tensorMap.get(i.dataId).complexTensorInfos.real},backend:n})}const aO={kernelName:dn,backendName:"webgpu",kernelFunc:oO};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lO={kernelName:Tt,backendName:"webgpu",kernelFunc:
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function t(e){const{inputs:n,backend:i,attrs:r}=e,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return dR({inputs:{x:s},backend:i});const e=fc(s.shape),n=t({inputs:{x:s},backend:i,attrs:{dtype:"float32"}}),r=fR({inputs:{real:n,imag:e},backend:i});return e.dispose(),i.disposeData(n.dataId),r}if("complex64"===s.dtype){const e=oO({inputs:{input:s},backend:i}),n=t({inputs:{x:e},backend:i,attrs:{dtype:o}});return i.disposeData(e.dataId),n}if(!E(s.dtype,o)){const t=dR({inputs:{x:s},backend:i});return{dataId:t.dataId,shape:t.shape,dtype:o}}if(i.shouldExecuteOnCPU([s])){const t=i.tensorMap.get(s.dataId).values,[e,n,r]=xR(t,s.shape,s.dtype,o);return i.makeTensorInfo(e,n,r)}if("int32"===o)return function(t,e){const n=new gR(t.shape,JA.TO_INT),i=e.runWebGPUProgram(n,[t],"int32");return{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}(s,i);if("bool"===o){const t=i.makeTensorInfo([],"bool",k("bool",1)),e=rO({inputs:{a:s,b:t},backend:i});return i.disposeData(t.dataId),e}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},cO=yR({opType:JA.CEIL,cpuKernelImpl:wR}),uO={kernelName:_t,backendName:"webgpu",kernelFunc:cO};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class hO{constructor(t){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`\n      ${eA("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue = clamp(\n              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));\n          clampedValue = select(clampedValue, value, isnanVec4(value));\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dO{constructor(t){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`\n      ${eA("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pO={kernelName:Et,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{clipValueMin:s,clipValueMax:o}=i;let a;const l=[{type:"float32",data:[s]},{type:"float32",data:[o]}];return a=d(r.shape)%4==0?new hO(r.shape):new dO(r.shape),n.runWebGPUProgram(a,[r],r.dtype,l)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fO{constructor(t){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`\n    ${eA("index")} {\n      if (index < uniforms.size) {\n        let re = abs(getRealByOutputIndex(index));\n        let im = abs(getImagByOutputIndex(index));\n        let mx = max(re, im);\n\n        // The length function in wgsl may be not underflow-safe on some GPUs.\n        // So the safe solution is to ensure underflow-safety in all cases.\n        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));\n      }\n    }\n  `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mO(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}const gO={kernelName:$t,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:i}=e,r=n.tensorMap.get(i.dataId),s=new fO(i.shape),o=[mO(i,r.complexTensorInfos.real),mO(i,r.complexTensorInfos.imag)];return n.runWebGPUProgram(s,o,o[0].dtype)}};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yO{constructor(t){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=of(t,1),this.variableNames=t.map(((t,e)=>`T${e}`)),this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=t.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const t=[];if(this.offsetLength>0){t.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let e=1;e<this.offsetLength;e++)t.push(`else if (yC < uniforms.offset${[e]}){ setOutputAtCoords(coords.x, coords.y, getT${e}(yR, yC - uniforms.offset${e-1})); }`);const e=this.offsetLength,n=this.offsetLength-1;t.push(`else { setOutputAtCoords(coords.x, coords.y, getT${e}(yR, yC - uniforms.offset${n})); }`)}else t.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`\n      ${eA("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${t.join("\n        ")}\n          }\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bO(t){const{inputs:e,backend:n}=t,{input:i}=e;return dR({inputs:{x:n.tensorMap.get(i.dataId).complexTensorInfos.imag},backend:n})}const vO={kernelName:ve,backendName:"webgpu",kernelFunc:bO};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xO(t,e,n){const i=t[0].dtype;if("complex64"===i){const i=t.map((t=>oO({inputs:{input:t},backend:n}))),r=t.map((t=>bO({inputs:{input:t},backend:n}))),s=xO(i,e,n),o=xO(r,e,n),a=fR({inputs:{real:s,imag:o},backend:n});return i.forEach((t=>n.disposeData(t.dataId))),r.forEach((t=>n.disposeData(t.dataId))),n.disposeData(s.dataId),n.disposeData(o.dataId),a}let r=n.shouldExecuteOnCPU(t);if("string"===i&&(r=!0),r){const r=t.map((t=>{const i=d(t.shape.slice(e));return oR({inputs:{x:t},backend:n,attrs:{shape:[-1,i]}})})),s=r.map((t=>({vals:n.readSync(t.dataId),shape:t.shape}))),o=of(r.map((t=>t.shape)),1),a=1===r[0].shape[0],l=SR(s,o,i,a),c=of(t.map((t=>t.shape)),e),u=n.makeTensorInfo(c,i,l);return r.forEach((t=>n.disposeData(t.dataId))),u}const s=n.device.limits.maxStorageBuffersPerShaderStage-1;if(t.length>s){const i=[];for(let r=0;r<t.length;r+=s){const o=t.slice(r,r+s);i.push(xO(o,e,n))}const r=xO(i,e,n);for(const t of i)n.disposeData(t.dataId);return r}const{tensors2D:o,outShape:a}=function(t,e,n){const i=of(t.map((t=>t.shape)),e),r=t.map((t=>oR({inputs:{x:t},backend:n,attrs:{shape:[d(t.shape.slice(0,e)),d(t.shape.slice(e))]}})));return{tensors2D:r,outShape:i}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(t,e,n),l=o.map((t=>t.shape)),c=new yO(l),u=[],h=new Array(l.length-1);if(h.length>0){h[0]=l[0][1],u.push({type:"int32",data:[h[0]]});for(let t=1;t<h.length;t++)h[t]=h[t-1]+l[t][1],u.push({type:"int32",data:[h[t]]})}const p=n.runWebGPUProgram(c,o,o[0].dtype,u);o.forEach((t=>n.disposeData(t.dataId)));const f=oR({inputs:{x:p},backend:n,attrs:{shape:a}});return n.disposeData(p.dataId),f}function wO(t){const{inputs:e,backend:n,attrs:i}=t,{axis:r}=i,s=w(r,e[0].shape)[0],o=e.map((t=>t.shape));sf(o,s);const a=of(e.map((t=>t.shape)),s);if(0===d(a))return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter((t=>d(t.shape)>0));return 1===l.length?dR({inputs:{x:l[0]},backend:n}):xO(l,s,n)}const SO={kernelName:It,backendName:"webgpu",kernelFunc:wO};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kO{constructor(t,e,n,i,r=!1,s=null,o=!1,a=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t.outShape,this.isChannelsLast="channelsLast"===t.dataFormat,this.isVec4=((t.inChannels%4==0||t.inChannels%3==0)&&this.isChannelsLast||t.outWidth%4==0&&!this.isChannelsLast)&&t.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=dA(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=pA(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&t.inChannels%4!=0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),r&&(this.variableNames.push("bias"),this.variableComponents.push(4)),o&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],r&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=a,this.addBias=r,this.activation=s,this.hasPreluActivationWeights=o,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=e%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=i%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const t=this.isVec4?KN(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):ZN(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),e=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`\n    ${function(t,e,n,i,r=!1,s=null,o=!1,a=4,l=4,c=4){const u=t?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",h=t?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",d=t?"uniforms.xShape[1]":"uniforms.xShape[2]",p=t?"uniforms.xShape[2]":"uniforms.xShape[3]",f=t?"row":"col",m=t?"col":"row",g=`\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n      let outRow = ${f} / outWidth;\n      let outCol = ${f} % outWidth;\n\n      let WRow = ${m} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${m} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];\n      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];\n      let xCh = ${m} % inChannels;\n      var resData = ${JI(a)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${d} && xCol >= 0 && xCol < ${p}) {\n        ${u}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${(t=>{switch(t){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${t} is not supported.`)}})(a)}\n      }\n      return resData;`,y=t?e&&i?`\n      ${g}`:`\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${g}\n      }\n      return ${JI(a)}(0.0);`:i&&n?`\n      ${g}`:`\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${g}\n      }\n      return ${JI(a)}(0.0);`,b=`${(t=>{switch(t){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${t} is not supported.`)}})(l)}`,v=JI(c),x=JI(t?a:l),w=JI(t?l:a);return`\n      ${jN(s,o,4===c,4)}\n      fn mm_readA(batch: i32, row : i32, col : i32) -> ${x} {\n        ${t?y:b}\n      }\n\n      fn mm_readB(batch: i32, row : i32, col : i32) -> ${w} {\n        ${t?b:y}\n      }\n\n      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${v}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n        ${h}\n        ${GN(r,s)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,e[0],e[1],e[2])}\n    ${t}\n  `}}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CO{constructor(t,e=!1,n=null,i=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=t.outShape,this.isChannelsLast="channelsLast"===t.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=e,this.activation=n,this.hasPreluActivationWeights=i,e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`\n       ${jN(this.activation,this.hasPreluActivationWeights,!1,4)}\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ${GN(this.addBias,this.activation)}\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ${eA("index")} {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}\n         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}\n         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];\n             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];\n             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {\n               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     `}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TO{constructor(t,e){this.variableNames=["x"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const t=this.isChannelsLast?1:2,e=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",i=this.isChannelsLast?"coords[2]":"coords[1]",r=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`\n    ${eA("index")} {\n      let coords = getCoordsFromIndex(index);\n      if(index < uniforms.size) {\n        let batch = coords[0];\n        let row = ${n};\n        let col = ${i};\n        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];\n        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);\n        var value = 0.0;\n        if(xRow < uniforms.xShape[${t}] && xRow >= 0) {\n          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -\n              uniforms.pads[1];\n          let xCol = offsetX + uniforms.dilations[1] * ((col %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n          let ch = col % uniforms.inChannels;\n          if(xCol < uniforms.xShape[${e}] && xCol >= 0) {\n            value = ${r};\n          }\n        }\n        setOutputAtIndex(index, value);\n      }\n    }\n   `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _O(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&1===n&&t[0]>1?[t[0],1]:null}function EO({x:t,filter:e,convInfo:n,backend:i,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const l=null!=r,c=null!=s,u="channelsLast"===n.dataFormat,h=u&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type,d=Y().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!d&&(h||1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type)))return function({x:t,filter:e,convInfo:n,backend:i,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const l="channelsLast"===n.dataFormat,c=!l,u=[];let h,d;if(l&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type){const r=n.inHeight*n.inWidth*n.inChannels;h=oR({inputs:{x:t},backend:i,attrs:{shape:[1,n.batchSize,r]}}),d=oR({inputs:{x:e},backend:i,attrs:{shape:[1,r,n.outChannels]}})}else h=oR({inputs:{x:t},backend:i,attrs:{shape:l?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),d=oR({inputs:{x:e},backend:i,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(u.push(h),u.push(d),null!=s){const t=_O(s.shape,l);null!=t&&(s=oR({inputs:{x:s},backend:i,attrs:{shape:t}}),u.push(s))}if(null!=r){const t=_O(r.shape,l);null!=t&&(r=oR({inputs:{x:r},backend:i,attrs:{shape:t}}),u.push(r))}const p=lR({a:l?h:d,b:l?d:h,transposeA:c,transposeB:!1,backend:i,bias:r,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),f=oR({inputs:{x:p},backend:i,attrs:{shape:n.outShape}});u.push(p);for(const t of u)i.disposeData(t.dataId);return f}({x:t,filter:e,convInfo:n,backend:i,bias:r,activation:a,preluActivationWeights:s,leakyreluAlpha:o});const p=Y().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),f=p>-1?p:i.thresholdToIncreaseWorkgroups,m=n.batchSize*Math.ceil(n.outHeight*n.outWidth/32)*Math.ceil(n.outChannels/32);if(Y().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||m<=f)return function({x:t,filter:e,convInfo:n,backend:i,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,strideWidth:h,strideHeight:d,padInfo:p,outWidth:f,outHeight:m,dilationWidth:g,dilationHeight:y,dataFormat:b}=n,v="channelsLast"===b,x=l*c*u,w=m*f,S=v?[n.batchSize,w,x]:[n.batchSize,x,w],k=new TO(S,v),C=[{type:"int32",data:[p.top,p.left]},{type:"int32",data:[d,h]},{type:"int32",data:[y,g]},{type:"int32",data:[f]},{type:"int32",data:[u*l]},{type:"int32",data:[u]}],T=i.runWebGPUProgram(k,[t],t.dtype,C),_=[];_.push(T);const E=oR({inputs:{x:e},backend:i,attrs:{shape:[1,x,-1]}});if(_.push(E),null!=s){const t=_O(s.shape,v);null!=t&&(s=oR({inputs:{x:s},backend:i,attrs:{shape:t}}),_.push(s))}if(null!=r){const t=_O(r.shape,v);null!=t&&(r=oR({inputs:{x:r},backend:i,attrs:{shape:t}}),_.push(r))}const M=lR({a:v?T:E,b:v?E:T,transposeA:!v,transposeB:!1,backend:i,bias:r,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),$=oR({inputs:{x:M},backend:i,attrs:{shape:n.outShape}});_.push(M);for(const t of _)i.disposeData(t.dataId);return $}({x:t,filter:e,convInfo:n,backend:i,bias:r,preluActivationWeights:s,leakyreluAlpha:o,activation:a});let g;const y=[n.padInfo.top,n.padInfo.left],b=[{type:"int32",data:[n.filterHeight,n.filterWidth]},{type:"int32",data:[...y]},{type:"int32",data:[n.strideHeight,n.strideWidth]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]}];if(d)g=new CO(n,l,a,c);else{const t=u?n.outHeight*n.outWidth:n.outChannels,e=u?n.outChannels:n.outHeight*n.outWidth,r=n.filterHeight*n.filterWidth*n.inChannels;b.push({type:"int32",data:[t]},{type:"int32",data:[e]},{type:"int32",data:[r]});const s=i.adapterInfo.isIntel();g=new kO(n,t,e,r,l,a,c,s)}const v=[],x=[t,e];l&&(u||1!==r.shape.length||(r=oR({inputs:{x:r},backend:i,attrs:{shape:[r.shape[0],1,1]}}),v.push(r)),x.push(r)),c&&(u||1!==s.shape.length||(s=oR({inputs:{x:s},backend:i,attrs:{shape:[s.shape[0],1,1]}}),v.push(s)),x.push(s)),"leakyrelu"===a&&(b.push({type:"float32",data:[o]}),g.uniforms+=" alpha : f32,");const w=i.runWebGPUProgram(g,x,t.dtype,b);for(const t of v)i.disposeData(t.dataId);return w}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MO={kernelName:At,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:i}=t,{x:r,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=n,h=aa(l);return EO({x:r,filter:s,convInfo:Zo(r.shape,s.shape,o,c,a,u,!1,h),backend:i})}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $O{constructor(t){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=t.inShape,this.isChannelsLast="channelsLast"===t.dataFormat,this.isVec4=this.isChannelsLast&&t.outChannels%4==0&&t.inChannels%4==0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const t=this.isChannelsLast?1:2,e=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1,i=`\n    ${eA()} {\n      let batch = i32(globalId.z) / uniforms.outShape[1];\n      let r = i32(globalId.z) % uniforms.outShape[1];\n      let c = i32(globalId.y) * ${this.workPerThread};\n      let d1 = i32(globalId.x) * 4;\n\n      let dyCorner = vec2<i32>(r, c) - uniforms.pads;\n\n      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n      // ? = to be determined. : = across all values in that axis.\n      var dotProd: array<vec4<f32>, ${this.workPerThread}>;\n      for (var i = 0; i < ${this.workPerThread}; i++) {\n        dotProd[i] = vec4<f32>(0.0);\n      }\n      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);\n        let wRPerm = uniforms.filterDims.x - 1 - wR;\n        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||\n            fract(dyR) > 0.0) {\n          continue;\n        }\n        let idyR = i32(dyR);\n\n        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);\n          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);\n          let wCPerm = uniforms.filterDims.y - 1 - wC;\n          var bDyCVal = true;\n          var bDyCVal2 = true;\n          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC) > 0.0) {\n            bDyCVal = false;\n          }\n          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC2) > 0.0) {\n            bDyCVal2 = false;\n          }\n\n          let idyC = i32(dyC);\n          let idyC2 = i32(dyC2);\n          if (bDyCVal && bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n              xValue = getDy(batch, idyR, idyC2, d2);\n              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),\n                                                  dot(xValue, wValue1),\n                                                  dot(xValue, wValue2),\n                                                  dot(xValue, wValue3));\n            }\n          } else if (bDyCVal) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n            }\n          } else if (bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC2, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[1] = dotProd[1] + tmpval;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n        let coords = vec4<i32>(batch, r, c + i, d1);\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);\n        }\n      }\n    }\n    `;return this.isVec4?`\n    ${i}\n    `:`\n    ${eA("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[${n}];\n\n        let dyCorner = vec2<i32>(coords[${t}], coords[${e}]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};\n              let wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd = dotProd + xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class IO{constructor(t){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===t.dataFormat,this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`\n    ${eA("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let d2 = coords[3];\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b = b + 1) {\n          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              if (${this.isChannelsLast}) {\n                let dyValue = getDy(b, yR, yC, d2);\n                let xValue = getX(b, xR, xC, d1);\n                dotProd = dotProd + xValue * dyValue;\n              } else {\n                let dyValue = getDy(b, d2, yR, yC);\n                let xValue = getX(b, d1, xR, xC);\n                dotProd = dotProd + xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class AO{constructor(t){this.variableNames=["x","dy"],this.uniforms="pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,\n       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`\n    ${eA("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wF = coords.x;\n        let wR = coords.y;\n        let wC = coords.z;\n        let d1 = coords.w;\n        let d2 = coords.u;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yF = 0; yF < uniforms.outDepth; yF++) {\n            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];\n            if (xF < 0 || xF >= uniforms.inDepth) {\n              continue;\n            }\n\n            for (var yR = 0; yR < uniforms.outHeight; yR++) {\n              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];\n              if (xR < 0 || xR >= uniforms.inHeight) {\n                continue;\n              }\n\n              for (var yC = 0; yC < uniforms.outWidth; yC++) {\n                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];\n                if (xC < 0 || xC >= uniforms.inWidth) {\n                  continue;\n                }\n\n                let dyValue = getDy(b, yF, yR, yC, d2);\n                let xValue = getX(b, xF, xR, xC, d1);\n                dotProd += xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class NO{constructor(t){this.variableNames=["dy","W"],this.uniforms="filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`\n    ${eA("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let d1 = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyFCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);\n          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {\n            continue;\n          }\n          let idyF = i32(dyF);\n\n          let wFPerm = uniforms.filterDims[0] - 1 - wF;\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            let wRPerm = uniforms.filterDims[1] - 1 - wR;\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let wCPerm = uniforms.filterDims[2] - 1 - wC;\n\n              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {\n                let xValue = getDy(batch, idyF, idyR, idyC, d2);\n                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RO={kernelName:Nt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,dy:s}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=i,h=aa(l),d=Zo(r.shape,u,o,1,a,c,!1,h),p=new IO(d),f=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]}];return n.runWebGPUProgram(p,[r,s],r.dtype,f)}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PO{constructor(t){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t.inShape,c("channelsLast"===t.dataFormat,(()=>"TODO: NCHW is unimplemented")),this.isVec4=t.inChannels%4==0&&t.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=dA(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=pA(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const t=this.isVec4?KN(this.elementsPerThread,this.workgroupSize):ZN(this.elementsPerThread,this.workgroupSize);return`\n    ${function(t=4){const e=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        \n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${JI(t)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${JI(t)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${t}];\n      }\n      return ${JI(t)}(0.0);`;return`\n  fn mm_readA(batch: i32, row : i32, col : i32) -> ${JI(t)} {\n    ${e}\n  }\n\n  fn mm_readB(batch: i32, row : i32, col : i32) -> ${JI(t)} {\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${(t=>{switch(t){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${t} is not supported.`)}})(t)}\n    }\n    return ${JI(t)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${JI(t)}) {\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${t}] = value;\n    }\n  }`}(this.isVec4?4:1)}\n    ${t}\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OO={kernelName:Rt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,filter:s}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=i,h=aa(c),d=Zo(o,s.shape,a,1,l,u,!1,h),p=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize,d.outHeight,d.outWidth,d.outChannels]}];let f;if(Y().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||"channelsLast"!==d.dataFormat)f=new $O(d);else{f=new PO(d);const t=d.inHeight*d.inWidth,e=d.inChannels,n=d.filterHeight*d.filterWidth*d.outChannels;p.push({type:"uint32",data:[t]},{type:"uint32",data:[e]},{type:"uint32",data:[n]})}return n.runWebGPUProgram(f,[r,s],"float32",p)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LO{constructor(t){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`\n    ${eA("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords.x;\n        let d2 = coords.u;\n\n        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n        let xFCorner = xFRCCorner.x;\n        let xRCorner = xFRCCorner.y;\n        let xCCorner = xFRCCorner.z;\n\n        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;\n        let inputDepthVec4Remainder = uniforms.xShape.u % 4;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let xF = xFCorner + wF * uniforms.dilations[0];\n          if (xF < 0 || xF >= uniforms.xShape.y) {\n            continue;\n          }\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let xR = xRCorner + wR * uniforms.dilations[1];\n            if (xR < 0 || xR >= uniforms.xShape.z) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let xC = xCCorner + wC * uniforms.dilations[2];\n              if (xC < 0 || xC >= uniforms.xShape.w) {\n                continue;\n              }\n\n              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {\n                let xValues = vec4<f32>(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                let wValues = vec4<f32>(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (inputDepthVec4Remainder == 1) {\n                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2);\n              } else if (inputDepthVec4Remainder == 2) {\n                let xValues = vec2<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)\n                );\n                let wValues = vec2<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (inputDepthVec4Remainder == 3) {\n                let xValues = vec3<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)\n                );\n                let wValues = vec3<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }`}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DO={kernelName:Pt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l}=i,c=Jo(r.shape,s.shape,o,l,a),u=[c.padInfo.front,c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationDepth,c.dilationHeight,c.dilationWidth]}],d=new LO(c),p=Hr(r.dtype,s.dtype);return n.runWebGPUProgram(d,[r,s],p,h)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FO={kernelName:Ot,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,dy:s}=e,{strides:o,pad:a,filterShape:l}=i,c=Jo(r.shape,l,o,1,a),u=new AO(c),h=[{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inDepth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return n.runWebGPUProgram(u,[r,s],s.dtype,h)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zO={kernelName:Lt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,filter:s}=e,{strides:o,pad:a,inputShape:l}=i,c=Jo(l,s.shape,o,1,a),u=new NO(c),h=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterDepth-1-c.padInfo.front,c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels]}];return n.runWebGPUProgram(u,[r,s],r.dtype,h)}},BO=yR({opType:JA.COS}),UO={kernelName:Dt,backendName:"webgpu",kernelFunc:BO},VO=yR({opType:JA.COSH}),WO={kernelName:Ft,backendName:"webgpu",kernelFunc:VO};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class HO{constructor(t,e,n,i){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[r]=e;this.outputShape=[r,n[0],n[1],t],this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===i?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[t,e]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,i,r]=this.cropHeightBiggerThan1?[`(${t} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${t} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${t}`],[s,o,a]=this.cropWidthBiggerThan1?[`(${e} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${e} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${e}`];return`\n    ${eA("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${n});\n        let width_ratio = f32(${s});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${i};\n        let width_scale = ${o};\n        let in_y = ${r};\n        if( in_y < 0.0 || in_y > ${t} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${a};\n        if( in_x < 0.0 || in_x > ${e} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jO={kernelName:Ut,backendName:"webgpu",kernelFunc:t=>{const{inputs:e,backend:n,attrs:i}=t,{image:r,boxes:s,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=i,u=new HO(r.shape[3],s.shape,a,l),h=[{type:"float32",data:[c]}];return n.runWebGPUProgram(u,[r,s,o],"float32",h)}};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var GO;!function(t){t.Prod="*",t.Sum="+"}(GO||(GO={}));class qO{constructor(t,e,n,i){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=i,this.op=t,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const t=this.outputShape.length,e=this.op===GO.Prod?"1.0":"0.0",n=this.exclusive?e:`getX(${XO(t,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1];let r="",s="";return this.exclusive?(r=this.reverse?"end != "+(i-1):"end != 0",s=this.reverse?"end + 1":"end - 1"):(r=this.reverse?`end + pow2 < ${i}`:"end >= pow2",s=this.reverse?"end + pow2":"end - pow2"),`\n      ${eA("index")} {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ${KO(t,"coords",this.op)};\n         var val = ${n};\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (${r}) {\n           let idx = ${s};\n           ${KO(t,"coords",this.op)} = idx;\n           val ${this.op}= getX(${XO(t,"coords",this.op)});\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    `}}function XO(t,e,n){if(1===t)return`${e}`;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function KO(t,e,n){if(1===t)return`${e}`;if(2===t)return`${e}.y`;if(3===t)return`${e}.z`;if(4===t)return`${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YO(t,e,n,i,r,s){const o=e.shape.length,a=fl([i],o);let l=e;null!=a&&(l=pP({inputs:{x:e},backend:n,attrs:{perm:a}}));const c=gl(1,o)[0];if(c!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${i}`);const u=l.shape[c];let h=dR({inputs:{x:l},backend:n});for(let e=0;e<=Math.ceil(Math.log2(u))-1;e++){const i=new qO(t,l.shape,!1,s),r=h,o=[{type:"float32",data:[e]}];h=n.runWebGPUProgram(i,[h],h.dtype,o),n.disposeData(r.dataId)}if(r){const e=new qO(t,l.shape,r,s),i=h,o=[{type:"float32",data:[0]}];h=n.runWebGPUProgram(e,[h],h.dtype,o),n.disposeData(i.dataId)}if(null!=a){const t=pP({inputs:{x:h},backend:n,attrs:{perm:ml(a)}});return n.disposeData(h.dataId),n.disposeData(l.dataId),t}return h}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZO={kernelName:zt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,exclusive:o,reverse:a}=i;return YO(GO.Prod,r,n,s,o,a)}};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JO={kernelName:Bt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,exclusive:o,reverse:a}=i;return YO(GO.Sum,r,n,s,o,a)}};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QO={kernelName:Vt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,weights:s}=e,{size:o,binaryOutput:a}=i,l=1===r.shape.length,c=d(s.shape)>0,u=s.dtype,h=l?[r.shape[0]]:[r.shape[0],r.shape[1]],p=rR({backend:n,attrs:{shape:l?[o]:[r.shape[0],o],value:0,dtype:u}}),f=new tO(h,c,a),m=[{type:"int32",data:[o]}],g=c?[r,s]:[r];return n.runWebGPUProgram(f,g,u,m,p)}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tL{constructor(t,e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${e}`,this.dataFormat=e}getUserCode(){return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ${this.getHeightCoordString()};\n          let w = ${this.getWidthCoordString()};\n          let d = ${this.getDepthCoordString()};\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ${this.getOutputDepthSize()};\n          let in_d = d + offset_d;\n\n          let rlt = ${this.getInputSamplingString()};\n          setOutputAtIndex(index, rlt);\n        }\n      }`}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eL={kernelName:Wt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{blockSize:s,dataFormat:o}=i,a=r.shape[0],l=("NHWC"===o?r.shape[1]:r.shape[2])*s,c=("NHWC"===o?r.shape[2]:r.shape[3])*s,u=("NHWC"===o?r.shape[3]:r.shape[1])/(s*s),h=[{type:"int32",data:[s]}],d=new tL("NHWC"===o?[a,l,c,u]:[a,u,l,c],o);return n.runWebGPUProgram(d,[r],r.dtype,h)}};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nL{constructor(t,e,n,i=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=t,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),i&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.addBias=i,this.activation=r,this.hasPreluActivation=s,this.filterHeight=e,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const t=this.filterWidth*this.filterHeight,e=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,i=this.workgroupSize[0]+this.filterWidth-1;return`\n      ${jN(this.activation,this.hasPreluActivation,!1,4)}\n\n      var<workgroup> mm_Asub : array<array<f32, ${i}>, ${n}>;\n      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      ${eA()} {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {\n          for (var inputCol = localCol; inputCol < ${i}; inputCol = inputCol + ${this.workgroupSize[0]}) {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = i32(localIndex);\n        ${t<e?`if (wIndex < ${t})`:`for(; wIndex < ${t}; wIndex = wIndex + ${e})`}\n\n        {\n          let wRow = wIndex / ${this.filterWidth};\n          let wCol = wIndex % ${this.filterWidth};\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {\n          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ${GN(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iL{constructor(t,e=!1,n=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=t.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const r=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=fA(r),this.dispatch=hA(this.dispatchLayout,r,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),c("channelsLast"===t.dataFormat,(()=>"TODO: NCHW is unimplemented")),e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=t,this.addBias=e,this.activation=n,this.hasPreluActivation=i,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const t=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,e=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return`\n      ${jN(this.activation,this.hasPreluActivation,!0,4)}\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      ${eA("index")} {\n        let width0 = uniforms.outShape[3] / ${this.outputComponent};\n        let d1 = (index % width0) * ${this.outputComponent};\n        var index1 = index / width0;\n        let width1 = uniforms.virtualWidth / ${this.workPerThread};\n        let c = (index1 % width1) * ${this.workPerThread};\n        index1 = index1 / width1;\n        let r = index1 % uniforms.outShape[1];\n        let batch = index1 / uniforms.outShape[1];\n\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${e}, ${n}) - uniforms.pads;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ${t}>;\n        var dotProd : array<vec4<f32>, ${this.workPerThread}>;\n        for (var i = 0; i < ${this.workPerThread}; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ${t}; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ${this.workPerThread}; i++) {\n                dotProd[i] = fma(xVals[i * ${n} + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ${GN(this.addBias,this.activation)}\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rL{constructor(t,e=!1,n=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===t.dataFormat,e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=t,this.addBias=e,this.activation=n,this.hasPreluActivation=i,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const t=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`\n      ${jN(this.activation,this.hasPreluActivation,!1,4)}\n\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;\n          let d2 = coords[${this.isChannelsLast?3:1}];\n          let channelMul = uniforms.wShape[3];\n          let d1 = d2 / channelMul;\n          let q = d2 % channelMul;\n\n          let inputRowStart = xRCCorner.x;\n          let inputColStart = xRCCorner.y;\n          let inputRowEnd = inputRowStart + uniforms.filterHeight *\n              uniforms.dilations[0];\n          let inputColEnd = inputColStart + uniforms.filterWidth *\n              uniforms.dilations[1];\n\n          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n          var value = 0.0;\n\n          // Extract if checking out of for loop for performance.\n          if (inputRowStart >= 0 && inputColStart >= 0 &&\n            inputRowEnd < uniforms.inDims[0] &&\n                inputColEnd < uniforms.inDims[1]) {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  let xVal = ${t};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            } else {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                if (xR < 0 || xR >= uniforms.inDims[0]) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  if (xC < 0 || xC >= uniforms.inDims[1]) {\n                    continue;\n                  }\n\n                  let xVal = ${t};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            }\n            ${GN(this.addBias,this.activation)}\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sL={kernelName:Ht,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=i,h=aa(l);let d=c;null==d&&(d=[1,1]);const p=Zo(r.shape,s.shape,o,d,a,u,!0,h),f=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inHeight,p.inWidth]}],m="channelsLast"===p.dataFormat;let g;return!m&&p.inHeight>16&&p.inWidth>16&&1===p.strideHeight&&1===p.strideWidth&&1===p.dilationWidth&&1===p.dilationHeight&&p.inChannels===p.outChannels?g=new nL(p.outShape,p.filterHeight,p.filterWidth):m&&p.outHeight>4&&p.outWidth>4&&p.strideWidth<=2&&p.inChannels===p.outChannels&&1===p.dilationHeight&&1===p.dilationWidth&&p.inChannels%4==0?(g=new iL(p),f.push({type:"int32",data:[g.virtualWidth]})):(g=new rL(p),f.push({type:"int32",data:[p.filterHeight]},{type:"int32",data:[p.filterWidth]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]})),n.runWebGPUProgram(g,[r,s],r.dtype,f)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oL{constructor(t){this.variableNames=["x","dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,\n      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`\n      ${eA("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let dm = coords[3];\n        let d2 = d1 * uniforms.channelMul + dm;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yR = 0; yR < uniforms.outHeight; yR++) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC++) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              let dyValue = getDy(b, yR, yC, d2);\n              let xValue = getX(b, xR, xC, d1);\n              dotProd += xValue * dyValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class aL{constructor(t){this.variableNames=["dy","W"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`\n      ${eA("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[3];\n        let dyCorner = coords.yz - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n\n          let idyR = i32(dyR);\n          let wRPerm = uniforms.filterDims[0] - 1 - wR;\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n\n            let idyC = i32(dyC);\n            let wCPerm = uniforms.filterDims[1] - 1 - wC;\n\n            for (var dm = 0; dm < uniforms.channelMul; dm++) {\n              let d2 = d1 * uniforms.channelMul + dm;\n              let xValue = getDy(batch, idyR, idyC, d2);\n              let wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lL={kernelName:jt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,dy:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=i,h=Zo(r.shape,u,o,a,l,c,!0),d=new oL(h),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return n.runWebGPUProgram(d,[r,s],"float32",p)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cL={kernelName:Gt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,filter:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=i,h=Zo(u,s.shape,o,a,l,c,!0),d=new aL(h),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return n.runWebGPUProgram(d,[r,s],r.dtype,p)}};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uL{constructor(t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,t],this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hL={kernelName:qt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:i}=e,r=[...i.shape,...i.shape],s=d(i.shape),o=oR({inputs:{x:i},backend:n,attrs:{shape:[s]}}),a=new uL(s),l=n.runWebGPUProgram(a,[o],o.dtype),c=oR({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeData(o.dataId),n.disposeData(l.dataId),c}};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dL{constructor(t){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`\n       ${eA("index")} {\n         if (index < uniforms.size) {\n           let neg_infinity = -3.4e38;\n           let coords = getOutputCoords();\n           let batch = coords.x;\n           let d1 = coords.w;\n           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;\n           let hBeg = outTopLeftCorner.x;\n           let wBeg = outTopLeftCorner.y;\n\n           var curVal = neg_infinity;\n           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {\n             let hIn = hBeg + h * uniforms.dilations[0];\n\n             if (hIn >= 0 && hIn < uniforms.xShape[1]) {\n               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {\n                 let wIn = wBeg + w * uniforms.dilations[1];\n\n                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {\n                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);\n                   if (val > curVal) {\n                     curVal = val;\n                   }\n                 }\n               }\n             }\n           }\n\n           setOutputAtIndex(index, curVal);\n         }\n       }\n     `}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pL={kernelName:Xt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s}=e,{strides:o,pad:a,dilations:l}=i,c=Xo(r.shape,s.shape,o,a,"NHWC",l),u=[c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],d=new dL(c);return n.runWebGPUProgram(d,[r,s],r.dtype,h)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fL{constructor(t,e){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t.inShape,this.dispatchLayout=fA(t.outShape),this.dispatch=hA(this.dispatchLayout,t.outShape,this.workgroupSize),"float32"!==e&&"int32"!==e)throw new Error(`Dilation2DBackpropInput only supports float32 and int32\n          types, does not support ${e} type.`);this.type=e,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`\n       ${eA("index")} {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var xRMax = 0;\n           var xCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     xRMax = xR;\n                     xCMax = xC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.xShape[3] *\n               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));\n           let value = getDy(b, r, c, d);\n           ${KI("&result[flatIndexIn]","value",this.type)}\n         }\n       }\n     `}}class mL{constructor(t,e,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t.filterShape,this.dispatchLayout=fA(t.outShape),this.dispatch=hA(this.dispatchLayout,t.outShape,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error(`Dilation2DBackpropFilter only supports float32 and int32\n          types, does not support ${n} type.`);this.type=n,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`\n       ${eA("index")} {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var wRMax = 0;\n           var wCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     wRMax = wR;\n                     wCMax = wC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);\n           let value = getDy(b, r, c, d);\n           ${KI("&result[flatIndexIn]","value",this.type)}\n         }\n       }\n     `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gL={kernelName:Yt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s,dy:o}=e,{strides:a,pad:l,dilations:c}=i,u=Xo(r.shape,s.shape,a,l,"NHWC",c),h=s.dtype,p=new mL(u,s.shape,h),f=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[d(u.outShape)]}],m=rR({backend:n,attrs:{shape:s.shape,value:0,dtype:h}});return n.runWebGPUProgram(p,[r,s,o],h,f,m)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yL={kernelName:Kt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s,dy:o}=e,{strides:a,pad:l,dilations:c}=i,u=Xo(r.shape,s.shape,a,l,"NHWC",c),h=r.dtype,p=new fL(u,h),f=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[d(u.outShape)]}],m=rR({backend:n,attrs:{shape:u.inShape,value:0,dtype:h}});return n.runWebGPUProgram(p,[r,s,o],h,f,m)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bL{constructor(t,e,n){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=YI.DRAW,this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=e,this.textureFormat=n,this.shaderKey=`draw_${e}_${n}`}getUserCode(){let t;const e="float32"===this.type?"value":"value / 255.0";t=`\n      if (uniforms.numChannels == 1) {\n        rgba[0] = ${e};\n        rgba[1] = ${e};\n        rgba[2] = ${e};\n      } else {\n        rgba[d] = ${e};\n      }`;return`\n       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;\n       ${eA("index")} {\n         if (index < uniforms.size) {\n           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);\n           for (var d = 0; d < uniforms.numChannels; d = d + 1) {\n             let value = f32(inBuf[index * uniforms.numChannels + d]);\n             ${t}\n           }\n           rgba.x = rgba.x * rgba.w;\n           rgba.y = rgba.y * rgba.w;\n           rgba.z = rgba.z * rgba.w;\n           let coords = getCoordsFromIndex(index);\n           textureStore(outImage, vec2<i32>(coords.yx), rgba);\n         }\n       }\n      `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vL={kernelName:Zt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{image:r}=e,{canvas:s,options:o}=i,[a,l]=r.shape.slice(0,2),{imageOptions:c}=o||{},u=(null==c?void 0:c.alpha)||1,h=n.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",d=[a,l],p=new bL(d,r.dtype,h);s.width=l,s.height=a;const f="webgpu";let m,g=s.getContext(f);g||(m=new OffscreenCanvas(l,a),g=m.getContext(f));const y=3===r.shape.length?r.shape[2]:1;g.configure({device:n.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const b="int32",v=n.makeTensorInfo(d,b),x=n.tensorMap.get(v.dataId);x.resource=g.getCurrentTexture(),x.external=!0;const w=[{type:"uint32",data:[y]},{type:"float32",data:[u]}];if(n.runWebGPUProgram(p,[r],b,w,v),m){const t=s.getContext("2d");if(!t)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");t.drawImage(m,0,0)}return n.disposeData(v.dataId),r}},xL=bR({opType:wA.MUL,cpuKernelImpl:FR,supportsComplex:!0}),wL={kernelName:Xe,backendName:"webgpu",kernelFunc:xL};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SL(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,keepDims:o}=i;return yP(r,s,o,"sum",n)}const kL={kernelName:Ln,backendName:"webgpu",kernelFunc:SL};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CL={kernelName:Qt,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{equation:r}=i,s=e,{allDims:o,summedDims:a,idDims:l}=Bf(r,s.length);Vf(o.length,l,s);const{path:c,steps:u}=Wf(a,l),h=u.length;let d=null,p=o.length;const f=[];for(let t=0;t<h;++t){for(const e of u[t]){const{permutationIndices:t,expandDims:i}=Uf(p,l[e]);let r;Hf(t)?r=s[e]:(r=pP({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(r));const o=r.shape.slice();for(let t=0;t<i.length;++t)o.splice(i[t],0,1);m(r.shape,o)||(r=oR({inputs:{x:r},backend:n,attrs:{shape:o}}),f.push(r)),null===d?d=r:(d=xL({inputs:{a:r,b:d},backend:n}),f.push(d))}t<h-1&&(c[t]>=0&&(d=SL({inputs:{x:d},backend:n,attrs:{axis:c[t]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const t of f)t!==d&&n.disposeData(t.dataId);return d}},TL=yR({opType:JA.ELU}),_L={kernelName:te,backendName:"webgpu",kernelFunc:TL},EL={kernelName:ee,backendName:"webgpu",kernelFunc:t=>{const{inputs:e,backend:n}=t,{dy:i,y:r}=e,s=new hR(wA.ELU_DER,i.shape,r.shape);return n.runWebGPUProgram(s,[i,r],i.dtype)}},ML=bR({opType:wA.EQUAL,dtype:"bool",cpuKernelImpl:kR}),$L={kernelName:ie,backendName:"webgpu",kernelFunc:ML},IL=yR({opType:JA.ERF}),AL={kernelName:ne,backendName:"webgpu",kernelFunc:IL},NL=yR({opType:JA.EXP,cpuKernelImpl:CR,dtype:"float32"}),RL={kernelName:re,backendName:"webgpu",kernelFunc:NL};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PL(t){const{inputs:e,attrs:n,backend:i}=t,{dim:r}=n,{input:s}=e,o=s.shape.length,a=s.shape.slice();let l=r;return r<0&&(c(-(o+1)<=r,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+r+1),a.splice(l,0,1),oR({inputs:{x:s},backend:i,attrs:{shape:a}})}const OL={kernelName:se,backendName:"webgpu",kernelFunc:PL},LL=yR({opType:JA.EXPM1,cpuKernelImpl:TR}),DL={kernelName:oe,backendName:"webgpu",kernelFunc:LL};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class FL{constructor(t,e){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=t,this.shaderKey=`fft_${t}`}getUserCode(){return`\n    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {\n      ${"real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}\n    }\n\n    fn mulMatDFT(batch: i32, index: i32) -> f32 {\n      let indexRatio = f32(index) / f32(uniforms.realShape[1]);\n      let exponentMultiplierTimesIndexRatio =\n          uniforms.exponentMultiplier * indexRatio;\n\n      var result = 0.0;\n\n      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {\n        // x = (-2|2 * PI / N) * index * i;\n        let x = exponentMultiplierTimesIndexRatio * f32(i);\n        let expR = cos(x);\n        let expI = sin(x);\n        let real = getReal(batch, i);\n        let imag = getImag(batch, i);\n\n        result = result +\n            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;\n      }\n\n      return result;\n    }\n\n    ${eA("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));\n      }\n    }\n  `}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zL(t,e,n){const i=n.tensorMap.get(t.dataId),r=d(t.shape),s=t.shape[t.shape.length-1],o=[],a=oR({inputs:{x:t},backend:n,attrs:{shape:[r/s,s]}});o.push(a);const l=a.shape,c=new FL("real",l),u=new FL("imag",l),h=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:l},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:l}],p=[{type:"float32",data:[e?2*Math.PI:-2*Math.PI]},{type:"float32",data:[e?l[1]:1]}],f=n.runWebGPUProgram(c,h,"float32",p);o.push(f);const m=n.runWebGPUProgram(u,h,"float32",p);o.push(m);const g=fR({inputs:{real:f,imag:m},backend:n});o.push(g);const y=oR({inputs:{x:g},backend:n,attrs:{shape:t.shape}});return o.forEach((t=>n.disposeData(t.dataId))),y}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BL={kernelName:ae,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:i}=e;return zL(i,!1,n)}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UL{constructor(t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VL={kernelName:ce,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,i=e,r=new UL(n.shape);return i.runWebGPUProgram(r,[n],n.dtype)}},WL=yR({opType:JA.FLOOR,cpuKernelImpl:_R}),HL={kernelName:ue,backendName:"webgpu",kernelFunc:WL},jL=bR({opType:wA.FLOOR_DIV,cpuKernelImpl:ER,dtype:"int32"}),GL={kernelName:he,backendName:"webgpu",kernelFunc:jL};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class qL{constructor(t,e,n=!1){this.pixelsOpType=YI.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize,[e,1,1]),this.importVideo=n,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const t=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`\n      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};\n      ${eA("index")} {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ${t};\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XL={kernelName:ui,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t;let{pixels:r}=e;const{numChannels:s}=i;if(null==r)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,a="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,l="undefined"!=typeof HTMLCanvasElement&&r instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&r instanceof OffscreenCanvas,c="undefined"!=typeof ImageBitmap&&r instanceof ImageBitmap,[u,h]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],p=[h,u,s],f=o||a;if(c||l||f){let t;{if(f){const t=Y().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=KL&&t===YL||(YL=t,KL=document.createElement("canvas").getContext("2d",{willReadFrequently:YL})),KL.canvas.width=u,KL.canvas.height=h,KL.drawImage(r,0,0,u,h),r=KL.canvas}const e=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,i="rgba8unorm",s=n.textureManager.acquireTexture(p[1],p[0],i,e);n.queue.copyExternalImageToTexture({source:r},{texture:s},[p[1],p[0]]),t=s}const e=d(p),i=L(p),o=new qL(p,s,false),a=[{type:"uint32",data:[e]},{type:"uint32",data:[s]},{type:"uint32",data:[...i]}],l=n.makeTensorInfo([h,u],"int32");n.tensorMap.get(l.dataId).resource=t;const c=n.runWebGPUProgram(o,[l],"int32",a);return n.disposeData(l.dataId),c}const m=r.data;let g=m;if(null!=s&&4!==s){g=new Uint8Array(r.width*r.height*s);const t=m.length;let e=0;for(let n=0;n<t;n++)n%4<s&&(g[e++]=m[n])}const y=n.makeTensorInfo(p,"int32",new Int32Array(g));return n.uploadToGPU(y.dataId),y}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */};let KL,YL=Y().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class ZL{constructor(t,e,n,i,r){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],Ja(t,e),Ja(t,n),this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=i&&(Ja(t,i),this.variableNames.push("offset")),null!=r&&(Ja(t,r),this.variableNames.push("scale")),this.offsetShape=i,this.scaleShape=r,this.shaderKey="batchNorm"}getUserCode(){let t="0.0";null!=this.offsetShape&&(t="getOffsetByOutputIndex(index)");let e="1.0";null!=this.scaleShape&&(e="getScaleByOutputIndex(index)");return`\n      ${eA("index")} {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ${t};\n          let scaleValue = ${e};\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JL={kernelName:de,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:i,scale:r,offset:s,mean:o,variance:a}=t,{varianceEpsilon:l}=e,c=n,u=[i,o,a];let h=null;null!=s&&(h=s.shape,u.push(s));let d=null;null!=r&&(d=r.shape,u.push(r));const p=new ZL(i.shape,o.shape,a.shape,h,d),f=[{type:"float32",data:[l]}];return c.runWebGPUProgram(p,u,i.dtype,f)}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QL={kernelName:pi,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=i,m=aa(u);return EO({x:r,filter:s,convInfo:Zo(r.shape,s.shape,l,h,c,d,!1,m),backend:n,bias:o,preluActivationWeights:a,leakyreluAlpha:f,activation:p})}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tD={kernelName:fi,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=i;let m=h;null==m&&(m=[1,1]),c(sa(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=Zo(r.shape,s.shape,l,m,u,d,!0),y=[r,s],b=null!=o,v=null!=a;b&&y.push(o),v&&y.push(a);const x=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}];let w;return g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&1===g.dilationHeight&&1===g.dilationWidth&&g.inChannels%4==0?(w=new iL(g,b,p,v),x.push({type:"int32",data:[w.virtualWidth]})):(w=new rL(g,b,p,v),x.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),"leakyrelu"===p&&(x.push({type:"float32",data:[f]}),w.uniforms+=" alpha : f32,"),n.runWebGPUProgram(w,y,"float32",x)}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eD{constructor(t,e){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${t}`,this.sliceDim=t,this.uniforms=`sliceDim : i32, strides : ${QI(t)},`}getUserCode(){let t;t=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides";return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ${t};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nD={kernelName:fe,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:i,indices:r}=e,s=r.shape,o=s[s.length-1],a=d(i.shape),[l,c,u,h]=Pp(i,r),p=oR({inputs:{x:r},backend:n,attrs:{shape:[c,o]}}),f=oR({inputs:{x:i},backend:n,attrs:{shape:[d(i.shape)/u,u]}});if(n.shouldExecuteOnCPU([i,r])||"string"===i.dtype){const t=n.readSync(r.dataId),e=n.bufferSync(i),s=MR(t,e,i.dtype,c,o,u,h,i.shape,a);return n.makeTensorInfo(l,i.dtype,s.values)}const m=new eD(o,[c,u]),g=[{type:"int32",data:[o]},{type:"int32",data:h}],y=n.runWebGPUProgram(m,[f,p],f.dtype,g),b=oR({inputs:{x:y},backend:n,attrs:{shape:l}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(y.dataId),b}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iD{constructor(t,e){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.slice(),this.aShape=t,this.outputShape=e,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const t=function(t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let i=0;i<t.length;i++)2===i?n.push("indexZ"):n.push(`${e[i]}`);return n.join()}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(this.aShape);return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(${t}));\n        }\n      }\n    `}}function rD(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,indices:s}=e,{axis:o,batchDims:a}=i,l=am(r,s,w(o,r.shape)[0],a),c=d(s.shape),u=[],h=oR({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=oR({inputs:{x:s},backend:n,attrs:{shape:[l.batchSize,c/l.batchSize]}});u.push(h),u.push(p);const f=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([r,s])){const t=n.tensorMap.get(p.dataId).values,e=bo(p.shape,p.dtype,t),i=n.tensorMap.get(h.dataId).values,r=bo(h.shape,h.dtype,i),s=$R(r,e,f);return u.forEach((t=>n.disposeData(t.dataId))),n.makeTensorInfo(l.outputShape,s.dtype,s.values)}const m=new iD(h.shape,f),g=n.runWebGPUProgram(m,[h,p],h.dtype);u.push(g);const y=oR({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return u.forEach((t=>n.disposeData(t.dataId))),y}const sD={kernelName:pe,backendName:"webgpu",kernelFunc:rD},oD=bR({opType:wA.GREATER,cpuKernelImpl:AR,dtype:"bool"}),aD={kernelName:me,backendName:"webgpu",kernelFunc:oD},lD=bR({opType:wA.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:IR}),cD={kernelName:ge,backendName:"webgpu",kernelFunc:lD};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uD={kernelName:be,backendName:"webgpu",kernelFunc:
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n}=t,{input:i}=e;return zL(i,!0,n)}},hD=yR({opType:JA.IS_FINITE,dtype:"bool"}),dD={kernelName:xe,backendName:"webgpu",kernelFunc:hD},pD=yR({opType:JA.IS_INF,dtype:"bool"}),fD={kernelName:we,backendName:"webgpu",kernelFunc:pD},mD=yR({opType:JA.IS_NAN,dtype:"bool"}),gD={kernelName:Se,backendName:"webgpu",kernelFunc:mD};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yD={kernelName:ke,backendName:"webgpu",kernelFunc:
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{alpha:s}=i,o=[{type:"float32",data:[s]}],a=new gR(r.shape,JA.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(a,[r],"float32",o)}},bD=bR({opType:wA.LESS,dtype:"bool",cpuKernelImpl:RR}),vD={kernelName:Ce,backendName:"webgpu",kernelFunc:bD},xD=bR({opType:wA.LESS_EQUAL,dtype:"bool",cpuKernelImpl:NR}),wD={kernelName:Te,backendName:"webgpu",kernelFunc:xD};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class SD{constructor(t){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t],this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kD={kernelName:_e,backendName:"webgpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:i,stop:r,num:s}=n,o=(r-i)/(s-1),a=new SD(s),l=[{type:"float32",data:[i]},{type:"float32",data:[o]}];return e.runWebGPUProgram(a,[],"float32",l)}},CD=yR({opType:JA.LOG,cpuKernelImpl:PR}),TD={kernelName:Ee,backendName:"webgpu",kernelFunc:CD},_D=yR({opType:JA.LOG1P}),ED={kernelName:Me,backendName:"webgpu",kernelFunc:_D},MD=bR({opType:wA.LOGICAL_AND,dtype:"bool"}),$D={kernelName:$e,backendName:"webgpu",kernelFunc:MD},ID=yR({opType:JA.LOGICAL_NOT}),AD={kernelName:Ie,backendName:"webgpu",kernelFunc:ID},ND=bR({opType:wA.LOGICAL_OR}),RD={kernelName:Ae,backendName:"webgpu",kernelFunc:ND},PD="\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n";
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OD{constructor(t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`\n    ${eA("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ${PD}\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  `}}class LD{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,c(e<=this.maxAllowRadius,(()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${e}`)),this.outputShape=t,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=hA(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`\n    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;\n    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};\n    const maxAllowRadius = ${this.maxAllowRadius};\n\n    ${eA()} {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ${PD}\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } `}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DD={kernelName:Re,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{depthRadius:s,bias:o,alpha:a,beta:l}=i;let c;c=s>16?new OD(r.shape):new LD(r.shape,s);const u=[{type:"int32",data:[s]},{type:"float32",data:[o]},{type:"float32",data:[a]},{type:"float32",data:[l]}];return n.runWebGPUProgram(c,[r],r.dtype,u)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FD{constructor(t){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`\n    ${eA("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n\n        let MIN_DEPTH_BEGIN = 0;\n        let MAX_DEPTH_END = uniforms.outShape[3];\n        var result = 0.0;\n        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {\n          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);\n          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);\n\n          var norm = 0.0;\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            } else {\n              break;\n            }\n          }\n\n          norm = uniforms.alpha * norm + uniforms.bias;\n\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              var dyi = -2.0 * uniforms.alpha * uniforms.beta\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * uniforms.beta);\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, result);\n      }\n    }\n  `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zD={kernelName:Pe,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,y:s,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=i,h=new FD(r.shape),d=[{type:"int32",data:[a]},{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[u]}];return n.runWebGPUProgram(h,[r,s,o],r.dtype,d)}},BD=bR({opType:wA.MAX,cpuKernelImpl:LR}),UD={kernelName:Le,backendName:"webgpu",kernelFunc:BD};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VD={kernelName:De,backendName:"webgpu",kernelFunc:
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=i;return BP(r,Ko(r.shape,s,o,1,a,l),"max",n)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WD={kernelName:ze,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{filterSize:s,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=i,u=Yo(r.shape,s,o,[1,1,1],a,c,l),h=new OP(u,"max"),d=[{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.front,u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.inDepth,u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth]}];return n.runWebGPUProgram(h,[r],r.dtype,d)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HD{constructor(t){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`\n      ${eA("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            let curPosValue = wR * uniforms.filterDims[1] + wC;\n            let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class jD{constructor(t){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`\n      ${eA("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;\n\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;\n              let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GD={kernelName:Be,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s}=e,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=i,h=Yo(o.shape,a,l,[1,1,1],c,u),d=new OP(h,"max",!0);let p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];const f=n.runWebGPUProgram(d,[o],"int32",p),m=new jD(h);p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]}];const g=n.runWebGPUProgram(m,[r,f],o.dtype,p);return n.disposeData(f.dataId),g}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qD={kernelName:Fe,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{dy:r,input:s,output:o}=e,a=s;yA([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=i,d=Ko(a.shape,l,c,1,u,h),p=new PP(d,"max",!0);let f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];const m=n.runWebGPUProgram(p,[a],"int32",f),g=new HD(d);f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const y=n.runWebGPUProgram(g,[r,m],a.dtype,f);return n.disposeData(m.dataId),y}};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XD={kernelName:Ue,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{filterSize:r,strides:s,pad:o,includeBatchInIndex:a}=i,{x:l}=e;c(4===l.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`));const u=[1,1];c(sa(s,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`));const h=Ko(l.shape,r,s,u,o),d=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]}];let p=new PP(h,"max",!1);const f=n.runWebGPUProgram(p,[l],l.dtype,d);return p=new PP(h,"max",!0,!0,a),[f,n.runWebGPUProgram(p,[l],"int32",d)]}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KD={kernelName:We,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,keepDims:o}=i;return yP(r,s,o,"min",n)}},YD=bR({opType:wA.MIN,cpuKernelImpl:DR}),ZD={kernelName:He,backendName:"webgpu",kernelFunc:YD};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class JD{constructor(t,e,n){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1])),this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=t,e.map(((t,e)=>{this.uniforms+=` pad${e} : vec2<i32>,`})),this.offset="reflect"===n?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){const t=this.xShape.length,e=this.xShape.map(((t,e)=>`uniforms.pad${e}[0]`)).join(","),n=this.xShape.map(((e,n)=>`uniforms.pad${n}[0] + uniforms.xShape${t>1?`[${n}]`:""}`)).join(","),i=1===t?"start":"start[i]",r=1===t?"end":"end[i]",s=1===t?"outC":"outC[i]",o=QI(t),a=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let start = ${o}(${e});\n          let end = ${o}(${n});\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ${t}; i = i + 1) {\n            if (${s} < ${i}) {\n              ${s} = ${i} * 2 - ${s} - ${this.offset};\n            } else if(${s} >= ${r}) {\n              ${s} = (${r} - 1) * 2 - ${s} + ${this.offset};\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(${a}));\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QD={kernelName:je,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:i}=t,{paddings:r,mode:s}=e,o=n,a=r.map((t=>({type:"int32",data:[t[0],t[1]]}))),l=new JD(i.shape,r,s);return o.runWebGPUProgram(l,[i],i.dtype,a)}},tF=bR({opType:wA.MOD}),eF={kernelName:Ge,backendName:"webgpu",kernelFunc:tF};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class nF{constructor(t,e){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,e],this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {\n      let HASHSCALE1 = 443.8975;\n      let p = resultUV * seed;\n      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);\n      p3 = p3 + dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${eA("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n\n        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),\n            f32(coords[0]) / f32(uniforms.outShape[0]));\n        let r = random(uniforms.seed, resUV);\n        var cdf = 0.0;\n        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {\n          cdf = cdf + getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutputAtIndexI32(index, i);\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);\n      }\n    }\n  `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iF{constructor(t){this.variableNames=["logits"],this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`\n    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;\n    var<workgroup> rowMaxShared : f32;\n    var<workgroup> rowSumShared : f32;\n    const blockSize = ${this.workgroupSize[0]};\n    ${eA("index")} {\n      let row = index / blockSize;\n      let tid = i32(localId.x);\n      let cols = uniforms.outShape[1];\n\n      var threadMax = -3.402823e+38f;\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = getLogits(row, col);\n        threadMax = max(threadMax, value);\n      }\n      if (tid < cols) {\n        buf[tid] = threadMax;\n      }\n      workgroupBarrier();\n\n      var reduceSize = min(cols, blockSize);\n      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n        reduceSize = currSize + (reduceSize & 1);\n        if (tid < currSize) {\n          buf[tid] = max(buf[tid], buf[tid + reduceSize]);\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowMaxShared = buf[0];\n      }\n      workgroupBarrier();\n\n      var threadSum = 0.0;\n      for (var col = tid; col < cols; col += blockSize) {\n        let subExp = exp(getLogits(row, col) - rowMaxShared);\n        threadSum += subExp;\n      }\n      buf[tid] = threadSum;\n      workgroupBarrier();\n\n      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n        if (tid < currSize) {\n          buf[tid] = buf[tid] + buf[tid + currSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowSumShared = buf[0];\n      }\n      workgroupBarrier();\n\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;\n        setOutputAtCoords(row, col, value);\n      }\n  }\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rF(t){const{inputs:e,backend:n,attrs:i}=t,{logits:r}=e,{dim:s}=i,o=oR({inputs:{x:r},backend:n,attrs:{shape:[d(r.shape)/r.shape[s],r.shape[s]]}}),a=new iF(o.shape),l=n.runWebGPUProgram(a,[o],r.dtype),c=oR({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeData(o.dataId),n.disposeData(l.dataId),c}const sF={kernelName:zn,backendName:"webgpu",kernelFunc:rF};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oF={kernelName:qe,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{logits:r}=e,{numSamples:s,seed:o,normalized:a}=i,l=a?r:rF({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new nF(c,s),d=[{type:"float32",data:[o]},{type:"int32",data:[u]}],p=n.runWebGPUProgram(h,[l],"int32",d);return a||n.disposeData(l.dataId),p}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aF={kernelName:Ke,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:i}=e;if(n.shouldExecuteOnCPU([i])){const t=n.tensorMap.get(i.dataId),[e,r]=zR(t.values,i.shape,i.dtype);return n.makeTensorInfo(r,i.dtype,e)}const r=new gR(i.shape,JA.NEG);return n.runWebGPUProgram(r,[i],i.dtype)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lF={kernelName:Ze,backendName:"webgpu",kernelFunc:function(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:i}=t,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=i,c=n.readSync(r.dataId),u=n.readSync(s.dataId),{selectedIndices:h}=id(c,u,o,a,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cF={kernelName:Qe,backendName:"webgpu",kernelFunc:function(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:i}=t,{boxes:r,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=i,u=n.readSync(r.dataId),h=n.readSync(s.dataId),d=o,p=a,f=l,m=c,{selectedIndices:g,selectedScores:y}=sd(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uF{constructor(t,e){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,e],this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`\n      ${eA("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,\n                                      f32(i32(round(getX(coords.x))) == coords.y)));\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hF={kernelName:en,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{indices:r}=e,{dtype:s,depth:o,onValue:a,offValue:l}=i,c=d(r.shape),u=new uF(c,o),h=oR({inputs:{x:r},backend:n,attrs:{shape:[c]}}),p=[{type:"float32",data:[a]},{type:"float32",data:[l]}],f=n.runWebGPUProgram(u,[h],s,p);n.disposeData(h.dataId);const m=oR({inputs:{x:f},backend:n,attrs:{shape:[...r.shape,o]}});return n.disposeData(f.dataId),m}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dF(t){const{inputs:e,backend:n}=t,{x:i}=e;if("complex64"===i.dtype){const t=oO({inputs:{input:i},backend:n}),e=dF({inputs:{x:t},backend:n}),r=bO({inputs:{input:i},backend:n}),s=dF({inputs:{x:r},backend:n}),o=fR({inputs:{real:e,imag:s},backend:n});return n.disposeData(t.dataId),n.disposeData(e.dataId),n.disposeData(r.dataId),n.disposeData(s.dataId),o}return rR({attrs:{shape:i.shape,dtype:i.dtype,value:"string"===i.dtype?"":0},backend:n})}const pF={kernelName:li,backendName:"webgpu",kernelFunc:dF};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fF={kernelName:tn,backendName:"webgpu",kernelFunc:function t(e){const{inputs:n,backend:i}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const e=oO({inputs:{input:r},backend:i}),n=t({inputs:{x:e},backend:i}),s=bO({inputs:{input:r},backend:i}),o=dF({inputs:{x:s},backend:i}),a=fR({inputs:{real:n,imag:o},backend:i});return i.disposeData(e.dataId),i.disposeData(n.dataId),i.disposeData(s.dataId),i.disposeData(o.dataId),a}return rR({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:i})}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mF={kernelName:nn,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{axis:r}=i;if(1===e.length)return PL({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const s=e[0].shape,o=e[0].dtype;e.forEach((t=>{u(s,t.shape,"All tensors passed to stack must have matching shapes"),c(o===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const a=[],l=e.map((t=>{const e=PL({inputs:{input:t},backend:n,attrs:{dim:r}});return a.push(e),e})),h=wO({inputs:l,backend:n,attrs:{axis:r}});return a.forEach((t=>n.disposeData(t.dataId))),h}};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gF(t,e=!1){const n=t.length,i=QI(n),r=t.map(((t,e)=>`uniforms.pad${e}[0]`)).join(","),s=t.map(((t,e)=>`uniforms.pad${e}[0] + uniforms.xShape${n>1?`[${e}]`:""}`)).join(",");return`\n        let start = ${n>1?`${i}(${r})`:`${r}`};\n        let end = ${n>1?`${i}(${s})`:`${s}`};\n        if (${n>1?"any(paddedCoords < start)":"paddedCoords < start"} || ${n>1?"any(paddedCoords >= end)":"paddedCoords >= end"}) {\n          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});\n        } else {\n          let coords = paddedCoords - start;\n          setOutputAtIndex(index, getX(${n>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n):"coords"}));\n        }\n  `}class yF{constructor(t,e){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1])),this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),e.map(((t,e)=>{this.uniforms+=` pad${e} : vec2<i32>,`})),this.xShape=t,this.shaderKey="pad"}getUserCode(){return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let paddedCoords = getCoordsFromIndex(index);\n          ${gF(this.xShape)}\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bF={kernelName:rn,backendName:"webgpu",kernelFunc:t=>{const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{paddings:s,constantValue:o}=i;if(s.every((t=>m(t,[0,0]))))return dR({inputs:{x:r},backend:n});if(0===d(r.shape)){const t=s.map(((t,e)=>t[0]+r.shape[e]+t[1]));return rR({backend:n,attrs:{shape:t,value:o,dtype:r.dtype}})}const a=[{type:"float32",data:[o]}];s.map((t=>a.push({type:"int32",data:[t[0],t[1]]})));const l=new yF(r.shape,s);return n.runWebGPUProgram(l,[r],r.dtype,a)}},vF=bR({opType:wA.POW}),xF={kernelName:sn,backendName:"webgpu",kernelFunc:vF};const wF={kernelName:on,backendName:"webgpu",kernelFunc:
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n}=t,{x:i,alpha:r}=e,s=new hR(wA.PRELU,i.shape,r.shape);return n.runWebGPUProgram(s,[i,r],"float32")}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SF={kernelName:an,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:s,keepDims:o}=i;return yP(r,s,o,"prod",n)}},kF={kernelName:hn,backendName:"webgpu",kernelFunc:t=>{const{backend:e,attrs:n}=t,{start:i,stop:r,step:s,dtype:o}=n,a=VR(i,r,s,o);return e.makeTensorInfo([a.length],o,a)}},CF=bR({opType:wA.DIV}),TF={kernelName:Jt,backendName:"webgpu",kernelFunc:CF},_F=yR({opType:JA.RECIPROCAL}),EF={kernelName:pn,backendName:"webgpu",kernelFunc:_F},MF=yR({opType:JA.RELU}),$F={kernelName:fn,backendName:"webgpu",kernelFunc:MF},IF=yR({opType:JA.RELU6}),AF={kernelName:xn,backendName:"webgpu",kernelFunc:IF};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class NF{constructor(t,e,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t[0],e,n,t[3]],this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RF={kernelName:bn,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r}=e,{alignCorners:s,size:o,halfPixelCenters:a}=i,[l,c]=o,u=[{type:"float32",data:[s&&l>1?1:0,s&&c>1?1:0]},{type:"float32",data:[a?.5:0]}],h=new NF(r.shape,l,c);return n.runWebGPUProgram(h,[r],"float32",u)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PF{constructor(t,e){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,\n       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=e,this.shaderKey=`resizeBilinearBackprop_${e}`}getUserCode(){return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let dxR = f32(dyR) * uniforms.heightScale;\n              let topDxRIndex = i32(floor(dxR));\n              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));\n              let dxRLerp = dxR - f32(topDxRIndex);\n              let inverseDxRLerp = 1.0 - dxRLerp;\n\n              let dxC = f32(dyC) * uniforms.widthScale;\n              let leftDxCIndex = i32(floor(dxC));\n              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));\n              let dxCLerp = dxC - f32(leftDxCIndex);\n              let inverseDxCLerp = 1.0 - dxCLerp;\n\n              if (r == topDxRIndex && c == leftDxCIndex) {\n                // topLeft\n                accumulator +=\n                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n              }\n\n              if (r == topDxRIndex && c == rightDxCIndex) {\n                // topRight\n                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == leftDxCIndex) {\n                // bottomLeft\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == rightDxCIndex) {\n                // bottomRight\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OF={kernelName:vn,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r,dy:s}=e,{alignCorners:o}=i,[,a,l]=r.shape,[,c,u]=s.shape,h=[o&&c>1?a-1:a,o&&u>1?l-1:l],d=[o&&c>1?c-1:c,o&&u>1?u-1:u],p=h[0]/d[0],f=h[1]/d[1],m=1/p,g=1/f,y=2*Math.ceil(m)+2,b=2*Math.ceil(g)+2,v=new PF(r.shape,o),x=[{type:"int32",data:h},{type:"int32",data:d},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[b]}];return n.runWebGPUProgram(v,[s],s.dtype,x)}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LF{constructor(t,e,n,i){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t[0],e,n,t[3]],this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=i,this.shaderKey=`resizeNearest_${i}`}getUserCode(){let t;t=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC";return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${t};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DF={kernelName:gn,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r}=e,{alignCorners:s,halfPixelCenters:o,size:a}=i,[l,c]=a,u=[{type:"float32",data:[s&&l>1?1:0,s&&c>1?1:0]},{type:"float32",data:[s?.5:0]}],h=new LF(r.shape,l,c,o);return n.runWebGPUProgram(h,[r],r.dtype,u)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FF{constructor(t,e){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,\n       winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=e,this.shaderKey=`resizeNearestNeigborBackprop_${e}`}getUserCode(){return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *\n                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));\n\n              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *\n                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));\n\n              let sourceNearestRow =\n                  i32(min(f32(uniforms.outShape[1] - 1),\n                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));\n\n              let sourceNearestCol =\n                  i32(min(f32(uniforms.outShape[2] - 1),\n                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));\n\n              if (r == sourceNearestRow && c == sourceNearestCol) {\n                accumulator += getDy(b, dyR, dyC, d);\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zF={kernelName:yn,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{images:r,dy:s}=e,{alignCorners:o}=i,[,a,l]=r.shape,[,c,u]=s.shape,h=[o&&c>1?a-1:a,o&&u>1?l-1:l],d=[o&&c>1?c-1:c,o&&u>1?u-1:u],p=1/(h[0]/d[0]),f=1/(h[1]/d[1]),m=2*Math.ceil(p)+2,g=2*Math.ceil(f)+2,y=new FF(r.shape,o),b=[{type:"int32",data:h},{type:"int32",data:d},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[g]}];return n.runWebGPUProgram(y,[s],s.dtype,b)}};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BF{constructor(t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`\n      \n      // Using uniform variables as judging conditions, so the function has\n      // coherent execution within all threads.\n      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {\n        var reverseCoords = coords;\n        if (uniforms.axis[0] == 1) {\n          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;\n        }\n        if (uniforms.axis[1] == 1) {\n          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;\n        }\n        if (uniforms.axis[2] == 1) {\n          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;\n        }\n        if (uniforms.axis[3] == 1) {\n          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;\n        }\n\n        return reverseCoords;\n      }\n    \n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let reverseCoords = getReverseCoords(coords);\n          setOutputAtIndex(index, getX(reverseCoords[0],\n              reverseCoords[1], reverseCoords[2], reverseCoords[3]));\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UF={kernelName:wn,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{dims:s}=i,o=r.shape.length;if(0===o)return dR({inputs:{x:r},backend:n});const a=r.shape,l=[1,1,1,1];a.forEach(((t,e)=>{l[e+4-o]=t}));const c=w(s,r.shape),u=[0,0,0,0];c.forEach((t=>{u[t+4-o]=1}));const h=[{type:"int32",data:u}],d=oR({inputs:{x:r},backend:n,attrs:{shape:l}}),p=new BF(l),f=n.runWebGPUProgram(p,[d],d.dtype,h);n.disposeData(d.dataId);const m=oR({inputs:{x:f},backend:n,attrs:{shape:a}});return n.disposeData(f.dataId),m}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VF{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=t,"number"==typeof e?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`\n        ${eA("index")} {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ${this.fillSnippet}\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WF={kernelName:hi,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:i}=t,{radians:r,fillValue:s,center:o}=e,a=n,l=new VF(i.shape,s),[c,u]=ff(o,i.shape[1],i.shape[2]),h=[{type:"float32",data:[c]},{type:"float32",data:[u]},{type:"float32",data:[Math.sin(r)]},{type:"float32",data:[Math.cos(r)]}];"number"==typeof s?h.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):h.push({type:"float32",data:s});return a.runWebGPUProgram(l,[i],i.dtype,h)}},HF=yR({opType:JA.ROUND}),jF={kernelName:Sn,backendName:"webgpu",kernelFunc:HF},GF=yR({opType:JA.RSQRT,cpuKernelImpl:WR}),qF={kernelName:kn,backendName:"webgpu",kernelFunc:GF};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class XF{constructor(t,e,n,i,r,s,o,a=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=s,this.type=o,this.sumDupeIndices=a,this.dispatchLayout=fA(t),this.dispatch=hA(this.dispatchLayout,t,this.workgroupSize),this.sliceDimGreaterThanOne=e>1,this.shaderKey=`scatter_${n}_${i}_${this.sliceDimGreaterThanOne}_${o}_${a}`;const l=QI(r.length);this.uniforms=`sliceDim : i32, strides: ${l}, updatesSize: i32,`,this.updatesRank=i,this.indicesRank=n}getUserCode(){let t="";1===this.indicesRank?t="coords[0]":2===this.indicesRank&&(t="coords[0], j");const e=`getIndices(${t})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let i="",r="";1===this.dispatchLayout.x.length?(i="flattenedIndex",r="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(i="vec2<i32>(flattenedIndex, coords[1])",r="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const s=`getUpdates(${Array.from({length:this.updatesRank},((t,e)=>`coords[${e}]`)).join(", ")})`;return`\n    ${r}\n      ${eA("index")} {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${e}));\n            flattenedIndex = flattenedIndex + indexInside * ${n};\n          }\n          let updateValue =\n              ${lA(this.type)}(${s});\n          let flatIndex = getOutputIndexFromCoords(${i});\n\n          ${this.sumDupeIndices?KI("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}\n        }\n      }`}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KF={kernelName:Cn,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{indices:r,updates:s}=e,{shape:o}=i,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=hh(0,r,o),p=[h/c,c];if(0===h)return n.makeTensorInfo(o,r.dtype);const f=oR({inputs:{x:r},backend:n,attrs:{shape:[l,a]}}),m=oR({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),g=m.dtype,y=rR({backend:n,attrs:{shape:p,value:0,dtype:g}}),b=[{type:"int32",data:[a]},{type:"int32",data:u},{type:"int32",data:[d(m.shape)]}],v=new XF(m.shape,a,f.shape.length,m.shape.length,u,p,g),x=n.runWebGPUProgram(v,[m,f],g,b,y),w=oR({inputs:{x:x},backend:n,attrs:{shape:o}});return n.disposeData(f.dataId),n.disposeData(m.dataId),n.disposeData(x.dataId),w}};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YF{constructor(t,e){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=e,this.shaderKey=`search_sorted_${e}`}getUserCode(){return`\n      fn findBound(batch: i32, value: f32) -> i32 {\n        var left = i32(0);\n        var right = uniforms.numInputs;\n        while (left < right) {\n          var mid = (left + right) / 2;\n          if (getSortedSequence(batch, mid) ${"left"===this.side?"<":"<="} value) {\n            left = mid + 1;\n          } else {\n            right = mid;\n          }\n        }\n        return right;\n      }\n\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let value = getValuesByOutputIndex(index);\n          setOutputAtIndexI32(index, findBound(coords[0], value));\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZF={kernelName:_n,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{sortedSequence:r,values:s}=e,{side:o}=i,a=new YF([s.shape[0],s.shape[1]],o),l=[{type:"int32",data:[r.shape[1]]}];return n.runWebGPUProgram(a,[r,s],"int32",l)}};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JF{constructor(t,e,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=t,this.rank=n,this.shaderKey="select"}getUserCode(){let t,e;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)e="resRC",t="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],r=[];for(let t=0;t<this.outputShape.length;t++)r.push(`${n[t]}`),t<this.cRank&&i.push(`${n[t]}`);t=i.join(),e=r.join()}return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(${t});\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(${e}));\n          } else {\n            setOutputAtIndex(index, getB(${e}));\n          }\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QF={kernelName:En,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:i,t:r,e:s}=e,o=new JF(i.shape.length,r.shape,r.shape.length);return n.runWebGPUProgram(o,[i,r,s],Hr(r.dtype,s.dtype))}},tz=yR({opType:JA.SELU}),ez={kernelName:Mn,backendName:"webgpu",kernelFunc:tz},nz=yR({opType:JA.SIGMOID}),iz={kernelName:Rn,backendName:"webgpu",kernelFunc:nz},rz=yR({opType:JA.SIGN}),sz={kernelName:Nn,backendName:"webgpu",kernelFunc:rz},oz=yR({opType:JA.SIN}),az={kernelName:In,backendName:"webgpu",kernelFunc:oz},lz=yR({opType:JA.SINH}),cz={kernelName:An,backendName:"webgpu",kernelFunc:lz},uz=yR({opType:JA.SOFTPLUS}),hz={kernelName:Pn,backendName:"webgpu",kernelFunc:uz};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class dz{constructor(t,e,n,i,r,s){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const o=new Array(i.length);for(let t=0;t<o.length;t++)o[t]=i[r[t]];this.outputShape=o,this.newDim=r,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=t,this.paddedXShape=e,this.uniforms+=`reshapedPaddedXShape : ${QI(i.length)}, paddedXShapeStrides : ${QI(s)}, `,n.map(((t,e)=>{this.uniforms+=` pad${e} : vec2<i32>,`})),this.shaderKey=`spaceToBatchND_${r}`}getUserCode(){const t=QI(this.outputShape.length),e=dP(this.newDim);return`\n      ${sA(this.paddedXShape,"PaddedX")}\n      ${eA("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${t}(${e}), uniforms.reshapedPaddedXShape);\n          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);\n          ${gF(this.xShape,!0)}\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pz={kernelName:Dn,backendName:"webgpu",kernelFunc:t=>{const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{blockShape:s,paddings:o}=i;c(r.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"));const a=s.reduce(((t,e)=>t*e)),l=[[0,0]];l.push(...o);for(let t=1+s.length;t<r.shape.length;++t)l.push([0,0]);const u=l.map(((t,e)=>t[0]+r.shape[e]+t[1])),h=mf(u,s,a,!1),d=gf(h.length,s.length,!1),p=yf(u,s,a,!1),f=L(u),m=new dz(r.shape,u,l,h,d,f.length),g=[{type:"int32",data:h},{type:"int32",data:f}];l.map((t=>g.push({type:"int32",data:[t[0],t[1]]})));const y=n.runWebGPUProgram(m,[r],r.dtype,g),b=oR({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeData(y.dataId),b}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class fz{constructor(t,e,n){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.type=n,this.dispatchLayout=fA([e]),this.dispatch=hA(this.dispatchLayout,[e],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`\n    ${eA("index")} {\n      if (index < uniforms.sparseSize) {\n        let indexInSegmentIds = index / uniforms.segmentSize;\n        let indexInSegment = index % uniforms.segmentSize;\n        let indexInInput = indices[indexInSegmentIds];\n        let segmentId = segmentIds[indexInSegmentIds];\n\n        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];\n        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;\n        ${KI("&result[outIndex]","value",this.type)}\n      }\n    }\n  `}}class mz{constructor(t,e){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[t],this.dispatchLayout=fA(e),this.dispatch=hA(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`\n    ${eA("index")} {\n      if (index < uniforms.segmentIdsShape) {\n        let segmentId = segmentIds[index];\n        ${KI("&result[segmentId]","1","int32")}\n      }\n    }\n  `}}class gz{constructor(t,e){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.type=e,this.dispatchLayout=fA(t),this.dispatch=hA(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`\n    ${eA("index")} {\n      if (index < uniforms.size) {\n        let segmentId = index / uniforms.segmentSize;\n        let count = sameSegmentIdCount[segmentId];\n        if (count != 0) {\n          ${"float32"===this.type?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}\n        }\n      }\n    }\n  `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yz(t,e,n,i=!1,r){const s=d(t.shape)/t.shape[0],o=t.dtype,a=d(e.shape),l=r.readSync(n.dataId),c=a>0?l[a-1]+1:0;let u;const h=t.shape.slice();h[0]=c;const p=a*s,f=rR({backend:r,attrs:{shape:h,value:0,dtype:o}});u=new fz(h,p,o);let m=[{type:"int32",data:[s]},{type:"int32",data:[p]}];const g=r.runWebGPUProgram(u,[t,e,n],o,m,f);if(i)return g;const y=rR({backend:r,attrs:{shape:[c],value:0,dtype:"int32"}});u=new mz(c,n.shape);const b=r.runWebGPUProgram(u,[n],"int32",null,y),v=rR({backend:r,attrs:{shape:h,value:0,dtype:o}});u=new gz(h,o),m=[{type:"int32",data:[s]}];const x=r.runWebGPUProgram(u,[g,b],o,m,v);return r.disposeData(g.dataId),r.disposeData(b.dataId),x}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bz={kernelName:Vn,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:i,indices:r,segmentIds:s}=e;return yz(i,r,s,!1,n)}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vz={kernelName:Wn,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:i,indices:r,segmentIds:s}=e;return yz(i,r,s,!0,n)}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xz{constructor(t,e){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*e[i];this.outputShape=n,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const t=function(t,e=""){if(t>=5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`(resRC % ${e}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[];for(let r=0;r<t;r++)i.push(`(${n[r]} % ${e}aShape[${r}])`);return i.join()}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(this.rank,"uniforms.");return`\n      ${eA("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(${t}));\n        }\n      }\n    `}}function wz(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{reps:s}=i;if(n.shouldExecuteOnCPU([r])||"string"===r.dtype||r.shape.length>=5){const t=n.readSync(r.dataId),e="string"===r.dtype?t.map((t=>yr(t))):t,i=bo(r.shape,r.dtype,e),o=YR(i,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new xz(r.shape,s);return n.runWebGPUProgram(o,[r],r.dtype)}const Sz={kernelName:ei,backendName:"webgpu",kernelFunc:wz};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kz={kernelName:Hn,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{sparseIndices:r,sparseValues:s,defaultValue:o}=e,{outputShape:a}=i,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:p}=hh(0,r,a),f=!1;if("string"===s.dtype){const t=n.bufferSync(r),e=n.bufferSync(s),i=yr(n.readSync(o.dataId)[0]),d=HR(t,e,a,p,u,c,l,h,i,f);return n.makeTensorInfo(a,d.dtype,d.values)}const m=[p/u,u],g=oR({inputs:{x:r},backend:n,attrs:{shape:[c,l]}}),y=s.shape.length?oR({inputs:{x:s},backend:n,attrs:{shape:[c,u]}}):dR({inputs:{x:s},backend:n}),b=y.dtype,v=n.makeTensorInfo([],b,U(1,b)),x=oR({inputs:{x:o},backend:n,attrs:{shape:Array(m.length).fill(1)}}),w=wz({inputs:{x:x},backend:n,attrs:{reps:m}}),S=[{type:"int32",data:[l]},{type:"int32",data:h},{type:"int32",data:[d([c,u])]}];switch(c){case 0:break;case 1:{const t=new XF([c,u],l,g.shape.length,y.shape.length,h,m,b,f);n.runWebGPUProgram(t,[y,g],b,S,w)}break;default:{const t=new XF([c,u],l,g.shape.length,v.shape.length,h,m,b,f);n.runWebGPUProgram(t,[v,g],b,S,w)}{const t=new XF([c,u],l,g.shape.length,y.shape.length,h,m,b);n.runWebGPUProgram(t,[y,g],b,S,w)}}const k=oR({inputs:{x:w},backend:n,attrs:{shape:a}});return n.disposeData(g.dataId),n.disposeData(y.dataId),n.disposeData(x.dataId),n.disposeData(v.dataId),n.disposeData(w.dataId),k}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cz={kernelName:Fn,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{numOrSizeSplits:s,axis:o}=i,a=w(o,r.shape)[0],l=Gf(r,s,a),c=r.shape.length,u=new Array(c).fill(0),h=r.shape.slice();return l.map((t=>{const e=[...h];e[a]=t;const i=YP({inputs:{x:r},backend:n,attrs:{begin:u,size:e}});return u[a]+=t,i}))}},Tz=yR({opType:JA.SQRT}),_z={kernelName:On,backendName:"webgpu",kernelFunc:Tz},Ez={kernelName:Gn,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,i=e,r=new gR(n.shape,JA.SQUARE);return i.runWebGPUProgram(r,[n],n.dtype)}},Mz=bR({opType:wA.SQUARED_DIFFERENCE}),$z={kernelName:jn,backendName:"webgpu",kernelFunc:Mz};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iz={kernelName:ci,backendName:"webgpu",kernelFunc:
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function({inputs:t,attrs:e,backend:n}){const{x:i}=t,r=new gR(i.shape,JA.STEP,"stepAlpha : f32,"),s=[{type:"float32",data:[e.alpha]}];return n.runWebGPUProgram(r,[i],i.dtype,s)}};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Az{constructor(t){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const e=QI(this.outputShape.length);this.uniforms=`begin : ${e},  strides : ${e}, `,this.shaderKey="stridedSlice"}getUserCode(){let t="";if(1===this.outputShape.length)t="coords * uniforms.strides + uniforms.begin";else{let e=0;t=this.outputShape.map(((t,n)=>(e++,1===this.outputShape.length?`coords * uniforms.strides[${n}] + uniforms.begin[${n}]`:`coords[${e-1}] * uniforms.strides[${n}] + uniforms.begin[${n}]`))).join(",")}return`\n       ${eA("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(${t}));\n         }\n       }\n     `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nz={kernelName:Xn,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{begin:s,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=i,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=Zp(r.shape,s,o,a,l,u,h,d,p);let S;if(g)S=oR({inputs:{x:r},backend:n,attrs:{shape:m}});else if(y||b){c(r.shape.length>=1,(()=>`Input must have rank at least 1, got: ${r.shape.length}`));const t=zp(v,x,w),e=YP({inputs:{x:r},backend:n,attrs:{begin:v,size:t}});S=oR({inputs:{x:e},backend:n,attrs:{shape:m}}),n.disposeData(e.dataId)}else{if(n.shouldExecuteOnCPU([r])){const t=n.readSync(r.dataId),e=bo(r.shape,r.dtype,t),i=qR(f,e,w,v);S=n.makeTensorInfo(m,r.dtype,i.values)}else{const t=new Az(f),e=[{type:"int32",data:v},{type:"int32",data:w}],i=n.runWebGPUProgram(t,[r],r.dtype,e);S=oR({inputs:{x:i},backend:n,attrs:{shape:m}}),n.disposeData(i.dataId)}}return S}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rz={kernelName:Kn,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{separator:r,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=i,{data:u,dataSplits:h}=e,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,m]=XR(d,p,r,s,o,a,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},Pz=bR({opType:wA.SUB,cpuKernelImpl:KR,supportsComplex:!0}),Oz={kernelName:Jn,backendName:"webgpu",kernelFunc:Pz},Lz=yR({opType:JA.TAN}),Dz={kernelName:Qn,backendName:"webgpu",kernelFunc:Lz},Fz=yR({opType:JA.TANH}),zz={kernelName:ti,backendName:"webgpu",kernelFunc:Fz};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bz={kernelName:Tn,backendName:"webgpu",kernelFunc:
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t){const{inputs:e,backend:n,attrs:i}=t,{tensor:r,indices:s,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=hh(0,s,r.shape),p=[h/c,c];if(0===h)return n.makeTensorInfo(r.shape,s.dtype);const f=[],m=oR({inputs:{x:s},backend:n,attrs:{shape:[l,a]}});f.push(m);const g=oR({inputs:{x:o},backend:n,attrs:{shape:[l,c]}});f.push(g);const y=oR({inputs:{x:r},backend:n,attrs:{shape:p}});f.push(y);const b=wz({inputs:{x:y},backend:n,attrs:{reps:Array(p.length).fill(1)}}),v=new XF([l,c],a,m.shape.length,g.shape.length,u,p,r.dtype,!1),x=[{type:"int32",data:[a]},{type:"int32",data:u},{type:"int32",data:[d([l,c])]}],w=n.runWebGPUProgram(v,[g,m],y.dtype,x,b);f.push(w);const S=oR({inputs:{x:w},backend:n,attrs:{shape:r.shape}});return f.forEach((t=>n.disposeData(t.dataId))),S}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uz{constructor(t){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return`\n        ${eA("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}class Vz{constructor(t){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`\n        ${eA("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wz(t,e){null!==e&&t.disposeData(e.dataId)}function Hz(t){let e=1;for(;e<t;)e*=2;return e}const jz={kernelName:ni,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{k:s,sorted:o}=i,a=r.shape,l=a[a.length-1];if(n.shouldExecuteOnCPU([r])){const t=n.readSync(r.dataId),[e,i]=ZR(t,a,r.dtype,s,o);return[n.makeTensorInfo(e.shape,e.dtype,e.values),n.makeTensorInfo(i.shape,i.dtype,i.values)]}if(0===s)return a[a.length-1]=0,[n.makeTensorInfo(a,r.dtype,[]),n.makeTensorInfo(a,"int32",[])];if(1===l)return[r,rR({attrs:{shape:a,dtype:"int32",value:0},backend:n})];const c=d(a)/l,u=oR({inputs:{x:r},attrs:{shape:[c,l]},backend:n}),h=Hz(s),p=Hz(l);let f=null;const m=()=>null===f?[u,u]:[u,f],g=(t,e,i)=>{const r=m(),s=new Uz(i),o=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[t]},{type:"int32",data:[e]}],a=f;f=n.runWebGPUProgram(s,r,"int32",o),Wz(n,a)};for(let t=1;t<h;t*=2){const e=2*t;for(let n=t;n>=1;n/=2)g(e,n,[c,p])}for(let t=p;t>h;t/=2){const e=m(),i=new Vz([c,t/2]),r=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"int32",data:[h]}],s=f;f=n.runWebGPUProgram(i,e,"int32",r),Wz(n,s);const o=h/2,a=2*o;for(let t=o;t>=1;t/=2)g(a,t,f.shape)}let y=f;f=YP({inputs:{x:f},backend:n,attrs:{begin:0,size:[c,s]}}),Wz(n,y);let b=rD({inputs:{x:u,indices:f},backend:n,attrs:{axis:1,batchDims:1}});Wz(n,u);const v=a.slice(0,-1);v.push(s),y=f,f=oR({inputs:{x:f},attrs:{shape:v},backend:n}),Wz(n,y);const x=b;return b=oR({inputs:{x:b},attrs:{shape:v},backend:n}),Wz(n,x),[b,f]}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gz{constructor(t){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${eA("index")} {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qz={kernelName:ii,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{image:r,transforms:s}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=i,[u,h,d,p]=r.shape,[f,m]=null!=c?c:[h,d],g=new Gz([u,f,m,p]),y="nearest"===o?1:2;let b;switch(a){case"constant":default:b=1;break;case"reflect":b=2;break;case"wrap":b=3;break;case"nearest":b=4}const v=[{type:"int32",data:[y]},{type:"int32",data:[b]},{type:"float32",data:[l]}];return n.runWebGPUProgram(g,[r,s],"float32",v)}};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xz={kernelName:oi,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{value:r}=e;let{axis:s}=i;s<0&&(s+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[s],c=new Array(a-1);let u=0;for(let t=0;t<a;t++)t!==s&&(c[u++]=o.shape[t]);const h=[],d=new Array(a).fill(0),p=o.shape.slice();p[s]=1;const f=new Array(l);for(let t=0;t<f.length;t++){d[s]=t;const e=YP({inputs:{x:o},backend:n,attrs:{begin:d,size:p}}),i=oR({inputs:{x:e},backend:n,attrs:{shape:c}});f[t]=i,h.push(e)}return h.forEach((t=>n.disposeData(t.dataId))),f}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kz{constructor(t,e,n){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.dispatchLayout=fA(t),this.dispatch=hA(this.dispatchLayout,t,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error(`UnsortedSegmentSum only supports float32 and int32\n              types, does not support ${n} type.`);this.type=n,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`\n    ${eA("index")} {\n      if (index < uniforms.xSize) {\n        let coords = getXCoordsFromIndex(index);\n        let b = coords[0];\n        let inCol = coords[1];\n\n        let segmentId = i32(getSegmentIds(inCol));\n        if (segmentId >= 0) {\n          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;\n          let value = getX(b, inCol);\n\n          ${KI("&result[flatIndex]","value",this.type)}\n        }\n      }\n    }\n  `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yz={kernelName:ai,backendName:"webgpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r,segmentIds:s}=e,{numSegments:o}=i,a=r.shape.length,l=[];let c=0;const u=fl([c],a);let h=r;null!=u&&(h=pP({inputs:{x:r},backend:n,attrs:{perm:u}}),l.push(h),c=gl(1,a)[0]);const p=om(h.shape,c,o),f=d([h.shape[c]]),m=oR({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}});l.push(m);const g=r.dtype,y=[m.shape[0],o],b=rR({backend:n,attrs:{shape:y,value:0,dtype:g}}),v=new Kz(m.shape,y,g),x=[{type:"int32",data:[o]},{type:"int32",data:[d(m.shape)]}],w=n.runWebGPUProgram(v,[m,s],g,x,b),S=oR({inputs:{x:w},backend:n,attrs:{shape:p}});l.push(w);let k=S;if(null!=u){l.push(S);const t=ml(u);k=pP({inputs:{x:k},backend:n,attrs:{perm:t}})}return l.forEach((t=>n.disposeData(t.dataId))),k}},Zz=[cR,eP,iP,sP,aP,cP,bP,vP,wP,SP,CP,_P,MP,IP,NP,UP,VP,jP,GP,qP,JP,eO,iO,lO,uO,pO,mR,gO,SO,MO,RO,OO,DO,FO,zO,UO,WO,jO,ZO,JO,QO,eL,lL,cL,sL,hL,pL,gL,yL,vL,CL,_L,EL,$L,AL,RL,OL,DL,BL,sR,VL,XL,HL,GL,JL,QL,tD,nD,sD,aD,cD,pR,uD,vO,dD,fD,gD,yD,vD,wD,kD,ED,TD,$D,AD,RD,DD,zD,DP,UD,VD,qD,WD,GD,XD,zP,KD,ZD,QD,eF,oF,wL,aF,lF,cF,sO,hF,fF,mF,bF,xF,wF,SF,kF,aO,TF,EF,$F,AF,aR,RF,OF,DF,zF,UF,WF,jF,qF,KF,ZF,QF,ez,iz,sz,az,cz,ZP,Iz,Nz,Rz,sF,hz,pz,bz,vz,kz,Cz,_z,Ez,$z,Oz,kL,Dz,zz,Bz,Sz,jz,qz,fP,Xz,Yz,pF];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */for(const t of Zz)wi(t);function Jz(){}const Qz=t=>t;function tB(t){return t()}function eB(){return Object.create(null)}function nB(t){t.forEach(tB)}function iB(t){return"function"==typeof t}function rB(t,e){return t!=t?e==e:t!==e||t&&"object"==typeof t||"function"==typeof t}let sB;function oB(t,e){return sB||(sB=document.createElement("a")),sB.href=e,t===sB.href}function aB(t,...e){if(null==t)return Jz;const n=t.subscribe(...e);return n.unsubscribe?()=>n.unsubscribe():n}function lB(t){let e;return aB(t,(t=>e=t))(),e}function cB(t,e,n){t.$$.on_destroy.push(aB(e,n))}function uB(t,e,n,i){if(t){const r=hB(t,e,n,i);return t[0](r)}}function hB(t,e,n,i){return t[1]&&i?function(t,e){for(const n in e)t[n]=e[n];return t}(n.ctx.slice(),t[1](i(e))):n.ctx}function dB(t,e,n,i){if(t[2]&&i){const r=t[2](i(n));if(void 0===e.dirty)return r;if("object"==typeof r){const t=[],n=Math.max(e.dirty.length,r.length);for(let i=0;i<n;i+=1)t[i]=e.dirty[i]|r[i];return t}return e.dirty|r}return e.dirty}function pB(t,e,n,i,r,s){if(r){const o=hB(e,n,i,s);t.p(o,r)}}function fB(t){if(t.ctx.length>32){const e=[],n=t.ctx.length/32;for(let t=0;t<n;t++)e[t]=-1;return e}return-1}const mB="undefined"!=typeof window;let gB=mB?()=>window.performance.now():()=>Date.now(),yB=mB?t=>requestAnimationFrame(t):Jz;const bB=new Set;function vB(t){bB.forEach((e=>{e.c(t)||(bB.delete(e),e.f())})),0!==bB.size&&yB(vB)}function xB(t){let e;return 0===bB.size&&yB(vB),{promise:new Promise((n=>{bB.add(e={c:t,f:n})})),abort(){bB.delete(e)}}}const wB="undefined"!=typeof window?window:"undefined"!=typeof globalThis?globalThis:global;function SB(t,e){t.appendChild(e)}function kB(t){if(!t)return document;const e=t.getRootNode?t.getRootNode():t.ownerDocument;return e&&e.host?e:t.ownerDocument}function CB(t){const e=MB("style");return function(t,e){SB(t.head||t,e),e.sheet}(kB(t),e),e.sheet}function TB(t,e,n){t.insertBefore(e,n||null)}function _B(t){t.parentNode&&t.parentNode.removeChild(t)}function EB(t,e){for(let n=0;n<t.length;n+=1)t[n]&&t[n].d(e)}function MB(t){return document.createElement(t)}function $B(t){return document.createElementNS("http://www.w3.org/2000/svg",t)}function IB(t){return document.createTextNode(t)}function AB(){return IB(" ")}function NB(){return IB("")}function RB(t,e,n,i){return t.addEventListener(e,n,i),()=>t.removeEventListener(e,n,i)}function PB(t){return function(e){return e.preventDefault(),t.call(this,e)}}function OB(t,e,n){null==n?t.removeAttribute(e):t.getAttribute(e)!==n&&t.setAttribute(e,n)}function LB(t,e,n){e in t?t[e]="boolean"==typeof t[e]&&""===n||n:OB(t,e,n)}function DB(t,e){e=""+e,t.data!==e&&(t.data=e)}function FB(t,e){t.value=null==e?"":e}function zB(t,e,n,i){null==n?t.style.removeProperty(e):t.style.setProperty(e,n,i?"important":"")}function BB(t,e,n){for(let n=0;n<t.options.length;n+=1){const i=t.options[n];if(i.__value===e)return void(i.selected=!0)}n&&void 0===e||(t.selectedIndex=-1)}let UB;function VB(){if(void 0===UB){UB=!1;try{"undefined"!=typeof window&&window.parent&&window.parent.document}catch(t){UB=!0}}return UB}function WB(t,e,n){t.classList[n?"add":"remove"](e)}function HB(t,e,{bubbles:n=!1,cancelable:i=!1}={}){const r=document.createEvent("CustomEvent");return r.initCustomEvent(t,n,i,e),r}class jB{constructor(t=!1){this.is_svg=!1,this.is_svg=t,this.e=this.n=null}c(t){this.h(t)}m(t,e,n=null){this.e||(this.is_svg?this.e=$B(e.nodeName):this.e=MB(11===e.nodeType?"TEMPLATE":e.nodeName),this.t="TEMPLATE"!==e.tagName?e:e.content,this.c(t)),this.i(n)}h(t){this.e.innerHTML=t,this.n=Array.from("TEMPLATE"===this.e.nodeName?this.e.content.childNodes:this.e.childNodes)}i(t){for(let e=0;e<this.n.length;e+=1)TB(this.t,this.n[e],t)}p(t){this.d(),this.h(t),this.i(this.a)}d(){this.n.forEach(_B)}}const GB=new Map;let qB,XB=0;function KB(t,e,n,i,r,s,o,a=0){const l=16.666/i;let c="{\n";for(let t=0;t<=1;t+=l){const i=e+(n-e)*s(t);c+=100*t+`%{${o(i,1-i)}}\n`}const u=c+`100% {${o(n,1-n)}}\n}`,h=`__svelte_${function(t){let e=5381,n=t.length;for(;n--;)e=(e<<5)-e^t.charCodeAt(n);return e>>>0}(u)}_${a}`,d=kB(t),{stylesheet:p,rules:f}=GB.get(d)||function(t,e){const n={stylesheet:CB(e),rules:{}};return GB.set(t,n),n}(d,t);f[h]||(f[h]=!0,p.insertRule(`@keyframes ${h} ${u}`,p.cssRules.length));const m=t.style.animation||"";return t.style.animation=`${m?`${m}, `:""}${h} ${i}ms linear ${r}ms 1 both`,XB+=1,h}function YB(t,e){const n=(t.style.animation||"").split(", "),i=n.filter(e?t=>t.indexOf(e)<0:t=>-1===t.indexOf("__svelte")),r=n.length-i.length;r&&(t.style.animation=i.join(", "),XB-=r,XB||yB((()=>{XB||(GB.forEach((t=>{const{ownerNode:e}=t.stylesheet;e&&_B(e)})),GB.clear())})))}function ZB(t,e){const n=t.getBoundingClientRect();if(e.left!==n.left||e.top!==n.top){const i=getComputedStyle(t),r="none"===i.transform?"":i.transform;t.style.transform=`${r} translate(${e.left-n.left}px, ${e.top-n.top}px)`}}function JB(t){qB=t}function QB(){if(!qB)throw new Error("Function called outside component initialization");return qB}function tU(t){QB().$$.on_mount.push(t)}function eU(t){QB().$$.after_update.push(t)}function nU(t){QB().$$.on_destroy.push(t)}function iU(){const t=QB();return(e,n,{cancelable:i=!1}={})=>{const r=t.$$.callbacks[e];if(r){const s=HB(e,n,{cancelable:i});return r.slice().forEach((e=>{e.call(t,s)})),!s.defaultPrevented}return!0}}function rU(t){return QB().$$.context.get(t)}function sU(t,e){const n=t.$$.callbacks[e.type];n&&n.slice().forEach((t=>t.call(this,e)))}const oU=[],aU=[];let lU=[];const cU=[],uU=Promise.resolve();let hU=!1;function dU(){hU||(hU=!0,uU.then(vU))}function pU(){return dU(),uU}function fU(t){lU.push(t)}function mU(t){cU.push(t)}const gU=new Set;let yU,bU=0;function vU(){if(0!==bU)return;const t=qB;do{try{for(;bU<oU.length;){const t=oU[bU];bU++,JB(t),xU(t.$$)}}catch(t){throw oU.length=0,bU=0,t}for(JB(null),oU.length=0,bU=0;aU.length;)aU.pop()();for(let t=0;t<lU.length;t+=1){const e=lU[t];gU.has(e)||(gU.add(e),e())}lU.length=0}while(oU.length);for(;cU.length;)cU.pop()();hU=!1,gU.clear(),JB(t)}function xU(t){if(null!==t.fragment){t.update(),nB(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(fU)}}function wU(){return yU||(yU=Promise.resolve(),yU.then((()=>{yU=null}))),yU}function SU(t,e,n){t.dispatchEvent(HB(`${e?"intro":"outro"}${n}`))}const kU=new Set;let CU;function TU(){CU={r:0,c:[],p:CU}}function _U(){CU.r||nB(CU.c),CU=CU.p}function EU(t,e){t&&t.i&&(kU.delete(t),t.i(e))}function MU(t,e,n,i){if(t&&t.o){if(kU.has(t))return;kU.add(t),CU.c.push((()=>{kU.delete(t),i&&(n&&t.d(1),i())})),t.o(e)}else i&&i()}const $U={duration:0};function IU(t,e,n,i){const r={direction:"both"};let s=e(t,n,r),o=i?0:1,a=null,l=null,c=null;function u(){c&&YB(t,c)}function h(t,e){const n=t.b-o;return e*=Math.abs(n),{a:o,b:t.b,d:n,duration:e,start:t.start,end:t.start+e,group:t.group}}function d(e){const{delay:n=0,duration:i=300,easing:r=Qz,tick:d=Jz,css:p}=s||$U,f={start:gB()+n,b:e};e||(f.group=CU,CU.r+=1),a||l?l=f:(p&&(u(),c=KB(t,o,e,i,n,r,p)),e&&d(0,1),a=h(f,i),fU((()=>SU(t,e,"start"))),xB((e=>{if(l&&e>l.start&&(a=h(l,i),l=null,SU(t,a.b,"start"),p&&(u(),c=KB(t,o,a.b,a.duration,0,r,s.css))),a)if(e>=a.end)d(o=a.b,1-o),SU(t,a.b,"end"),l||(a.b?u():--a.group.r||nB(a.group.c)),a=null;else if(e>=a.start){const t=e-a.start;o=a.a+a.d*r(t/a.duration),d(o,1-o)}return!(!a&&!l)})))}return{run(t){iB(s)?wU().then((()=>{s=s(r),d(t)})):d(t)},end(){u(),a=l=null}}}function AU(t,e){const n=e.token={};function i(t,i,r,s){if(e.token!==n)return;e.resolved=s;let o=e.ctx;void 0!==r&&(o=o.slice(),o[r]=s);const a=t&&(e.current=t)(o);let l=!1;e.block&&(e.blocks?e.blocks.forEach(((t,n)=>{n!==i&&t&&(TU(),MU(t,1,1,(()=>{e.blocks[n]===t&&(e.blocks[n]=null)})),_U())})):e.block.d(1),a.c(),EU(a,1),a.m(e.mount(),e.anchor),l=!0),e.block=a,e.blocks&&(e.blocks[i]=a),l&&vU()}if(!(r=t)||"object"!=typeof r&&"function"!=typeof r||"function"!=typeof r.then){if(e.current!==e.then)return i(e.then,1,e.value,t),!0;e.resolved=t}else{const n=QB();if(t.then((t=>{JB(n),i(e.then,1,e.value,t),JB(null)}),(t=>{if(JB(n),i(e.catch,2,e.error,t),JB(null),!e.hasCatch)throw t})),e.current!==e.pending)return i(e.pending,0),!0}var r}function NU(t,e,n){const i=e.slice(),{resolved:r}=t;t.current===t.then&&(i[t.value]=r),t.current===t.catch&&(i[t.error]=r),t.block.p(i,n)}function RU(t,e){MU(t,1,1,(()=>{e.delete(t.key)}))}function PU(t,e){t.f(),RU(t,e)}function OU(t,e,n,i,r,s,o,a,l,c,u,h){let d=t.length,p=s.length,f=d;const m={};for(;f--;)m[t[f].key]=f;const g=[],y=new Map,b=new Map,v=[];for(f=p;f--;){const t=h(r,s,f),a=n(t);let l=o.get(a);l?i&&v.push((()=>l.p(t,e))):(l=c(a,t),l.c()),y.set(a,g[f]=l),a in m&&b.set(a,Math.abs(f-m[a]))}const x=new Set,w=new Set;function S(t){EU(t,1),t.m(a,u),o.set(t.key,t),u=t.first,p--}for(;d&&p;){const e=g[p-1],n=t[d-1],i=e.key,r=n.key;e===n?(u=e.first,d--,p--):y.has(r)?!o.has(i)||x.has(i)?S(e):w.has(r)?d--:b.get(i)>b.get(r)?(w.add(i),S(e)):(x.add(r),d--):(l(n,o),d--)}for(;d--;){const e=t[d];y.has(e.key)||l(e,o)}for(;p;)S(g[p-1]);return nB(v),g}function LU(t,e,n){const i=t.$$.props[e];void 0!==i&&(t.$$.bound[i]=n,n(t.$$.ctx[i]))}function DU(t){t&&t.c()}function FU(t,e,n,i){const{fragment:r,after_update:s}=t.$$;r&&r.m(e,n),i||fU((()=>{const e=t.$$.on_mount.map(tB).filter(iB);t.$$.on_destroy?t.$$.on_destroy.push(...e):nB(e),t.$$.on_mount=[]})),s.forEach(fU)}function zU(t,e){const n=t.$$;null!==n.fragment&&(!function(t){const e=[],n=[];lU.forEach((i=>-1===t.indexOf(i)?e.push(i):n.push(i))),n.forEach((t=>t())),lU=e}(n.after_update),nB(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}function BU(t,e,n,i,r,s,o,a=[-1]){const l=qB;JB(t);const c=t.$$={fragment:null,ctx:[],props:s,update:Jz,not_equal:r,bound:eB(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(e.context||(l?l.$$.context:[])),callbacks:eB(),dirty:a,skip_bound:!1,root:e.target||l.$$.root};o&&o(c.root);let u=!1;if(c.ctx=n?n(t,e.props||{},((e,n,...i)=>{const s=i.length?i[0]:n;return c.ctx&&r(c.ctx[e],c.ctx[e]=s)&&(!c.skip_bound&&c.bound[e]&&c.bound[e](s),u&&function(t,e){-1===t.$$.dirty[0]&&(oU.push(t),dU(),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}(t,e)),n})):[],c.update(),u=!0,nB(c.before_update),c.fragment=!!i&&i(c.ctx),e.target){if(e.hydrate){const t=function(t){return Array.from(t.childNodes)}(e.target);c.fragment&&c.fragment.l(t),t.forEach(_B)}else c.fragment&&c.fragment.c();e.intro&&EU(t.$$.fragment),FU(t,e.target,e.anchor,e.customElement),vU()}JB(l)}class UU{$destroy(){zU(this,1),this.$destroy=Jz}$on(t,e){if(!iB(e))return Jz;const n=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return n.push(e),()=>{const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}$set(t){var e;this.$$set&&(e=t,0!==Object.keys(e).length)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}function VU(t){let e,n,i,r,s;const o=t[10].default,a=uB(o,t,t[9],null);return{c(){e=AB(),n=MB("button"),a&&a.c(),OB(n,"class","marcelle svelte-2j0fl0"),n.disabled=t[1],WB(n,"outline","outline"===t[0]),WB(n,"filled","filled"===t[0]),WB(n,"light","light"===t[0]),WB(n,"success","success"===t[2]),WB(n,"warning","warning"===t[2]),WB(n,"danger","danger"===t[2]),WB(n,"size-small","small"===t[3]),WB(n,"size-large","large"===t[3]),WB(n,"round",t[4])},m(o,l){TB(o,e,l),TB(o,n,l),a&&a.m(n,null),i=!0,r||(s=[RB(document.body,"mouseup",t[6]),RB(document.body,"touchend",t[6]),RB(n,"click",t[11]),RB(n,"mousedown",t[5]),RB(n,"touchstart",PB(t[5])),RB(n,"touchend",t[7])],r=!0)},p(t,[e]){a&&a.p&&(!i||512&e)&&pB(a,o,t,t[9],i?dB(o,t[9],e,null):fB(t[9]),null),(!i||2&e)&&(n.disabled=t[1]),(!i||1&e)&&WB(n,"outline","outline"===t[0]),(!i||1&e)&&WB(n,"filled","filled"===t[0]),(!i||1&e)&&WB(n,"light","light"===t[0]),(!i||4&e)&&WB(n,"success","success"===t[2]),(!i||4&e)&&WB(n,"warning","warning"===t[2]),(!i||4&e)&&WB(n,"danger","danger"===t[2]),(!i||8&e)&&WB(n,"size-small","small"===t[3]),(!i||8&e)&&WB(n,"size-large","large"===t[3]),(!i||16&e)&&WB(n,"round",t[4])},i(t){i||(EU(a,t),i=!0)},o(t){MU(a,t),i=!1},d(t){t&&_B(e),t&&_B(n),a&&a.d(t),r=!1,nB(s)}}}function WU(t,e,n){let{$$slots:i={},$$scope:r}=e,{variant:s="outline"}=e,{disabled:o=!1}=e,{type:a="default"}=e,{size:l="medium"}=e,{round:c=!1}=e,{pressed:u=!1}=e;const h=iU();return t.$$set=t=>{"variant"in t&&n(0,s=t.variant),"disabled"in t&&n(1,o=t.disabled),"type"in t&&n(2,a=t.type),"size"in t&&n(3,l=t.size),"round"in t&&n(4,c=t.round),"pressed"in t&&n(8,u=t.pressed),"$$scope"in t&&n(9,r=t.$$scope)},[s,o,a,l,c,function(){n(8,u=!0),h("pressed",u)},function(){u&&(n(8,u=!1),h("pressed",u))},function(t){h("click",t)},u,r,i,function(e){sU.call(this,t,e)}]}let HU=class extends UU{constructor(t){super(),BU(this,t,WU,VU,rB,{variant:0,disabled:1,type:2,size:3,round:4,pressed:8})}};function jU(t){let e,n,i;return{c(){e=MB("input"),OB(e,"class","marcelle svelte-1mutsa0"),e.disabled=t[2],OB(e,"type",t[3]),OB(e,"placeholder",t[1]),e.value=t[0]},m(r,s){TB(r,e,s),n||(i=RB(e,"input",t[4]),n=!0)},p(t,[n]){4&n&&(e.disabled=t[2]),8&n&&OB(e,"type",t[3]),2&n&&OB(e,"placeholder",t[1]),1&n&&e.value!==t[0]&&(e.value=t[0])},i:Jz,o:Jz,d(t){t&&_B(e),n=!1,i()}}}function GU(t,e,n){let{placeholder:i=""}=e,{disabled:r=!1}=e,{type:s="text"}=e,{value:o=null}=e;return t.$$set=t=>{"placeholder"in t&&n(1,i=t.placeholder),"disabled"in t&&n(2,r=t.disabled),"type"in t&&n(3,s=t.type),"value"in t&&n(0,o=t.value)},[o,i,r,s,function(t){n(0,o=t.currentTarget.value)}]}let qU=class extends UU{constructor(t){super(),BU(this,t,GU,jU,rB,{placeholder:1,disabled:2,type:3,value:0})}};function XU(t){let e,n,i,r,s,o,a,l;const c=t[2].default,u=uB(c,t,t[1],null);return{c(){e=MB("div"),n=MB("div"),i=MB("div"),r=AB(),s=MB("div"),u&&u.c(),OB(i,"class","absolute inset-0 bg-gray-500 opacity-50"),OB(n,"class","absolute min-h-screen inset-0 transition-opacity"),OB(s,"class","bg-white rounded-lg shadow-xl transform transition-all sm:max-w-3xl sm:w-full"),OB(e,"class","absolute min-h-screen top-0 inset-x-0 p-4 pb-4 z-20 sm:flex sm:items-center sm:justify-center")},m(c,h){TB(c,e,h),SB(e,n),SB(n,i),SB(e,r),SB(e,s),u&&u.m(s,null),o=!0,a||(l=[RB(i,"click",t[0]),RB(i,"keypress",PB(t[3]))],a=!0)},p(t,[e]){u&&u.p&&(!o||2&e)&&pB(u,c,t,t[1],o?dB(c,t[1],e,null):fB(t[1]),null)},i(t){o||(EU(u,t),o=!0)},o(t){MU(u,t),o=!1},d(t){t&&_B(e),u&&u.d(t),a=!1,nB(l)}}}function KU(t,e,n){let{$$slots:i={},$$scope:r}=e;const s=iU();function o(){s("quit")}return t.$$set=t=>{"$$scope"in t&&n(1,r=t.$$scope)},[o,r,i,t=>"Escape"===t.key&&o()]}class YU extends UU{constructor(t){super(),BU(this,t,KU,XU,rB,{quit:0})}get quit(){return this.$$.ctx[0]}}function ZU(t){return t<.5?4*t*t*t:.5*Math.pow(2*t-2,3)+1}function JU(t){const e=t-1;return e*e*e+1}function QU(t,{delay:e=0,duration:n=400,easing:i=ZU,amount:r=5,opacity:s=0}={}){const o=getComputedStyle(t),a=+o.opacity,l="none"===o.filter?"":o.filter,c=a*(1-s),[u,h]=function(t){const e="string"==typeof t&&t.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);return e?[parseFloat(e[1]),e[2]||"px"]:[t,"px"]}(r);return{delay:e,duration:n,easing:i,css:(t,e)=>`opacity: ${a-c*e}; filter: ${l} blur(${e*u}${h});`}}function tV(t,{delay:e=0,duration:n=400,easing:i=JU,axis:r="y"}={}){const s=getComputedStyle(t),o=+s.opacity,a="y"===r?"height":"width",l=parseFloat(s[a]),c="y"===r?["top","bottom"]:["left","right"],u=c.map((t=>`${t[0].toUpperCase()}${t.slice(1)}`)),h=parseFloat(s[`padding${u[0]}`]),d=parseFloat(s[`padding${u[1]}`]),p=parseFloat(s[`margin${u[0]}`]),f=parseFloat(s[`margin${u[1]}`]),m=parseFloat(s[`border${u[0]}Width`]),g=parseFloat(s[`border${u[1]}Width`]);return{delay:e,duration:n,easing:i,css:t=>`overflow: hidden;opacity: ${Math.min(20*t,1)*o};${a}: ${t*l}px;padding-${c[0]}: ${t*h}px;padding-${c[1]}: ${t*d}px;margin-${c[0]}: ${t*p}px;margin-${c[1]}: ${t*f}px;border-${c[0]}-width: ${t*m}px;border-${c[1]}-width: ${t*g}px;`}}function eV(t,{delay:e=0,duration:n=400,easing:i=JU,start:r=0,opacity:s=0}={}){const o=getComputedStyle(t),a=+o.opacity,l="none"===o.transform?"":o.transform,c=1-r,u=a*(1-s);return{delay:e,duration:n,easing:i,css:(t,e)=>`\n\t\t\ttransform: ${l} scale(${1-c*e});\n\t\t\topacity: ${a-u*e}\n\t\t`}}function nV(t,{from:e,to:n},i={}){const r=getComputedStyle(t),s="none"===r.transform?"":r.transform,[o,a]=r.transformOrigin.split(" ").map(parseFloat),l=e.left+e.width*o/n.width-(n.left+o),c=e.top+e.height*a/n.height-(n.top+a),{delay:u=0,duration:h=(t=>120*Math.sqrt(t)),easing:d=JU}=i;return{delay:u,duration:iB(h)?h(Math.sqrt(l*l+c*c)):h,easing:d,css:(t,i)=>{const r=i*l,o=i*c,a=t+i*e.width/n.width,u=t+i*e.height/n.height;return`transform: ${s} translate(${r}px, ${o}px) scale(${a}, ${u});`}}}function iV(t,e,n){const i=t.slice();return i[6]=e[n].title,i[7]=e[n].message,i[8]=e[n].type,i[9]=e[n].id,i}function rV(t){let e;return{c(){e=$B("path"),OB(e,"d","M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0\n                4.34 4.34a8 8 0 0 0 11.32 11.32zM9 5h2v6H9V5zm0 8h2v2H9v-2z")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function sV(t){let e;return{c(){e=$B("path"),OB(e,"d","M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0\n                4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function oV(t,e){let n,i,r,s,o,a,l,c,u,h,d,p,f,m,g,y,b,v,x,w,S,k,C,T=e[6]+"",_=e[7]+"",E=Jz;function M(t,e){return"default"===t[8]?sV:"danger"===t[8]?rV:void 0}let $=M(e),I=$&&$(e);function A(){return e[3](e[9])}function N(...t){return e[4](e[9],...t)}return{key:t,first:null,c(){n=MB("div"),i=MB("div"),r=MB("div"),s=$B("svg"),I&&I.c(),o=AB(),a=MB("div"),l=MB("p"),c=IB(T),u=AB(),h=MB("p"),d=IB(_),p=AB(),f=MB("div"),m=$B("svg"),g=$B("title"),y=IB("Close"),b=$B("path"),v=AB(),OB(s,"class","notification-svg mr-4 svelte-c58nio"),OB(s,"xmlns","http://www.w3.org/2000/svg"),OB(s,"viewBox","0 0 20 20"),WB(s,"default","default"===e[8]),WB(s,"danger","danger"===e[8]),OB(r,"class","py-1"),OB(l,"class","my-1 font-bold"),OB(h,"class","my-1 text-sm"),OB(b,"d","M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1\n              1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10\n              8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0\n              1.698z"),OB(m,"class","notification-svg ml-4 cursor-pointer svelte-c58nio"),OB(m,"role","button"),OB(m,"xmlns","http://www.w3.org/2000/svg"),OB(m,"viewBox","0 0 20 20"),OB(m,"tabindex","0"),WB(m,"default","default"===e[8]),WB(m,"danger","danger"===e[8]),OB(i,"class","flex items-start"),OB(n,"class","notification-card svelte-c58nio"),OB(n,"role","alert"),WB(n,"default","default"===e[8]),WB(n,"danger","danger"===e[8]),this.first=n},m(t,e){TB(t,n,e),SB(n,i),SB(i,r),SB(r,s),I&&I.m(s,null),SB(i,o),SB(i,a),SB(a,l),SB(l,c),SB(a,u),SB(a,h),SB(h,d),SB(i,p),SB(i,f),SB(f,m),SB(m,g),SB(g,y),SB(m,b),SB(n,v),S=!0,k||(C=[RB(m,"click",A),RB(m,"keypress",PB(N))],k=!0)},p(t,i){$!==($=M(e=t))&&(I&&I.d(1),I=$&&$(e),I&&(I.c(),I.m(s,null))),(!S||1&i)&&WB(s,"default","default"===e[8]),(!S||1&i)&&WB(s,"danger","danger"===e[8]),(!S||1&i)&&T!==(T=e[6]+"")&&DB(c,T),(!S||1&i)&&_!==(_=e[7]+"")&&DB(d,_),(!S||1&i)&&WB(m,"default","default"===e[8]),(!S||1&i)&&WB(m,"danger","danger"===e[8]),(!S||1&i)&&WB(n,"default","default"===e[8]),(!S||1&i)&&WB(n,"danger","danger"===e[8])},r(){w=n.getBoundingClientRect()},f(){!function(t){const e=getComputedStyle(t);if("absolute"!==e.position&&"fixed"!==e.position){const{width:n,height:i}=e,r=t.getBoundingClientRect();t.style.position="absolute",t.style.width=n,t.style.height=i,ZB(t,r)}}(n),E(),ZB(n,w)},a(){E(),E=function(t,e,n,i){if(!e)return Jz;const r=t.getBoundingClientRect();if(e.left===r.left&&e.right===r.right&&e.top===r.top&&e.bottom===r.bottom)return Jz;const{delay:s=0,duration:o=300,easing:a=Qz,start:l=gB()+s,end:c=l+o,tick:u=Jz,css:h}=n(t,{from:e,to:r},i);let d,p=!0,f=!1;function m(){h&&YB(t,d),p=!1}return xB((t=>{if(!f&&t>=l&&(f=!0),f&&t>=c&&(u(1,0),m()),!p)return!1;if(f){const e=0+1*a((t-l)/o);u(e,1-e)}return!0})),h&&(d=KB(t,0,1,o,s,a,h)),s||(f=!0),u(0,1),m}(n,w,nV,{})},i(t){S||(fU((()=>{S&&(x||(x=IU(n,QU,{amount:10},!0)),x.run(1))})),S=!0)},o(t){x||(x=IU(n,QU,{amount:10},!1)),x.run(0),S=!1},d(t){t&&_B(n),I&&I.d(),t&&x&&x.end(),k=!1,nB(C)}}}function aV(t){let e,n,i=[],r=new Map,s=t[0].slice(0,10);const o=t=>t[9];for(let e=0;e<s.length;e+=1){let n=iV(t,s,e),a=o(n);r.set(a,i[e]=oV(a,n))}return{c(){e=MB("div");for(let t=0;t<i.length;t+=1)i[t].c();OB(e,"class","marcelle notification-container svelte-c58nio")},m(t,r){TB(t,e,r);for(let t=0;t<i.length;t+=1)i[t]&&i[t].m(e,null);n=!0},p(t,[n]){if(3&n){s=t[0].slice(0,10),TU();for(let t=0;t<i.length;t+=1)i[t].r();i=OU(i,n,o,1,t,s,r,e,PU,oV,null,iV);for(let t=0;t<i.length;t+=1)i[t].a();_U()}},i(t){if(!n){for(let t=0;t<s.length;t+=1)EU(i[t]);n=!0}},o(t){for(let t=0;t<i.length;t+=1)MU(i[t]);n=!1},d(t){t&&_B(e);for(let t=0;t<i.length;t+=1)i[t].d()}}}function lV(t,e,n){let{notifications:i=[]}=e;function r(t){n(0,i=i.filter((e=>e.id!==t)))}let s=1;return t.$$set=t=>{"notifications"in t&&n(0,i=t.notifications)},[i,r,function({title:t,message:e,type:o="default",duration:a=3e3}){const l={id:s,title:t,message:e,type:o};s+=1,n(0,i=[...i,l]),a>0&&setTimeout((()=>{r(l.id)}),a)},t=>r(t),(t,e)=>"Escape"===e.key&&r(t)]}class cV extends UU{constructor(t){super(),BU(this,t,lV,aV,rB,{notifications:0,add:2})}get add(){return this.$$.ctx[2]}}function uV(t){let e,n,i,r,s,o,a,l,c,u;return{c(){e=MB("div"),n=MB("button"),i=IB("-"),r=AB(),s=MB("input"),o=AB(),a=MB("button"),l=IB("+"),n.disabled=t[1],OB(n,"class","left svelte-vad1o4"),OB(s,"type","number"),OB(s,"inputmode","decimal"),s.value=t[0],s.disabled=t[1],zB(s,"width","80px"),OB(s,"class","svelte-vad1o4"),a.disabled=t[1],OB(a,"class","right svelte-vad1o4"),OB(e,"class","flex")},m(h,d){TB(h,e,d),SB(e,n),SB(n,i),SB(e,r),SB(e,s),SB(e,o),SB(e,a),SB(a,l),c||(u=[RB(n,"click",t[3]),RB(s,"change",t[2]),RB(a,"click",t[4])],c=!0)},p(t,[e]){2&e&&(n.disabled=t[1]),1&e&&s.value!==t[0]&&(s.value=t[0]),2&e&&(s.disabled=t[1]),2&e&&(a.disabled=t[1])},i:Jz,o:Jz,d(t){t&&_B(e),c=!1,nB(u)}}}function hV(t,e,n){let{disabled:i=!1}=e,{value:r}=e;return t.$$set=t=>{"disabled"in t&&n(1,i=t.disabled),"value"in t&&n(0,r=t.value)},[r,i,function(t){const e=t.target,i=parseFloat(e.value);Number.isNaN(i)?e.value=r.toString():n(0,r=i)},()=>{n(0,r-=1)},()=>{n(0,r+=1)}]}class dV extends UU{constructor(t){super(),BU(this,t,hV,uV,rB,{disabled:1,value:0})}}function pV(t,e,n){const i=t.slice();return i[12]=e[n],i[14]=n,i}function fV(t){let e,n,i,r,s,o,a,l,c,u=t[0],h=[];for(let e=0;e<u.length;e+=1)h[e]=mV(pV(t,u,e));return{c(){e=MB("div");for(let t=0;t<h.length;t+=1)h[t].c();n=AB(),i=MB("button"),r=IB("-"),s=AB(),o=MB("button"),a=IB("+"),i.disabled=t[1],OB(i,"class","left svelte-vad1o4"),o.disabled=t[1],OB(o,"class","right svelte-vad1o4"),zB(o,"border-left","none"),OB(e,"class","flex items-center")},m(u,d){TB(u,e,d);for(let t=0;t<h.length;t+=1)h[t]&&h[t].m(e,null);SB(e,n),SB(e,i),SB(i,r),SB(e,s),SB(e,o),SB(o,a),l||(c=[RB(i,"click",t[10]),RB(o,"click",t[11])],l=!0)},p(t,r){if(31&r){let i;for(u=t[0],i=0;i<u.length;i+=1){const s=pV(t,u,i);h[i]?h[i].p(s,r):(h[i]=mV(s),h[i].c(),h[i].m(e,n))}for(;i<h.length;i+=1)h[i].d(1);h.length=u.length}2&r&&(i.disabled=t[1]),2&r&&(o.disabled=t[1])},d(t){t&&_B(e),EB(h,t),l=!1,nB(c)}}}function mV(t){let e,n,i,r,s,o,a,l,c,u,h;function d(){return t[7](t[14])}function p(...e){return t[8](t[14],...e)}function f(){return t[9](t[14])}return{c(){e=MB("div"),n=MB("button"),i=IB("-"),r=AB(),s=MB("input"),a=AB(),l=MB("button"),c=IB("+"),n.disabled=t[1],OB(n,"class","left svelte-vad1o4"),OB(s,"type","number"),OB(s,"inputmode","decimal"),s.value=o=t[12],s.disabled=t[1],zB(s,"width","80px"),OB(s,"class","svelte-vad1o4"),l.disabled=t[1],OB(l,"class","right svelte-vad1o4"),OB(e,"class","flex mr-2")},m(t,o){TB(t,e,o),SB(e,n),SB(n,i),SB(e,r),SB(e,s),SB(e,a),SB(e,l),SB(l,c),u||(h=[RB(n,"click",d),RB(s,"change",p),RB(l,"click",f)],u=!0)},p(e,i){t=e,2&i&&(n.disabled=t[1]),1&i&&o!==(o=t[12])&&s.value!==o&&(s.value=o),2&i&&(s.disabled=t[1]),2&i&&(l.disabled=t[1])},d(t){t&&_B(e),u=!1,nB(h)}}}function gV(t){let e,n=t[0]&&Array.isArray(t[0]),i=n&&fV(t);return{c(){i&&i.c(),e=NB()},m(t,n){i&&i.m(t,n),TB(t,e,n)},p(t,[r]){1&r&&(n=t[0]&&Array.isArray(t[0])),n?i?i.p(t,r):(i=fV(t),i.c(),i.m(e.parentNode,e)):i&&(i.d(1),i=null)},i:Jz,o:Jz,d(t){i&&i.d(t),t&&_B(e)}}}function yV(t,e,n){let{disabled:i=!1}=e,{value:r}=e;function s(t,e){const i=t.target,s=parseFloat(i.value);Number.isNaN(s)?i.value=r[e].toString():n(0,r[e]=s,r)}function o(t){const e=r.slice();e[t]-=1,n(0,r=e)}function a(t){const e=r.slice();e[t]+=1,n(0,r=e)}function l(){const t=r.slice();t.push(t.length?t[t.length-1]:0),n(0,r=t)}function c(){n(0,r=r.slice(0,r.length-1))}return t.$$set=t=>{"disabled"in t&&n(1,i=t.disabled),"value"in t&&n(0,r=t.value)},[r,i,s,o,a,l,c,t=>o(t),(t,e)=>s(e,t),t=>a(t),()=>c(),()=>l()]}let bV=class extends UU{constructor(t){super(),BU(this,t,yV,gV,rB,{disabled:1,value:0})}};function vV(t,e,n){const i=t.slice();return i[7]=e[n],i}function xV(t){let e,n;return{c(){e=$B("svg"),n=$B("path"),OB(n,"d","M10 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0-6a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"),OB(e,"class","fill-current inline-block h-5 w-5"),OB(e,"xmlns","http://www.w3.org/2000/svg"),OB(e,"viewBox","0 0 20 20")},m(t,i){TB(t,e,i),SB(e,n)},p:Jz,d(t){t&&_B(e)}}}function wV(t){let e,n,i,r,s,o=t[0],a=[];for(let e=0;e<o.length;e+=1)a[e]=SV(vV(t,o,e));return{c(){e=MB("div"),n=MB("div"),i=MB("div");for(let t=0;t<a.length;t+=1)a[t].c();OB(i,"class","py-1"),OB(i,"role","menu"),OB(i,"aria-orientation","vertical"),OB(i,"aria-labelledby","options-menu"),OB(n,"class","origin-top-right absolute right-0 mt-1 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none"),OB(e,"class","origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg z-50"),WB(e,"hidden",!1)},m(t,r){TB(t,e,r),SB(e,n),SB(n,i);for(let t=0;t<a.length;t+=1)a[t]&&a[t].m(i,null);s=!0},p(t,e){if(9&e){let n;for(o=t[0],n=0;n<o.length;n+=1){const r=vV(t,o,n);a[n]?a[n].p(r,e):(a[n]=SV(r),a[n].c(),a[n].m(i,null))}for(;n<a.length;n+=1)a[n].d(1);a.length=o.length}},i(t){s||(fU((()=>{s&&(r||(r=IU(e,tV,{duration:100},!0)),r.run(1))})),s=!0)},o(t){r||(r=IU(e,tV,{duration:100},!1)),r.run(0),s=!1},d(t){t&&_B(e),EB(a,t),t&&r&&r.end()}}}function SV(t){let e,n,i,r,s,o=t[7].text+"";function a(){return t[5](t[7])}return{c(){e=MB("button"),n=IB(o),i=AB(),OB(e,"class","text-sm py-2 px-4 font-normal block w-full whitespace-no-wrap bg-transparent text-gray-800 hover:bg-gray-100 border-0 cursor-pointer")},m(t,o){TB(t,e,o),SB(e,n),SB(e,i),r||(s=RB(e,"click",a),r=!0)},p(e,i){t=e,1&i&&o!==(o=t[7].text+"")&&DB(n,o)},d(t){t&&_B(e),r=!1,s()}}}function kV(t){let e,n,i,r,s,o,a;i=new HU({props:{size:"small",round:!0,$$slots:{default:[xV]},$$scope:{ctx:t}}}),i.$on("click",t[2]);let l=t[1]&&wV(t);return{c(){e=AB(),n=MB("div"),DU(i.$$.fragment),r=AB(),l&&l.c(),OB(n,"class","relative")},m(c,u){TB(c,e,u),TB(c,n,u),FU(i,n,null),SB(n,r),l&&l.m(n,null),s=!0,o||(a=RB(document.body,"click",t[4]),o=!0)},p(t,[e]){const r={};1024&e&&(r.$$scope={dirty:e,ctx:t}),i.$set(r),t[1]?l?(l.p(t,e),2&e&&EU(l,1)):(l=wV(t),l.c(),EU(l,1),l.m(n,null)):l&&(TU(),MU(l,1,1,(()=>{l=null})),_U())},i(t){s||(EU(i.$$.fragment,t),EU(l),s=!0)},o(t){MU(i.$$.fragment,t),MU(l),s=!1},d(t){t&&_B(e),t&&_B(n),zU(i),l&&l.d(),o=!1,a()}}}function CV(t,e,n){let{actions:i=[]}=e;const r=iU();let s=!1;function o(t){r("select",t)}return t.$$set=t=>{"actions"in t&&n(0,i=t.actions)},[i,s,function(t){t.stopPropagation(),n(1,s=!s)},o,()=>{n(1,s=!1)},t=>o(t.code)]}class TV extends UU{constructor(t){super(),BU(this,t,CV,kV,rB,{actions:0})}}function _V(t){let e,n;return{c(){e=MB("div"),OB(e,"class","progress-line svelte-igsaf6"),OB(e,"style",n=t[0]>=0?`--bar-mr: ${100-Math.floor(100*t[0])}%;`:"--bar-mr: 0px"),WB(e,"thin",t[2]),WB(e,"indeterminate",void 0===t[0]||null===t[0]||t[0]<0),WB(e,"gray","idle"===t[1]),WB(e,"green","success"===t[1]),WB(e,"red","danger"===t[1])},m(t,n){TB(t,e,n)},p(t,[i]){1&i&&n!==(n=t[0]>=0?`--bar-mr: ${100-Math.floor(100*t[0])}%;`:"--bar-mr: 0px")&&OB(e,"style",n),4&i&&WB(e,"thin",t[2]),1&i&&WB(e,"indeterminate",void 0===t[0]||null===t[0]||t[0]<0),2&i&&WB(e,"gray","idle"===t[1]),2&i&&WB(e,"green","success"===t[1]),2&i&&WB(e,"red","danger"===t[1])},i:Jz,o:Jz,d(t){t&&_B(e)}}}function EV(t,e,n){let{progress:i}=e,{type:r="default"}=e,{thin:s=!1}=e;return t.$$set=t=>{"progress"in t&&n(0,i=t.progress),"type"in t&&n(1,r=t.type),"thin"in t&&n(2,s=t.thin)},[i,r,s]}class MV extends UU{constructor(t){super(),BU(this,t,EV,_V,rB,{progress:0,type:1,thin:2})}}function $V(t,e,n){const i=t.slice();return i[7]=e[n],i}function IV(t){let e,n;return{c(){e=MB("option"),n=IB(t[2]),e.__value="",e.value=e.__value,e.disabled=!0,OB(e,"class","svelte-g3sqa4")},m(t,i){TB(t,e,i),SB(e,n)},p(t,e){4&e&&DB(n,t[2])},d(t){t&&_B(e)}}}function AV(t){let e,n,i,r=t[7]+"";return{c(){e=MB("option"),n=IB(r),e.__value=i=t[7],e.value=e.__value,OB(e,"class","svelte-g3sqa4")},m(t,i){TB(t,e,i),SB(e,n)},p(t,s){2&s&&r!==(r=t[7]+"")&&DB(n,r),2&s&&i!==(i=t[7])&&(e.__value=i,e.value=e.__value)},d(t){t&&_B(e)}}}function NV(t){let e,n,i,r,s,o,a,l=t[2]&&IV(t),c=t[1],u=[];for(let e=0;e<c.length;e+=1)u[e]=AV($V(t,c,e));return{c(){e=MB("div"),n=MB("select"),l&&l.c(),i=NB();for(let t=0;t<u.length;t+=1)u[t].c();r=AB(),s=MB("div"),s.innerHTML='<svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"></path></svg>',OB(n,"class","svelte-g3sqa4"),void 0===t[0]&&fU((()=>t[5].call(n))),WB(n,"small","small"===t[3]),OB(s,"class","pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700"),OB(e,"class","select-container svelte-g3sqa4")},m(c,h){TB(c,e,h),SB(e,n),l&&l.m(n,null),SB(n,i);for(let t=0;t<u.length;t+=1)u[t]&&u[t].m(n,null);BB(n,t[0],!0),SB(e,r),SB(e,s),o||(a=[RB(n,"change",t[5]),RB(n,"change",t[6])],o=!0)},p(t,[e]){if(t[2]?l?l.p(t,e):(l=IV(t),l.c(),l.m(n,i)):l&&(l.d(1),l=null),2&e){let i;for(c=t[1],i=0;i<c.length;i+=1){const r=$V(t,c,i);u[i]?u[i].p(r,e):(u[i]=AV(r),u[i].c(),u[i].m(n,null))}for(;i<u.length;i+=1)u[i].d(1);u.length=c.length}3&e&&BB(n,t[0]),8&e&&WB(n,"small","small"===t[3])},i:Jz,o:Jz,d(t){t&&_B(e),l&&l.d(),EB(u,t),o=!1,nB(a)}}}function RV(t,e,n){let{options:i}=e,{value:r=""}=e,{placeholder:s="Select an Option"}=e,{size:o="normal"}=e;const a=iU();return t.$$set=t=>{"options"in t&&n(1,i=t.options),"value"in t&&n(0,r=t.value),"placeholder"in t&&n(2,s=t.placeholder),"size"in t&&n(3,o=t.size)},[r,i,s,o,a,function(){r=function(t){const e=t.querySelector(":checked");return e&&e.__value}(this),n(0,r),n(1,i)},t=>a("change",t.currentTarget.value)]}let PV=class extends UU{constructor(t){super(),BU(this,t,RV,NV,rB,{options:1,value:0,placeholder:2,size:3})}};function OV(t){let e;return{c(){e=MB("span"),e.innerHTML='<span class="spinner svelte-1vj95jw"><span class="dot1 svelte-1vj95jw"></span>  <span class="dot2 svelte-1vj95jw"></span></span>',OB(e,"class","spinner-container svelte-1vj95jw")},m(t,n){TB(t,e,n)},p:Jz,i:Jz,o:Jz,d(t){t&&_B(e)}}}class LV extends UU{constructor(t){super(),BU(this,t,null,OV,rB,{})}}function DV(t){let e,n,i,r,s,o,a,l,c;return{c(){e=MB("label"),n=MB("input"),i=AB(),r=MB("span"),r.innerHTML='<span class="track svelte-huqh7w"></span> \n    <span class="thumb svelte-huqh7w"></span>',s=AB(),o=MB("span"),a=IB(t[1]),OB(n,"type","checkbox"),n.disabled=t[2],OB(n,"class","svelte-huqh7w"),OB(r,"class","switch svelte-huqh7w"),OB(o,"class","ml-2 cursor-pointer"),OB(e,"class","marcelle")},m(u,h){TB(u,e,h),SB(e,n),n.checked=t[0],SB(e,i),SB(e,r),SB(e,s),SB(e,o),SB(o,a),l||(c=RB(n,"change",t[3]),l=!0)},p(t,[e]){4&e&&(n.disabled=t[2]),1&e&&(n.checked=t[0]),2&e&&DB(a,t[1])},i:Jz,o:Jz,d(t){t&&_B(e),l=!1,c()}}}function FV(t,e,n){let{text:i=""}=e,{checked:r=!1}=e,{disabled:s=!1}=e;return t.$$set=t=>{"text"in t&&n(1,i=t.text),"checked"in t&&n(0,r=t.checked),"disabled"in t&&n(2,s=t.disabled)},[r,i,s,function(){r=this.checked,n(0,r)}]}let zV=class extends UU{constructor(t){super(),BU(this,t,FV,DV,rB,{text:1,checked:0,disabled:2})}};const BV=[];function UV(t,e=Jz){let n;const i=new Set;function r(e){if(rB(t,e)&&(t=e,n)){const e=!BV.length;for(const e of i)e[1](),BV.push(e,t);if(e){for(let t=0;t<BV.length;t+=2)BV[t][0](BV[t+1]);BV.length=0}}}return{set:r,update:function(e){r(e(t))},subscribe:function(s,o=Jz){const a=[s,o];return i.add(a),1===i.size&&(n=e(r)||Jz),s(t),()=>{i.delete(a),0===i.size&&n&&(n(),n=null)}}}}function VV(t){let e,n;const i=t[1].default,r=uB(i,t,t[0],null);return{c(){e=MB("div"),r&&r.c(),OB(e,"class","tabs")},m(t,i){TB(t,e,i),r&&r.m(e,null),n=!0},p(t,[e]){r&&r.p&&(!n||1&e)&&pB(r,i,t,t[0],n?dB(i,t[0],e,null):fB(t[0]),null)},i(t){n||(EU(r,t),n=!0)},o(t){MU(r,t),n=!1},d(t){t&&_B(e),r&&r.d(t)}}}const WV={};function HV(t,e,n){let{$$slots:i={},$$scope:r}=e;const s=[],o=[],a=UV(null),l=UV(null);return function(t,e){QB().$$.context.set(t,e)}(WV,{registerTab:t=>{s.push(t),a.update((e=>e||t)),nU((()=>{const e=s.indexOf(t);s.splice(e,1),a.update((n=>n===t?s[e]||s[s.length-1]:n))}))},registerPanel:t=>{o.push(t),l.update((e=>e||t)),nU((()=>{const e=o.indexOf(t);o.splice(e,1),l.update((n=>n===t?o[e]||o[o.length-1]:n))}))},selectTab:t=>{const e=s.indexOf(t);a.set(t),l.set(o[e])},selectedTab:a,selectedPanel:l}),t.$$set=t=>{"$$scope"in t&&n(0,r=t.$$scope)},[r,i]}class jV extends UU{constructor(t){super(),BU(this,t,HV,VV,rB,{})}}function GV(t){let e,n,i,r;const s=t[5].default,o=uB(s,t,t[4],null);return{c(){e=MB("div"),o&&o.c(),OB(e,"class","text-sm font-semibold text-gray-600 cursor-pointer mx-4 p-2 hover:text-gray-800 svelte-d0yt2a"),OB(e,"role","tab"),OB(e,"tabindex","0"),WB(e,"selected",t[0]===t[1])},m(s,a){TB(s,e,a),o&&o.m(e,null),n=!0,i||(r=RB(e,"click",t[6]),i=!0)},p(t,[i]){o&&o.p&&(!n||16&i)&&pB(o,s,t,t[4],n?dB(s,t[4],i,null):fB(t[4]),null),(!n||3&i)&&WB(e,"selected",t[0]===t[1])},i(t){n||(EU(o,t),n=!0)},o(t){MU(o,t),n=!1},d(t){t&&_B(e),o&&o.d(t),i=!1,r()}}}function qV(t,e,n){let i,{$$slots:r={},$$scope:s}=e;const o={},{registerTab:a,selectTab:l,selectedTab:c}=rU(WV);cB(t,c,(t=>n(0,i=t))),a(o);return t.$$set=t=>{"$$scope"in t&&n(4,s=t.$$scope)},[i,o,l,c,s,r,()=>l(o)]}class XV extends UU{constructor(t){super(),BU(this,t,qV,GV,rB,{})}}function KV(t){let e;const n=t[4].default,i=uB(n,t,t[3],null);return{c(){i&&i.c()},m(t,n){i&&i.m(t,n),e=!0},p(t,r){i&&i.p&&(!e||8&r)&&pB(i,n,t,t[3],e?dB(n,t[3],r,null):fB(t[3]),null)},i(t){e||(EU(i,t),e=!0)},o(t){MU(i,t),e=!1},d(t){i&&i.d(t)}}}function YV(t){let e,n,i=t[0]===t[1]&&KV(t);return{c(){i&&i.c(),e=NB()},m(t,r){i&&i.m(t,r),TB(t,e,r),n=!0},p(t,[n]){t[0]===t[1]?i?(i.p(t,n),1&n&&EU(i,1)):(i=KV(t),i.c(),EU(i,1),i.m(e.parentNode,e)):i&&(TU(),MU(i,1,1,(()=>{i=null})),_U())},i(t){n||(EU(i),n=!0)},o(t){MU(i),n=!1},d(t){i&&i.d(t),t&&_B(e)}}}function ZV(t,e,n){let i,{$$slots:r={},$$scope:s}=e;const o={},{registerPanel:a,selectedPanel:l}=rU(WV);return cB(t,l,(t=>n(0,i=t))),a(o),t.$$set=t=>{"$$scope"in t&&n(3,s=t.$$scope)},[i,o,l,s,r]}class JV extends UU{constructor(t){super(),BU(this,t,ZV,YV,rB,{})}}function QV(t){return QV="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},QV(t)}function tW(t,e){if(e.length<t)throw new TypeError(t+" argument"+(t>1?"s":"")+" required, but only "+e.length+" present")}function eW(t){tW(1,arguments);var e=Object.prototype.toString.call(t);return t instanceof Date||"object"===QV(t)&&"[object Date]"===e?new Date(t.getTime()):"number"==typeof t||"[object Number]"===e?new Date(t):("string"!=typeof t&&"[object String]"!==e||"undefined"==typeof console||(console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"),console.warn((new Error).stack)),new Date(NaN))}var nW={};function iW(t){var e=new Date(Date.UTC(t.getFullYear(),t.getMonth(),t.getDate(),t.getHours(),t.getMinutes(),t.getSeconds(),t.getMilliseconds()));return e.setUTCFullYear(t.getFullYear()),t.getTime()-e.getTime()}function rW(t,e){tW(2,arguments);var n=eW(t),i=eW(e),r=n.getTime()-i.getTime();return r<0?-1:r>0?1:r}var sW={ceil:Math.ceil,round:Math.round,floor:Math.floor,trunc:function(t){return t<0?Math.ceil(t):Math.floor(t)}},oW="trunc";function aW(t){tW(1,arguments);var e=eW(t);return function(t){tW(1,arguments);var e=eW(t);return e.setHours(23,59,59,999),e}(e).getTime()===function(t){tW(1,arguments);var e=eW(t),n=e.getMonth();return e.setFullYear(e.getFullYear(),n+1,0),e.setHours(23,59,59,999),e}(e).getTime()}function lW(t,e){tW(2,arguments);var n,i=eW(t),r=eW(e),s=rW(i,r),o=Math.abs(function(t,e){tW(2,arguments);var n=eW(t),i=eW(e);return 12*(n.getFullYear()-i.getFullYear())+(n.getMonth()-i.getMonth())}(i,r));if(o<1)n=0;else{1===i.getMonth()&&i.getDate()>27&&i.setDate(30),i.setMonth(i.getMonth()-s*o);var a=rW(i,r)===-s;aW(eW(t))&&1===o&&1===rW(t,r)&&(a=!1),n=s*(o-Number(a))}return 0===n?0:n}function cW(t,e,n){tW(2,arguments);var i=function(t,e){return tW(2,arguments),eW(t).getTime()-eW(e).getTime()}(t,e)/1e3;return function(t){return t?sW[t]:sW[oW]}(null==n?void 0:n.roundingMethod)(i)}var uW={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXWeeks:{one:"about 1 week",other:"about {{count}} weeks"},xWeeks:{one:"1 week",other:"{{count}} weeks"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}},hW=function(t,e,n){var i,r=uW[t];return i="string"==typeof r?r:1===e?r.one:r.other.replace("{{count}}",e.toString()),null!=n&&n.addSuffix?n.comparison&&n.comparison>0?"in "+i:i+" ago":i};function dW(t){return function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=e.width?String(e.width):t.defaultWidth;return t.formats[n]||t.formats[t.defaultWidth]}}var pW={date:dW({formats:{full:"EEEE, MMMM do, y",long:"MMMM do, y",medium:"MMM d, y",short:"MM/dd/yyyy"},defaultWidth:"full"}),time:dW({formats:{full:"h:mm:ss a zzzz",long:"h:mm:ss a z",medium:"h:mm:ss a",short:"h:mm a"},defaultWidth:"full"}),dateTime:dW({formats:{full:"{{date}} 'at' {{time}}",long:"{{date}} 'at' {{time}}",medium:"{{date}}, {{time}}",short:"{{date}}, {{time}}"},defaultWidth:"full"})},fW={lastWeek:"'last' eeee 'at' p",yesterday:"'yesterday at' p",today:"'today at' p",tomorrow:"'tomorrow at' p",nextWeek:"eeee 'at' p",other:"P"},mW=function(t,e,n,i){return fW[t]};function gW(t){return function(e,n){var i;if("formatting"===(null!=n&&n.context?String(n.context):"standalone")&&t.formattingValues){var r=t.defaultFormattingWidth||t.defaultWidth,s=null!=n&&n.width?String(n.width):r;i=t.formattingValues[s]||t.formattingValues[r]}else{var o=t.defaultWidth,a=null!=n&&n.width?String(n.width):t.defaultWidth;i=t.values[a]||t.values[o]}return i[t.argumentCallback?t.argumentCallback(e):e]}}var yW={ordinalNumber:function(t,e){var n=Number(t),i=n%100;if(i>20||i<10)switch(i%10){case 1:return n+"st";case 2:return n+"nd";case 3:return n+"rd"}return n+"th"},era:gW({values:{narrow:["B","A"],abbreviated:["BC","AD"],wide:["Before Christ","Anno Domini"]},defaultWidth:"wide"}),quarter:gW({values:{narrow:["1","2","3","4"],abbreviated:["Q1","Q2","Q3","Q4"],wide:["1st quarter","2nd quarter","3rd quarter","4th quarter"]},defaultWidth:"wide",argumentCallback:function(t){return t-1}}),month:gW({values:{narrow:["J","F","M","A","M","J","J","A","S","O","N","D"],abbreviated:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],wide:["January","February","March","April","May","June","July","August","September","October","November","December"]},defaultWidth:"wide"}),day:gW({values:{narrow:["S","M","T","W","T","F","S"],short:["Su","Mo","Tu","We","Th","Fr","Sa"],abbreviated:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],wide:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]},defaultWidth:"wide"}),dayPeriod:gW({values:{narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"}},defaultWidth:"wide",formattingValues:{narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"}},defaultFormattingWidth:"wide"})},bW=yW;function vW(t){return function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=n.width,r=i&&t.matchPatterns[i]||t.matchPatterns[t.defaultMatchWidth],s=e.match(r);if(!s)return null;var o,a=s[0],l=i&&t.parsePatterns[i]||t.parsePatterns[t.defaultParseWidth],c=Array.isArray(l)?function(t,e){for(var n=0;n<t.length;n++)if(e(t[n]))return n;return}(l,(function(t){return t.test(a)})):function(t,e){for(var n in t)if(t.hasOwnProperty(n)&&e(t[n]))return n;return}(l,(function(t){return t.test(a)}));return o=t.valueCallback?t.valueCallback(c):c,{value:o=n.valueCallback?n.valueCallback(o):o,rest:e.slice(a.length)}}}var xW,wW={ordinalNumber:(xW={matchPattern:/^(\d+)(th|st|nd|rd)?/i,parsePattern:/\d+/i,valueCallback:function(t){return parseInt(t,10)}},function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=t.match(xW.matchPattern);if(!n)return null;var i=n[0],r=t.match(xW.parsePattern);if(!r)return null;var s=xW.valueCallback?xW.valueCallback(r[0]):r[0];return{value:s=e.valueCallback?e.valueCallback(s):s,rest:t.slice(i.length)}}),era:vW({matchPatterns:{narrow:/^(b|a)/i,abbreviated:/^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,wide:/^(before christ|before common era|anno domini|common era)/i},defaultMatchWidth:"wide",parsePatterns:{any:[/^b/i,/^(a|c)/i]},defaultParseWidth:"any"}),quarter:vW({matchPatterns:{narrow:/^[1234]/i,abbreviated:/^q[1234]/i,wide:/^[1234](th|st|nd|rd)? quarter/i},defaultMatchWidth:"wide",parsePatterns:{any:[/1/i,/2/i,/3/i,/4/i]},defaultParseWidth:"any",valueCallback:function(t){return t+1}}),month:vW({matchPatterns:{narrow:/^[jfmasond]/i,abbreviated:/^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,wide:/^(january|february|march|april|may|june|july|august|september|october|november|december)/i},defaultMatchWidth:"wide",parsePatterns:{narrow:[/^j/i,/^f/i,/^m/i,/^a/i,/^m/i,/^j/i,/^j/i,/^a/i,/^s/i,/^o/i,/^n/i,/^d/i],any:[/^ja/i,/^f/i,/^mar/i,/^ap/i,/^may/i,/^jun/i,/^jul/i,/^au/i,/^s/i,/^o/i,/^n/i,/^d/i]},defaultParseWidth:"any"}),day:vW({matchPatterns:{narrow:/^[smtwf]/i,short:/^(su|mo|tu|we|th|fr|sa)/i,abbreviated:/^(sun|mon|tue|wed|thu|fri|sat)/i,wide:/^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i},defaultMatchWidth:"wide",parsePatterns:{narrow:[/^s/i,/^m/i,/^t/i,/^w/i,/^t/i,/^f/i,/^s/i],any:[/^su/i,/^m/i,/^tu/i,/^w/i,/^th/i,/^f/i,/^sa/i]},defaultParseWidth:"any"}),dayPeriod:vW({matchPatterns:{narrow:/^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,any:/^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i},defaultMatchWidth:"any",parsePatterns:{any:{am:/^a/i,pm:/^p/i,midnight:/^mi/i,noon:/^no/i,morning:/morning/i,afternoon:/afternoon/i,evening:/evening/i,night:/night/i}},defaultParseWidth:"any"})},SW={code:"en-US",formatDistance:hW,formatLong:pW,formatRelative:mW,localize:bW,match:wW,options:{weekStartsOn:0,firstWeekContainsDate:1}};function kW(t,e){if(null==t)throw new TypeError("assign requires that input parameter not be null or undefined");for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t}var CW=1440,TW=2520,_W=43200,EW=86400;function MW(t,e,n){var i,r;tW(2,arguments);var s=nW,o=null!==(i=null!==(r=null==n?void 0:n.locale)&&void 0!==r?r:s.locale)&&void 0!==i?i:SW;if(!o.formatDistance)throw new RangeError("locale must contain formatDistance property");var a=rW(t,e);if(isNaN(a))throw new RangeError("Invalid time value");var l,c,u=kW(kW({},n),{addSuffix:Boolean(null==n?void 0:n.addSuffix),comparison:a});a>0?(l=eW(e),c=eW(t)):(l=eW(t),c=eW(e));var h,d=cW(c,l),p=(iW(c)-iW(l))/1e3,f=Math.round((d-p)/60);if(f<2)return null!=n&&n.includeSeconds?d<5?o.formatDistance("lessThanXSeconds",5,u):d<10?o.formatDistance("lessThanXSeconds",10,u):d<20?o.formatDistance("lessThanXSeconds",20,u):d<40?o.formatDistance("halfAMinute",0,u):d<60?o.formatDistance("lessThanXMinutes",1,u):o.formatDistance("xMinutes",1,u):0===f?o.formatDistance("lessThanXMinutes",1,u):o.formatDistance("xMinutes",f,u);if(f<45)return o.formatDistance("xMinutes",f,u);if(f<90)return o.formatDistance("aboutXHours",1,u);if(f<CW){var m=Math.round(f/60);return o.formatDistance("aboutXHours",m,u)}if(f<TW)return o.formatDistance("xDays",1,u);if(f<_W){var g=Math.round(f/CW);return o.formatDistance("xDays",g,u)}if(f<EW)return h=Math.round(f/_W),o.formatDistance("aboutXMonths",h,u);if((h=lW(c,l))<12){var y=Math.round(f/_W);return o.formatDistance("xMonths",y,u)}var b=h%12,v=Math.floor(h/12);return b<3?o.formatDistance("aboutXYears",v,u):b<9?o.formatDistance("overXYears",v,u):o.formatDistance("almostXYears",v+1,u)}function $W(t){let e;return{c(){e=IB(t[1])},m(t,n){TB(t,e,n)},p(t,n){2&n&&DB(e,t[1])},i:Jz,o:Jz,d(t){t&&_B(e)}}}function IW(t){let e,n=t[1].toPrecision(2)+"";return{c(){e=IB(n)},m(t,n){TB(t,e,n)},p(t,i){2&i&&n!==(n=t[1].toPrecision(2)+"")&&DB(e,n)},i:Jz,o:Jz,d(t){t&&_B(e)}}}function AW(t){let e,n,i,r=zW(t[1]).join(", ")+"";return{c(){e=IB("Array("),n=IB(r),i=IB(")")},m(t,r){TB(t,e,r),TB(t,n,r),TB(t,i,r)},p(t,e){2&e&&r!==(r=zW(t[1]).join(", ")+"")&&DB(n,r)},i:Jz,o:Jz,d(t){t&&_B(e),t&&_B(n),t&&_B(i)}}}function NW(t){let e,n=t[3](t[1])+"";return{c(){e=IB(n)},m(t,n){TB(t,e,n)},p(t,i){2&i&&n!==(n=t[3](t[1])+"")&&DB(e,n)},i:Jz,o:Jz,d(t){t&&_B(e)}}}function RW(t){let e;const n=t[4].default,i=uB(n,t,t[7],null);return{c(){i&&i.c()},m(t,n){i&&i.m(t,n),e=!0},p(t,r){i&&i.p&&(!e||128&r)&&pB(i,n,t,t[7],e?dB(n,t[7],r,null):fB(t[7]),null)},i(t){e||(EU(i,t),e=!0)},o(t){MU(i,t),e=!1},d(t){i&&i.d(t)}}}function PW(t){let e,n;return e=new HU({props:{size:"small",$$slots:{default:[DW]},$$scope:{ctx:t}}}),e.$on("click",t[6]),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};130&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function OW(t){let e,n,i,r,s=t[1].text+"";return{c(){e=MB("sl-button"),n=IB(s),LB(e,"type","text"),LB(e,"size","small")},m(s,o){TB(s,e,o),SB(e,n),i||(r=RB(e,"click",t[5]),i=!0)},p(t,e){2&e&&s!==(s=t[1].text+"")&&DB(n,s)},i:Jz,o:Jz,d(t){t&&_B(e),i=!1,r()}}}function LW(t){let e,n;return{c(){e=MB("img"),OB(e,"alt","thumbnail"),oB(e.src,n=t[1])||OB(e,"src",n),OB(e,"width","30"),OB(e,"height","30"),OB(e,"class","rounded-md")},m(t,n){TB(t,e,n)},p(t,i){2&i&&!oB(e.src,n=t[1])&&OB(e,"src",n)},i:Jz,o:Jz,d(t){t&&_B(e)}}}function DW(t){let e;return{c(){e=IB(t[1])},m(t,n){TB(t,e,n)},p(t,n){2&n&&DB(e,t[1])},d(t){t&&_B(e)}}}function FW(t){let e,n,i,r;const s=[LW,OW,PW,RW,NW,AW,IW,$W],o=[];function a(t,e){return"image"===t[0]?0:"link"===t[0]?1:"action"===t[0]?2:"slot"===t[0]?3:"date"===t[0]?4:"array"===t[0]?5:"number"==typeof t[1]?6:7}return n=a(t),i=o[n]=s[n](t),{c(){e=MB("td"),i.c(),OB(e,"class","svelte-fe0rg4")},m(t,i){TB(t,e,i),o[n].m(e,null),r=!0},p(t,[r]){let l=n;n=a(t),n===l?o[n].p(t,r):(TU(),MU(o[l],1,1,(()=>{o[l]=null})),_U(),i=o[n],i?i.p(t,r):(i=o[n]=s[n](t),i.c()),EU(i,1),i.m(e,null))},i(t){r||(EU(i),r=!0)},o(t){MU(i),r=!1},d(t){t&&_B(e),o[n].d()}}}function zW(t){return Array.isArray(t)?t.length>0&&Array.isArray(t[0])?[t.length,...zW(t[0])]:[t.length]:[]}function BW(t,e,n){let{$$slots:i={},$$scope:r}=e,{type:s="generic"}=e,{value:o=null}=e;const a=iU();return t.$$set=t=>{"type"in t&&n(0,s=t.type),"value"in t&&n(1,o=t.value),"$$scope"in t&&n(7,r=t.$$scope)},[s,o,a,function(t){try{return function(t,e){return tW(1,arguments),MW(t,Date.now(),e)}(Date.parse(t),{includeSeconds:!0,addSuffix:!0})}catch(e){return console.log("Date Parsing Error",t,e),t}},i,()=>{console.log("GOTO:",o.href)},()=>a("action",o),r]}class UW extends UU{constructor(t){super(),BU(this,t,BW,FW,rB,{type:0,value:1})}}function VW(t){let e,n,i,r;const s=[HW,WW],o=[];function a(t,e){return t[2]?0:1}return e=a(t),n=o[e]=s[e](t),{c(){n.c(),i=NB()},m(t,n){o[e].m(t,n),TB(t,i,n),r=!0},p(t,r){let l=e;e=a(t),e===l?o[e].p(t,r):(TU(),MU(o[l],1,1,(()=>{o[l]=null})),_U(),n=o[e],n?n.p(t,r):(n=o[e]=s[e](t),n.c()),EU(n,1),n.m(i.parentNode,i))},i(t){r||(EU(n),r=!0)},o(t){MU(n),r=!1},d(t){o[e].d(t),t&&_B(i)}}}function WW(t){let e,n;return e=new HU({props:{round:!0,size:"small",$$slots:{default:[jW]},$$scope:{ctx:t}}}),e.$on("click",t[3]),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};64&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function HW(t){let e,n;return e=new HU({props:{round:!0,size:"small",$$slots:{default:[GW]},$$scope:{ctx:t}}}),e.$on("click",t[3]),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};64&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function jW(t){let e,n;return{c(){e=$B("svg"),n=$B("path"),OB(n,"stroke-linecap","round"),OB(n,"stroke-linejoin","round"),OB(n,"stroke-width","2"),OB(n,"d","M16 17l-4 4m0 0l-4-4m4 4V3"),OB(e,"xmlns","http://www.w3.org/2000/svg"),OB(e,"class","h-6 w-6"),OB(e,"fill","none"),OB(e,"viewBox","0 0 24 24"),OB(e,"stroke","currentColor")},m(t,i){TB(t,e,i),SB(e,n)},p:Jz,d(t){t&&_B(e)}}}function GW(t){let e,n;return{c(){e=$B("svg"),n=$B("path"),OB(n,"stroke-linecap","round"),OB(n,"stroke-linejoin","round"),OB(n,"stroke-width","2"),OB(n,"d","M8 7l4-4m0 0l4 4m-4-4v18"),OB(e,"xmlns","http://www.w3.org/2000/svg"),OB(e,"class","h-6 w-6"),OB(e,"fill","none"),OB(e,"viewBox","0 0 24 24"),OB(e,"stroke","currentColor")},m(t,i){TB(t,e,i),SB(e,n)},p:Jz,d(t){t&&_B(e)}}}function qW(t){let e,n,i,r,s,o,a=t[1]&&VW(t);return{c(){e=MB("th"),n=MB("span"),i=MB("span"),r=IB(t[0]),s=AB(),a&&a.c(),zB(i,"margin-top","0.5rem"),zB(i,"margin-bottom","0.5rem"),zB(n,"display","flex"),zB(n,"justify-content","space-between"),zB(n,"align-items","center"),OB(e,"class","svelte-1310j1m")},m(t,l){TB(t,e,l),SB(e,n),SB(n,i),SB(i,r),SB(n,s),a&&a.m(n,null),o=!0},p(t,[e]){(!o||1&e)&&DB(r,t[0]),t[1]?a?(a.p(t,e),2&e&&EU(a,1)):(a=VW(t),a.c(),EU(a,1),a.m(n,null)):a&&(TU(),MU(a,1,1,(()=>{a=null})),_U())},i(t){o||(EU(a),o=!0)},o(t){MU(a),o=!1},d(t){t&&_B(e),a&&a.d()}}}function XW(t,e,n){let{name:i="name"}=e,{sortable:r=!1}=e,{sorting:s={col:"",ascending:!0}}=e;const o=iU();let a=!0;return t.$$set=t=>{"name"in t&&n(0,i=t.name),"sortable"in t&&n(1,r=t.sortable),"sorting"in t&&n(4,s=t.sorting)},t.$$.update=()=>{17&t.$$.dirty&&s.col===i&&n(2,a=s.ascending)},[i,r,a,function(){n(2,a=!a),o("sort",{col:i,ascending:a})},s]}class KW extends UU{constructor(t){super(),BU(this,t,XW,qW,rB,{name:0,sortable:1,sorting:4})}}function YW(t,e,n){const i=t.slice();return i[10]=e[n].name,i[11]=e[n].multiple,i[12]=e[n].confirm,i}function ZW(t){let e,n=t[10]+"";return{c(){e=IB(n)},m(t,n){TB(t,e,n)},p(t,i){2&i&&n!==(n=t[10]+"")&&DB(e,n)},d(t){t&&_B(e)}}}function JW(t){let e,n;return e=new HU({props:{size:"small",disabled:!1===t[11]&&t[0].length>1,type:"delete"===t[10]?"danger":"default",$$slots:{default:[ZW]},$$scope:{ctx:t}}}),e.$on("click",(function(){return t[7](t[10],t[12])})),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(n,i){t=n;const r={};3&i&&(r.disabled=!1===t[11]&&t[0].length>1),2&i&&(r.type="delete"===t[10]?"danger":"default"),32770&i&&(r.$$scope={dirty:i,ctx:t}),e.$set(r)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function QW(t){let e,n;return e=new YU({props:{$$slots:{default:[nH]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};32780&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function tH(t){let e;return{c(){e=IB("Cancel")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function eH(t){let e;return{c(){e=IB("Confirm")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function nH(t){let e,n,i,r,s,o,a,l,c,u,h,d,p;return l=new HU({props:{type:"danger",$$slots:{default:[tH]},$$scope:{ctx:t}}}),l.$on("click",t[8]),d=new HU({props:{variant:"filled",$$slots:{default:[eH]},$$scope:{ctx:t}}}),d.$on("click",t[4]),{c(){e=MB("div"),n=MB("p"),i=IB("Do you want to "),r=IB(t[2]),s=IB(" the selected items?"),o=AB(),a=MB("div"),DU(l.$$.fragment),c=AB(),u=MB("span"),h=AB(),DU(d.$$.fragment),OB(u,"class","w-2"),OB(a,"class","w-full flex justify-end"),OB(e,"class","p-8")},m(t,f){TB(t,e,f),SB(e,n),SB(n,i),SB(n,r),SB(n,s),SB(e,o),SB(e,a),FU(l,a,null),SB(a,c),SB(a,u),SB(a,h),FU(d,a,null),p=!0},p(t,e){(!p||4&e)&&DB(r,t[2]);const n={};32768&e&&(n.$$scope={dirty:e,ctx:t}),l.$set(n);const i={};32768&e&&(i.$$scope={dirty:e,ctx:t}),d.$set(i)},i(t){p||(EU(l.$$.fragment,t),EU(d.$$.fragment,t),p=!0)},o(t){MU(l.$$.fragment,t),MU(d.$$.fragment,t),p=!1},d(t){t&&_B(e),zU(l),zU(d)}}}function iH(t){let e,n,i,r,s=t[1],o=[];for(let e=0;e<s.length;e+=1)o[e]=JW(YW(t,s,e));const a=t=>MU(o[t],1,1,(()=>{o[t]=null}));let l=t[3]&&QW(t);return{c(){e=MB("div");for(let t=0;t<o.length;t+=1)o[t].c();n=AB(),l&&l.c(),i=NB(),OB(e,"class","actions")},m(t,s){TB(t,e,s);for(let t=0;t<o.length;t+=1)o[t]&&o[t].m(e,null);TB(t,n,s),l&&l.m(t,s),TB(t,i,s),r=!0},p(t,[n]){if(35&n){let i;for(s=t[1],i=0;i<s.length;i+=1){const r=YW(t,s,i);o[i]?(o[i].p(r,n),EU(o[i],1)):(o[i]=JW(r),o[i].c(),EU(o[i],1),o[i].m(e,null))}for(TU(),i=s.length;i<o.length;i+=1)a(i);_U()}t[3]?l?(l.p(t,n),8&n&&EU(l,1)):(l=QW(t),l.c(),EU(l,1),l.m(i.parentNode,i)):l&&(TU(),MU(l,1,1,(()=>{l=null})),_U())},i(t){if(!r){for(let t=0;t<s.length;t+=1)EU(o[t]);EU(l),r=!0}},o(t){o=o.filter(Boolean);for(let t=0;t<o.length;t+=1)MU(o[t]);MU(l),r=!1},d(t){t&&_B(e),EB(o,t),t&&_B(n),l&&l.d(t),t&&_B(i)}}}function rH(t,e,n){let{provider:i}=e,{actions:r}=e,{selected:s}=e;const o=iU();let a="",l=!1;async function c(){if("delete"===a)for(const t of s)await i.delete(t);else o("action",[a,s]);n(3,l=!1),n(0,s=[]),o("selected",s)}function u(t,e){n(2,a=t),a&&0!==s.length&&(e?n(3,l=!0):c())}return t.$$set=t=>{"provider"in t&&n(6,i=t.provider),"actions"in t&&n(1,r=t.actions),"selected"in t&&n(0,s=t.selected)},[s,r,a,l,c,u,i,(t,e)=>u(t,e),()=>{n(3,l=!1)}]}class sH extends UU{constructor(t){super(),BU(this,t,rH,iH,rB,{provider:6,actions:1,selected:0})}}function oH(t){let e,n,i;function r(e){t[11](e)}let s={provider:t[1],actions:t[2]};return void 0!==t[0]&&(s.selected=t[0]),e=new sH({props:s}),aU.push((()=>LU(e,"selected",r))),e.$on("selected",t[12]),e.$on("action",t[13]),{c(){DU(e.$$.fragment)},m(t,n){FU(e,t,n),i=!0},p(t,i){const r={};2&i&&(r.provider=t[1]),4&i&&(r.actions=t[2]),!n&&1&i&&(n=!0,r.selected=t[0],mU((()=>n=!1))),e.$set(r)},i(t){i||(EU(e.$$.fragment,t),i=!0)},o(t){MU(e.$$.fragment,t),i=!1},d(t){zU(e,t)}}}function aH(t){let e,n;return{c(){e=$B("svg"),n=$B("path"),OB(n,"stroke-linecap","round"),OB(n,"stroke-linejoin","round"),OB(n,"stroke-width","2"),OB(n,"d","M15 19l-7-7 7-7"),OB(e,"xmlns","http://www.w3.org/2000/svg"),OB(e,"class","h-3 w-3"),OB(e,"fill","none"),OB(e,"viewBox","0 0 24 24"),OB(e,"stroke","currentColor")},m(t,i){TB(t,e,i),SB(e,n)},p:Jz,d(t){t&&_B(e)}}}function lH(t){let e,n;return{c(){e=$B("svg"),n=$B("path"),OB(n,"stroke-linecap","round"),OB(n,"stroke-linejoin","round"),OB(n,"stroke-width","2"),OB(n,"d","M9 5l7 7-7 7"),OB(e,"xmlns","http://www.w3.org/2000/svg"),OB(e,"class","h-3 w-3"),OB(e,"fill","none"),OB(e,"viewBox","0 0 24 24"),OB(e,"stroke","currentColor")},m(t,i){TB(t,e,i),SB(e,n)},p:Jz,d(t){t&&_B(e)}}}function cH(t){let e,n,i,r,s,o,a,l,c,u,h,d,p,f,m,g,y,b,v,x,w,S,k,C,T,_=t[2].length>0&&t[0].length>0&&oH(t);return l=new PV({props:{size:"small",options:["10","20","50","all"],value:t[5].toString()}}),l.$on("change",t[14]),y=new HU({props:{round:!0,disabled:1===t[3],$$slots:{default:[aH]},$$scope:{ctx:t}}}),y.$on("click",t[15]),S=new HU({props:{round:!0,disabled:t[3]===t[6],$$slots:{default:[lH]},$$scope:{ctx:t}}}),S.$on("click",t[17]),{c(){e=MB("div"),n=MB("div"),_&&_.c(),i=AB(),r=MB("div"),s=MB("div"),o=IB("Items per page:\n\t\t\t"),a=MB("div"),DU(l.$$.fragment),c=AB(),u=MB("div"),h=IB(t[7]),d=IB("-"),p=IB(t[8]),f=IB(" of "),m=IB(t[4]),g=AB(),DU(y.$$.fragment),b=AB(),v=MB("input"),w=AB(),DU(S.$$.fragment),OB(n,"class","actions"),OB(a,"class","w-12 ml-2"),OB(s,"class","flex items-center mx-4"),OB(u,"class","mx-3"),OB(v,"class","marcelle w-8 rounded mr-1 mb-1 bg-white text-gray-600 border border-solid border-gray-300 text-center focus:outline-none focus:ring-blue-400 focus:ring-2 focus:ring-opacity-50 active:ring-blue-400 active:ring-4 active:ring-opacity-50"),v.value=x=t[3].toString(),OB(r,"class","flex items-center"),OB(e,"class","table-footer svelte-13k2ee6")},m(x,E){TB(x,e,E),SB(e,n),_&&_.m(n,null),SB(e,i),SB(e,r),SB(r,s),SB(s,o),SB(s,a),FU(l,a,null),SB(r,c),SB(r,u),SB(u,h),SB(u,d),SB(u,p),SB(u,f),SB(u,m),SB(r,g),FU(y,r,null),SB(r,b),SB(r,v),SB(r,w),FU(S,r,null),k=!0,C||(T=RB(v,"blur",t[16]),C=!0)},p(t,[e]){t[2].length>0&&t[0].length>0?_?(_.p(t,e),5&e&&EU(_,1)):(_=oH(t),_.c(),EU(_,1),_.m(n,null)):_&&(TU(),MU(_,1,1,(()=>{_=null})),_U());const i={};32&e&&(i.value=t[5].toString()),l.$set(i),(!k||128&e)&&DB(h,t[7]),(!k||256&e)&&DB(p,t[8]),(!k||16&e)&&DB(m,t[4]);const r={};8&e&&(r.disabled=1===t[3]),262144&e&&(r.$$scope={dirty:e,ctx:t}),y.$set(r),(!k||8&e&&x!==(x=t[3].toString())&&v.value!==x)&&(v.value=x);const s={};72&e&&(s.disabled=t[3]===t[6]),262144&e&&(s.$$scope={dirty:e,ctx:t}),S.$set(s)},i(t){k||(EU(_),EU(l.$$.fragment,t),EU(y.$$.fragment,t),EU(S.$$.fragment,t),k=!0)},o(t){MU(_),MU(l.$$.fragment,t),MU(y.$$.fragment,t),MU(S.$$.fragment,t),k=!1},d(t){t&&_B(e),_&&_.d(),zU(l),zU(y),zU(S),C=!1,T()}}}function uH(t,e,n){let i,{provider:r}=e,{actions:s}=e,{selected:o}=e,a=1,l=1,c=0,u=0,h=0,d=()=>{};function p(t){n(3,a=t),r.page(t)}return t.$$set=t=>{"provider"in t&&n(1,r=t.provider),"actions"in t&&n(2,s=t.actions),"selected"in t&&n(0,o=t.selected)},t.$$.update=()=>{2&t.$$.dirty&&n(5,i=r.options.itemsPerPage),1082&t.$$.dirty&&(d(),n(10,d=r.total.subscribe((t=>{void 0===t||0===t?(n(6,l=1),n(7,c=0),n(8,u=0),n(4,h=0)):(n(6,l=Math.ceil(h/i)),n(7,c=(a-1)*i+1),n(8,u=Math.min(h||0,a*i)),n(4,h=t))}))))},[o,r,s,a,h,i,l,c,u,p,d,function(t){o=t,n(0,o)},function(e){sU.call(this,t,e)},function(e){sU.call(this,t,e)},({detail:t})=>{const e="all"===t?h:parseInt(t);r.paginate(e),n(5,i=e)},()=>{p(a-1)},t=>{let e=parseInt(t.currentTarget.value);isNaN(e)||p(Math.max(1,Math.min(l,e)))},()=>{p(a+1)}]}class hH extends UU{constructor(t){super(),BU(this,t,uH,cH,rB,{provider:1,actions:2,selected:0})}}function dH(t,e,n){const i=t.slice();return i[22]=e[n],i[24]=n,i}function pH(t,e,n){const i=t.slice();return i[25]=e[n].type,i[26]=e[n].name,i}function fH(t,e,n){const i=t.slice();return i[26]=e[n].name,i[29]=e[n].sortable,i}function mH(t){let e,n,i,r,s,o,a,l;return{c(){e=MB("div"),n=MB("sl-alert"),i=MB("sl-icon"),r=AB(),s=MB("strong"),s.textContent="Table Data Error",o=MB("br"),a=AB(),l=IB(t[9]),LB(i,"slot","icon"),LB(i,"name","check2-circle"),LB(n,"type","danger"),LB(n,"open",""),OB(e,"class","service-error")},m(t,c){TB(t,e,c),SB(e,n),SB(n,i),SB(n,r),SB(n,s),SB(n,o),SB(n,a),SB(n,l)},p(t,e){512&e[0]&&DB(l,t[9])},d(t){t&&_B(e)}}}function gH(t){let e,n=!t[4]&&yH(t);return{c(){e=MB("th"),n&&n.c(),OB(e,"class","svelte-12gp9na")},m(t,i){TB(t,e,i),n&&n.m(e,null)},p(t,i){t[4]?n&&(n.d(1),n=null):n?n.p(t,i):(n=yH(t),n.c(),n.m(e,null))},d(t){t&&_B(e),n&&n.d()}}}function yH(t){let e,n,i,r;return{c(){e=MB("input"),OB(e,"type","checkbox"),e.checked=n=t[6].length>0&&t[6].length===t[10].length},m(n,s){TB(n,e,s),i||(r=RB(e,"click",t[12]),i=!0)},p(t,i){1088&i[0]&&n!==(n=t[6].length>0&&t[6].length===t[10].length)&&(e.checked=n)},d(t){t&&_B(e),i=!1,r()}}}function bH(t){let e,n;return e=new KW({props:{name:t[26],sortable:t[29],sorting:t[7]}}),e.$on("sort",t[11]),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};1&n[0]&&(i.name=t[26]),1&n[0]&&(i.sortable=t[29]),128&n[0]&&(i.sorting=t[7]),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function vH(t){let e,n;return e=new UW({props:{type:"slot",$$slots:{default:[xH]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};64&n[0]|2&n[1]&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function xH(t){let e,n,i,r;function s(...e){return t[16](t[24],...e)}return{c(){e=MB("input"),OB(e,"type","checkbox"),e.checked=n=t[6].includes(t[24])},m(t,n){TB(t,e,n),i||(r=RB(e,"click",s),i=!0)},p(i,r){t=i,64&r[0]&&n!==(n=t[6].includes(t[24]))&&(e.checked=n)},d(t){t&&_B(e),i=!1,r()}}}function wH(t){let e,n;return e=new UW({props:{type:t[25],value:t[22][t[26]]}}),e.$on("action",(function(...e){return t[17](t[24],...e)})),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(n,i){t=n;const r={};1&i[0]&&(r.type=t[25]),1025&i[0]&&(r.value=t[22][t[26]]),e.$set(r)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function SH(t){let e,n,i,r,s=t[3]&&vH(t),o=t[0],a=[];for(let e=0;e<o.length;e+=1)a[e]=wH(pH(t,o,e));const l=t=>MU(a[t],1,1,(()=>{a[t]=null}));return{c(){e=MB("tr"),s&&s.c(),n=AB();for(let t=0;t<a.length;t+=1)a[t].c();i=AB(),OB(e,"class","svelte-12gp9na")},m(t,o){TB(t,e,o),s&&s.m(e,null),SB(e,n);for(let t=0;t<a.length;t+=1)a[t]&&a[t].m(e,null);SB(e,i),r=!0},p(t,r){if(t[3]?s?(s.p(t,r),8&r[0]&&EU(s,1)):(s=vH(t),s.c(),EU(s,1),s.m(e,n)):s&&(TU(),MU(s,1,1,(()=>{s=null})),_U()),17409&r[0]){let n;for(o=t[0],n=0;n<o.length;n+=1){const s=pH(t,o,n);a[n]?(a[n].p(s,r),EU(a[n],1)):(a[n]=wH(s),a[n].c(),EU(a[n],1),a[n].m(e,i))}for(TU(),n=o.length;n<a.length;n+=1)l(n);_U()}},i(t){if(!r){EU(s);for(let t=0;t<o.length;t+=1)EU(a[t]);r=!0}},o(t){MU(s),a=a.filter(Boolean);for(let t=0;t<a.length;t+=1)MU(a[t]);r=!1},d(t){t&&_B(e),s&&s.d(),EB(a,t)}}}function kH(t){let e,n,i,r,s,o,a,l,c,u,h,d,p=t[9]&&mH(t),f=t[3]&&gH(t),m=t[0],g=[];for(let e=0;e<m.length;e+=1)g[e]=bH(fH(t,m,e));const y=t=>MU(g[t],1,1,(()=>{g[t]=null}));let b=t[10],v=[];for(let e=0;e<b.length;e+=1)v[e]=SH(dH(t,b,e));const x=t=>MU(v[t],1,1,(()=>{v[t]=null}));function w(e){t[18](e)}let S={provider:t[1],actions:t[2]};return void 0!==t[6]&&(S.selected=t[6]),u=new hH({props:S}),aU.push((()=>LU(u,"selected",w))),u.$on("action",t[19]),{c(){p&&p.c(),e=AB(),n=MB("div"),i=MB("table"),r=MB("thead"),s=MB("tr"),f&&f.c(),o=AB();for(let t=0;t<g.length;t+=1)g[t].c();a=AB(),l=MB("tbody");for(let t=0;t<v.length;t+=1)v[t].c();c=AB(),DU(u.$$.fragment),OB(s,"class","svelte-12gp9na"),OB(r,"class","svelte-12gp9na"),OB(l,"class","svelte-12gp9na"),OB(i,"class","svelte-12gp9na"),OB(n,"class","marcelle table-container svelte-12gp9na")},m(t,h){p&&p.m(t,h),TB(t,e,h),TB(t,n,h),SB(n,i),SB(i,r),SB(r,s),f&&f.m(s,null),SB(s,o);for(let t=0;t<g.length;t+=1)g[t]&&g[t].m(s,null);SB(i,a),SB(i,l);for(let t=0;t<v.length;t+=1)v[t]&&v[t].m(l,null);SB(n,c),FU(u,n,null),d=!0},p(t,n){if(t[9]?p?p.p(t,n):(p=mH(t),p.c(),p.m(e.parentNode,e)):p&&(p.d(1),p=null),t[3]?f?f.p(t,n):(f=gH(t),f.c(),f.m(s,o)):f&&(f.d(1),f=null),2177&n[0]){let e;for(m=t[0],e=0;e<m.length;e+=1){const i=fH(t,m,e);g[e]?(g[e].p(i,n),EU(g[e],1)):(g[e]=bH(i),g[e].c(),EU(g[e],1),g[e].m(s,null))}for(TU(),e=m.length;e<g.length;e+=1)y(e);_U()}if(25673&n[0]){let e;for(b=t[10],e=0;e<b.length;e+=1){const i=dH(t,b,e);v[e]?(v[e].p(i,n),EU(v[e],1)):(v[e]=SH(i),v[e].c(),EU(v[e],1),v[e].m(l,null))}for(TU(),e=b.length;e<v.length;e+=1)x(e);_U()}const i={};2&n[0]&&(i.provider=t[1]),4&n[0]&&(i.actions=t[2]),!h&&64&n[0]&&(h=!0,i.selected=t[6],mU((()=>h=!1))),u.$set(i)},i(t){if(!d){for(let t=0;t<m.length;t+=1)EU(g[t]);for(let t=0;t<b.length;t+=1)EU(v[t]);EU(u.$$.fragment,t),d=!0}},o(t){g=g.filter(Boolean);for(let t=0;t<g.length;t+=1)MU(g[t]);v=v.filter(Boolean);for(let t=0;t<v.length;t+=1)MU(v[t]);MU(u.$$.fragment,t),d=!1},d(t){p&&p.d(t),t&&_B(e),t&&_B(n),f&&f.d(),EB(g,t),EB(v,t),zU(u)}}}function CH(t,e,n){let i,r,s,o,a=Jz,l=Jz;t.$$.on_destroy.push((()=>a())),t.$$.on_destroy.push((()=>l()));let{columns:c}=e,{provider:u}=e,{actions:h=[]}=e,{selectable:d=!0}=e,{singleSelection:p=!1}=e,{selection:f=[]}=e,m=[];const g=iU();let y={col:"",ascending:!0};async function b(){n(15,f=await Promise.all(m.map(u.get.bind(u)))),g("selection",f)}function v(t,e){p?(n(6,m=e.currentTarget.checked?[t]:[]),b()):e.currentTarget.checked?m.includes(t)||(n(6,m=m.concat([t])),b()):(n(6,m=m.filter((e=>e!==t))),b())}async function x([t,e]){const n=Array.isArray(e)?await Promise.all(e.map(u.get.bind(u))):await u.get(e);g(t,n)}return t.$$set=t=>{"columns"in t&&n(0,c=t.columns),"provider"in t&&n(1,u=t.provider),"actions"in t&&n(2,h=t.actions),"selectable"in t&&n(3,d=t.selectable),"singleSelection"in t&&n(4,p=t.singleSelection),"selection"in t&&n(15,f=t.selection)},t.$$.update=()=>{2&t.$$.dirty[0]&&(n(5,i=u.data),l(),l=aB(i,(t=>n(10,o=t)))),2&t.$$.dirty[0]&&(n(8,r=u.error),a(),a=aB(r,(t=>n(9,s=t)))),32800&t.$$.dirty[0]&&n(6,m=f.map((t=>lB(i).indexOf(t))))},[c,u,h,d,p,i,m,y,r,s,o,function({detail:t}){n(7,y=t),u.sort(t)},function(){m.length===lB(i).length?n(6,m=[]):n(6,m=lB(i).map(((t,e)=>e))),b()},v,x,f,(t,e)=>v(t,e),(t,{detail:e})=>{x([e,t])},function(t){m=t,n(6,m),n(15,f),n(5,i),n(1,u)},({detail:t})=>x(t)]}class TH extends UU{constructor(t){super(),BU(this,t,CH,kH,rB,{columns:0,provider:1,actions:2,selectable:3,singleSelection:4,selection:15},null,[-1,-1])}}function _H(t){let e,n;const i=t[1].default,r=uB(i,t,t[0],null);return{c(){e=MB("div"),r&&r.c(),OB(e,"class","flex border-solid border-0 border-b border-gray-200 mb-2")},m(t,i){TB(t,e,i),r&&r.m(e,null),n=!0},p(t,[e]){r&&r.p&&(!n||1&e)&&pB(r,i,t,t[0],n?dB(i,t[0],e,null):fB(t[0]),null)},i(t){n||(EU(r,t),n=!0)},o(t){MU(r,t),n=!1},d(t){t&&_B(e),r&&r.d(t)}}}function EH(t,e,n){let{$$slots:i={},$$scope:r}=e;return t.$$set=t=>{"$$scope"in t&&n(0,r=t.$$scope)},[r,i]}class MH extends UU{constructor(t){super(),BU(this,t,EH,_H,rB,{})}}const $H={itemsPerPage:10};class IH{options;data=UV([]);total=UV(0);error=UV(null);constructor(t=$H){this.options={...$H,...t}}paginate(t){this.options.itemsPerPage=t,this.update()}async get(t){const e=lB(this.data);return t>=0&&t<e.length?e[t]:null}}class AH extends IH{rawData;currentPage=1;constructor({data:t,...e}){super(e),this.rawData=t,this.total.set(t.length),this.data.set(this.rawData.slice(0,this.options.itemsPerPage))}async update(){this.page(this.currentPage)}async page(t){this.data.set(this.rawData.slice((t-1)*this.options.itemsPerPage,Math.min(t*this.options.itemsPerPage,this.rawData.length))),this.currentPage=t}async sort(t){this.rawData.sort(((e,n)=>e[t.col]>n[t.col]?t.ascending?1:-1:e[t.col]<n[t.col]?t.ascending?-1:1:0)),this.page(this.currentPage)}async delete(t){return this.rawData.splice(t,1),this.page(this.currentPage),null}}class NH extends IH{service;query;transform;constructor({service:t,columns:e,transform:n,...i}){super(i),this.service=t,this.transform=n||{},this.query={$sort:{updatedAt:-1},$limit:this.options.itemsPerPage},e&&(this.query.$select=e.map((t=>t.name)).concat(["id"])),this.update(),this.service.on("created",this.update.bind(this)),this.service.on("patched",this.update.bind(this)),this.service.on("updated",this.update.bind(this)),this.service.on("removed",this.update.bind(this))}paginate(t){super.paginate(t),this.query.$limit=this.options.itemsPerPage,this.update()}async update(){try{const t=await this.service.find({query:this.query}),e=t.data.map(((t,e)=>{const n=Object.entries(this.transform).map((([n,i])=>{try{return{[n]:i(t,e)}}catch(t){return{[n]:"transform error"}}})).reduce(((t,e)=>({...t,...e})),{});return{...t,...n}}));this.data.set(e),this.total.set(t.total),this.error.set(null)}catch(t){this.data.set([]),this.total.set(0),this.error.set(t)}}async page(t){this.query.$skip=(t-1)*this.query.$limit,this.update()}async sort(t){const{col:e,ascending:n}=t;e?this.query.$sort={[e]:n?1:-1}:delete this.query.$sort,this.update()}async delete(t){const e=lB(this.data)[t];return await this.service.remove(e.id),this.update(),e}}function RH(t){let e,n,i;return n=new MV({props:{progress:t[2],thin:!0}}),{c(){e=MB("div"),DU(n.$$.fragment),OB(e,"class","absolute top-0 left-0 right-0")},m(t,r){TB(t,e,r),FU(n,e,null),i=!0},p(t,e){const i={};4&e&&(i.progress=t[2]),n.$set(i)},i(t){i||(EU(n.$$.fragment,t),i=!0)},o(t){MU(n.$$.fragment,t),i=!1},d(t){t&&_B(e),zU(n)}}}function PH(t){let e,n;return e=new LV({}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function OH(t){let e,n,i,r,s,o,a,l=!1!==t[2]&&RH(t),c=t[1]&&PH();const u=t[4].default,h=uB(u,t,t[3],null);return{c(){e=MB("div"),l&&l.c(),n=AB(),i=MB("span"),r=IB(t[0]),s=AB(),c&&c.c(),o=AB(),h&&h.c(),OB(i,"class","card-title"),OB(e,"class","card-container svelte-xnhseh")},m(t,u){TB(t,e,u),l&&l.m(e,null),SB(e,n),SB(e,i),SB(i,r),SB(e,s),c&&c.m(e,null),SB(e,o),h&&h.m(e,null),a=!0},p(t,[i]){!1!==t[2]?l?(l.p(t,i),4&i&&EU(l,1)):(l=RH(t),l.c(),EU(l,1),l.m(e,n)):l&&(TU(),MU(l,1,1,(()=>{l=null})),_U()),(!a||1&i)&&DB(r,t[0]),t[1]?c?2&i&&EU(c,1):(c=PH(),c.c(),EU(c,1),c.m(e,o)):c&&(TU(),MU(c,1,1,(()=>{c=null})),_U()),h&&h.p&&(!a||8&i)&&pB(h,u,t,t[3],a?dB(u,t[3],i,null):fB(t[3]),null)},i(t){a||(EU(l),EU(c),EU(h,t),a=!0)},o(t){MU(l),MU(c),MU(h,t),a=!1},d(t){t&&_B(e),l&&l.d(),c&&c.d(),h&&h.d(t)}}}function LH(t,e,n){let{$$slots:i={},$$scope:r}=e,{title:s}=e,{loading:o=!1}=e,{progress:a=!1}=e;return t.$$set=t=>{"title"in t&&n(0,s=t.title),"loading"in t&&n(1,o=t.loading),"progress"in t&&n(2,a=t.progress),"$$scope"in t&&n(3,r=t.$$scope)},[s,o,a,r,i]}class DH extends UU{constructor(t){super(),BU(this,t,LH,OH,rB,{title:0,loading:1,progress:2})}}let FH,zH;function BH({title:t,message:e,duration:n=3e3,type:i="default"}){FH||(FH=document.createElement("div"),FH.id="notification-container",document.body.appendChild(FH),zH=new cV({target:FH})),null==zH||zH.add({title:t,message:e,duration:n,type:i})}
/** @license MIT License (c) copyright 2010-2016 original author or authors */function UH(t,e){for(var n=e.length,i=new Array(n+1),r=0;r<n;++r)i[r]=e[r];return i[n]=t,i}function VH(t,e,n){for(var i=e,r=0,s=n.length;r<s;++r)i=t(i,n[r],r);return i}function WH(t,e){if(t<0)throw new TypeError("i must be >= 0");var n=e.length;return 0===n||t>=n?e:1===n?[]:function(t,e,n){var i,r=new Array(n);for(i=0;i<t;++i)r[i]=e[i];for(i=t;i<n;++i)r[i]=e[i+1];return r}(t,e,n-1)}function HH(t,e){for(var n=0,i=e.length;n<i;++n)if(t===e[n])return n;return-1}
/** @license MIT License (c) copyright 2010-2016 original author or authors */var jH=function(t){return t},GH=function(t,e){return t(e)};function qH(t){return function e(n,i){switch(arguments.length){case 0:return e;case 1:return function(e){return t(n,e)};default:return t(n,i)}}}function XH(t){return function e(n,i,r){switch(arguments.length){case 0:return e;case 1:return qH((function(e,i){return t(n,e,i)}));case 2:return function(e){return t(n,i,e)};default:return t(n,i,r)}}}var KH=function(){function t(t,e,n,i,r){this.time=t,this.localOffset=e,this.period=n,this.task=i,this.scheduler=r,this.active=!0}return t.prototype.run=function(){return this.task.run(this.time-this.localOffset)},t.prototype.error=function(t){return this.task.error(this.time-this.localOffset,t)},t.prototype.dispose=function(){return this.active=!1,this.scheduler.cancel(this),this.task.dispose()},t}(),YH=function(){function t(t,e){this.origin=t,this.scheduler=e}return t.prototype.currentTime=function(){return this.scheduler.currentTime()-this.origin},t.prototype.scheduleTask=function(t,e,n,i){return this.scheduler.scheduleTask(t+this.origin,e,n,i)},t.prototype.relative=function(e){return new t(e+this.origin,this.scheduler)},t.prototype.cancel=function(t){return this.scheduler.cancel(t)},t.prototype.cancelAll=function(t){return this.scheduler.cancelAll(t)},t}();function ZH(t){try{return t.run()}catch(e){return t.error(e)}}
/** @license MIT License (c) copyright 2010-2017 original author or authors */var JH=function(){function t(t,e){var n=this;this._runReadyTasksBound=function(){return n._runReadyTasks()},this.timer=t,this.timeline=e,this._timer=null,this._nextArrival=1/0}return t.prototype.currentTime=function(){return this.timer.now()},t.prototype.scheduleTask=function(t,e,n,i){var r=this.currentTime()+Math.max(0,e),s=new KH(r,t,n,i,this);return this.timeline.add(s),this._scheduleNextRun(),s},t.prototype.relative=function(t){return new YH(t,this)},t.prototype.cancel=function(t){t.active=!1,this.timeline.remove(t)&&this._reschedule()},t.prototype.cancelAll=function(t){this.timeline.removeAll(t),this._reschedule()},t.prototype._reschedule=function(){this.timeline.isEmpty()?this._unschedule():this._scheduleNextRun()},t.prototype._unschedule=function(){this.timer.clearTimer(this._timer),this._timer=null},t.prototype._scheduleNextRun=function(){if(!this.timeline.isEmpty()){var t=this.timeline.nextArrival();null===this._timer?this._scheduleNextArrival(t):t<this._nextArrival&&(this._unschedule(),this._scheduleNextArrival(t))}},t.prototype._scheduleNextArrival=function(t){this._nextArrival=t;var e=Math.max(0,t-this.currentTime());this._timer=this.timer.setTimer(this._runReadyTasksBound,e)},t.prototype._runReadyTasks=function(){this._timer=null,this.timeline.runTasks(this.currentTime(),ZH),this._scheduleNextRun()},t}(),QH=function(){function t(){this.tasks=[]}return t.prototype.nextArrival=function(){return this.isEmpty()?1/0:this.tasks[0].time},t.prototype.isEmpty=function(){return 0===this.tasks.length},t.prototype.add=function(t){ej(t,this.tasks)},t.prototype.remove=function(t){var e=rj(nj(t),this.tasks);if(e>=0&&e<this.tasks.length){var n=this.tasks[e].events,i=HH(t,n);if(i>=0)return n.splice(i,1),0===n.length&&this.tasks.splice(e,1),!0}return!1},t.prototype.removeAll=function(t){for(var e=0;e<this.tasks.length;++e)ij(t,this.tasks[e])},t.prototype.runTasks=function(t,e){for(var n=this.tasks,i=n.length,r=0;r<i&&n[r].time<=t;)++r;this.tasks=n.slice(r);for(var s=0;s<r;++s)this.tasks=tj(e,n[s].events,this.tasks)},t}();
/** @license MIT License (c) copyright 2010-2017 original author or authors */function tj(t,e,n){for(var i=0;i<e.length;++i){var r=e[i];r.active&&(t(r),r.period>=0&&r.active&&(r.time=r.time+r.period,ej(r,n)))}return n}function ej(t,e){var n=e.length,i=nj(t);if(0!==n){var r=rj(i,e);r>=n?e.push(sj(i,[t])):function(t,e,n,i){var r=e[i];n===r.time?function(t,e){0===e.length||t.time>=e[e.length-1].time?e.push(t):function(t,e){for(var n=0;n<e.length;n++)if(t.time<e[n].time){e.splice(n,0,t);break}}(t,e)}(t,r.events):e.splice(i,0,sj(n,[t]))}(t,e,i,r)}else e.push(sj(i,[t]))}function nj(t){return Math.floor(t.time)}function ij(t,e){e.events=function(t,e){for(var n=e.length,i=new Array(n),r=0,s=void 0,o=0;o<n;++o)t(s=e[o])||(i[r]=s,++r);return i.length=r,i}(t,e.events)}function rj(t,e){for(var n,i,r=0,s=e.length;r<s;){if(t===(i=e[n=Math.floor((r+s)/2)]).time)return n;t<i.time?s=n:r=n+1}return s}var sj=function(t,e){return{time:t,events:e}},oj=function(){function t(t){this._clock=t}return t.prototype.now=function(){return this._clock.now()},t.prototype.setTimer=function(t,e){return e<=0?function(t){var e=new aj(t);return function(t){Promise.resolve(t).then(ZH)}(e),e}(t):setTimeout(t,e)},t.prototype.clearTimer=function(t){return t instanceof aj?t.cancel():clearTimeout(t)},t}(),aj=function(){function t(t){this.f=t,this.active=!0}return t.prototype.run=function(){if(this.active)return this.f()},t.prototype.error=function(t){throw t},t.prototype.cancel=function(){this.active=!1},t}();
/** @license MIT License (c) copyright 2010-2017 original author or authors */var lj=function(){function t(t,e){this.origin=e,this.clock=t}return t.prototype.now=function(){return this.clock.now()-this.origin},t}(),cj=function(){function t(t,e){this.origin=e,this.hrtime=t}return t.prototype.now=function(){var t=this.hrtime(this.origin);return(1e9*t[0]+t[1])/1e6},t}(),uj=function(t){return new lj(t,t.now())},hj=function(){return"undefined"!=typeof performance&&"function"==typeof performance.now?uj(performance):"undefined"!=typeof process&&"function"==typeof process.hrtime?new cj(process.hrtime,process.hrtime()):uj(Date)},dj=function(t){return t.currentTime()},pj=qH((function(t,e){return e.scheduleTask(0,0,-1,t)})),fj=XH((function(t,e,n){return n.scheduleTask(0,t,-1,e)})),mj=XH((function(t,e,n){return n.scheduleTask(0,0,t,e)})),gj=function(t){return t.dispose()},yj=qH((function(t,e){return new YH(t,e)})),bj=function(){return new oj(hj())},vj=function(){return xj},xj=new(function(){function t(){}return t.prototype.dispose=function(){},t}()),wj=function(t){return new Sj(t)},Sj=function(){function t(t){this.disposed=!1,this.disposable=t}return t.prototype.dispose=function(){this.disposed||(this.disposed=!0,this.disposable&&(this.disposable.dispose(),this.disposable=void 0))},t}(),kj=function(t){var e=VH(Tj,[],t);return 0===e.length?vj():new _j(e)},Cj=qH((function(t,e){return kj([t,e])})),Tj=function(t,e){return function(t){return t===xj}(e)?t:e instanceof _j?function(t,e){var n=t.length,i=e.length,r=new Array(n+i),s=0;for(s=0;s<n;s++)r[s]=t[s];for(var o=0;o<i;o++)r[s++]=e[o];return r}(t,e.disposables):UH(e,t)},_j=function(){function t(t){this.disposables=t}return t.prototype.dispose=function(){$j(Ej(this.disposables))},t}(),Ej=function(t){return VH(Mj,[],t)},Mj=function(t,e){try{e.dispose()}catch(e){t.push(e)}return t},$j=function(t){if(t.length>0)throw new Ij(t.length+" errors",t)},Ij=function t(e,n){this.name="DisposeAllError",this.message=e,this.errors=n,Error.call(this,e),Error.captureStackTrace&&Error.captureStackTrace(this,t),this.stack=""+this.stack+Aj(this.errors)};Ij.prototype=Object.create(Error.prototype);var Aj=function(t){return VH(Nj,"",t)},Nj=function(t,e,n){return t+"\n["+(n+1)+"] "+e.stack},Rj=XH((function(t,e,n){try{e.dispose()}catch(e){n.error(t,e)}})),Pj=function(t,e){return Pj=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])},Pj(t,e)};function Oj(t,e){function n(){this.constructor=t}Pj(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}
/** @license MIT License (c) copyright 2010-2016 original author or authors */function Lj(t){setTimeout(Dj,0,t)}function Dj(t){throw t}
/** @license MIT License (c) copyright 2010-2016 original author or authors */var Fj=function(t,e){return new Vj(t,e)},zj=function(t){return new Wj(t)},Bj=function(){function t(t){this.sink=t,this.active=!0}return t.prototype.dispose=function(){this.active=!1},t.prototype.run=function(t){this.active&&this.runIfActive(t)},t.prototype.error=function(t,e){if(!this.active)return Lj(e);this.sink.error(t,e)},t}(),Uj=function(t){function e(e,n,i){var r=t.call(this,i)||this;return r.runEvent=e,r.value=n,r}return Oj(e,t),e.prototype.runIfActive=function(t){this.runEvent(t,this.value,this.sink)},e}(Bj),Vj=function(t){function e(e,n){var i=t.call(this,n)||this;return i.value=e,i}return Oj(e,t),e.prototype.runIfActive=function(t){this.sink.event(t,this.value)},e}(Bj),Wj=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return Oj(e,t),e.prototype.runIfActive=function(t){this.sink.end(t)},e}(Bj),Hj=function(t){function e(e,n){var i=t.call(this,n)||this;return i.value=e,i}return Oj(e,t),e.prototype.runIfActive=function(t){this.sink.error(t,this.value)},e}(Bj),jj=function(){return Kj},Gj=function(t){return t===Kj},qj=function(t){return t.some(Gj)},Xj=function(){function t(){}return t.prototype.run=function(t,e){return pj(zj(t),e)},t}(),Kj=new Xj,Yj=function(){return Zj},Zj=new(function(){function t(){}return t.prototype.run=function(){return vj()},t}()),Jj=function(t,e){return new Qj(t,e)},Qj=function(){function t(t,e){this.time=t,this.value=e}return t.prototype.run=function(t,e){return fj(this.time,function(t,e,n){return new Uj(t,e,n)}(tG,this.value,t),e)},t}();function tG(t,e,n){n.event(t,e),n.end(t)}
/** @license MIT License (c) copyright 2010-2017 original author or authors */var eG=function(t){return Jj(0,t)},nG=function(){function t(t){this.period=t}return t.prototype.run=function(t,e){return mj(this.period,Fj(void 0,t),e)},t}(),iG=function(){function t(){this.disposable=void 0,this.disposed=!1}return t.prototype.setDisposable=function(t){if(void 0!==this.disposable)throw new Error("setDisposable called more than once");this.disposable=t,this.disposed&&t.dispose()},t.prototype.dispose=function(){this.disposed||(this.disposed=!0,void 0!==this.disposable&&this.disposable.dispose())},t}(),rG=qH((function(t,e){return new Promise((function(n,i){return function(t,e,n,i){var r=new iG,s=new sG(n,i,r);r.setDisposable(t.run(s,e))}(t,e,n,i)}))}));
/** @license MIT License (c) copyright 2010-2016 original author or authors */var sG=function(){function t(t,e,n){this._end=t,this._error=e,this._disposable=n,this.active=!0}return t.prototype.event=function(){},t.prototype.end=function(){this.active&&this.dispose(this._error,this._end,void 0)},t.prototype.error=function(t,e){this.dispose(this._error,this._error,e)},t.prototype.dispose=function(t,e,n){this.active=!1,function(t,e,n,i){try{i.dispose()}catch(e){return void t(e)}e(n)}(t,e,n,this._disposable)},t}();var oG=function(t,e,n){return n.run(t,e)},aG=function(){function t(t,e){this.sink=e,this.offset=t}return t.prototype.event=function(t,e){this.sink.event(t+this.offset,e)},t.prototype.error=function(t,e){this.sink.error(t+this.offset,e)},t.prototype.end=function(t){this.sink.end(t+this.offset)},t}(),lG=function(t,e){return new cG(t,e)},cG=function(){function t(t,e){this.origin=t,this.source=e}return t.prototype.run=function(t,e){return this.source.run(uG(this.origin,t),yj(this.origin,e))},t}(),uG=function(t,e){return e instanceof aG?new aG(t+e.offset,e.sink):new aG(t,e)},hG=function(){function t(t){this.sink=t}return t.prototype.end=function(t){return this.sink.end(t)},t.prototype.error=function(t,e){return this.sink.error(t,e)},t}(),dG=function(){function t(t,e,n){this.step=t,this.seed=e,this.source=n}return t.prototype.run=function(t,e){return this.source.run(new pG(this.step,this.seed,t),e)},t}(),pG=function(t){function e(e,n,i){var r=t.call(this,i)||this;return r.step=e,r.seed=n,r}return Oj(e,t),e.prototype.event=function(t,e){var n=this.step(this.seed,e);this.seed=n.seed,this.sink.event(t,n.value)},e}(hG),fG=function(){function t(t,e,n){this.source=n,this.f=t,this.value=e}return t.prototype.run=function(t,e){var n=pj(Fj(this.value,t),e),i=this.source.run(new mG(this.f,this.value,t),e);return Cj(n,i)},t}(),mG=function(t){function e(e,n,i){var r=t.call(this,i)||this;return r.f=e,r.value=n,r}return Oj(e,t),e.prototype.event=function(t,e){var n=this.f;this.value=n(this.value,e),this.sink.event(t,this.value)},e}(hG),gG=function(t,e){return new yG(t,e)},yG=function(){function t(t,e){this.f=t,this.source=e}return t.prototype.run=function(t,e){return new bG(this.f,this.source,t,e)},t}(),bG=function(t){function e(e,n,i,r){var s=t.call(this,i)||this;return s.f=e,s.scheduler=r,s.active=!0,s.disposable=wj(n.run(s,r)),s}return Oj(e,t),e.prototype.event=function(t,e){this.active&&this.sink.event(t,e)},e.prototype.end=function(t){this.active&&(Rj(t,this.disposable,this.sink),this.startNext(t,this.sink))},e.prototype.startNext=function(t,e){try{this.disposable=this.continue(this.f,t,e)}catch(n){e.error(t,n)}},e.prototype.continue=function(t,e,n){return oG(n,this.scheduler,lG(e,t()))},e.prototype.dispose=function(){return this.active=!1,this.disposable.dispose()},e}(hG),vG=function(){function t(t,e){this.p=t,this.source=e}return t.prototype.run=function(t,e){return this.source.run(new xG(this.p,t),e)},t.create=function(e,n){return Gj(n)?n:n instanceof t?new t(wG(n.p,e),n.source):new t(e,n)},t}(),xG=function(t){function e(e,n){var i=t.call(this,n)||this;return i.p=e,i}return Oj(e,t),e.prototype.event=function(t,e){(0,this.p)(e)&&this.sink.event(t,e)},e}(hG),wG=function(t,e){return function(n){return t(n)&&e(n)}},SG=function(){function t(t,e,n){this.p=t,this.f=e,this.source=n}return t.prototype.run=function(t,e){return this.source.run(new kG(this.p,this.f,t),e)},t}(),kG=function(t){function e(e,n,i){var r=t.call(this,i)||this;return r.p=e,r.f=n,r}return Oj(e,t),e.prototype.event=function(t,e){var n=this.f;(0,this.p)(e)&&this.sink.event(t,n(e))},e}(hG),CG=function(){function t(t,e){this.f=t,this.source=e}return t.prototype.run=function(t,e){return this.source.run(new TG(this.f,t),e)},t.create=function(e,n){return Gj(n)?jj():n instanceof t?new t(function(t,e){return function(n){return t(e(n))}}(e,n.f),n.source):n instanceof vG?new SG(n.p,e,n.source):new t(e,n)},t}(),TG=function(t){function e(e,n){var i=t.call(this,n)||this;return i.f=e,i}return Oj(e,t),e.prototype.event=function(t,e){var n=this.f;this.sink.event(t,n(e))},e}(hG),_G=function(t,e){return CG.create(t,e)},EG=function(){function t(t,e){this.source=e,this.f=t}return t.prototype.run=function(t,e){return this.source.run(new MG(this.f,t),e)},t}(),MG=function(t){function e(e,n){var i=t.call(this,n)||this;return i.f=e,i}return Oj(e,t),e.prototype.event=function(t,e){(0,this.f)(e),this.sink.event(t,e)},e}(hG),$G=function(t){function e(e,n){var i=t.call(this,n)||this;return i.index=e,i.active=!0,i.value=void 0,i}return Oj(e,t),e.prototype.event=function(t,e){this.active&&(this.value=e,this.sink.event(t,this))},e.prototype.end=function(t){this.active&&(this.active=!1,this.sink.event(t,this))},e}(hG);
/** @license MIT License (c) copyright 2010-2016 original author or authors */
function IG(t,e){switch(e.length){case 0:return t();case 1:return t(e[0]);case 2:return t(e[0],e[1]);case 3:return t(e[0],e[1],e[2]);case 4:return t(e[0],e[1],e[2],e[3]);case 5:return t(e[0],e[1],e[2],e[3],e[4]);default:return t.apply(void 0,e)}}
/** @license MIT License (c) copyright 2010 original author or authors */var AG=function(t,e,n){return NG(t,[e,n])},NG=function(t,e){return 0===e.length||qj(e)?jj():1===e.length?_G(t,e[0]):new RG(t,e)},RG=function(){function t(t,e){this.f=t,this.sources=e}return t.prototype.run=function(t,e){for(var n=this.sources.length,i=new Array(n),r=new Array(n),s=new PG(i,r.length,t,this.f),o=void 0,a=0;a<n;++a)o=r[a]=new $G(a,s),i[a]=this.sources[a].run(o,e);return kj(i)},t}(),PG=function(t){function e(e,n,i,r){var s=t.call(this,i)||this;return s.disposables=e,s.f=r,s.awaiting=n,s.values=new Array(n),s.hasValue=new Array(n).fill(!1),s.activeCount=n,s}return Oj(e,t),e.prototype.event=function(t,e){if(e.active){var n=e.index,i=this.updateReady(n);this.values[n]=e.value,0===i&&this.sink.event(t,IG(this.f,this.values))}else this.dispose(t,e.index)},e.prototype.updateReady=function(t){return this.awaiting>0&&(this.hasValue[t]||(this.hasValue[t]=!0,this.awaiting-=1)),this.awaiting},e.prototype.dispose=function(t,e){Rj(t,this.disposables[e],this.sink),0==--this.activeCount&&this.sink.end(t)},e}(hG);
/** @license MIT License (c) copyright 2010 original author or authors */
var OG=function(t,e){return LG(jH,t,e)},LG=function(t,e,n){return Gj(n)?jj():new DG(t,e,n)},DG=function(){function t(t,e,n){this.f=t,this.concurrency=e,this.source=n}return t.prototype.run=function(t,e){return new FG(this.f,this.concurrency,this.source,t,e)},t}(),FG=function(){function t(t,e,n,i,r){this.f=t,this.concurrency=e,this.sink=i,this.scheduler=r,this.pending=[],this.current=[],this.disposable=wj(n.run(this,r)),this.active=!0}return t.prototype.event=function(t,e){this.addInner(t,e)},t.prototype.addInner=function(t,e){this.current.length<this.concurrency?this.startInner(t,e):this.pending.push(e)},t.prototype.startInner=function(t,e){try{this.initInner(t,e)}catch(e){this.error(t,e)}},t.prototype.initInner=function(t,e){var n=new BG(t,this,this.sink);n.disposable=zG(this.f,t,e,n,this.scheduler),this.current.push(n)},t.prototype.end=function(t){this.active=!1,Rj(t,this.disposable,this.sink),this.checkEnd(t)},t.prototype.error=function(t,e){this.active=!1,this.sink.error(t,e)},t.prototype.dispose=function(){this.active=!1,this.pending.length=0,this.disposable.dispose(),kj(this.current).dispose()},t.prototype.endInner=function(t,e){var n=this.current.indexOf(e);n>=0&&this.current.splice(n,1),Rj(t,e,this);var i=this.pending;i.length>0?this.startInner(t,i.shift()):this.checkEnd(t)},t.prototype.checkEnd=function(t){this.active||0!==this.current.length||this.sink.end(t)},t}(),zG=function(t,e,n,i,r){return t(n).run(i,yj(e,r))},BG=function(){function t(t,e,n){this.time=t,this.outer=e,this.sink=n,this.disposable=vj()}return t.prototype.event=function(t,e){this.sink.event(t+this.time,e)},t.prototype.end=function(t){this.outer.endInner(t+this.time,this)},t.prototype.error=function(t,e){this.outer.error(t+this.time,e)},t.prototype.dispose=function(){return this.disposable.dispose()},t}(),UG=function(t){return OG(1/0,t)};var VG=function(t){return WG(HG(t))},WG=function(t){return 0===t.length?jj():1===t.length?t[0]:new qG(VH(GG,[],t))},HG=function(t){return t.filter(jG)},jG=function(t){return!Gj(t)},GG=function(t,e){return t.concat(e instanceof qG?e.sources:e)},qG=function(){function t(t){this.sources=t}return t.prototype.run=function(t,e){for(var n=this.sources.length,i=new Array(n),r=new Array(n),s=new XG(i,r,t),o=void 0,a=0;a<n;++a)o=r[a]=new $G(a,s),i[a]=this.sources[a].run(o,e);return kj(i)},t}(),XG=function(t){function e(e,n,i){var r=t.call(this,i)||this;return r.disposables=e,r.activeCount=n.length,r}return Oj(e,t),e.prototype.event=function(t,e){e.active?this.sink.event(t,e.value):this.dispose(t,e.index)},e.prototype.dispose=function(t,e){Rj(t,this.disposables[e],this.sink),0==--this.activeCount&&this.sink.end(t)},e}(hG),KG=function(t,e,n){return Gj(n)||Gj(e)?jj():new YG(t,e,n)},YG=function(){function t(t,e,n){this.f=t,this.values=e,this.sampler=n}return t.prototype.run=function(t,e){var n=new ZG(this.f,t),i=this.values.run(n.latest,e),r=this.sampler.run(n,e);return Cj(r,i)},t}(),ZG=function(t){function e(e,n){var i=t.call(this,n)||this;return i.f=e,i.latest=new JG(i),i}return Oj(e,t),e.prototype.event=function(t,e){if(this.latest.hasValue){var n=this.f;this.sink.event(t,n(this.latest.value,e))}},e}(hG),JG=function(t){function e(e){var n=t.call(this,e)||this;return n.hasValue=!1,n}return Oj(e,t),e.prototype.event=function(t,e){this.value=e,this.hasValue=!0},e.prototype.end=function(){},e}(hG),QG=function(t,e){var n=Math.max(0,t);return{min:n,max:Math.max(n,e)}},tq=function(t,e){return eq(0,t,e)},eq=function(t,e,n){return nq(QG(t,e),n)},nq=function(t,e){return iq(t,e)?jj():e instanceof CG?sq(t,e):e instanceof aq?oq(t,e):rq(t,e)},iq=function(t,e){return Gj(e)||(n=t).min>=n.max;var n},rq=function(t,e){return(n=t).min<=0&&n.max===1/0?e:new aq(t,e);var n},sq=function(t,e){return CG.create(e.f,nq(t,e.source))},oq=function(t,e){return nq((n=e.bounds,i=t,QG(n.min+i.min,Math.min(n.max,n.min+i.max))),e.source);var n,i},aq=function(){function t(t,e){this.source=e,this.bounds=t}return t.prototype.run=function(t,e){var n=new iG,i=new lq(this.bounds.min,this.bounds.max-this.bounds.min,t,n);return n.setDisposable(this.source.run(i,e)),n},t}(),lq=function(t){function e(e,n,i,r){var s=t.call(this,i)||this;return s.skip=e,s.take=n,s.disposable=r,s}return Oj(e,t),e.prototype.event=function(t,e){this.skip>0?this.skip-=1:0!==this.take&&(this.take-=1,this.sink.event(t,e),0===this.take&&(this.disposable.dispose(),this.sink.end(t)))},e}(hG),cq=function(){function t(t,e){this.p=t,this.source=e}return t.prototype.run=function(t,e){var n=new iG,i=new uq(this.p,t,n);return n.setDisposable(this.source.run(i,e)),n},t}(),uq=function(t){function e(e,n,i){var r=t.call(this,n)||this;return r.p=e,r.active=!0,r.disposable=i,r}return Oj(e,t),e.prototype.event=function(t,e){if(this.active){var n=this.p;this.active=n(e),this.active?this.sink.event(t,e):(this.disposable.dispose(),this.sink.end(t))}},e}(hG),hq=function(){function t(t,e){this.p=t,this.source=e}return t.prototype.run=function(t,e){return this.source.run(new dq(this.p,t),e)},t}(),dq=function(t){function e(e,n){var i=t.call(this,n)||this;return i.p=e,i.skipping=!0,i}return Oj(e,t),e.prototype.event=function(t,e){if(this.skipping){var n=this.p;if(this.skipping=n(e),this.skipping)return}this.sink.event(t,e)},e}(hG),pq=function(){function t(t,e){this.p=t,this.source=e}return t.prototype.run=function(t,e){return this.source.run(new fq(this.p,t),e)},t}(),fq=function(t){function e(e,n){var i=t.call(this,n)||this;return i.p=e,i.skipping=!1,i}return Oj(e,t),e.prototype.event=function(t,e){if(!this.skipping){var n=this.p;this.skipping=n(e),this.sink.event(t,e),this.skipping&&this.sink.end(t)}},e}(hG),mq=function(t,e,n){return Gj(n)||0===e.length?jj():new yq(t,e,tq(e.length,n))},gq=function(t){return t},yq=function(){function t(t,e,n){this.f=t,this.items=e,this.source=n}return t.prototype.run=function(t,e){return this.source.run(new bq(this.f,this.items,t),e)},t}(),bq=function(t){function e(e,n,i){var r=t.call(this,i)||this;return r.f=e,r.items=n,r.index=0,r}return Oj(e,t),e.prototype.event=function(t,e){var n=this.f;this.sink.event(t,n(this.items[this.index],e)),this.index+=1},e}(hG),vq=function(){function t(){this.head=0,this.tail=0,this.capacityMask=3,this.list=new Array(4)}return t.prototype.push=function(t){var e=this.tail;return this.list[e]=t,this.tail=e+1&this.capacityMask,this.tail===this.head&&this.growArray(),this.head<this.tail?this.tail-this.head:this.capacityMask+1-(this.head-this.tail)},t.prototype.shift=function(){var t=this.head;if(t!==this.tail){var e=this.list[t];return this.list[t]=void 0,this.head=t+1&this.capacityMask,t<2&&this.tail>1e4&&this.tail<=this.list.length>>>2&&this.shrinkArray(),e}},t.prototype.isEmpty=function(){return this.head===this.tail},t.prototype.length=function(){return this.head===this.tail?0:this.head<this.tail?this.tail-this.head:this.capacityMask+1-(this.head-this.tail)},t.prototype.growArray=function(){this.head&&(this.list=this.copyArray(),this.head=0),this.tail=this.list.length,this.list.length*=2,this.capacityMask=this.capacityMask<<1|1},t.prototype.shrinkArray=function(){this.list.length>>>=1,this.capacityMask>>>=1},t.prototype.copyArray=function(){var t,e=[],n=this.list,i=n.length;for(t=this.head;t<i;t++)e.push(n[t]);for(t=0;t<this.tail;t++)e.push(n[t]);return e},t}();var xq=function(t,e){return 0===e.length||qj(e)?jj():1===e.length?_G(t,e[0]):new wq(t,e)},wq=function(){function t(t,e){this.f=t,this.sources=e}return t.prototype.run=function(t,e){for(var n=this.sources.length,i=new Array(n),r=new Array(n),s=new Array(n),o=new Sq(this.f,s,r,t),a=void 0,l=0;l<n;++l)s[l]=new vq,a=r[l]=new $G(l,o),i[l]=this.sources[l].run(a,e);return kj(i)},t}(),Sq=function(t){function e(e,n,i,r){var s=t.call(this,r)||this;return s.f=e,s.sinks=i,s.buffers=n,s}return Oj(e,t),e.prototype.event=function(t,e){if(e.active){var n=this.buffers,i=n[e.index];if(i.push(e.value),1===i.length()){if(!function(t){for(var e=0,n=t.length;e<n;++e)if(t[e].isEmpty())return!1;return!0}
/** @license MIT License (c) copyright 2010-2016 original author or authors */(n))return;kq(this.f,t,n,this.sink),function(t,e){for(var n=0,i=t.length;n<i;++n)if(t[n].isEmpty()&&!e[n].active)return!0;return!1}(this.buffers,this.sinks)&&this.sink.end(t)}}else this.dispose(t,e.index)},e.prototype.dispose=function(t,e){this.buffers[e].isEmpty()&&this.sink.end(t)},e}(hG),kq=function(t,e,n,i){return i.event(e,IG(t,function(t,e){for(var n=e.length,i=new Array(n),r=0;r<n;++r)i[r]=t(e[r]);return i}(Cq,n)))},Cq=function(t){return t.shift()};var Tq=function(){function t(t){this.source=t}return t.prototype.run=function(t,e){var n=new _q(t,e);return Cj(n,this.source.run(n,e))},t}(),_q=function(){function t(t,e){this.sink=t,this.scheduler=e,this.current=null,this.ended=!1}return t.prototype.event=function(t,e){this.disposeCurrent(t),this.current=new Eq(e,t,1/0,this,this.sink,this.scheduler)},t.prototype.end=function(t){this.ended=!0,this.checkEnd(t)},t.prototype.error=function(t,e){this.ended=!0,this.sink.error(t,e)},t.prototype.dispose=function(){return this.disposeCurrent(dj(this.scheduler))},t.prototype.disposeCurrent=function(t){if(null!==this.current)return this.current.dispose(t)},t.prototype.disposeInner=function(t,e){e.dispose(t),e===this.current&&(this.current=null)},t.prototype.checkEnd=function(t){this.ended&&null===this.current&&this.sink.end(t)},t.prototype.endInner=function(t,e){this.disposeInner(t,e),this.checkEnd(t)},t.prototype.errorInner=function(t,e,n){this.disposeInner(t,n),this.sink.error(t,e)},t}(),Eq=function(){function t(t,e,n,i,r,s){this.min=e,this.max=n,this.outer=i,this.sink=r,this.disposable=t.run(this,yj(e,s))}return t.prototype.event=function(t,e){var n=Math.max(0,t+this.min);n<this.max&&this.sink.event(n,e)},t.prototype.end=function(t){this.outer.endInner(t+this.min,this)},t.prototype.error=function(t,e){this.outer.errorInner(t+this.min,e,this)},t.prototype.dispose=function(t){Rj(t,this.disposable,this.sink)},t}();var Mq=function(t,e){return Gj(e)?jj():new $q(t,e)},$q=function(){function t(t,e){this.equals=t,this.source=e}return t.prototype.run=function(t,e){return this.source.run(new Iq(this.equals,t),e)},t}(),Iq=function(t){function e(e,n){var i=t.call(this,n)||this;return i.equals=e,i.value=void 0,i.init=!0,i}return Oj(e,t),e.prototype.event=function(t,e){this.init?(this.init=!1,this.value=e,this.sink.event(t,e)):this.equals(this.value,e)||(this.value=e,this.sink.event(t,e))},e}(hG);function Aq(t,e){return t===e}
/** @license MIT License (c) copyright 2010-2016 original author or authors */var Nq=function(t,e){return new Pq(t,e)},Rq=function(t,e){return new Oq(t,e)},Pq=function(){function t(t,e){this.maxSignal=t,this.source=e}return t.prototype.run=function(t,e){var n=new iG,i=this.source.run(t,e),r=this.maxSignal.run(new Fq(t,n),e);return n.setDisposable(Cj(i,r)),n},t}(),Oq=function(){function t(t,e){this.minSignal=t,this.source=e}return t.prototype.run=function(t,e){var n=new Dq(this.minSignal,t,e),i=this.source.run(new Lq(n,t),e);return Cj(n,i)},t}(),Lq=function(t){function e(e,n){var i=t.call(this,n)||this;return i.min=e,i}return Oj(e,t),e.prototype.event=function(t,e){this.min.allow&&this.sink.event(t,e)},e}(hG),Dq=function(t){function e(e,n,i){var r=t.call(this,n)||this;return r.allow=!1,r.disposable=e.run(r,i),r}return Oj(e,t),e.prototype.event=function(){this.allow=!0,this.dispose()},e.prototype.end=function(){},e.prototype.dispose=function(){this.disposable.dispose()},e}(hG),Fq=function(t){function e(e,n){var i=t.call(this,e)||this;return i.disposable=n,i}return Oj(e,t),e.prototype.event=function(t){this.disposable.dispose(),this.sink.end(t)},e.prototype.end=function(){},e}(hG),zq=function(){function t(t,e){this.dt=t,this.source=e}return t.prototype.run=function(t,e){var n=new Bq(this.dt,t,e);return Cj(n,this.source.run(n,e))},t}(),Bq=function(t){function e(e,n,i){var r=t.call(this,n)||this;return r.dt=e,r.scheduler=i,r.tasks=[],r}return Oj(e,t),e.prototype.dispose=function(){this.tasks.forEach(gj)},e.prototype.event=function(t,e){this.tasks.push(fj(this.dt,Fj(e,this.sink),this.scheduler))},e.prototype.end=function(){this.tasks.push(fj(this.dt,zj(this.sink),this.scheduler))},e}(hG),Uq=function(t,e){return Gj(e)?jj():e instanceof CG?Vq(t,e):e instanceof Hq?Wq(t,e):new Hq(t,e)},Vq=function(t,e){return CG.create(e.f,Uq(t,e.source))},Wq=function(t,e){return new Hq(Math.max(t,e.period),e.source)},Hq=function(){function t(t,e){this.period=t,this.source=e}return t.prototype.run=function(t,e){return this.source.run(new jq(this.period,t),e)},t}(),jq=function(t){function e(e,n){var i=t.call(this,n)||this;return i.time=0,i.period=e,i}return Oj(e,t),e.prototype.event=function(t,e){t>=this.time&&(this.time=t+this.period,this.sink.event(t,e))},e}(hG),Gq=function(){function t(t,e){this.dt=t,this.source=e}return t.prototype.run=function(t,e){return new qq(this.dt,this.source,t,e)},t}(),qq=function(){function t(t,e,n,i){this.dt=t,this.sink=n,this.scheduler=i,this.timer=null,this.disposable=e.run(this,i)}return t.prototype.event=function(t,e){this.clearTimer(),this.value=e,this.timer=fj(this.dt,new Xq(this,e),this.scheduler)},t.prototype.handleEventFromTask=function(t,e){this.clearTimer(),this.sink.event(t,e)},t.prototype.end=function(t){this.clearTimer()&&(this.sink.event(t,this.value),this.value=void 0),this.sink.end(t)},t.prototype.error=function(t,e){this.clearTimer(),this.sink.error(t,e)},t.prototype.dispose=function(){this.clearTimer(),this.disposable.dispose()},t.prototype.clearTimer=function(){return null!==this.timer&&(this.timer.dispose(),this.timer=null,!0)},t}(),Xq=function(){function t(t,e){this.sink=t,this.value=e}return t.prototype.run=function(t){this.sink.handleEventFromTask(t,this.value)},t.prototype.error=function(t,e){this.sink.error(t,e)},t.prototype.dispose=function(){},t}(),Kq=function(){function t(t){this.source=t}return t.prototype.run=function(t,e){return this.source.run(new Yq(t,e),e)},t}(),Yq=function(){function t(t,e){var n=this;this.eventBound=function(t){return n.sink.event(dj(n.scheduler),t)},this.endBound=function(){return n.sink.end(dj(n.scheduler))},this.errorBound=function(t){return n.sink.error(dj(n.scheduler),t)},this.sink=t,this.scheduler=e,this.queue=Promise.resolve()}return t.prototype.event=function(t,e){var n=this;this.queue=this.queue.then((function(){return n.handlePromise(e)})).catch(this.errorBound)},t.prototype.end=function(){this.queue=this.queue.then(this.endBound).catch(this.errorBound)},t.prototype.error=function(t,e){var n=this;this.queue=this.queue.then((function(){return n.errorBound(e)})).catch(Lj)},t.prototype.handlePromise=function(t){return t.then(this.eventBound)},t}(),Zq=function(){function t(t){this.sink=t,this.active=!0}return t.prototype.event=function(t,e){this.active&&this.sink.event(t,e)},t.prototype.end=function(t){this.active&&(this.disable(),this.sink.end(t))},t.prototype.error=function(t,e){this.disable(),this.sink.error(t,e)},t.prototype.disable=function(){return this.active=!1,this.sink},t}();
/** @license MIT License (c) copyright 2010-2016 original author or authors */
function Jq(t,e,n){try{n.event(t,e)}catch(e){n.error(t,e)}}function Qq(t,e){try{e.end(t)}catch(n){e.error(t,n)}}
/** @license MIT License (c) copyright 2010-2016 original author or authors */var tX=function(){function t(t){this.value=t}return t.prototype.run=function(t,e){return pj(function(t,e){return new Hj(t,e)}(this.value,t),e)},t}(),eX=function(){function t(t,e){this.f=t,this.source=e}return t.prototype.run=function(t,e){return new nX(this.f,this.source,t,e)},t}(),nX=function(){function t(t,e,n,i){this.f=t,this.sink=new Zq(n),this.scheduler=i,this.disposable=e.run(this,i)}return t.prototype.event=function(t,e){Jq(t,e,this.sink)},t.prototype.end=function(t){Qq(t,this.sink)},t.prototype.error=function(t,e){var n=this.sink.disable();Rj(t,this.disposable,this.sink),this._startNext(t,e,n)},t.prototype._startNext=function(t,e,n){try{this.disposable=this._continue(this.f,t,e,n)}catch(e){n.error(t,e)}},t.prototype._continue=function(t,e,n,i){return oG(i,this.scheduler,lG(e,t(n)))},t.prototype.dispose=function(){return this.disposable.dispose()},t}(),iX=function(){function t(t){this.source=new rX(t)}return t.prototype.run=function(t,e){return this.source.run(t,e)},t}(),rX=function(){function t(t){this.source=t,this.sinks=[],this.disposable=vj()}return t.prototype.run=function(t,e){return 1===this.add(t)&&(this.disposable=this.source.run(this,e)),wj(new sX(this,t))},t.prototype.dispose=function(){var t=this.disposable;return this.disposable=vj(),t.dispose()},t.prototype.add=function(t){return this.sinks=UH(t,this.sinks),this.sinks.length},t.prototype.remove=function(t){var e=HH(t,this.sinks);return e>=0&&(this.sinks=WH(e,this.sinks)),this.sinks.length},t.prototype.event=function(t,e){var n=this.sinks;if(1===n.length)return n[0].event(t,e);for(var i=0;i<n.length;++i)Jq(t,e,n[i])},t.prototype.end=function(t){for(var e=this.sinks,n=0;n<e.length;++n)Qq(t,e[n])},t.prototype.error=function(t,e){for(var n=this.sinks,i=0;i<n.length;++i)n[i].error(t,e)},t}(),sX=function(){function t(t,e){this.source=t,this.sink=e}return t.prototype.dispose=function(){0===this.source.remove(this.sink)&&this.source.dispose()},t}(),oX=qH(lG),aX=XH((function(t,e,n){return Gj(n)?jj():new dG(t,e,n)})),lX=XH((function(t,e,n){return new fG(t,e,n)})),cX=qH((function(t,e){return gG((function(){return e}),eG(t))})),uX=qH(_G),hX=qH((function(t,e){return _G((function(){return t}),e)})),dX=qH((function(t,e){return new EG(t,e)})),pX=qH((
/** @license MIT License (c) copyright 2010-2016 original author or authors */
function(t,e){return AG(GH,t,e)})),fX=qH((function(t,e){return LG(t,1/0,e)})),mX=qH(gG),gX=qH((function(t,e){return LG(t,1,e)})),yX=qH(OG),bX=XH(LG),vX=qH((
/** @license MIT License (c) copyright 2010-2016 original author or authors */
function(t,e){return VG([t,e])})),xX=XH(AG),wX=qH((function(t,e){return KG((function(t){return t}),t,e)})),SX=XH(KG),kX=XH(mq),CX=qH((function(t,e){return mq(gq,t,e)})),TX=XH((
/** @license MIT License (c) copyright 2010 original author or authors */
function(t,e,n){return xq(t,[e,n])})),_X=qH((
/** @license MIT License (c) copyright 2010-2016 original author or authors */
function(t,e){return vG.create(t,e)})),EX=qH(Mq),MX=qH(tq),$X=qH((function(t,e){return eq(t,1/0,e)})),IX=XH(eq),AX=qH((function(t,e){return Gj(e)?jj():new cq(t,e)})),NX=qH((function(t,e){return Gj(e)?jj():new hq(t,e)})),RX=qH((function(t,e){return Gj(e)?jj():new pq(t,e)})),PX=qH(Nq),OX=qH(Rq),LX=qH((function(t,e){return Nq(UG(t),Rq(t,e))})),DX=qH((function(t,e){return t<=0?e:new zq(t,e)})),FX=qH(Uq),zX=qH((function(t,e){return Gj(e)?jj():new Gq(t,e)})),BX=qH((function(t,e){return Gj(e)?jj():new eX(t,e)}));function UX(t,e,n,i){var r,s=arguments.length,o=s<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,n,i);else for(var a=t.length-1;a>=0;a--)(r=t[a])&&(o=(s<3?r(o):s>3?r(e,n,o):r(e,n))||o);return s>3&&o&&Object.defineProperty(e,n,o),o}function VX(t,e,n,i){if("a"===n&&!i)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof e?t!==e||!i:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?i:"a"===n?i.call(t):i?i.value:e.get(t)}function WX(t,e,n,i,r){if("m"===i)throw new TypeError("Private method is not writable");if("a"===i&&!r)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof e?t!==e||!r:!e.has(t))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===i?r.call(t,n):r?r.value=n:e.set(t,n),n}var HX,jX,GX,qX=function(){var t=[];return[function(e){return XX(t,e)},new KX(t)]},XX=function(t,e){return t.forEach((function(t){var n=t.sink;return function(t,e,n){try{n.event(t,e)}catch(e){n.error(t,e)}}(t.scheduler.currentTime(),e,n)}))},KX=function(){function t(t){this.sinks=t}return t.prototype.run=function(t,e){var n={sink:t,scheduler:e};return this.sinks.push(n),new YX(n,this.sinks)},t}(),YX=function(){function t(t,e){this.sink=t,this.sinks=e}return t.prototype.dispose=function(){var t=this.sinks.indexOf(this.sink);t>=0&&this.sinks.splice(t,1)},t}();function ZX(){}function JX(t){}const QX=new JH(bj(),new QH);function tK(t){return t&&"object"==typeof t&&void 0!==t.run&&void 0!==t.id}class eK{constructor(t,e=void 0){this.id=eK.nextId++,this.subscribers=[],this.value=void 0,this.ready=!1,HX.set(this,void 0),jX.set(this,!1),GX.set(this,void 0),WX(this,HX,!!e,"f");const[n,i]=qX(),[r,s]=qX();let o;this.stopStream=n,this.set=t=>{this.value=t,r(t)},tK(t)?(o=t,void 0===e&&WX(this,HX,t.holding,"f"),t.holding&&(this.value=t.value)):!function(t){return t&&"object"==typeof t&&void 0!==t.run}(t)?(o=uX((()=>this.value),eG(t)),this.value=t):o=t,this.stream=function(t){return t instanceof iX||Gj(t)?t:new iX(t)}(dX(this.runListeners.bind(this),PX(i,vX(o,s))))}get(){return this.value}get holding(){return VX(this,HX,"f")}run(t,e){return this.stream.run(t,e)}runListeners(t){this.value=t;for(const e of this.subscribers)e(t)}subscribe(t=JX,e=ZX){VX(this,HX,"f")&&VX(this,jX,"f")&&t(this.value);const n=n=>{e(),t(n)};return this.subscribers.push(n),VX(this,jX,"f")||this.start(),()=>{const t=this.subscribers.indexOf(n);-1!==t&&this.subscribers.splice(t,1)}}async start(){return VX(this,jX,"f")||(eK.numActive++,rG(this.stream,QX).then((()=>{eK.numActive--})),WX(this,jX,!0,"f"),WX(this,GX,new Promise(((t,e)=>{pj({run:()=>{this.ready=!0,t()},error(t){e(t)},dispose(){}},QX)})),"f")),VX(this,GX,"f")}stop(){this.stopStream(void 0),WX(this,jX,!1,"f")}hold(t=!0){return WX(this,HX,t,"f"),this}thru(t){return new eK(t(this))}startWith(t){const e=new eK(cX(t,this));return this.holding&&(e.value=t),e}continueWith(t){const e=new eK(mX(t,this));return this.holding&&(e.value=this.value),e}map(t){const e=new eK(uX(t,this));return this.holding&&(e.value=t(this.value)),e}constant(t){const e=new eK(hX(t,this));return this.holding&&(e.value=t),e}tap(t){const e=new eK(dX(t,this));return this.holding&&(e.value=this.value),e}ap(t){const e=new eK(pX(t,this));return this.holding&&t.holding&&(e.value=t.get()(this.value)),e}scan(t,e){const n=new eK(lX(t,e,this));return this.holding&&(n.value=e),n}loop(t,e){return new eK(aX(t,e,this))}withItems(t){return new eK(CX(t,this))}zipItems(t,e){return new eK(kX(t,e,this))}switchLatest(){return new eK(Gj(t=this)?jj():new Tq(t));var t}join(){return new eK(UG(this))}chain(t){return new eK(fX(t,this))}concatMap(t){return new eK(gX(t,this))}mergeConcurrently(t){return new eK(yX(t,this))}mergeMapConcurrently(t,e){return new eK(bX(t,e,this))}merge(t){const e=new eK(vX(t,this));return this.holding&&(e.value=this.value),e}combine(t,e){const n=new eK(xX(t,e,this));return this.holding&&(n.value=t(e.value,this.value)),n}zip(t,e){const n=new eK(TX(t,e,this));return this.holding&&(n.value=t(e.value,this.value)),n}resample(t){return new eK(wX(this,t))}sample(t){return new eK(wX(t,this))}snapshot(t,e){return new eK(SX(t,e,this))}filter(t){const e=new eK(_X(t,this));return this.holding&&t(this.value)&&(e.value=this.value),e}skipRepeats(){const t=new eK(Mq(Aq,this));return this.holding&&(t.value=this.value),t}skipRepeatsWith(t){return new eK(EX(t,this))}slice(t,e){return new eK(IX(t,e,this))}take(t){return new eK(MX(t,this))}skip(t){return new eK($X(t,this))}takeWhile(t){return new eK(AX(t,this))}skipWhile(t){return new eK(NX(t,this))}skipAfter(t){return new eK(RX(t,this))}until(t){return new eK(PX(t,this))}since(t){return new eK(OX(t,this))}during(t){return new eK(LX(t,this))}delay(t){return new eK(DX(t,this))}withLocalTime(t){return new eK(oX(t,this))}throttle(t){return new eK(FX(t,this))}debounce(t){return new eK(zX(t,this))}awaitPromises(){return new eK(Gj(t=this)?jj():new Kq(t));var t}recoverWith(t){return new eK(BX(t,this))}static empty(){return new eK(jj())}static never(){return new eK(Yj())}static now(t){return new eK(eG(t))}static at(t,e){return new eK(Jj(t,e))}static periodic(t){return new eK(function(t){return new nG(t)}(t))}static throwError(t){return new eK(function(t){return new tX(t)}(t))}}function nK(t,e=!1){return new eK(t,e)}var iK;HX=new WeakMap,jX=new WeakMap,GX=new WeakMap,eK.nextId=0,eK.numActive=0,function(t){t[t.Debug=0]="Debug",t[t.Info=1]="Info",t[t.Warning=2]="Warning",t[t.Error=3]="Error"}(iK||(iK={}));const rK=new eK(Yj()),sK={log(...t){console.log(...t),rK.set([iK.Info,t.filter((t=>void 0!==t)).map((t=>t.toString())).join(" ")])},debug(...t){rK.set([iK.Debug,t.filter((t=>void 0!==t)).map((t=>t.toString())).join(" ")])},info(...t){this.log(...t)},warning(...t){rK.set([iK.Warning,t.filter((t=>void 0!==t)).map((t=>t.toString())).join(" ")])},error(...t){console.error(...t),rK.set([iK.Error,t.filter((t=>void 0!==t)).map((t=>t.toString())).join(" ")])}};function oK(){return rK}function aK(t,e,n){const i=n.value;return n.value=function(...t){try{return i.apply(this,t)}catch(t){return sK.error(t),BH({title:t.name,message:t.message,type:"danger"}),t}},n}class lK extends Error{constructor(t){super(t),this.name="Training Error"}}function cK(t,{duration:e=3e3}={}){sK.error(`${t.name}: ${t.message}`,t),BH({title:t.name,message:t.message,type:"danger",duration:e})}function uK(t,e){return async function*(){let n=0;for await(const i of t())e(i,n++)&&(yield await i)}}function hK(t,e){return async function*(){let n=0;for await(const i of t())yield await e(i,n++)}}function dK(t,e){return async function*(){yield*await t(),yield*await e}}class pK{constructor(t){this.source=t}[Symbol.asyncIterator](){return this.source()[Symbol.asyncIterator]()}entries(){return new pK(hK(this.source,((t,e)=>[e,t])))}keys(){return new pK(hK(this.source,((t,e)=>e)))}values(){return new pK(this.source)}forEach(t){return async function(t,e){let n=0;for await(const i of t())e(i,n++)}(this.source,t)}concat(t){return"function"==typeof t[Symbol.iterator]?new pK(dK(this.source,async function*(t){yield*t}(t))):function(t){return"function"==typeof t[Symbol.asyncIterator]}(t)?new pK(dK(this.source,t)):new pK(dK(this.source,async function*(t){yield t}(t)))}reduce(t,e){return async function(t,e,n){let[i,r]=[-1,n];for await(const s of t())r=0==++i&&void 0===n?s:e(r,s,i);if(void 0===n&&-1===i)throw new Error("Sequence contains no elements.");return r}(this.source,t,e)}filter(t){return new pK(uK(this.source,t))}take(t){return new pK(function(t,e){if(e<0)throw Error("Negative count is not supported, use await and sync iterator instead.");return async function*(){let n=e;for await(const e of t()){if(0==n--)return;yield await e}}}(this.source,t))}skip(t){return new pK(function(t,e){if(e<0)throw Error("Negative count is not supported, use await and sync iterator instead.");return async function*(){yield*uK(t,((t,n)=>n>=e))()}}(this.source,t))}map(t){return new pK(hK(this.source,t))}zip(t){return new pK((e=this.source,n=t,async function*(){const t=n()[Symbol.asyncIterator]();for await(const n of e()){const e=await t.next();if(e.done)return;yield[n,e.value]}}));var e,n}toArray(){return async function(t){const e=[];for await(const n of t())e.push(n);return e}(this.source)}}class fK extends pK{constructor(t){super((async function*(){for(const e of t)yield e}))}}function mK(t){return new fK(t)}function gK(t){return t&&"object"==typeof t&&!Array.isArray(t)}function yK(t,...e){if(!e.length)return t;const n=e.shift(),i={...t};if(gK(t)&&gK(n))for(const t in n)gK(n[t])?(i[t]||Object.assign(i,{[t]:{}}),i[t]=yK(i[t],n[t])):Object.assign(i,{[t]:n[t]});return yK(i,...e)}window&&(window.onerror=t=>{"string"==typeof t&&BH({title:"An error occurred",message:t,type:"danger"})},window.addEventListener("unhandledrejection",(t=>{BH({title:"An error occurred",message:t.reason,type:"danger"})})));function bK(t,{include:e,exclude:n}={}){const i=t=>{const i=e=>"string"==typeof e?t===e:e.test(t);return e?e.some(i):!n||!n.some(i)};for(const[e,n]of(t=>{const e=new Set;do{for(const n of Reflect.ownKeys(t))e.add([t,n])}while((t=Reflect.getPrototypeOf(t))&&t!==Object.prototype);return e})(t.constructor.prototype)){if("constructor"===n||!i(n))continue;const r=Reflect.getOwnPropertyDescriptor(e,n);r&&"function"==typeof r.value&&(t[n]=t[n].bind(t))}return t}let vK=0,xK=class{constructor(){this.id=`component-${String(vK++).padStart(3,"0")}`,this.$$={streams:[],app:void 0},bK(this)}destroy(){var t;null===(t=this.$$.app)||void 0===t||t.$destroy(),this.$$.app=void 0}start(){this.$$.streams=Object.entries(this).filter((([t,e])=>"$"===t[0]&&tK(e))).map((([,t])=>(t.start(),t)))}stop(){for(const t of this.$$.streams)t.stop()}dispose(){this.destroy(),this.stop()}};var wK={exports:{}},SK=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,kK=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],CK=function(t){var e=t,n=t.indexOf("["),i=t.indexOf("]");-1!=n&&-1!=i&&(t=t.substring(0,n)+t.substring(n,i).replace(/:/g,";")+t.substring(i,t.length));for(var r=SK.exec(t||""),s={},o=14;o--;)s[kK[o]]=r[o]||"";return-1!=n&&-1!=i&&(s.source=e,s.host=s.host.substring(1,s.host.length-1).replace(/;/g,":"),s.authority=s.authority.replace("[","").replace("]","").replace(/;/g,":"),s.ipv6uri=!0),s.pathNames=function(t,e){var n=/\/{2,9}/g,i=e.replace(n,"/").split("/");"/"!=e.substr(0,1)&&0!==e.length||i.splice(0,1);"/"==e.substr(e.length-1,1)&&i.splice(i.length-1,1);return i}(0,s.path),s.queryKey=function(t,e){var n={};return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g,(function(t,e,i){e&&(n[e]=i)})),n}(0,s.query),s};var TK={exports:{}},_K={exports:{}},EK=1e3,MK=6e4,$K=60*MK,IK=24*$K,AK=365.25*IK,NK=function(t,e){e=e||{};var n=typeof t;if("string"===n&&t.length>0)return function(t){if((t=String(t)).length>100)return;var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t);if(!e)return;var n=parseFloat(e[1]);switch((e[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return n*AK;case"days":case"day":case"d":return n*IK;case"hours":case"hour":case"hrs":case"hr":case"h":return n*$K;case"minutes":case"minute":case"mins":case"min":case"m":return n*MK;case"seconds":case"second":case"secs":case"sec":case"s":return n*EK;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return n;default:return}}(t);if("number"===n&&!1===isNaN(t))return e.long?function(t){return RK(t,IK,"day")||RK(t,$K,"hour")||RK(t,MK,"minute")||RK(t,EK,"second")||t+" ms"}(t):function(t){if(t>=IK)return Math.round(t/IK)+"d";if(t>=$K)return Math.round(t/$K)+"h";if(t>=MK)return Math.round(t/MK)+"m";if(t>=EK)return Math.round(t/EK)+"s";return t+"ms"}(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))};function RK(t,e,n){if(!(t<e))return t<1.5*e?Math.floor(t/e)+" "+n:Math.ceil(t/e)+" "+n+"s"}!function(t,e){function n(t){var n;function r(){if(r.enabled){var t=r,i=+new Date,s=i-(n||i);t.diff=s,t.prev=n,t.curr=i,n=i;for(var o=new Array(arguments.length),a=0;a<o.length;a++)o[a]=arguments[a];o[0]=e.coerce(o[0]),"string"!=typeof o[0]&&o.unshift("%O");var l=0;o[0]=o[0].replace(/%([a-zA-Z%])/g,(function(n,i){if("%%"===n)return n;l++;var r=e.formatters[i];if("function"==typeof r){var s=o[l];n=r.call(t,s),o.splice(l,1),l--}return n})),e.formatArgs.call(t,o),(r.log||e.log||console.log.bind(console)).apply(t,o)}}return r.namespace=t,r.enabled=e.enabled(t),r.useColors=e.useColors(),r.color=function(t){var n,i=0;for(n in t)i=(i<<5)-i+t.charCodeAt(n),i|=0;return e.colors[Math.abs(i)%e.colors.length]}(t),r.destroy=i,"function"==typeof e.init&&e.init(r),e.instances.push(r),r}function i(){var t=e.instances.indexOf(this);return-1!==t&&(e.instances.splice(t,1),!0)}(e=_K.exports=n.debug=n.default=n).coerce=function(t){return t instanceof Error?t.stack||t.message:t},e.disable=function(){e.enable("")},e.enable=function(t){var n;e.save(t),e.names=[],e.skips=[];var i=("string"==typeof t?t:"").split(/[\s,]+/),r=i.length;for(n=0;n<r;n++)i[n]&&("-"===(t=i[n].replace(/\*/g,".*?"))[0]?e.skips.push(new RegExp("^"+t.substr(1)+"$")):e.names.push(new RegExp("^"+t+"$")));for(n=0;n<e.instances.length;n++){var s=e.instances[n];s.enabled=e.enabled(s.namespace)}},e.enabled=function(t){if("*"===t[t.length-1])return!0;var n,i;for(n=0,i=e.skips.length;n<i;n++)if(e.skips[n].test(t))return!1;for(n=0,i=e.names.length;n<i;n++)if(e.names[n].test(t))return!0;return!1},e.humanize=NK,e.instances=[],e.names=[],e.skips=[],e.formatters={}}(0,_K.exports);var PK=_K.exports;!function(t,e){function n(){var t;try{t=e.storage.debug}catch(t){}return!t&&"undefined"!=typeof process&&"env"in process&&(t=process.env.DEBUG),t}(e=TK.exports=PK).log=function(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)},e.formatArgs=function(t){var n=this.useColors;if(t[0]=(n?"%c":"")+this.namespace+(n?" %c":" ")+t[0]+(n?"%c ":" ")+"+"+e.humanize(this.diff),!n)return;var i="color: "+this.color;t.splice(1,0,i,"color: inherit");var r=0,s=0;t[0].replace(/%[a-zA-Z%]/g,(function(t){"%%"!==t&&(r++,"%c"===t&&(s=r))})),t.splice(s,0,i)},e.save=function(t){try{null==t?e.storage.removeItem("debug"):e.storage.debug=t}catch(t){}},e.load=n,e.useColors=function(){if("undefined"!=typeof window&&window.process&&"renderer"===window.process.type)return!0;if("undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},e.storage="undefined"!=typeof chrome&&void 0!==chrome.storage?chrome.storage.local:function(){try{return window.localStorage}catch(t){}}(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],e.formatters.j=function(t){try{return JSON.stringify(t)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}},e.enable(n())}(0,TK.exports);var OK=TK.exports,LK=CK,DK=OK("socket.io-client:url"),FK=function(t,e){var n=t;e=e||"undefined"!=typeof location&&location,null==t&&(t=e.protocol+"//"+e.host);"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?e.protocol+t:e.host+t),/^(https?|wss?):\/\//.test(t)||(DK("protocol-less url %s",t),t=void 0!==e?e.protocol+"//"+t:"https://"+t),DK("parse %s",t),n=LK(t));n.port||(/^(http|ws)$/.test(n.protocol)?n.port="80":/^(http|ws)s$/.test(n.protocol)&&(n.port="443"));n.path=n.path||"/";var i=-1!==n.host.indexOf(":")?"["+n.host+"]":n.host;return n.id=n.protocol+"://"+i+":"+n.port,n.href=n.protocol+"://"+i+(e&&e.port===n.port?"":":"+n.port),n};var zK={},BK={exports:{}};!function(t){function e(t){if(t)return function(t){for(var n in e.prototype)t[n]=e.prototype[n];return t}(t)}BK.exports=e,e.prototype.on=e.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},e.prototype.once=function(t,e){function n(){this.off(t,n),e.apply(this,arguments)}return n.fn=e,this.on(t,n),this},e.prototype.off=e.prototype.removeListener=e.prototype.removeAllListeners=e.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n,i=this._callbacks["$"+t];if(!i)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var r=0;r<i.length;r++)if((n=i[r])===e||n.fn===e){i.splice(r,1);break}return 0===i.length&&delete this._callbacks["$"+t],this},e.prototype.emit=function(t){this._callbacks=this._callbacks||{};for(var e=new Array(arguments.length-1),n=this._callbacks["$"+t],i=1;i<arguments.length;i++)e[i-1]=arguments[i];if(n){i=0;for(var r=(n=n.slice(0)).length;i<r;++i)n[i].apply(this,e)}return this},e.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},e.prototype.hasListeners=function(t){return!!this.listeners(t).length}}();var UK=BK.exports,VK={},WK={}.toString,HK=Array.isArray||function(t){return"[object Array]"==WK.call(t)},jK=function(t){return GK&&Buffer.isBuffer(t)||qK&&(t instanceof ArrayBuffer||XK(t))},GK="function"==typeof Buffer&&"function"==typeof Buffer.isBuffer,qK="function"==typeof ArrayBuffer,XK=function(t){return"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(t):t.buffer instanceof ArrayBuffer};var KK=HK,YK=jK,ZK=Object.prototype.toString,JK="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===ZK.call(Blob),QK="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===ZK.call(File);function tY(t,e){if(!t)return t;if(YK(t)){var n={_placeholder:!0,num:e.length};return e.push(t),n}if(KK(t)){for(var i=new Array(t.length),r=0;r<t.length;r++)i[r]=tY(t[r],e);return i}if("object"==typeof t&&!(t instanceof Date)){i={};for(var s in t)i[s]=tY(t[s],e);return i}return t}function eY(t,e){if(!t)return t;if(t&&t._placeholder)return e[t.num];if(KK(t))for(var n=0;n<t.length;n++)t[n]=eY(t[n],e);else if("object"==typeof t)for(var i in t)t[i]=eY(t[i],e);return t}VK.deconstructPacket=function(t){var e=[],n=t.data,i=t;return i.data=tY(n,e),i.attachments=e.length,{packet:i,buffers:e}},VK.reconstructPacket=function(t,e){return t.data=eY(t.data,e),t.attachments=void 0,t},VK.removeBlobs=function(t,e){var n=0,i=t;!function t(r,s,o){if(!r)return r;if(JK&&r instanceof Blob||QK&&r instanceof File){n++;var a=new FileReader;a.onload=function(){o?o[s]=this.result:i=this.result,--n||e(i)},a.readAsArrayBuffer(r)}else if(KK(r))for(var l=0;l<r.length;l++)t(r[l],l,r);else if("object"==typeof r&&!YK(r))for(var c in r)t(r[c],c,r)}(i),n||e(i)},function(t){var e=OK("socket.io-parser"),n=UK,i=VK,r=HK,s=jK;function o(){}t.protocol=4,t.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],t.CONNECT=0,t.DISCONNECT=1,t.EVENT=2,t.ACK=3,t.ERROR=4,t.BINARY_EVENT=5,t.BINARY_ACK=6,t.Encoder=o,t.Decoder=c;var a=t.ERROR+'"encode error"';function l(n){var i=""+n.type;if(t.BINARY_EVENT!==n.type&&t.BINARY_ACK!==n.type||(i+=n.attachments+"-"),n.nsp&&"/"!==n.nsp&&(i+=n.nsp+","),null!=n.id&&(i+=n.id),null!=n.data){var r=function(t){try{return JSON.stringify(t)}catch(t){return!1}}(n.data);if(!1===r)return a;i+=r}return e("encoded %j as %s",n,i),i}function c(){this.reconstructor=null}function u(t){this.reconPack=t,this.buffers=[]}function h(e){return{type:t.ERROR,data:"parser error: "+e}}o.prototype.encode=function(n,r){(e("encoding packet %j",n),t.BINARY_EVENT===n.type||t.BINARY_ACK===n.type)?function(t,e){function n(t){var n=i.deconstructPacket(t),r=l(n.packet),s=n.buffers;s.unshift(r),e(s)}i.removeBlobs(t,n)}(n,r):r([l(n)])},n(c.prototype),c.prototype.add=function(n){var i;if("string"==typeof n)i=function(n){var i=0,s={type:Number(n.charAt(0))};if(null==t.types[s.type])return h("unknown packet type "+s.type);if(t.BINARY_EVENT===s.type||t.BINARY_ACK===s.type){for(var o=i+1;"-"!==n.charAt(++i)&&i!=n.length;);var a=n.substring(o,i);if(a!=Number(a)||"-"!==n.charAt(i))throw new Error("Illegal attachments");s.attachments=Number(a)}if("/"===n.charAt(i+1)){for(o=i+1;++i;){if(","===(c=n.charAt(i)))break;if(i===n.length)break}s.nsp=n.substring(o,i)}else s.nsp="/";var l=n.charAt(i+1);if(""!==l&&Number(l)==l){for(o=i+1;++i;){var c;if(null==(c=n.charAt(i))||Number(c)!=c){--i;break}if(i===n.length)break}s.id=Number(n.substring(o,i+1))}if(n.charAt(++i)){var u=function(t){try{return JSON.parse(t)}catch(t){return!1}}(n.substr(i));if(!(!1!==u&&(s.type===t.ERROR||r(u))))return h("invalid payload");s.data=u}return e("decoded %s as %j",n,s),s}(n),t.BINARY_EVENT===i.type||t.BINARY_ACK===i.type?(this.reconstructor=new u(i),0===this.reconstructor.reconPack.attachments&&this.emit("decoded",i)):this.emit("decoded",i);else{if(!s(n)&&!n.base64)throw new Error("Unknown type: "+n);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");(i=this.reconstructor.takeBinaryData(n))&&(this.reconstructor=null,this.emit("decoded",i))}},c.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()},u.prototype.takeBinaryData=function(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){var e=i.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null},u.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]}}(zK);var nY={exports:{}},iY={},rY={exports:{}};try{rY.exports="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(t){rY.exports=!1}var sY,oY,aY=rY.exports,lY="undefined"!=typeof self?self:"undefined"!=typeof window?window:Function("return this")(),cY=aY,uY=lY,hY=function(t){var e=t.xdomain,n=t.xscheme,i=t.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!e||cY))return new XMLHttpRequest}catch(t){}try{if("undefined"!=typeof XDomainRequest&&!n&&i)return new XDomainRequest}catch(t){}if(!e)try{return new(uY[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(t){}},dY={exports:{}},pY={},fY=Object.keys||function(t){var e=[],n=Object.prototype.hasOwnProperty;for(var i in t)n.call(t,i)&&e.push(i);return e};function mY(){if(oY)return sY;oY=1;var t=HK,e=Object.prototype.toString,n="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===e.call(Blob),i="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===e.call(File);return sY=function e(r){if(!r||"object"!=typeof r)return!1;if(t(r)){for(var s=0,o=r.length;s<o;s++)if(e(r[s]))return!0;return!1}if("function"==typeof Buffer&&Buffer.isBuffer&&Buffer.isBuffer(r)||"function"==typeof ArrayBuffer&&r instanceof ArrayBuffer||n&&r instanceof Blob||i&&r instanceof File)return!0;if(r.toJSON&&"function"==typeof r.toJSON&&1===arguments.length)return e(r.toJSON(),!0);for(var a in r)if(Object.prototype.hasOwnProperty.call(r,a)&&e(r[a]))return!0;return!1},sY}var gY=function(t,e,n){var i=t.byteLength;if(e=e||0,n=n||i,t.slice)return t.slice(e,n);if(e<0&&(e+=i),n<0&&(n+=i),n>i&&(n=i),e>=i||e>=n||0===i)return new ArrayBuffer(0);for(var r=new Uint8Array(t),s=new Uint8Array(n-e),o=e,a=0;o<n;o++,a++)s[a]=r[o];return s.buffer},yY=function(t,e,n){var i=!1;return n=n||bY,r.count=t,0===t?e():r;function r(t,s){if(r.count<=0)throw new Error("after called too many times");--r.count,t?(i=!0,e(t),e=n):0!==r.count||i||e(null,s)}};function bY(){}
/*! https://mths.be/utf8js v2.1.2 by @mathias */var vY,xY,wY,SY=String.fromCharCode;function kY(t){for(var e,n,i=[],r=0,s=t.length;r<s;)(e=t.charCodeAt(r++))>=55296&&e<=56319&&r<s?56320==(64512&(n=t.charCodeAt(r++)))?i.push(((1023&e)<<10)+(1023&n)+65536):(i.push(e),r--):i.push(e);return i}function CY(t,e){if(t>=55296&&t<=57343){if(e)throw Error("Lone surrogate U+"+t.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function TY(t,e){return SY(t>>e&63|128)}function _Y(t,e){if(0==(4294967168&t))return SY(t);var n="";return 0==(4294965248&t)?n=SY(t>>6&31|192):0==(4294901760&t)?(CY(t,e)||(t=65533),n=SY(t>>12&15|224),n+=TY(t,6)):0==(4292870144&t)&&(n=SY(t>>18&7|240),n+=TY(t,12),n+=TY(t,6)),n+=SY(63&t|128)}function EY(){if(wY>=xY)throw Error("Invalid byte index");var t=255&vY[wY];if(wY++,128==(192&t))return 63&t;throw Error("Invalid continuation byte")}function MY(t){var e,n;if(wY>xY)throw Error("Invalid byte index");if(wY==xY)return!1;if(e=255&vY[wY],wY++,0==(128&e))return e;if(192==(224&e)){if((n=(31&e)<<6|EY())>=128)return n;throw Error("Invalid continuation byte")}if(224==(240&e)){if((n=(15&e)<<12|EY()<<6|EY())>=2048)return CY(n,t)?n:65533;throw Error("Invalid continuation byte")}if(240==(248&e)&&(n=(7&e)<<18|EY()<<12|EY()<<6|EY())>=65536&&n<=1114111)return n;throw Error("Invalid UTF-8 detected")}var $Y,IY,AY,NY,RY,PY={version:"2.1.2",encode:function(t,e){for(var n=!1!==(e=e||{}).strict,i=kY(t),r=i.length,s=-1,o="";++s<r;)o+=_Y(i[s],n);return o},decode:function(t,e){var n=!1!==(e=e||{}).strict;vY=kY(t),xY=vY.length,wY=0;for(var i,r=[];!1!==(i=MY(n));)r.push(i);return function(t){for(var e,n=t.length,i=-1,r="";++i<n;)(e=t[i])>65535&&(r+=SY((e-=65536)>>>10&1023|55296),e=56320|1023&e),r+=SY(e);return r}(r)}},OY={};function LY(){if(AY)return IY;AY=1;var t=void 0!==t?t:"undefined"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder&&MozBlobBuilder,e=function(){try{return 2===new Blob(["hi"]).size}catch(t){return!1}}(),n=e&&function(){try{return 2===new Blob([new Uint8Array([1,2])]).size}catch(t){return!1}}(),i=t&&t.prototype.append&&t.prototype.getBlob;function r(t){return t.map((function(t){if(t.buffer instanceof ArrayBuffer){var e=t.buffer;if(t.byteLength!==e.byteLength){var n=new Uint8Array(t.byteLength);n.set(new Uint8Array(e,t.byteOffset,t.byteLength)),e=n.buffer}return e}return t}))}function s(e,n){n=n||{};var i=new t;return r(e).forEach((function(t){i.append(t)})),n.type?i.getBlob(n.type):i.getBlob()}function o(t,e){return new Blob(r(t),e||{})}return"undefined"!=typeof Blob&&(s.prototype=Blob.prototype,o.prototype=Blob.prototype),IY=e?n?Blob:o:i?s:void 0}function DY(){if(RY)return NY;RY=1;var t=pY;function e(t){this.path=t.path,this.hostname=t.hostname,this.port=t.port,this.secure=t.secure,this.query=t.query,this.timestampParam=t.timestampParam,this.timestampRequests=t.timestampRequests,this.readyState="",this.agent=t.agent||!1,this.socket=t.socket,this.enablesXDR=t.enablesXDR,this.withCredentials=t.withCredentials,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.forceNode=t.forceNode,this.isReactNative=t.isReactNative,this.extraHeaders=t.extraHeaders,this.localAddress=t.localAddress}return NY=e,UK(e.prototype),e.prototype.onError=function(t,e){var n=new Error(t);return n.type="TransportError",n.description=e,this.emit("error",n),this},e.prototype.open=function(){return"closed"!==this.readyState&&""!==this.readyState||(this.readyState="opening",this.doOpen()),this},e.prototype.close=function(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this},e.prototype.send=function(t){if("open"!==this.readyState)throw new Error("Transport not open");this.write(t)},e.prototype.onOpen=function(){this.readyState="open",this.writable=!0,this.emit("open")},e.prototype.onData=function(e){var n=t.decodePacket(e,this.socket.binaryType);this.onPacket(n)},e.prototype.onPacket=function(t){this.emit("packet",t)},e.prototype.onClose=function(){this.readyState="closed",this.emit("close")},NY}!function(t){var e,n,i=fY,r=mY(),s=gY,o=yY,a=PY;"undefined"!=typeof ArrayBuffer&&($Y||($Y=1,n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",OY.encode=function(t){var e,i=new Uint8Array(t),r=i.length,s="";for(e=0;e<r;e+=3)s+=n[i[e]>>2],s+=n[(3&i[e])<<4|i[e+1]>>4],s+=n[(15&i[e+1])<<2|i[e+2]>>6],s+=n[63&i[e+2]];return r%3==2?s=s.substring(0,s.length-1)+"=":r%3==1&&(s=s.substring(0,s.length-2)+"=="),s},OY.decode=function(t){var e,i,r,s,o,a=.75*t.length,l=t.length,c=0;"="===t[t.length-1]&&(a--,"="===t[t.length-2]&&a--);var u=new ArrayBuffer(a),h=new Uint8Array(u);for(e=0;e<l;e+=4)i=n.indexOf(t[e]),r=n.indexOf(t[e+1]),s=n.indexOf(t[e+2]),o=n.indexOf(t[e+3]),h[c++]=i<<2|r>>4,h[c++]=(15&r)<<4|s>>2,h[c++]=(3&s)<<6|63&o;return u}),e=OY);var l="undefined"!=typeof navigator&&/Android/i.test(navigator.userAgent),c="undefined"!=typeof navigator&&/PhantomJS/i.test(navigator.userAgent),u=l||c;t.protocol=3;var h=t.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},d=i(h),p={type:"error",data:"parser error"},f=LY();function m(t,e,n){for(var i=new Array(t.length),r=o(t.length,n),s=function(t,n,r){e(n,(function(e,n){i[t]=n,r(e,i)}))},a=0;a<t.length;a++)s(a,t[a],r)}t.encodePacket=function(e,n,i,r){"function"==typeof n&&(r=n,n=!1),"function"==typeof i&&(r=i,i=null);var s=void 0===e.data?void 0:e.data.buffer||e.data;if("undefined"!=typeof ArrayBuffer&&s instanceof ArrayBuffer)return function(e,n,i){if(!n)return t.encodeBase64Packet(e,i);var r=e.data,s=new Uint8Array(r),o=new Uint8Array(1+r.byteLength);o[0]=h[e.type];for(var a=0;a<s.length;a++)o[a+1]=s[a];return i(o.buffer)}(e,n,r);if(void 0!==f&&s instanceof f)return function(e,n,i){if(!n)return t.encodeBase64Packet(e,i);if(u)return function(e,n,i){if(!n)return t.encodeBase64Packet(e,i);var r=new FileReader;return r.onload=function(){t.encodePacket({type:e.type,data:r.result},n,!0,i)},r.readAsArrayBuffer(e.data)}(e,n,i);var r=new Uint8Array(1);r[0]=h[e.type];var s=new f([r.buffer,e.data]);return i(s)}(e,n,r);if(s&&s.base64)return function(e,n){var i="b"+t.packets[e.type]+e.data.data;return n(i)}(e,r);var o=h[e.type];return void 0!==e.data&&(o+=i?a.encode(String(e.data),{strict:!1}):String(e.data)),r(""+o)},t.encodeBase64Packet=function(e,n){var i,r="b"+t.packets[e.type];if(void 0!==f&&e.data instanceof f){var s=new FileReader;return s.onload=function(){var t=s.result.split(",")[1];n(r+t)},s.readAsDataURL(e.data)}try{i=String.fromCharCode.apply(null,new Uint8Array(e.data))}catch(t){for(var o=new Uint8Array(e.data),a=new Array(o.length),l=0;l<o.length;l++)a[l]=o[l];i=String.fromCharCode.apply(null,a)}return r+=btoa(i),n(r)},t.decodePacket=function(e,n,i){if(void 0===e)return p;if("string"==typeof e){if("b"===e.charAt(0))return t.decodeBase64Packet(e.substr(1),n);if(i&&!1===(e=function(t){try{t=a.decode(t,{strict:!1})}catch(t){return!1}return t}(e)))return p;var r=e.charAt(0);return Number(r)==r&&d[r]?e.length>1?{type:d[r],data:e.substring(1)}:{type:d[r]}:p}r=new Uint8Array(e)[0];var o=s(e,1);return f&&"blob"===n&&(o=new f([o])),{type:d[r],data:o}},t.decodeBase64Packet=function(t,n){var i=d[t.charAt(0)];if(!e)return{type:i,data:{base64:!0,data:t.substr(1)}};var r=e.decode(t.substr(1));return"blob"===n&&f&&(r=new f([r])),{type:i,data:r}},t.encodePayload=function(e,n,i){"function"==typeof n&&(i=n,n=null);var s=r(e);if(n&&s)return f&&!u?t.encodePayloadAsBlob(e,i):t.encodePayloadAsArrayBuffer(e,i);if(!e.length)return i("0:");m(e,(function(e,i){t.encodePacket(e,!!s&&n,!1,(function(t){i(null,function(t){return t.length+":"+t}(t))}))}),(function(t,e){return i(e.join(""))}))},t.decodePayload=function(e,n,i){if("string"!=typeof e)return t.decodePayloadAsBinary(e,n,i);var r;if("function"==typeof n&&(i=n,n=null),""===e)return i(p,0,1);for(var s,o,a="",l=0,c=e.length;l<c;l++){var u=e.charAt(l);if(":"===u){if(""===a||a!=(s=Number(a)))return i(p,0,1);if(a!=(o=e.substr(l+1,s)).length)return i(p,0,1);if(o.length){if(r=t.decodePacket(o,n,!1),p.type===r.type&&p.data===r.data)return i(p,0,1);if(!1===i(r,l+s,c))return}l+=s,a=""}else a+=u}return""!==a?i(p,0,1):void 0},t.encodePayloadAsArrayBuffer=function(e,n){if(!e.length)return n(new ArrayBuffer(0));m(e,(function(e,n){t.encodePacket(e,!0,!0,(function(t){return n(null,t)}))}),(function(t,e){var i=e.reduce((function(t,e){var n;return t+(n="string"==typeof e?e.length:e.byteLength).toString().length+n+2}),0),r=new Uint8Array(i),s=0;return e.forEach((function(t){var e="string"==typeof t,n=t;if(e){for(var i=new Uint8Array(t.length),o=0;o<t.length;o++)i[o]=t.charCodeAt(o);n=i.buffer}r[s++]=e?0:1;var a=n.byteLength.toString();for(o=0;o<a.length;o++)r[s++]=parseInt(a[o]);r[s++]=255;for(i=new Uint8Array(n),o=0;o<i.length;o++)r[s++]=i[o]})),n(r.buffer)}))},t.encodePayloadAsBlob=function(e,n){m(e,(function(e,n){t.encodePacket(e,!0,!0,(function(t){var e=new Uint8Array(1);if(e[0]=1,"string"==typeof t){for(var i=new Uint8Array(t.length),r=0;r<t.length;r++)i[r]=t.charCodeAt(r);t=i.buffer,e[0]=0}var s=(t instanceof ArrayBuffer?t.byteLength:t.size).toString(),o=new Uint8Array(s.length+1);for(r=0;r<s.length;r++)o[r]=parseInt(s[r]);if(o[s.length]=255,f){var a=new f([e.buffer,o.buffer,t]);n(null,a)}}))}),(function(t,e){return n(new f(e))}))},t.decodePayloadAsBinary=function(e,n,i){"function"==typeof n&&(i=n,n=null);for(var r=e,o=[];r.byteLength>0;){for(var a=new Uint8Array(r),l=0===a[0],c="",u=1;255!==a[u];u++){if(c.length>310)return i(p,0,1);c+=a[u]}r=s(r,2+c.length),c=parseInt(c);var h=s(r,0,c);if(l)try{h=String.fromCharCode.apply(null,new Uint8Array(h))}catch(t){var d=new Uint8Array(h);h="";for(u=0;u<d.length;u++)h+=String.fromCharCode(d[u])}o.push(h),r=s(r,c)}var f=o.length;o.forEach((function(e,r){i(t.decodePacket(e,n,!0),r,f)}))}}(pY);var FY,zY={};function BY(){return FY||(FY=1,zY.encode=function(t){var e="";for(var n in t)t.hasOwnProperty(n)&&(e.length&&(e+="&"),e+=encodeURIComponent(n)+"="+encodeURIComponent(t[n]));return e},zY.decode=function(t){for(var e={},n=t.split("&"),i=0,r=n.length;i<r;i++){var s=n[i].split("=");e[decodeURIComponent(s[0])]=decodeURIComponent(s[1])}return e}),zY}var UY,VY=function(t,e){var n=function(){};n.prototype=e.prototype,t.prototype=new n,t.prototype.constructor=t},WY="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),HY=64,jY={},GY=0,qY=0;function XY(t){var e="";do{e=WY[t%HY]+e,t=Math.floor(t/HY)}while(t>0);return e}function KY(){var t=XY(+new Date);return t!==UY?(GY=0,UY=t):t+"."+XY(GY++)}for(;qY<HY;qY++)jY[WY[qY]]=qY;KY.encode=XY,KY.decode=function(t){var e=0;for(qY=0;qY<t.length;qY++)e=e*HY+jY[t.charAt(qY)];return e};var YY=KY,ZY=DY(),JY=BY(),QY=pY,tZ=VY,eZ=YY,nZ=OK("engine.io-client:polling"),iZ=sZ,rZ=null!=new hY({xdomain:!1}).responseType;function sZ(t){var e=t&&t.forceBase64;rZ&&!e||(this.supportsBinary=!1),ZY.call(this,t)}tZ(sZ,ZY),sZ.prototype.name="polling",sZ.prototype.doOpen=function(){this.poll()},sZ.prototype.pause=function(t){var e=this;function n(){nZ("paused"),e.readyState="paused",t()}if(this.readyState="pausing",this.polling||!this.writable){var i=0;this.polling&&(nZ("we are currently polling - waiting to pause"),i++,this.once("pollComplete",(function(){nZ("pre-pause polling complete"),--i||n()}))),this.writable||(nZ("we are currently writing - waiting to pause"),i++,this.once("drain",(function(){nZ("pre-pause writing complete"),--i||n()})))}else n()},sZ.prototype.poll=function(){nZ("polling"),this.polling=!0,this.doPoll(),this.emit("poll")},sZ.prototype.onData=function(t){var e=this;nZ("polling got data %s",t);QY.decodePayload(t,this.socket.binaryType,(function(t,n,i){if("opening"===e.readyState&&"open"===t.type&&e.onOpen(),"close"===t.type)return e.onClose(),!1;e.onPacket(t)})),"closed"!==this.readyState&&(this.polling=!1,this.emit("pollComplete"),"open"===this.readyState?this.poll():nZ('ignoring poll - transport state "%s"',this.readyState))},sZ.prototype.doClose=function(){var t=this;function e(){nZ("writing close packet"),t.write([{type:"close"}])}"open"===this.readyState?(nZ("transport open - closing"),e()):(nZ("transport not open - deferring close"),this.once("open",e))},sZ.prototype.write=function(t){var e=this;this.writable=!1;var n=function(){e.writable=!0,e.emit("drain")};QY.encodePayload(t,this.supportsBinary,(function(t){e.doWrite(t,n)}))},sZ.prototype.uri=function(){var t=this.query||{},e=this.secure?"https":"http",n="";return!1!==this.timestampRequests&&(t[this.timestampParam]=eZ()),this.supportsBinary||t.sid||(t.b64=1),t=JY.encode(t),this.port&&("https"===e&&443!==Number(this.port)||"http"===e&&80!==Number(this.port))&&(n=":"+this.port),t.length&&(t="?"+t),e+"://"+(-1!==this.hostname.indexOf(":")?"["+this.hostname+"]":this.hostname)+n+this.path+t};var oZ=hY,aZ=iZ,lZ=UK,cZ=VY,uZ=OK("engine.io-client:polling-xhr"),hZ=lY;function dZ(){}function pZ(t){if(aZ.call(this,t),this.requestTimeout=t.requestTimeout,this.extraHeaders=t.extraHeaders,"undefined"!=typeof location){var e="https:"===location.protocol,n=location.port;n||(n=e?443:80),this.xd="undefined"!=typeof location&&t.hostname!==location.hostname||n!==t.port,this.xs=t.secure!==e}}function fZ(t){this.method=t.method||"GET",this.uri=t.uri,this.xd=!!t.xd,this.xs=!!t.xs,this.async=!1!==t.async,this.data=void 0!==t.data?t.data:null,this.agent=t.agent,this.isBinary=t.isBinary,this.supportsBinary=t.supportsBinary,this.enablesXDR=t.enablesXDR,this.withCredentials=t.withCredentials,this.requestTimeout=t.requestTimeout,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.extraHeaders=t.extraHeaders,this.create()}if(dY.exports=pZ,dY.exports.Request=fZ,cZ(pZ,aZ),pZ.prototype.supportsBinary=!0,pZ.prototype.request=function(t){return(t=t||{}).uri=this.uri(),t.xd=this.xd,t.xs=this.xs,t.agent=this.agent||!1,t.supportsBinary=this.supportsBinary,t.enablesXDR=this.enablesXDR,t.withCredentials=this.withCredentials,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized,t.requestTimeout=this.requestTimeout,t.extraHeaders=this.extraHeaders,new fZ(t)},pZ.prototype.doWrite=function(t,e){var n="string"!=typeof t&&void 0!==t,i=this.request({method:"POST",data:t,isBinary:n}),r=this;i.on("success",e),i.on("error",(function(t){r.onError("xhr post error",t)})),this.sendXhr=i},pZ.prototype.doPoll=function(){uZ("xhr poll");var t=this.request(),e=this;t.on("data",(function(t){e.onData(t)})),t.on("error",(function(t){e.onError("xhr poll error",t)})),this.pollXhr=t},lZ(fZ.prototype),fZ.prototype.create=function(){var t={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized;var e=this.xhr=new oZ(t),n=this;try{uZ("xhr open %s: %s",this.method,this.uri),e.open(this.method,this.uri,this.async);try{if(this.extraHeaders)for(var i in e.setDisableHeaderCheck&&e.setDisableHeaderCheck(!0),this.extraHeaders)this.extraHeaders.hasOwnProperty(i)&&e.setRequestHeader(i,this.extraHeaders[i])}catch(t){}if("POST"===this.method)try{this.isBinary?e.setRequestHeader("Content-type","application/octet-stream"):e.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(t){}try{e.setRequestHeader("Accept","*/*")}catch(t){}"withCredentials"in e&&(e.withCredentials=this.withCredentials),this.requestTimeout&&(e.timeout=this.requestTimeout),this.hasXDR()?(e.onload=function(){n.onLoad()},e.onerror=function(){n.onError(e.responseText)}):e.onreadystatechange=function(){if(2===e.readyState)try{var t=e.getResponseHeader("Content-Type");(n.supportsBinary&&"application/octet-stream"===t||"application/octet-stream; charset=UTF-8"===t)&&(e.responseType="arraybuffer")}catch(t){}4===e.readyState&&(200===e.status||1223===e.status?n.onLoad():setTimeout((function(){n.onError("number"==typeof e.status?e.status:0)}),0))},uZ("xhr data %s",this.data),e.send(this.data)}catch(t){return void setTimeout((function(){n.onError(t)}),0)}"undefined"!=typeof document&&(this.index=fZ.requestsCount++,fZ.requests[this.index]=this)},fZ.prototype.onSuccess=function(){this.emit("success"),this.cleanup()},fZ.prototype.onData=function(t){this.emit("data",t),this.onSuccess()},fZ.prototype.onError=function(t){this.emit("error",t),this.cleanup(!0)},fZ.prototype.cleanup=function(t){if(void 0!==this.xhr&&null!==this.xhr){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=dZ:this.xhr.onreadystatechange=dZ,t)try{this.xhr.abort()}catch(t){}"undefined"!=typeof document&&delete fZ.requests[this.index],this.xhr=null}},fZ.prototype.onLoad=function(){var t;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch(t){}t=("application/octet-stream"===e||"application/octet-stream; charset=UTF-8"===e)&&this.xhr.response||this.xhr.responseText}catch(t){this.onError(t)}null!=t&&this.onData(t)},fZ.prototype.hasXDR=function(){return"undefined"!=typeof XDomainRequest&&!this.xs&&this.enablesXDR},fZ.prototype.abort=function(){this.cleanup()},fZ.requestsCount=0,fZ.requests={},"undefined"!=typeof document)if("function"==typeof attachEvent)attachEvent("onunload",mZ);else if("function"==typeof addEventListener){addEventListener("onpagehide"in hZ?"pagehide":"unload",mZ,!1)}function mZ(){for(var t in fZ.requests)fZ.requests.hasOwnProperty(t)&&fZ.requests[t].abort()}var gZ,yZ=dY.exports,bZ=iZ,vZ=lY,xZ=CZ,wZ=/\n/g,SZ=/\\n/g;function kZ(){}function CZ(t){bZ.call(this,t),this.query=this.query||{},gZ||(gZ=vZ.___eio=vZ.___eio||[]),this.index=gZ.length;var e=this;gZ.push((function(t){e.onData(t)})),this.query.j=this.index,"function"==typeof addEventListener&&addEventListener("beforeunload",(function(){e.script&&(e.script.onerror=kZ)}),!1)}VY(CZ,bZ),CZ.prototype.supportsBinary=!1,CZ.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),bZ.prototype.doClose.call(this)},CZ.prototype.doPoll=function(){var t=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(e){t.onError("jsonp poll error",e)};var n=document.getElementsByTagName("script")[0];n?n.parentNode.insertBefore(e,n):(document.head||document.body).appendChild(e),this.script=e,"undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent)&&setTimeout((function(){var t=document.createElement("iframe");document.body.appendChild(t),document.body.removeChild(t)}),100)},CZ.prototype.doWrite=function(t,e){var n=this;if(!this.form){var i,r=document.createElement("form"),s=document.createElement("textarea"),o=this.iframeId="eio_iframe_"+this.index;r.className="socketio",r.style.position="absolute",r.style.top="-1000px",r.style.left="-1000px",r.target=o,r.method="POST",r.setAttribute("accept-charset","utf-8"),s.name="d",r.appendChild(s),document.body.appendChild(r),this.form=r,this.area=s}function a(){l(),e()}function l(){if(n.iframe)try{n.form.removeChild(n.iframe)}catch(t){n.onError("jsonp polling iframe removal error",t)}try{var t='<iframe src="javascript:0" name="'+n.iframeId+'">';i=document.createElement(t)}catch(t){(i=document.createElement("iframe")).name=n.iframeId,i.src="javascript:0"}i.id=n.iframeId,n.form.appendChild(i),n.iframe=i}this.form.action=this.uri(),l(),t=t.replace(SZ,"\\\n"),this.area.value=t.replace(wZ,"\\n");try{this.form.submit()}catch(t){}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){"complete"===n.iframe.readyState&&a()}:this.iframe.onload=a};var TZ,_Z,EZ=DY(),MZ=pY,$Z=BY(),IZ=VY,AZ=YY,NZ=OK("engine.io-client:websocket");if("undefined"!=typeof WebSocket?TZ=WebSocket:"undefined"!=typeof self&&(TZ=self.WebSocket||self.MozWebSocket),"undefined"==typeof window)try{_Z=tu}catch(vZt){}var RZ=TZ||_Z,PZ=OZ;function OZ(t){t&&t.forceBase64&&(this.supportsBinary=!1),this.perMessageDeflate=t.perMessageDeflate,this.usingBrowserWebSocket=TZ&&!t.forceNode,this.protocols=t.protocols,this.usingBrowserWebSocket||(RZ=_Z),EZ.call(this,t)}IZ(OZ,EZ),OZ.prototype.name="websocket",OZ.prototype.supportsBinary=!0,OZ.prototype.doOpen=function(){if(this.check()){var t=this.uri(),e=this.protocols,n={};this.isReactNative||(n.agent=this.agent,n.perMessageDeflate=this.perMessageDeflate,n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized),this.extraHeaders&&(n.headers=this.extraHeaders),this.localAddress&&(n.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket&&!this.isReactNative?e?new RZ(t,e):new RZ(t):new RZ(t,e,n)}catch(t){return this.emit("error",t)}void 0===this.ws.binaryType&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}},OZ.prototype.addEventListeners=function(){var t=this;this.ws.onopen=function(){t.onOpen()},this.ws.onclose=function(){t.onClose()},this.ws.onmessage=function(e){t.onData(e.data)},this.ws.onerror=function(e){t.onError("websocket error",e)}},OZ.prototype.write=function(t){var e=this;this.writable=!1;for(var n=t.length,i=0,r=n;i<r;i++)!function(t){MZ.encodePacket(t,e.supportsBinary,(function(i){if(!e.usingBrowserWebSocket){var r={};if(t.options&&(r.compress=t.options.compress),e.perMessageDeflate)("string"==typeof i?Buffer.byteLength(i):i.length)<e.perMessageDeflate.threshold&&(r.compress=!1)}try{e.usingBrowserWebSocket?e.ws.send(i):e.ws.send(i,r)}catch(t){NZ("websocket closed before onclose event")}--n||s()}))}(t[i]);function s(){e.emit("flush"),setTimeout((function(){e.writable=!0,e.emit("drain")}),0)}},OZ.prototype.onClose=function(){EZ.prototype.onClose.call(this)},OZ.prototype.doClose=function(){void 0!==this.ws&&this.ws.close()},OZ.prototype.uri=function(){var t=this.query||{},e=this.secure?"wss":"ws",n="";return this.port&&("wss"===e&&443!==Number(this.port)||"ws"===e&&80!==Number(this.port))&&(n=":"+this.port),this.timestampRequests&&(t[this.timestampParam]=AZ()),this.supportsBinary||(t.b64=1),(t=$Z.encode(t)).length&&(t="?"+t),e+"://"+(-1!==this.hostname.indexOf(":")?"["+this.hostname+"]":this.hostname)+n+this.path+t},OZ.prototype.check=function(){return!(!RZ||"__initialize"in RZ&&this.name===OZ.prototype.name)};var LZ=hY,DZ=yZ,FZ=xZ,zZ=PZ;iY.polling=function(t){var e=!1,n=!1,i=!1!==t.jsonp;if("undefined"!=typeof location){var r="https:"===location.protocol,s=location.port;s||(s=r?443:80),e=t.hostname!==location.hostname||s!==t.port,n=t.secure!==r}if(t.xdomain=e,t.xscheme=n,"open"in new LZ(t)&&!t.forceJSONP)return new DZ(t);if(!i)throw new Error("JSONP disabled");return new FZ(t)},iY.websocket=zZ;var BZ=[].indexOf,UZ=function(t,e){if(BZ)return t.indexOf(e);for(var n=0;n<t.length;++n)if(t[n]===e)return n;return-1},VZ=iY,WZ=UK,HZ=OK("engine.io-client:socket"),jZ=UZ,GZ=pY,qZ=CK,XZ=BY(),KZ=YZ;function YZ(t,e){if(!(this instanceof YZ))return new YZ(t,e);e=e||{},t&&"object"==typeof t&&(e=t,t=null),t?(t=qZ(t),e.hostname=t.host,e.secure="https"===t.protocol||"wss"===t.protocol,e.port=t.port,t.query&&(e.query=t.query)):e.host&&(e.hostname=qZ(e.host).host),this.secure=null!=e.secure?e.secure:"undefined"!=typeof location&&"https:"===location.protocol,e.hostname&&!e.port&&(e.port=this.secure?"443":"80"),this.agent=e.agent||!1,this.hostname=e.hostname||("undefined"!=typeof location?location.hostname:"localhost"),this.port=e.port||("undefined"!=typeof location&&location.port?location.port:this.secure?443:80),this.query=e.query||{},"string"==typeof this.query&&(this.query=XZ.decode(this.query)),this.upgrade=!1!==e.upgrade,this.path=(e.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!e.forceJSONP,this.jsonp=!1!==e.jsonp,this.forceBase64=!!e.forceBase64,this.enablesXDR=!!e.enablesXDR,this.withCredentials=!1!==e.withCredentials,this.timestampParam=e.timestampParam||"t",this.timestampRequests=e.timestampRequests,this.transports=e.transports||["polling","websocket"],this.transportOptions=e.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=e.policyPort||843,this.rememberUpgrade=e.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=e.onlyBinaryUpgrades,this.perMessageDeflate=!1!==e.perMessageDeflate&&(e.perMessageDeflate||{}),!0===this.perMessageDeflate&&(this.perMessageDeflate={}),this.perMessageDeflate&&null==this.perMessageDeflate.threshold&&(this.perMessageDeflate.threshold=1024),this.pfx=e.pfx||void 0,this.key=e.key||void 0,this.passphrase=e.passphrase||void 0,this.cert=e.cert||void 0,this.ca=e.ca||void 0,this.ciphers=e.ciphers||void 0,this.rejectUnauthorized=void 0===e.rejectUnauthorized||e.rejectUnauthorized,this.forceNode=!!e.forceNode,this.isReactNative="undefined"!=typeof navigator&&"string"==typeof navigator.product&&"reactnative"===navigator.product.toLowerCase(),("undefined"==typeof self||this.isReactNative)&&(e.extraHeaders&&Object.keys(e.extraHeaders).length>0&&(this.extraHeaders=e.extraHeaders),e.localAddress&&(this.localAddress=e.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,this.open()}YZ.priorWebsocketSuccess=!1,WZ(YZ.prototype),YZ.protocol=GZ.protocol,YZ.Socket=YZ,YZ.Transport=DY(),YZ.transports=iY,YZ.parser=pY,YZ.prototype.createTransport=function(t){HZ('creating transport "%s"',t);var e=function(t){var e={};for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);return e}(this.query);e.EIO=GZ.protocol,e.transport=t;var n=this.transportOptions[t]||{};return this.id&&(e.sid=this.id),new VZ[t]({query:e,socket:this,agent:n.agent||this.agent,hostname:n.hostname||this.hostname,port:n.port||this.port,secure:n.secure||this.secure,path:n.path||this.path,forceJSONP:n.forceJSONP||this.forceJSONP,jsonp:n.jsonp||this.jsonp,forceBase64:n.forceBase64||this.forceBase64,enablesXDR:n.enablesXDR||this.enablesXDR,withCredentials:n.withCredentials||this.withCredentials,timestampRequests:n.timestampRequests||this.timestampRequests,timestampParam:n.timestampParam||this.timestampParam,policyPort:n.policyPort||this.policyPort,pfx:n.pfx||this.pfx,key:n.key||this.key,passphrase:n.passphrase||this.passphrase,cert:n.cert||this.cert,ca:n.ca||this.ca,ciphers:n.ciphers||this.ciphers,rejectUnauthorized:n.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:n.perMessageDeflate||this.perMessageDeflate,extraHeaders:n.extraHeaders||this.extraHeaders,forceNode:n.forceNode||this.forceNode,localAddress:n.localAddress||this.localAddress,requestTimeout:n.requestTimeout||this.requestTimeout,protocols:n.protocols||void 0,isReactNative:this.isReactNative})},YZ.prototype.open=function(){var t;if(this.rememberUpgrade&&YZ.priorWebsocketSuccess&&-1!==this.transports.indexOf("websocket"))t="websocket";else{if(0===this.transports.length){var e=this;return void setTimeout((function(){e.emit("error","No transports available")}),0)}t=this.transports[0]}this.readyState="opening";try{t=this.createTransport(t)}catch(t){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)},YZ.prototype.setTransport=function(t){HZ("setting transport %s",t.name);var e=this;this.transport&&(HZ("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners()),this.transport=t,t.on("drain",(function(){e.onDrain()})).on("packet",(function(t){e.onPacket(t)})).on("error",(function(t){e.onError(t)})).on("close",(function(){e.onClose("transport close")}))},YZ.prototype.probe=function(t){HZ('probing transport "%s"',t);var e=this.createTransport(t,{probe:1}),n=!1,i=this;function r(){if(i.onlyBinaryUpgrades){var r=!this.supportsBinary&&i.transport.supportsBinary;n=n||r}n||(HZ('probe transport "%s" opened',t),e.send([{type:"ping",data:"probe"}]),e.once("packet",(function(r){if(!n)if("pong"===r.type&&"probe"===r.data){if(HZ('probe transport "%s" pong',t),i.upgrading=!0,i.emit("upgrading",e),!e)return;YZ.priorWebsocketSuccess="websocket"===e.name,HZ('pausing current transport "%s"',i.transport.name),i.transport.pause((function(){n||"closed"!==i.readyState&&(HZ("changing transport and sending upgrade packet"),u(),i.setTransport(e),e.send([{type:"upgrade"}]),i.emit("upgrade",e),e=null,i.upgrading=!1,i.flush())}))}else{HZ('probe transport "%s" failed',t);var s=new Error("probe error");s.transport=e.name,i.emit("upgradeError",s)}})))}function s(){n||(n=!0,u(),e.close(),e=null)}function o(n){var r=new Error("probe error: "+n);r.transport=e.name,s(),HZ('probe transport "%s" failed because of error: %s',t,n),i.emit("upgradeError",r)}function a(){o("transport closed")}function l(){o("socket closed")}function c(t){e&&t.name!==e.name&&(HZ('"%s" works - aborting "%s"',t.name,e.name),s())}function u(){e.removeListener("open",r),e.removeListener("error",o),e.removeListener("close",a),i.removeListener("close",l),i.removeListener("upgrading",c)}YZ.priorWebsocketSuccess=!1,e.once("open",r),e.once("error",o),e.once("close",a),this.once("close",l),this.once("upgrading",c),e.open()},YZ.prototype.onOpen=function(){if(HZ("socket open"),this.readyState="open",YZ.priorWebsocketSuccess="websocket"===this.transport.name,this.emit("open"),this.flush(),"open"===this.readyState&&this.upgrade&&this.transport.pause){HZ("starting upgrade probes");for(var t=0,e=this.upgrades.length;t<e;t++)this.probe(this.upgrades[t])}},YZ.prototype.onPacket=function(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(HZ('socket receive: type "%s", data "%s"',t.type,t.data),this.emit("packet",t),this.emit("heartbeat"),t.type){case"open":this.onHandshake(JSON.parse(t.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=t.data,this.onError(e);break;case"message":this.emit("data",t.data),this.emit("message",t.data)}else HZ('packet received with socket readyState "%s"',this.readyState)},YZ.prototype.onHandshake=function(t){this.emit("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.onOpen(),"closed"!==this.readyState&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))},YZ.prototype.onHeartbeat=function(t){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout((function(){"closed"!==e.readyState&&e.onClose("ping timeout")}),t||e.pingInterval+e.pingTimeout)},YZ.prototype.setPing=function(){var t=this;clearTimeout(t.pingIntervalTimer),t.pingIntervalTimer=setTimeout((function(){HZ("writing ping packet - expecting pong within %sms",t.pingTimeout),t.ping(),t.onHeartbeat(t.pingTimeout)}),t.pingInterval)},YZ.prototype.ping=function(){var t=this;this.sendPacket("ping",(function(){t.emit("ping")}))},YZ.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emit("drain"):this.flush()},YZ.prototype.flush=function(){"closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(HZ("flushing %d packets in socket",this.writeBuffer.length),this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))},YZ.prototype.write=YZ.prototype.send=function(t,e,n){return this.sendPacket("message",t,e,n),this},YZ.prototype.sendPacket=function(t,e,n,i){if("function"==typeof e&&(i=e,e=void 0),"function"==typeof n&&(i=n,n=null),"closing"!==this.readyState&&"closed"!==this.readyState){(n=n||{}).compress=!1!==n.compress;var r={type:t,data:e,options:n};this.emit("packetCreate",r),this.writeBuffer.push(r),i&&this.once("flush",i),this.flush()}},YZ.prototype.close=function(){if("opening"===this.readyState||"open"===this.readyState){this.readyState="closing";var t=this;this.writeBuffer.length?this.once("drain",(function(){this.upgrading?i():e()})):this.upgrading?i():e()}function e(){t.onClose("forced close"),HZ("socket closing - telling transport to close"),t.transport.close()}function n(){t.removeListener("upgrade",n),t.removeListener("upgradeError",n),e()}function i(){t.once("upgrade",n),t.once("upgradeError",n)}return this},YZ.prototype.onError=function(t){HZ("socket error %j",t),YZ.priorWebsocketSuccess=!1,this.emit("error",t),this.onClose("transport error",t)},YZ.prototype.onClose=function(t,e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){HZ('socket close with reason: "%s"',t);clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",t,e),this.writeBuffer=[],this.prevBufferLen=0}},YZ.prototype.filterUpgrades=function(t){for(var e=[],n=0,i=t.length;n<i;n++)~jZ(this.transports,t[n])&&e.push(t[n]);return e},nY.exports=KZ,nY.exports.parser=pY;var ZZ,JZ,QZ=nY.exports,tJ={exports:{}};var eJ=function(t,e,n){return t.on(e,n),{destroy:function(){t.removeListener(e,n)}}};var nJ,iJ=[].slice,rJ=function(t,e){if("string"==typeof e&&(e=t[e]),"function"!=typeof e)throw new Error("bind() requires a function");var n=iJ.call(arguments,2);return function(){return e.apply(t,n.concat(iJ.call(arguments)))}};function sJ(){return nJ||(nJ=1,function(t,e){var n=zK,i=UK,r=(JZ||(JZ=1,ZZ=function(t,e){for(var n=[],i=(e=e||0)||0;i<t.length;i++)n[i-e]=t[i];return n}),ZZ),s=eJ,o=rJ,a=OK("socket.io-client:socket"),l=BY(),c=mY();t.exports=d;var u={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},h=i.prototype.emit;function d(t,e,n){this.io=t,this.nsp=e,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,this.flags={},n&&n.query&&(this.query=n.query),this.io.autoConnect&&this.open()}i(d.prototype),d.prototype.subEvents=function(){if(!this.subs){var t=this.io;this.subs=[s(t,"open",o(this,"onopen")),s(t,"packet",o(this,"onpacket")),s(t,"close",o(this,"onclose"))]}},d.prototype.open=d.prototype.connect=function(){return this.connected||(this.subEvents(),this.io.reconnecting||this.io.open(),"open"===this.io.readyState&&this.onopen(),this.emit("connecting")),this},d.prototype.send=function(){var t=r(arguments);return t.unshift("message"),this.emit.apply(this,t),this},d.prototype.emit=function(t){if(u.hasOwnProperty(t))return h.apply(this,arguments),this;var e=r(arguments),i={type:(void 0!==this.flags.binary?this.flags.binary:c(e))?n.BINARY_EVENT:n.EVENT,data:e,options:{}};return i.options.compress=!this.flags||!1!==this.flags.compress,"function"==typeof e[e.length-1]&&(a("emitting packet with ack id %d",this.ids),this.acks[this.ids]=e.pop(),i.id=this.ids++),this.connected?this.packet(i):this.sendBuffer.push(i),this.flags={},this},d.prototype.packet=function(t){t.nsp=this.nsp,this.io.packet(t)},d.prototype.onopen=function(){if(a("transport is open - connecting"),"/"!==this.nsp)if(this.query){var t="object"==typeof this.query?l.encode(this.query):this.query;a("sending connect packet with query %s",t),this.packet({type:n.CONNECT,query:t})}else this.packet({type:n.CONNECT})},d.prototype.onclose=function(t){a("close (%s)",t),this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",t)},d.prototype.onpacket=function(t){var e=t.nsp===this.nsp,i=t.type===n.ERROR&&"/"===t.nsp;if(e||i)switch(t.type){case n.CONNECT:this.onconnect();break;case n.EVENT:case n.BINARY_EVENT:this.onevent(t);break;case n.ACK:case n.BINARY_ACK:this.onack(t);break;case n.DISCONNECT:this.ondisconnect();break;case n.ERROR:this.emit("error",t.data)}},d.prototype.onevent=function(t){var e=t.data||[];a("emitting event %j",e),null!=t.id&&(a("attaching ack callback to event"),e.push(this.ack(t.id))),this.connected?h.apply(this,e):this.receiveBuffer.push(e)},d.prototype.ack=function(t){var e=this,i=!1;return function(){if(!i){i=!0;var s=r(arguments);a("sending ack %j",s),e.packet({type:c(s)?n.BINARY_ACK:n.ACK,id:t,data:s})}}},d.prototype.onack=function(t){var e=this.acks[t.id];"function"==typeof e?(a("calling ack %s with %j",t.id,t.data),e.apply(this,t.data),delete this.acks[t.id]):a("bad ack %s",t.id)},d.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emitBuffered(),this.emit("connect")},d.prototype.emitBuffered=function(){var t;for(t=0;t<this.receiveBuffer.length;t++)h.apply(this,this.receiveBuffer[t]);for(this.receiveBuffer=[],t=0;t<this.sendBuffer.length;t++)this.packet(this.sendBuffer[t]);this.sendBuffer=[]},d.prototype.ondisconnect=function(){a("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")},d.prototype.destroy=function(){if(this.subs){for(var t=0;t<this.subs.length;t++)this.subs[t].destroy();this.subs=null}this.io.destroy(this)},d.prototype.close=d.prototype.disconnect=function(){return this.connected&&(a("performing disconnect (%s)",this.nsp),this.packet({type:n.DISCONNECT})),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},d.prototype.compress=function(t){return this.flags.compress=t,this},d.prototype.binary=function(t){return this.flags.binary=t,this}}(tJ)),tJ.exports}var oJ=aJ;function aJ(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}aJ.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),n=Math.floor(e*this.jitter*t);t=0==(1&Math.floor(10*e))?t-n:t+n}return 0|Math.min(t,this.max)},aJ.prototype.reset=function(){this.attempts=0},aJ.prototype.setMin=function(t){this.ms=t},aJ.prototype.setMax=function(t){this.max=t},aJ.prototype.setJitter=function(t){this.jitter=t};var lJ=QZ,cJ=sJ(),uJ=UK,hJ=zK,dJ=eJ,pJ=rJ,fJ=OK("socket.io-client:manager"),mJ=UZ,gJ=oJ,yJ=Object.prototype.hasOwnProperty,bJ=vJ;function vJ(t,e){if(!(this instanceof vJ))return new vJ(t,e);t&&"object"==typeof t&&(e=t,t=void 0),(e=e||{}).path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(!1!==e.reconnection),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new gJ({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==e.timeout?2e4:e.timeout),this.readyState="closed",this.uri=t,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var n=e.parser||hJ;this.encoder=new n.Encoder,this.decoder=new n.Decoder,this.autoConnect=!1!==e.autoConnect,this.autoConnect&&this.open()}vJ.prototype.emitAll=function(){for(var t in this.emit.apply(this,arguments),this.nsps)yJ.call(this.nsps,t)&&this.nsps[t].emit.apply(this.nsps[t],arguments)},vJ.prototype.updateSocketIds=function(){for(var t in this.nsps)yJ.call(this.nsps,t)&&(this.nsps[t].id=this.generateId(t))},vJ.prototype.generateId=function(t){return("/"===t?"":t+"#")+this.engine.id},uJ(vJ.prototype),vJ.prototype.reconnection=function(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection},vJ.prototype.reconnectionAttempts=function(t){return arguments.length?(this._reconnectionAttempts=t,this):this._reconnectionAttempts},vJ.prototype.reconnectionDelay=function(t){return arguments.length?(this._reconnectionDelay=t,this.backoff&&this.backoff.setMin(t),this):this._reconnectionDelay},vJ.prototype.randomizationFactor=function(t){return arguments.length?(this._randomizationFactor=t,this.backoff&&this.backoff.setJitter(t),this):this._randomizationFactor},vJ.prototype.reconnectionDelayMax=function(t){return arguments.length?(this._reconnectionDelayMax=t,this.backoff&&this.backoff.setMax(t),this):this._reconnectionDelayMax},vJ.prototype.timeout=function(t){return arguments.length?(this._timeout=t,this):this._timeout},vJ.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()},vJ.prototype.open=vJ.prototype.connect=function(t,e){if(fJ("readyState %s",this.readyState),~this.readyState.indexOf("open"))return this;fJ("opening %s",this.uri),this.engine=lJ(this.uri,this.opts);var n=this.engine,i=this;this.readyState="opening",this.skipReconnect=!1;var r=dJ(n,"open",(function(){i.onopen(),t&&t()})),s=dJ(n,"error",(function(e){if(fJ("connect_error"),i.cleanup(),i.readyState="closed",i.emitAll("connect_error",e),t){var n=new Error("Connection error");n.data=e,t(n)}else i.maybeReconnectOnOpen()}));if(!1!==this._timeout){var o=this._timeout;fJ("connect attempt will timeout after %d",o),0===o&&r.destroy();var a=setTimeout((function(){fJ("connect attempt timed out after %d",o),r.destroy(),n.close(),n.emit("error","timeout"),i.emitAll("connect_timeout",o)}),o);this.subs.push({destroy:function(){clearTimeout(a)}})}return this.subs.push(r),this.subs.push(s),this},vJ.prototype.onopen=function(){fJ("open"),this.cleanup(),this.readyState="open",this.emit("open");var t=this.engine;this.subs.push(dJ(t,"data",pJ(this,"ondata"))),this.subs.push(dJ(t,"ping",pJ(this,"onping"))),this.subs.push(dJ(t,"pong",pJ(this,"onpong"))),this.subs.push(dJ(t,"error",pJ(this,"onerror"))),this.subs.push(dJ(t,"close",pJ(this,"onclose"))),this.subs.push(dJ(this.decoder,"decoded",pJ(this,"ondecoded")))},vJ.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")},vJ.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)},vJ.prototype.ondata=function(t){this.decoder.add(t)},vJ.prototype.ondecoded=function(t){this.emit("packet",t)},vJ.prototype.onerror=function(t){fJ("error",t),this.emitAll("error",t)},vJ.prototype.socket=function(t,e){var n=this.nsps[t];if(!n){n=new cJ(this,t,e),this.nsps[t]=n;var i=this;n.on("connecting",r),n.on("connect",(function(){n.id=i.generateId(t)})),this.autoConnect&&r()}function r(){~mJ(i.connecting,n)||i.connecting.push(n)}return n},vJ.prototype.destroy=function(t){var e=mJ(this.connecting,t);~e&&this.connecting.splice(e,1),this.connecting.length||this.close()},vJ.prototype.packet=function(t){fJ("writing packet %j",t);var e=this;t.query&&0===t.type&&(t.nsp+="?"+t.query),e.encoding?e.packetBuffer.push(t):(e.encoding=!0,this.encoder.encode(t,(function(n){for(var i=0;i<n.length;i++)e.engine.write(n[i],t.options);e.encoding=!1,e.processPacketQueue()})))},vJ.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var t=this.packetBuffer.shift();this.packet(t)}},vJ.prototype.cleanup=function(){fJ("cleanup");for(var t=this.subs.length,e=0;e<t;e++){this.subs.shift().destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()},vJ.prototype.close=vJ.prototype.disconnect=function(){fJ("disconnect"),this.skipReconnect=!0,this.reconnecting=!1,"opening"===this.readyState&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()},vJ.prototype.onclose=function(t){fJ("onclose"),this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",t),this._reconnection&&!this.skipReconnect&&this.reconnect()},vJ.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var t=this;if(this.backoff.attempts>=this._reconnectionAttempts)fJ("reconnect failed"),this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();fJ("will wait %dms before reconnect attempt",e),this.reconnecting=!0;var n=setTimeout((function(){t.skipReconnect||(fJ("attempting reconnect"),t.emitAll("reconnect_attempt",t.backoff.attempts),t.emitAll("reconnecting",t.backoff.attempts),t.skipReconnect||t.open((function(e){e?(fJ("reconnect attempt error"),t.reconnecting=!1,t.reconnect(),t.emitAll("reconnect_error",e.data)):(fJ("reconnect success"),t.onreconnect())})))}),e);this.subs.push({destroy:function(){clearTimeout(n)}})}},vJ.prototype.onreconnect=function(){var t=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",t)},function(t,e){var n=FK,i=zK,r=bJ,s=OK("socket.io-client");t.exports=e=a;var o=e.managers={};function a(t,e){"object"==typeof t&&(e=t,t=void 0),e=e||{};var i,a=n(t),l=a.source,c=a.id,u=a.path,h=o[c]&&u in o[c].nsps;return e.forceNew||e["force new connection"]||!1===e.multiplex||h?(s("ignoring socket cache for %s",l),i=r(l,e)):(o[c]||(s("new io instance for %s",l),o[c]=r(l,e)),i=o[c]),a.query&&!e.query&&(e.query=a.query),i.socket(a.path,e)}e.protocol=i.protocol,e.connect=a,e.Manager=bJ,e.Socket=sJ()}(wK,wK.exports);var xJ,wJ,SJ=_i(wK.exports),kJ={exports:{}},CJ={},TJ={exports:{}};function _J(){if(wJ)return xJ;wJ=1;var t=1e3,e=60*t,n=60*e,i=24*n,r=7*i,s=365.25*i;function o(t,e,n,i){var r=e>=1.5*n;return Math.round(t/n)+" "+i+(r?"s":"")}return xJ=function(a,l){l=l||{};var c=typeof a;if("string"===c&&a.length>0)return function(o){if((o=String(o)).length>100)return;var a=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(o);if(!a)return;var l=parseFloat(a[1]);switch((a[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return l*s;case"weeks":case"week":case"w":return l*r;case"days":case"day":case"d":return l*i;case"hours":case"hour":case"hrs":case"hr":case"h":return l*n;case"minutes":case"minute":case"mins":case"min":case"m":return l*e;case"seconds":case"second":case"secs":case"sec":case"s":return l*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return l;default:return}}(a);if("number"===c&&isFinite(a))return l.long?function(r){var s=Math.abs(r);if(s>=i)return o(r,s,i,"day");if(s>=n)return o(r,s,n,"hour");if(s>=e)return o(r,s,e,"minute");if(s>=t)return o(r,s,t,"second");return r+" ms"}(a):function(r){var s=Math.abs(r);if(s>=i)return Math.round(r/i)+"d";if(s>=n)return Math.round(r/n)+"h";if(s>=e)return Math.round(r/e)+"m";if(s>=t)return Math.round(r/t)+"s";return r+"ms"}(a);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(a))},xJ}var EJ=function(t){function e(t){let i,r,s,o=null;function a(...t){if(!a.enabled)return;const n=a,r=Number(new Date),s=r-(i||r);n.diff=s,n.prev=i,n.curr=r,i=r,t[0]=e.coerce(t[0]),"string"!=typeof t[0]&&t.unshift("%O");let o=0;t[0]=t[0].replace(/%([a-zA-Z%])/g,((i,r)=>{if("%%"===i)return"%";o++;const s=e.formatters[r];if("function"==typeof s){const e=t[o];i=s.call(n,e),t.splice(o,1),o--}return i})),e.formatArgs.call(n,t);(n.log||e.log).apply(n,t)}return a.namespace=t,a.useColors=e.useColors(),a.color=e.selectColor(t),a.extend=n,a.destroy=e.destroy,Object.defineProperty(a,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==o?o:(r!==e.namespaces&&(r=e.namespaces,s=e.enabled(t)),s),set:t=>{o=t}}),"function"==typeof e.init&&e.init(a),a}function n(t,n){const i=e(this.namespace+(void 0===n?":":n)+t);return i.log=this.log,i}function i(t){return t.toString().substring(2,t.toString().length-2).replace(/\.\*\?$/,"*")}return e.debug=e,e.default=e,e.coerce=function(t){if(t instanceof Error)return t.stack||t.message;return t},e.disable=function(){const t=[...e.names.map(i),...e.skips.map(i).map((t=>"-"+t))].join(",");return e.enable(""),t},e.enable=function(t){let n;e.save(t),e.namespaces=t,e.names=[],e.skips=[];const i=("string"==typeof t?t:"").split(/[\s,]+/),r=i.length;for(n=0;n<r;n++)i[n]&&("-"===(t=i[n].replace(/\*/g,".*?"))[0]?e.skips.push(new RegExp("^"+t.slice(1)+"$")):e.names.push(new RegExp("^"+t+"$")))},e.enabled=function(t){if("*"===t[t.length-1])return!0;let n,i;for(n=0,i=e.skips.length;n<i;n++)if(e.skips[n].test(t))return!1;for(n=0,i=e.names.length;n<i;n++)if(e.names[n].test(t))return!0;return!1},e.humanize=_J(),e.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(t).forEach((n=>{e[n]=t[n]})),e.names=[],e.skips=[],e.formatters={},e.selectColor=function(t){let n=0;for(let e=0;e<t.length;e++)n=(n<<5)-n+t.charCodeAt(e),n|=0;return e.colors[Math.abs(n)%e.colors.length]},e.enable(e.load()),e};!function(t,e){e.formatArgs=function(e){if(e[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+e[0]+(this.useColors?"%c ":" ")+"+"+t.exports.humanize(this.diff),!this.useColors)return;const n="color: "+this.color;e.splice(1,0,n,"color: inherit");let i=0,r=0;e[0].replace(/%[a-zA-Z%]/g,(t=>{"%%"!==t&&(i++,"%c"===t&&(r=i))})),e.splice(r,0,n)},e.save=function(t){try{t?e.storage.setItem("debug",t):e.storage.removeItem("debug")}catch(t){}},e.load=function(){let t;try{t=e.storage.getItem("debug")}catch(t){}!t&&"undefined"!=typeof process&&"env"in process&&(t=process.env.DEBUG);return t},e.useColors=function(){if("undefined"!=typeof window&&window.process&&("renderer"===window.process.type||window.process.__nwjs))return!0;if("undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},e.storage=function(){try{return localStorage}catch(t){}}(),e.destroy=(()=>{let t=!1;return()=>{t||(t=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],e.log=console.debug||console.log||(()=>{}),t.exports=EJ(e);const{formatters:n}=t.exports;n.j=function(t){try{return JSON.stringify(t)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}(TJ,TJ.exports);var MJ=TJ.exports;const $J=MJ("@feathersjs/errors");function IJ(t,e,n,i,r){let s,o,a;(t=t||"Error")instanceof Error?(o=t.message||"Error",t.errors&&(s=t.errors)):"object"==typeof t?(o=t.message||"Error",r=t):o=t,r&&(a=JSON.parse(JSON.stringify(r)),a.errors?(s=a.errors,delete a.errors):r.errors&&(s=JSON.parse(JSON.stringify(r.errors)))),this.type="FeathersError",this.name=e,this.message=o,this.code=n,this.className=i,this.data=a,this.errors=s||{},$J(`${this.name}(${this.code}): ${this.message}`),$J(this.errors),Error.captureStackTrace?Error.captureStackTrace(this,IJ):this.stack=(new Error).stack}function AJ(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t}function NJ(t,e){IJ.call(this,t,"BadRequest",400,"bad-request",e)}function RJ(t,e){IJ.call(this,t,"NotAuthenticated",401,"not-authenticated",e)}function PJ(t,e){IJ.call(this,t,"PaymentError",402,"payment-error",e)}function OJ(t,e){IJ.call(this,t,"Forbidden",403,"forbidden",e)}function LJ(t,e){IJ.call(this,t,"NotFound",404,"not-found",e)}function DJ(t,e){IJ.call(this,t,"MethodNotAllowed",405,"method-not-allowed",e)}function FJ(t,e){IJ.call(this,t,"NotAcceptable",406,"not-acceptable",e)}function zJ(t,e){IJ.call(this,t,"Timeout",408,"timeout",e)}function BJ(t,e){IJ.call(this,t,"Conflict",409,"conflict",e)}function UJ(t,e){IJ(this,t,"Gone",410,"gone")}function VJ(t,e){IJ.call(this,t,"LengthRequired",411,"length-required",e)}function WJ(t,e){IJ.call(this,t,"Unprocessable",422,"unprocessable",e)}function HJ(t,e){IJ.call(this,t,"TooManyRequests",429,"too-many-requests",e)}function jJ(t,e){IJ.call(this,t,"GeneralError",500,"general-error",e)}function GJ(t,e){IJ.call(this,t,"NotImplemented",501,"not-implemented",e)}function qJ(t,e){IJ.call(this,t,"BadGateway",502,"bad-gateway",e)}function XJ(t,e){IJ.call(this,t,"Unavailable",503,"unavailable",e)}AJ(IJ,Error),Object.defineProperty(IJ.prototype,"toJSON",{value:function(){return{name:this.name,message:this.message,code:this.code,className:this.className,data:this.data,errors:this.errors}}}),AJ(NJ,IJ),AJ(RJ,IJ),AJ(PJ,IJ),AJ(OJ,IJ),AJ(LJ,IJ),AJ(DJ,IJ),AJ(FJ,IJ),AJ(zJ,IJ),AJ(BJ,IJ),AJ(UJ,IJ),AJ(VJ,IJ),AJ(WJ,IJ),AJ(HJ,IJ),AJ(jJ,IJ),AJ(GJ,IJ),AJ(qJ,IJ),AJ(XJ,IJ);const KJ={FeathersError:IJ,BadRequest:NJ,NotAuthenticated:RJ,PaymentError:PJ,Forbidden:OJ,NotFound:LJ,MethodNotAllowed:DJ,NotAcceptable:FJ,Timeout:zJ,Conflict:BJ,Gone:UJ,LengthRequired:VJ,Unprocessable:WJ,TooManyRequests:HJ,GeneralError:jJ,NotImplemented:GJ,BadGateway:qJ,Unavailable:XJ,400:NJ,401:RJ,402:PJ,403:OJ,404:LJ,405:DJ,406:FJ,408:zJ,409:BJ,410:UJ,411:VJ,422:WJ,429:HJ,500:jJ,501:GJ,502:qJ,503:XJ};var YJ=Object.assign({convert:function(t){if(!t)return t;const e=KJ[t.name],n=e?new e(t.message,t.data):new Error(t.message||t);return"object"==typeof t&&Object.assign(n,t),n}},KJ),ZJ={};Object.defineProperty(ZJ,"__esModule",{value:!0}),ZJ.StorageWrapper=ZJ.MemoryStorage=void 0;ZJ.MemoryStorage=class{constructor(){this.store={}}getItem(t){return Promise.resolve(this.store[t])}setItem(t,e){return Promise.resolve(this.store[t]=e)}removeItem(t){const e=this.store[t];return delete this.store[t],Promise.resolve(e)}};ZJ.StorageWrapper=class{constructor(t){this.storage=t}getItem(t){return Promise.resolve(this.storage.getItem(t))}setItem(t,e){return Promise.resolve(this.storage.setItem(t,e))}removeItem(t){return Promise.resolve(this.storage.removeItem(t))}},Object.defineProperty(CJ,"__esModule",{value:!0}),CJ.AuthenticationClient=void 0;const JJ=YJ,QJ=ZJ,tQ=(t,e)=>{const n=new RegExp(`(?:&?)${e}=([^&]*)`),i=t.hash?t.hash.match(n):null;if(null!==i){const[,t]=i;return[t,n]}return[null,n]};CJ.AuthenticationClient=class{constructor(t,e){const n=t.io||t.primus,i=new QJ.StorageWrapper(t.get("storage")||e.storage);this.app=t,this.options=e,this.authenticated=!1,this.app.set("storage",i),n&&this.handleSocket(n)}get service(){return this.app.service(this.options.path)}get storage(){return this.app.get("storage")}handleSocket(t){const e=this.app.io?"connect":"open",n=this.app.io?"disconnect":"disconnection";t.on(n,(()=>{const n=new Promise((n=>t.once(e,(t=>n(t))))).then((()=>this.authenticated?this.reAuthenticate(!0):null));this.app.set("authentication",n)}))}getFromLocation(t){const[e,n]=tQ(t,this.options.locationKey);if(null!==e)return t.hash=t.hash.replace(n,""),Promise.resolve(e);const[i,r]=tQ(t,this.options.locationErrorKey);return null!==i?(t.hash=t.hash.replace(r,""),Promise.reject(new JJ.NotAuthenticated(decodeURIComponent(i)))):Promise.resolve(null)}setAccessToken(t){return this.storage.setItem(this.options.storageKey,t)}getAccessToken(){return this.storage.getItem(this.options.storageKey).then((t=>!t&&"undefined"!=typeof window&&window.location?this.getFromLocation(window.location):t||null))}removeAccessToken(){return this.storage.removeItem(this.options.storageKey)}reset(){return this.app.set("authentication",null),this.authenticated=!1,Promise.resolve(null)}handleError(t,e){if(401===t.code||403===t.code){const n=this.removeAccessToken().then((()=>this.reset()));return"logout"===e?n:n.then((()=>Promise.reject(t)))}return Promise.reject(t)}reAuthenticate(t=!1,e){const n=this.app.get("authentication");return n&&!0!==t?n:this.getAccessToken().then((t=>{if(!t)throw new JJ.NotAuthenticated("No accessToken found in storage");return this.authenticate({strategy:e||this.options.jwtStrategy,accessToken:t})}))}authenticate(t,e){if(!t)return this.reAuthenticate();const n=this.service.create(t,e).then((t=>{const{accessToken:e}=t;return this.authenticated=!0,this.app.emit("login",t),this.app.emit("authenticated",t),this.setAccessToken(e).then((()=>t))})).catch((t=>this.handleError(t,"authenticate")));return this.app.set("authentication",n),n}logout(){return Promise.resolve(this.app.get("authentication")).then((()=>this.service.remove(null).then((t=>this.removeAccessToken().then((()=>this.reset())).then((()=>(this.app.emit("logout",t),t))))))).catch((t=>this.handleError(t,"logout")))}};var eQ,nQ={},iQ={},rQ={},sQ={},oQ={};eQ=oQ,Object.defineProperty(eQ,"__esModule",{value:!0}),eQ.createSymbol=eQ.makeUrl=eQ.isPromise=eQ._=eQ.stripSlashes=void 0,eQ.stripSlashes=function(t){return t.replace(/^(\/+)|(\/+)$/g,"")},eQ._={each(t,e){t&&"function"==typeof t.forEach?t.forEach(e):eQ._.isObject(t)&&Object.keys(t).forEach((n=>e(t[n],n)))},some:(t,e)=>Object.keys(t).map((e=>[t[e],e])).some((([t,n])=>e(t,n))),every:(t,e)=>Object.keys(t).map((e=>[t[e],e])).every((([t,n])=>e(t,n))),keys:t=>Object.keys(t),values:t=>eQ._.keys(t).map((e=>t[e])),isMatch:(t,e)=>eQ._.keys(e).every((n=>t[n]===e[n])),isEmpty:t=>0===eQ._.keys(t).length,isObject:t=>"object"==typeof t&&!Array.isArray(t)&&null!==t,isObjectOrArray:t=>"object"==typeof t&&null!==t,extend:(t,...e)=>Object.assign(t,...e),omit(t,...e){const n=eQ._.extend({},t);return e.forEach((t=>delete n[t])),n},pick:(t,...e)=>e.reduce(((e,n)=>(void 0!==t[n]&&(e[n]=t[n]),e)),{}),merge:(t,e)=>(eQ._.isObject(t)&&eQ._.isObject(e)&&Object.keys(e).forEach((n=>{eQ._.isObject(e[n])?(t[n]||Object.assign(t,{[n]:{}}),eQ._.merge(t[n],e[n])):Object.assign(t,{[n]:e[n]})})),t)},eQ.isPromise=function(t){return eQ._.isObject(t)&&"function"==typeof t.then},eQ.makeUrl=function(t,e={}){const n="function"==typeof e.get?e.get.bind(e):()=>{},i=n("env")||"production",r=n("host")||process.env.HOST_NAME||"localhost",s="development"===i||"test"===i||void 0===i?"http":"https",o=n("port")||process.env.PORT||3030;return t=t||"",`${s}://${r}${"development"===i||"test"===i||void 0===i?`:${o}`:""}/${eQ.stripSlashes(t)}`},eQ.createSymbol=function(t){return"undefined"!=typeof Symbol?Symbol(t):t},Object.defineProperty(sQ,"__esModule",{value:!0}),sQ.enableHooks=sQ.processHooks=sQ.getHooks=sQ.isHookObject=sQ.convertHookData=sQ.makeArguments=sQ.defaultMakeArguments=sQ.createHookObject=sQ.ACTIVATE_HOOKS=void 0;const aQ=oQ,{each:lQ,pick:cQ}=aQ._;function uQ(t){const e=[];return void 0!==t.id&&e.push(t.id),t.data&&e.push(t.data),e.push(t.params||{}),e}function hQ(t){let e={};return Array.isArray(t)?e={all:t}:"object"!=typeof t?e={all:[t]}:lQ(t,(function(t,n){e[n]=Array.isArray(t)?t:[t]})),e}function dQ(t){return"object"==typeof t&&"string"==typeof t.method&&"string"==typeof t.type}sQ.ACTIVATE_HOOKS=(0,aQ.createSymbol)("__feathersActivateHooks"),sQ.createHookObject=function(t,e={}){const n={};return Object.defineProperty(n,"toJSON",{value(){return cQ(this,"type","method","path","params","id","data","result","error")}}),Object.assign(n,e,{method:t,get path(){const{app:t,service:n}=e;return n&&t&&t.services?Object.keys(t.services).find((e=>t.services[e]===n)):null}})},sQ.defaultMakeArguments=uQ,sQ.makeArguments=function(t){switch(t.method){case"find":return[t.params];case"get":case"remove":return[t.id,t.params];case"update":case"patch":return[t.id,t.data,t.params];case"create":return[t.data,t.params]}return uQ(t)},sQ.convertHookData=hQ,sQ.isHookObject=dQ,sQ.getHooks=function(t,e,n,i,r=!1){const s=t.__hooks[n][i]||[],o=e.__hooks[n][i]||[];return r?o.concat(s):s.concat(o)},sQ.processHooks=function(t,e){let n=e;const i=t=>{if(t){if(!dQ(t))throw new Error(`${n.type} hook for '${n.method}' method returned invalid hook object`);n=t}return n},r=t.reduce(((t,e)=>{const n=e.bind(this);return t.then((t=>n(t))).then(i)}),Promise.resolve(n));return r.then((()=>n)).catch((t=>{throw t.hook=n,t}))},sQ.enableHooks=function(t,e,n){if("function"==typeof t.hooks)return t;const i={};return n.forEach((t=>{i[t]={}})),Object.defineProperty(t,"__hooks",{configurable:!0,value:i,writable:!0}),Object.assign(t,{hooks(t){return lQ(t,((t,n)=>{if(!this.__hooks[n])throw new Error(`'${n}' is not a valid hook type`);const i=hQ(t);lQ(i,((t,n)=>{if("all"!==n&&-1===e.indexOf(n))throw new Error(`'${n}' is not a valid hook method`)})),e.forEach((t=>{const e=this.__hooks[n][t]||(this.__hooks[n][t]=[]);i.all&&e.push.apply(e,i.all),i[t]&&e.push.apply(e,i[t])}))})),this}})},function(t){var e=Ti&&Ti.__createBinding||(Object.create?function(t,e,n,i){void 0===i&&(i=n);var r=Object.getOwnPropertyDescriptor(e,n);r&&!("get"in r?!e.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,i,r)}:function(t,e,n,i){void 0===i&&(i=n),t[i]=e[n]}),n=Ti&&Ti.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=Ti&&Ti.__importStar||function(t){if(t&&t.__esModule)return t;var i={};if(null!=t)for(var r in t)"default"!==r&&Object.prototype.hasOwnProperty.call(t,r)&&e(i,t,r);return n(i,t),i},r=Ti&&Ti.__exportStar||function(t,n){for(var i in t)"default"===i||Object.prototype.hasOwnProperty.call(n,i)||e(n,t,i)};Object.defineProperty(t,"__esModule",{value:!0}),t.hooks=void 0;const s=i(sQ);r(oQ,t),t.hooks=s}(rQ),Object.defineProperty(iQ,"__esModule",{value:!0}),iQ.authentication=void 0;const pQ=rQ;iQ.authentication=()=>t=>{const{app:e,params:n,path:i,method:r,app:{authentication:s}}=t;return(0,pQ.stripSlashes)(s.options.path)===i&&"create"===r?t:Promise.resolve(e.get("authentication")).then((e=>(e&&(t.params=Object.assign({},e,n)),t)))};var fQ={};Object.defineProperty(fQ,"__esModule",{value:!0}),fQ.populateHeader=void 0;fQ.populateHeader=()=>t=>{const{app:e,params:{accessToken:n}}=t,i=e.authentication;if(e.rest&&n){const{scheme:e,header:r}=i.options,s=`${e} ${n}`;t.params.headers=Object.assign({},{[r]:s},t.params.headers)}return t},function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.populateHeader=t.authentication=void 0;var e=iQ;Object.defineProperty(t,"authentication",{enumerable:!0,get:function(){return e.authentication}});var n=fQ;Object.defineProperty(t,"populateHeader",{enumerable:!0,get:function(){return n.populateHeader}})}(nQ),function(t,e){var n=Ti&&Ti.__createBinding||(Object.create?function(t,e,n,i){void 0===i&&(i=n);var r=Object.getOwnPropertyDescriptor(e,n);r&&!("get"in r?!e.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,i,r)}:function(t,e,n,i){void 0===i&&(i=n),t[i]=e[n]}),i=Ti&&Ti.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),r=Ti&&Ti.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)"default"!==r&&Object.prototype.hasOwnProperty.call(t,r)&&n(e,t,r);return i(e,t),e};Object.defineProperty(e,"__esModule",{value:!0}),e.defaults=e.defaultStorage=e.hooks=e.MemoryStorage=e.AuthenticationClient=e.getDefaultStorage=void 0;const s=CJ;Object.defineProperty(e,"AuthenticationClient",{enumerable:!0,get:function(){return s.AuthenticationClient}});const o=r(nQ);e.hooks=o;const a=ZJ;Object.defineProperty(e,"MemoryStorage",{enumerable:!0,get:function(){return a.MemoryStorage}});e.getDefaultStorage=()=>{try{return new a.StorageWrapper(window.localStorage)}catch(t){}return new a.MemoryStorage},e.defaultStorage=(0,e.getDefaultStorage)(),e.defaults={header:"Authorization",scheme:"Bearer",storageKey:"feathers-jwt",locationKey:"access_token",locationErrorKey:"error",jwtStrategy:"jwt",path:"/authentication",Authentication:s.AuthenticationClient,storage:e.defaultStorage};const l=(t={})=>{const n=Object.assign({},e.defaults,t),{Authentication:i}=n;return t=>{const e=new i(t,n);t.authentication=e,t.authenticate=e.authenticate.bind(e),t.reAuthenticate=e.reAuthenticate.bind(e),t.logout=e.logout.bind(e),t.hooks({before:{all:[o.authentication(),o.populateHeader()]}})}};e.default=l,t.exports=Object.assign(l,t.exports)}(kJ,kJ.exports);var mQ=_i(kJ.exports),gQ={exports:{}},yQ={exports:{}};yQ.exports=function(){var t="function"==typeof Object.getOwnPropertySymbols;function e(e,n,i,r){var s="function"==typeof n,o=function(){var t=this._super;this._super=s?n:e[i];var o=r.apply(this,arguments);return this._super=t,o};return s&&(Object.keys(n).forEach((function(t){o[t]=n[t]})),t&&Object.getOwnPropertySymbols(n).forEach((function(t){o[t]=n[t]}))),o}return{create:function(){var t=Object.create(this),e="string"==typeof t.__init?t.__init:"init";return"function"==typeof t[e]&&t[e].apply(t,arguments),t},mixin:function(n,i){var r=i||this,s=/\b_super\b/,o=Object.getPrototypeOf(r)||r.prototype,a={},l=n,c=function(t){var e=Object.getOwnPropertyDescriptor(l,t);!a[t]&&e&&(a[t]=e)};do{Object.getOwnPropertyNames(l).forEach(c),t&&Object.getOwnPropertySymbols(l).forEach(c)}while((l=Object.getPrototypeOf(l))&&Object.getPrototypeOf(l));var u=function(t){var n=a[t];"function"==typeof n.value&&s.test(n.value)&&(n.value=e(o,r[t],t,n.value)),Object.defineProperty(r,t,n)};return Object.keys(a).forEach(u),t&&Object.getOwnPropertySymbols(a).forEach(u),r},extend:function(t,e){return this.mixin(t,Object.create(e||this))},proxy:function(t){var e=this[t],n=Array.prototype.slice.call(arguments,1);return n.unshift(this),e.bind.apply(e,n)}}}();var bQ,vQ=yQ.exports,xQ={exports:{}},wQ={exports:{}},SQ="object"==typeof Reflect?Reflect:null,kQ=SQ&&"function"==typeof SQ.apply?SQ.apply:function(t,e,n){return Function.prototype.apply.call(t,e,n)};bQ=SQ&&"function"==typeof SQ.ownKeys?SQ.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};var CQ=Number.isNaN||function(t){return t!=t};function TQ(){TQ.init.call(this)}wQ.exports=TQ,wQ.exports.once=function(t,e){return new Promise((function(n,i){function r(n){t.removeListener(e,s),i(n)}function s(){"function"==typeof t.removeListener&&t.removeListener("error",r),n([].slice.call(arguments))}OQ(t,e,s,{once:!0}),"error"!==e&&function(t,e,n){"function"==typeof t.on&&OQ(t,"error",e,n)}(t,r,{once:!0})}))},TQ.EventEmitter=TQ,TQ.prototype._events=void 0,TQ.prototype._eventsCount=0,TQ.prototype._maxListeners=void 0;var _Q=10;function EQ(t){if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t)}function MQ(t){return void 0===t._maxListeners?TQ.defaultMaxListeners:t._maxListeners}function $Q(t,e,n,i){var r,s,o,a;if(EQ(n),void 0===(s=t._events)?(s=t._events=Object.create(null),t._eventsCount=0):(void 0!==s.newListener&&(t.emit("newListener",e,n.listener?n.listener:n),s=t._events),o=s[e]),void 0===o)o=s[e]=n,++t._eventsCount;else if("function"==typeof o?o=s[e]=i?[n,o]:[o,n]:i?o.unshift(n):o.push(n),(r=MQ(t))>0&&o.length>r&&!o.warned){o.warned=!0;var l=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");l.name="MaxListenersExceededWarning",l.emitter=t,l.type=e,l.count=o.length,a=l,console&&console.warn&&console.warn(a)}return t}function IQ(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function AQ(t,e,n){var i={fired:!1,wrapFn:void 0,target:t,type:e,listener:n},r=IQ.bind(i);return r.listener=n,i.wrapFn=r,r}function NQ(t,e,n){var i=t._events;if(void 0===i)return[];var r=i[e];return void 0===r?[]:"function"==typeof r?n?[r.listener||r]:[r]:n?function(t){for(var e=new Array(t.length),n=0;n<e.length;++n)e[n]=t[n].listener||t[n];return e}(r):PQ(r,r.length)}function RQ(t){var e=this._events;if(void 0!==e){var n=e[t];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function PQ(t,e){for(var n=new Array(e),i=0;i<e;++i)n[i]=t[i];return n}function OQ(t,e,n,i){if("function"==typeof t.on)i.once?t.once(e,n):t.on(e,n);else{if("function"!=typeof t.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof t);t.addEventListener(e,(function r(s){i.once&&t.removeEventListener(e,r),n(s)}))}}Object.defineProperty(TQ,"defaultMaxListeners",{enumerable:!0,get:function(){return _Q},set:function(t){if("number"!=typeof t||t<0||CQ(t))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+t+".");_Q=t}}),TQ.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},TQ.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||CQ(t))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+t+".");return this._maxListeners=t,this},TQ.prototype.getMaxListeners=function(){return MQ(this)},TQ.prototype.emit=function(t){for(var e=[],n=1;n<arguments.length;n++)e.push(arguments[n]);var i="error"===t,r=this._events;if(void 0!==r)i=i&&void 0===r.error;else if(!i)return!1;if(i){var s;if(e.length>0&&(s=e[0]),s instanceof Error)throw s;var o=new Error("Unhandled error."+(s?" ("+s.message+")":""));throw o.context=s,o}var a=r[t];if(void 0===a)return!1;if("function"==typeof a)kQ(a,this,e);else{var l=a.length,c=PQ(a,l);for(n=0;n<l;++n)kQ(c[n],this,e)}return!0},TQ.prototype.addListener=function(t,e){return $Q(this,t,e,!1)},TQ.prototype.on=TQ.prototype.addListener,TQ.prototype.prependListener=function(t,e){return $Q(this,t,e,!0)},TQ.prototype.once=function(t,e){return EQ(e),this.on(t,AQ(this,t,e)),this},TQ.prototype.prependOnceListener=function(t,e){return EQ(e),this.prependListener(t,AQ(this,t,e)),this},TQ.prototype.removeListener=function(t,e){var n,i,r,s,o;if(EQ(e),void 0===(i=this._events))return this;if(void 0===(n=i[t]))return this;if(n===e||n.listener===e)0==--this._eventsCount?this._events=Object.create(null):(delete i[t],i.removeListener&&this.emit("removeListener",t,n.listener||e));else if("function"!=typeof n){for(r=-1,s=n.length-1;s>=0;s--)if(n[s]===e||n[s].listener===e){o=n[s].listener,r=s;break}if(r<0)return this;0===r?n.shift():function(t,e){for(;e+1<t.length;e++)t[e]=t[e+1];t.pop()}(n,r),1===n.length&&(i[t]=n[0]),void 0!==i.removeListener&&this.emit("removeListener",t,o||e)}return this},TQ.prototype.off=TQ.prototype.removeListener,TQ.prototype.removeAllListeners=function(t){var e,n,i;if(void 0===(n=this._events))return this;if(void 0===n.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[t]&&(0==--this._eventsCount?this._events=Object.create(null):delete n[t]),this;if(0===arguments.length){var r,s=Object.keys(n);for(i=0;i<s.length;++i)"removeListener"!==(r=s[i])&&this.removeAllListeners(r);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(e=n[t]))this.removeListener(t,e);else if(void 0!==e)for(i=e.length-1;i>=0;i--)this.removeListener(t,e[i]);return this},TQ.prototype.listeners=function(t){return NQ(this,t,!0)},TQ.prototype.rawListeners=function(t){return NQ(this,t,!1)},TQ.listenerCount=function(t,e){return"function"==typeof t.listenerCount?t.listenerCount(e):RQ.call(t,e)},TQ.prototype.listenerCount=RQ,TQ.prototype.eventNames=function(){return this._eventsCount>0?bQ(this._events):[]};var LQ=wQ.exports;!function(t,e){const{EventEmitter:n}=LQ,i=vQ,r=e.eventHook=function(){return function(t){const{app:e,service:n}=t,i=null===t.event?t.event:e.eventMappings[t.method],r=n._hookEvents&&-1!==n._hookEvents.indexOf(i);if(i&&r&&"error"!==t.type){(Array.isArray(t.result)?t.result:[t.result]).forEach((e=>n.emit(i,e,t)))}}},s=e.eventMixin=function(t){if(t._serviceEvents)return;const e=this,i="function"==typeof t.on&&"function"==typeof t.emit;"function"!=typeof t.mixin||i||t.mixin(n.prototype),Object.defineProperties(t,{_serviceEvents:{value:Array.isArray(t.events)?t.events.slice():[]},_hookEvents:{value:[]}}),Object.keys(e.eventMappings).forEach((n=>{const i=e.eventMappings[n],r=-1!==t._serviceEvents.indexOf(i);"function"!=typeof t[n]||r||(t._serviceEvents.push(i),t._hookEvents.push(i))}))};t.exports=function(){return function(t){Object.assign(t,{eventMappings:{create:"created",update:"updated",remove:"removed",patch:"patched"}}),t.hooks({finally:r()}),i.mixin(n.prototype,t),t.mixins.push(s)}}}(xQ,xQ.exports);var DQ=xQ.exports,FQ={exports:{}};const{_:zQ}=rQ;var BQ=[t=>{const{service:e,method:n}=t,i=e.methods[n];return t.arguments.forEach(((e,n)=>{t[i[n]]=e})),t.params||(t.params={}),t},t=>{const{service:e,method:n,path:i}=t,r=e.methods[n];if(r.includes("id")&&void 0===t.id)throw new Error(`An id must be provided to the '${i}.${n}' method`);if(r.includes("data")&&!zQ.isObjectOrArray(t.data))throw new Error(`A data object must be provided to the '${i}.${n}' method`);return t}];!function(t,e){const{hooks:n,isPromise:i}=rQ,r=BQ,{createHookObject:s,getHooks:o,processHooks:a,enableHooks:l,ACTIVATE_HOOKS:c}=n,u=function({app:t,service:e,method:n,original:o}){return(l={})=>{const c=t.hookTypes.reduce(((t,e)=>{const n=l[e]||[];return t[e]=Array.isArray(n)?n:[n],t}),{});return function(...l){const u=!0===l[l.length-1]&&l.pop(),h=s(n,{type:"before",arguments:l,service:e,app:t});return Promise.resolve(h).then((t=>a.call(e,r.concat(c.before),t))).then((t=>{if(void 0!==t.result)return t;const r=new Promise((r=>{const s=o||e[n],a=e.methods[n].map((e=>t[e])),l=s.apply(e,a);if(!i(l))throw new Error(`Service method '${t.method}' for '${t.path}' service must return a promise`);r(l)}));return r.then((e=>(t.result=e,t))).catch((e=>{throw e.hook=t,e}))})).then((t=>{const n=Object.assign({},t,{type:"after"});return a.call(e,c.after,n)})).catch((t=>{const n=Object.assign({},t.hook,{type:"error",original:t.hook,error:t,result:void 0});return a.call(e,c.error,n).catch((t=>Object.assign({},t.hook,{error:t,result:void 0})))})).then((t=>a.call(e,c.finally,t).catch((t=>Object.assign({},t.hook,{error:t,result:void 0}))))).then((t=>void 0!==t.error&&void 0===t.result?Promise.reject(u?t:t.error):u?t:t.result))}}},h=e.hookMixin=function(t){if("function"==typeof t.hooks)return;t.methods=Object.getOwnPropertyNames(t).filter((e=>"function"==typeof t[e]&&t[e][c])).reduce(((e,n)=>(e[n]=t[n][c],e)),t.methods||{}),Object.assign(t.methods,{find:["params"],get:["id","params"],create:["data","params"],update:["id","data","params"],patch:["id","data","params"],remove:["id","params"]});const e=this,n=Object.keys(t.methods),i=n.reduce(((n,i)=>("function"!=typeof t[i]||(n[i]=function(){const t=this,n=Array.from(arguments),r=t._super.bind(t);return u({app:e,service:t,method:i,original:r})({before:o(e,t,"before",i),after:o(e,t,"after",i,!0),error:o(e,t,"error",i,!0),finally:o(e,t,"finally",i,!0)})(...n)}),n)),{});l(t,n,e.hookTypes),t.mixin(i)};t.exports=function(){return function(t){Object.assign(t,{hookTypes:["before","after","error","finally"]}),l(t,t.methods,t.hookTypes),t.mixins.push(h)}},t.exports.withHooks=u,t.exports.ACTIVATE_HOOKS=c,t.exports.activateHooks=function(t){return e=>(Object.defineProperty(e,c,{value:t}),e)}}(FQ,FQ.exports);var UQ=FQ.exports,VQ="4.5.16";const WQ=MJ("feathers:application"),{stripSlashes:HQ}=rQ,jQ=DQ,GQ=UQ,qQ=VQ,XQ=vQ.extend({create:null}),KQ={init(){Object.assign(this,{version:qQ,methods:["find","get","create","update","patch","remove"],mixins:[],services:{},providers:[],_setup:!1,settings:{}}),this.configure(GQ()),this.configure(jQ())},get(t){return this.settings[t]},set(t,e){return this.settings[t]=e,this},disable(t){return this.settings[t]=!1,this},disabled(t){return!this.settings[t]},enable(t){return this.settings[t]=!0,this},enabled(t){return!!this.settings[t]},configure(t){return t.call(this,this),this},service(t,e){if(void 0!==e)throw new Error("Registering a new service with `app.service(path, service)` is no longer supported. Use `app.use(path, service)` instead.");const n=HQ(t)||"/",i=this.services[n];return void 0===i&&"function"==typeof this.defaultService?this.use(n,this.defaultService(n)).service(n):i},use(t,e,n={}){if("string"!=typeof t)throw new Error(`'${t}' is not a valid service path.`);const i=HQ(t)||"/",r="function"==typeof e.service&&e.services,s=this.methods.concat("setup").some((t=>"function"==typeof e[t]));if(r){const t=e;return Object.keys(t.services).forEach((e=>this.use(`${i}/${e}`,t.service(e)))),this}if(!s)throw new Error(`Invalid service object passed for path \`${i}\``);const o=XQ.isPrototypeOf(e)?e:XQ.extend(e);return WQ(`Registering new service at \`${i}\``),this.mixins.forEach((t=>t.call(this,o,i,n))),"function"==typeof o._setup&&o._setup(this,i),this.providers.forEach((t=>t.call(this,o,i,n))),this._isSetup&&"function"==typeof o.setup&&(WQ(`Setting up service for \`${i}\``),o.setup(this,i)),this.services[i]=o,this},setup(){return Object.keys(this.services).forEach((t=>{const e=this.services[t];WQ(`Setting up service for \`${t}\``),"function"==typeof e.setup&&e.setup(this,t)})),this._isSetup=!0,this}};const YQ=vQ,ZQ=KQ,JQ=VQ,{ACTIVATE_HOOKS:QQ,activateHooks:t0}=UQ,e0=Object.create(null);function n0(){const t=Object.create(e0);return YQ.mixin(ZQ,t),t.init(),t}n0.version=JQ,n0.ACTIVATE_HOOKS=QQ,n0.activateHooks=t0,gQ.exports=n0,gQ.exports.default=n0;var i0=_i(gQ.exports),r0={exports:{}},s0={},o0=Ti&&Ti.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(s0,"__esModule",{value:!0}),s0.Service=void 0;const a0=o0(MJ),l0=YJ,c0=(0,a0.default)("@feathersjs/transport-commons/client"),u0=["addListener","emit","listenerCount","listeners","on","once","prependListener","prependOnceListener","removeAllListeners","removeListener"],h0=["eventNames","getMaxListeners","setMaxListeners"],d0=t=>{h0.forEach((e=>{t[e]=function(...t){if("function"!=typeof this.connection[e])throw new Error(`Can not call '${e}' on the client service connection`);return this.connection[e](...t)}})),u0.forEach((e=>{t[e]=function(t,...n){if("function"!=typeof this.connection[e])throw new Error(`Can not call '${e}' on the client service connection`);const i=`${this.path} ${t}`;c0(`Calling emitter method ${e} with namespaced event '${i}'`);const r=this.connection[e](i,...n);return r===this.connection?this:r}}))};s0.Service=class{constructor(t){this.events=t.events,this.path=t.name,this.connection=t.connection,this.method=t.method,this.timeout=t.timeout||5e3,d0(this)}send(t,...e){return new Promise(((n,i)=>{const r=setTimeout((()=>i(new l0.Timeout(`Timeout of ${this.timeout}ms exceeded calling ${t} on ${this.path}`,{timeout:this.timeout,method:t,path:this.path}))),this.timeout);e.unshift(t,this.path),e.push((function(t,e){return t=(0,l0.convert)(t),clearTimeout(r),t?i(t):n(e)})),c0(`Sending socket.${this.method}`,e),this.connection[this.method](...e)}))}find(t={}){return this.send("find",t.query||{})}get(t,e={}){return this.send("get",t,e.query||{})}create(t,e={}){return this.send("create",t,e.query||{})}update(t,e,n={}){return this.send("update",t,e,n.query||{})}patch(t,e,n={}){return this.send("patch",t,e,n.query||{})}remove(t,e={}){return this.send("remove",t,e.query||{})}off(t,...e){if("function"==typeof this.connection.off){const n=this.connection.off(`${this.path} ${t}`,...e);return n===this.connection?this:n}return 0===e.length?this.removeAllListeners(t):this.removeListener(t,...e)}};const p0=s0.Service;function f0(t,e){if(!t)throw new Error("Socket.io connection needs to be provided");if(t&&t.io&&t.io.engine&&t.io.engine.transport&&t.io.engine.transport.query&&t.io.engine.transport.query.EIO>3)throw console.error("You are trying to use the Socket.io client version 3 or later with Feathers v4 which only supports Socket.io version 2. Please use socket.io-client version 2 instead."),new Error("socket.io-client must be version 2.x");const n=function(n){const i=Object.keys(this.eventMappings||{}).map((t=>this.eventMappings[t])),r=Object.assign({},e,{events:i,name:n,connection:t,method:"emit"});return new p0(r)},i=function(e){if("function"==typeof e.defaultService)throw new Error("Only one default client provider can be configured");e.io=t,e.defaultService=n};return i.Service=p0,i.service=n,i}r0.exports=f0,r0.exports.default=f0;var m0=_i(r0.exports),g0={exports:{}},y0={},b0={},v0={};!function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.createSymbol=t.makeUrl=t.isPromise=t._=t.stripSlashes=void 0,t.stripSlashes=function(t){return t.replace(/^(\/+)|(\/+)$/g,"")},t._={each(e,n){e&&"function"==typeof e.forEach?e.forEach(n):t._.isObject(e)&&Object.keys(e).forEach((t=>n(e[t],t)))},some:(t,e)=>Object.keys(t).map((e=>[t[e],e])).some((([t,n])=>e(t,n))),every:(t,e)=>Object.keys(t).map((e=>[t[e],e])).every((([t,n])=>e(t,n))),keys:t=>Object.keys(t),values:e=>t._.keys(e).map((t=>e[t])),isMatch:(e,n)=>t._.keys(n).every((t=>e[t]===n[t])),isEmpty:e=>0===t._.keys(e).length,isObject:t=>"object"==typeof t&&!Array.isArray(t)&&null!==t,isObjectOrArray:t=>"object"==typeof t&&null!==t,extend:(t,...e)=>Object.assign(t,...e),omit(e,...n){const i=t._.extend({},e);return n.forEach((t=>delete i[t])),i},pick:(t,...e)=>e.reduce(((e,n)=>(void 0!==t[n]&&(e[n]=t[n]),e)),{}),merge:(e,n)=>(t._.isObject(e)&&t._.isObject(n)&&Object.keys(n).forEach((i=>{t._.isObject(n[i])?(e[i]||Object.assign(e,{[i]:{}}),t._.merge(e[i],n[i])):Object.assign(e,{[i]:n[i]})})),e)},t.isPromise=function(e){return t._.isObject(e)&&"function"==typeof e.then},t.makeUrl=function(e,n={}){const i="function"==typeof n.get?n.get.bind(n):()=>{},r=i("env")||"production",s=i("host")||process.env.HOST_NAME||"localhost",o="development"===r||"test"===r||void 0===r?"http":"https",a=i("port")||process.env.PORT||3030;return e=e||"",`${o}://${s}${"development"===r||"test"===r||void 0===r?`:${a}`:""}/${t.stripSlashes(e)}`},t.createSymbol=function(t){return"undefined"!=typeof Symbol?Symbol(t):t}}(v0),Object.defineProperty(b0,"__esModule",{value:!0}),b0.enableHooks=b0.processHooks=b0.getHooks=b0.isHookObject=b0.convertHookData=b0.makeArguments=b0.defaultMakeArguments=b0.createHookObject=b0.ACTIVATE_HOOKS=void 0;const x0=v0,{each:w0,pick:S0}=x0._;function k0(t){const e=[];return void 0!==t.id&&e.push(t.id),t.data&&e.push(t.data),e.push(t.params||{}),e}function C0(t){let e={};return Array.isArray(t)?e={all:t}:"object"!=typeof t?e={all:[t]}:w0(t,(function(t,n){e[n]=Array.isArray(t)?t:[t]})),e}function T0(t){return"object"==typeof t&&"string"==typeof t.method&&"string"==typeof t.type}b0.ACTIVATE_HOOKS=(0,x0.createSymbol)("__feathersActivateHooks"),b0.createHookObject=function(t,e={}){const n={};return Object.defineProperty(n,"toJSON",{value(){return S0(this,"type","method","path","params","id","data","result","error")}}),Object.assign(n,e,{method:t,get path(){const{app:t,service:n}=e;return n&&t&&t.services?Object.keys(t.services).find((e=>t.services[e]===n)):null}})},b0.defaultMakeArguments=k0,b0.makeArguments=function(t){switch(t.method){case"find":return[t.params];case"get":case"remove":return[t.id,t.params];case"update":case"patch":return[t.id,t.data,t.params];case"create":return[t.data,t.params]}return k0(t)},b0.convertHookData=C0,b0.isHookObject=T0,b0.getHooks=function(t,e,n,i,r=!1){const s=t.__hooks[n][i]||[],o=e.__hooks[n][i]||[];return r?o.concat(s):s.concat(o)},b0.processHooks=function(t,e){let n=e;const i=t=>{if(t){if(!T0(t))throw new Error(`${n.type} hook for '${n.method}' method returned invalid hook object`);n=t}return n},r=t.reduce(((t,e)=>{const n=e.bind(this);return t.then((t=>n(t))).then(i)}),Promise.resolve(n));return r.then((()=>n)).catch((t=>{throw t.hook=n,t}))},b0.enableHooks=function(t,e,n){if("function"==typeof t.hooks)return t;const i={};return n.forEach((t=>{i[t]={}})),Object.defineProperty(t,"__hooks",{configurable:!0,value:i,writable:!0}),Object.assign(t,{hooks(t){return w0(t,((t,n)=>{if(!this.__hooks[n])throw new Error(`'${n}' is not a valid hook type`);const i=C0(t);w0(i,((t,n)=>{if("all"!==n&&-1===e.indexOf(n))throw new Error(`'${n}' is not a valid hook method`)})),e.forEach((t=>{const e=this.__hooks[n][t]||(this.__hooks[n][t]=[]);i.all&&e.push.apply(e,i.all),i[t]&&e.push.apply(e,i[t])}))})),this}})},function(t){var e=Ti&&Ti.__createBinding||(Object.create?function(t,e,n,i){void 0===i&&(i=n);var r=Object.getOwnPropertyDescriptor(e,n);r&&!("get"in r?!e.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,i,r)}:function(t,e,n,i){void 0===i&&(i=n),t[i]=e[n]}),n=Ti&&Ti.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=Ti&&Ti.__importStar||function(t){if(t&&t.__esModule)return t;var i={};if(null!=t)for(var r in t)"default"!==r&&Object.prototype.hasOwnProperty.call(t,r)&&e(i,t,r);return n(i,t),i},r=Ti&&Ti.__exportStar||function(t,n){for(var i in t)"default"===i||Object.prototype.hasOwnProperty.call(n,i)||e(n,t,i)};Object.defineProperty(t,"__esModule",{value:!0}),t.hooks=void 0;const s=i(b0);r(v0,t),t.hooks=s}(y0);var _0={},E0={},M0={exports:{}};!function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.OPERATORS=e.FILTERS=void 0;const n=y0,i=YJ;function r(t){if(void 0!==t)return Math.abs(parseInt(t,10))}function s(t,e,r){if(Array.isArray(t))return t.map((t=>s(t,e,r)));if(n._.isObject(t)&&t.constructor==={}.constructor){const o={};return n._.each(t,((n,a)=>{if("$"===a[0]){if(void 0!==r[a])return;if(!e.includes(a))throw new i.BadRequest(`Invalid query parameter ${a}`,t)}o[a]=s(n,e,r)})),Object.getOwnPropertySymbols(t).forEach((e=>{o[e]=t[e]})),o}return t}function o(t,e,i,r){return Array.isArray(i)?n._.each(i,(n=>{void 0!==e[n]&&(t[n]=e[n])})):n._.each(i,((n,i)=>{const s=n(e[i],r);void 0!==s&&(t[i]=s)})),t}function a(t,n={}){const{filters:i={},operators:r=[]}=n,a={};return a.filters=o({},t,e.FILTERS,n),a.filters=o(a.filters,t,i,n),a.query=s(t,e.OPERATORS.concat(r),a.filters),a}e.FILTERS={$sort:t=>function(t){return"object"!=typeof t||Array.isArray(t)?t:Object.keys(t).reduce(((e,n)=>(e[n]="object"==typeof t[n]?t[n]:parseInt(t[n],10),e)),{})}(t),$limit:(t,e)=>function(t,e){if(e&&e.default){const n="number"!=typeof t||isNaN(t)?e.default:t,i="number"==typeof e.max?e.max:Number.MAX_VALUE;return Math.min(n,i)}return t}(r(t),e.paginate),$skip:t=>r(t),$select:t=>t},e.OPERATORS=["$in","$nin","$lt","$lte","$gt","$gte","$ne","$or"],e.default=a,t.exports=Object.assign(a,t.exports)}(M0,M0.exports);var $0=M0.exports,I0=Ti&&Ti.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(E0,"__esModule",{value:!0}),E0.AdapterService=void 0;const A0=YJ,N0=I0($0),R0=(t,e,...n)=>"function"!=typeof t[e]?Promise.reject(new A0.NotImplemented(`Method ${e} not available`)):t[e](...n),P0={find:!0,get:!1,update:!1};E0.AdapterService=class{constructor(t){this.options=Object.assign({id:"id",events:[],paginate:{},multi:!1,filters:[],whitelist:[]},t)}get id(){return this.options.id}get events(){return this.options.events}filterQuery(t={},e={}){const n=void 0!==t.paginate?t.paginate:this.options.paginate,{query:i={}}=t,r=Object.assign({operators:this.options.whitelist||[],filters:this.options.filters,paginate:n},e),s=(0,N0.default)(i,r);return Object.assign(s,{paginate:n})}allowsMulti(t){const e=P0[t];if(void 0!==e)return e;const n=this.options.multi;return!0===n||!1===n?n:n.includes(t)}find(t){return R0(this,"_find",t)}get(t,e){return R0(this,"_get",t,e)}create(t,e){return Array.isArray(t)&&!this.allowsMulti("create")?Promise.reject(new A0.MethodNotAllowed("Can not create multiple entries")):R0(this,"_create",t,e)}update(t,e,n){return null===t||Array.isArray(e)?Promise.reject(new A0.BadRequest("You can not replace multiple instances. Did you mean 'patch'?")):R0(this,"_update",t,e,n)}patch(t,e,n){return null!==t||this.allowsMulti("patch")?R0(this,"_patch",t,e,n):Promise.reject(new A0.MethodNotAllowed("Can not patch multiple entries"))}remove(t,e){return null!==t||this.allowsMulti("remove")?R0(this,"_remove",t,e):Promise.reject(new A0.MethodNotAllowed("Can not remove multiple entries"))}};var O0={};function L0(t){var e="[object "+t+"]";return function(t){return Object.prototype.toString.call(t)===e}}!function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.sorter=t.compare=t.compareArrays=t.compareNSB=void 0,t.compareNSB=function(t,e){return t<e?-1:t>e?1:0},t.compareArrays=function(e,n){let i,r;for(i=0;i<Math.min(e.length,n.length);i+=1)if(r=t.compare(e[i],n[i]),0!==r)return r;return t.compareNSB(e.length,n.length)},t.compare=function(e,n,i=t.compareNSB){const{compareNSB:r,compare:s,compareArrays:o}=t;if(void 0===e)return void 0===n?0:-1;if(void 0===n)return void 0===e?0:1;if(null===e)return null===n?0:-1;if(null===n)return null===e?0:1;if("number"==typeof e)return"number"==typeof n?r(e,n):-1;if("number"==typeof n)return"number"==typeof e?r(e,n):1;if("string"==typeof e)return"string"==typeof n?i(e,n):-1;if("string"==typeof n)return"string"==typeof e?i(e,n):1;if("boolean"==typeof e)return"boolean"==typeof n?r(e,n):-1;if("boolean"==typeof n)return"boolean"==typeof e?r(e,n):1;if(e instanceof Date)return n instanceof Date?r(e.getTime(),n.getTime()):-1;if(n instanceof Date)return e instanceof Date?r(e.getTime(),n.getTime()):1;if(Array.isArray(e))return Array.isArray(n)?o(e,n):-1;if(Array.isArray(n))return Array.isArray(e)?o(e,n):1;const a=Object.keys(e).sort(),l=Object.keys(n).sort();let c=0;for(let t=0;t<Math.min(a.length,l.length);t+=1)if(c=s(e[a[t]],n[l[t]]),0!==c)return c;return r(a.length,l.length)},t.sorter=function(e){const n=Object.keys(e).map((t=>({key:t,direction:e[t]})));return function(e,i){let r;for(const s of n)if(r=s.direction*t.compare(e[s.key],i[s.key]),0!==r)return r;return 0}}}(O0),function(t){var e=Ti&&Ti.__createBinding||(Object.create?function(t,e,n,i){void 0===i&&(i=n);var r=Object.getOwnPropertyDescriptor(e,n);r&&!("get"in r?!e.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,i,r)}:function(t,e,n,i){void 0===i&&(i=n),t[i]=e[n]}),n=Ti&&Ti.__exportStar||function(t,n){for(var i in t)"default"===i||Object.prototype.hasOwnProperty.call(n,i)||e(n,t,i)},i=Ti&&Ti.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(t,"__esModule",{value:!0}),t.select=t.OPERATORS=t.FILTERS=t.filterQuery=t.AdapterService=void 0;const r=y0;var s=E0;Object.defineProperty(t,"AdapterService",{enumerable:!0,get:function(){return s.AdapterService}});var o=$0;Object.defineProperty(t,"filterQuery",{enumerable:!0,get:function(){return i(o).default}}),Object.defineProperty(t,"FILTERS",{enumerable:!0,get:function(){return o.FILTERS}}),Object.defineProperty(t,"OPERATORS",{enumerable:!0,get:function(){return o.OPERATORS}}),n(O0,t),t.select=function(t,...e){const n=t&&t.query&&t.query.$select;Array.isArray(n)&&e.length&&n.push(...e);const i=t=>Array.isArray(n)?r._.pick(t,...n):t;return t=>Array.isArray(t)?t.map(i):i(t)}}(_0);var D0=L0("Array"),F0=L0("Object"),z0=L0("Function");function B0(t,e){return z0(t.get)?t.get(e):t[e]}const U0=(V0=t=>function(e,n,i,r,s){if(!D0(n)||!n.length)return t(e,n);for(var o=0,a=n.length;o<a;o++)if(t(e,B0(n,o)))return!0;return!1},(t,e,n,i,r)=>r?Boolean(r.find((([e,n,i])=>V0(t,n,i)))):V0(t,e,n,i));var V0;function W0(t){return function(e,n,i,r){if(!D0(n)||!n.length)return t(e,n,i,r);for(var s=0,o=n.length;s<o;s++)if(!t(e,B0(n,s),n,r))return!1;return!0}}function H0(t,e,n,i,r){return t.validate(t.options,e,n,i,r)}var j0={$eq:U0((function(t,e){return t(e)})),$ne:W0((function(t,e){return t(e)})),$gt:U0((function(t,e){return t(e)})),$gte:U0((function(t,e){return t(e)})),$lt:U0((function(t,e){return t(e)})),$lte:U0((function(t,e){return t(e)})),$mod:U0((function(t,e){return t(e)})),$in:(t,e)=>t(e),$nin:function(t,e){return t(e)},$not:function(t,e,n,i){return t(e,n,i)},$type:function(t,e){return t(e)},$all:function(t,e,n,i,r){return j0.$and(t,e,n,i,r)},$size:function(t,e){return!!e&&t===e.length},$or:function(t,e,n,i){for(var r=0,s=t.length;r<s;r++)if(H0(B0(t,r),e,n,i))return!0;return!1},$nor:function(t,e,n,i){return!j0.$or(t,e,n,i)},$and:function(t,e,n,i,r){if(r){for(var s=0,o=t.length;s<o;s++)if(!H0(B0(t,s),e,n,i,r))return!1}else for(s=0,o=t.length;s<o;s++)if(!H0(B0(t,s),e,n,i,r))return!1;return!0},$regex:U0((function(t,e){return"string"==typeof e&&t.test(e)})),$where:function(t,e,n,i){return t.call(e,e,n,i)},$elemMatch:function(t,e,n,i){return D0(e)?!!~function(t,e){for(var n=0;n<t.length;n++)if(B0(t,n),H0(e,B0(t,n)))return n;return-1}(e,t):H0(t,e,n,i)},$exists:function(t,e,n,i){return i.hasOwnProperty(n)===t}},G0={$eq:function(t,e,{comparable:n,compare:i}){return t instanceof RegExp?U0((function(e){return"string"==typeof e&&t.test(e)})):t instanceof Function?U0(t):D0(t)&&!t.length?U0((function(t){return D0(t)&&!t.length})):U0(null===t?function(t){return null==t}:function(e){return 0===i(n(e),n(t))})},$gt:function(t,e,{comparable:n,compare:i}){return function(e){return i(n(e),n(t))>0}},$gte:function(t,e,{comparable:n,compare:i}){return function(e){return i(n(e),n(t))>=0}},$lt:function(t,e,{comparable:n,compare:i}){return function(e){return i(n(e),n(t))<0}},$lte:function(t,e,{comparable:n,compare:i}){return function(e){return i(n(e),n(t))<=0}},$in:function(t,e,n){const{comparable:i}=n;return function(e){if(!(e instanceof Array)){var r=i(e);if(r===e&&"object"==typeof e)for(o=t.length;o--;)if(String(t[o])===String(e)&&"[object Object]"!==String(e))return!0;if(void 0===r)for(o=t.length;o--;)if(null==t[o])return!0;for(o=t.length;o--;){var s=H0(t1(B0(t,o),n),r,o,t);if(s&&"[object Object]"!==String(s)&&"[object Object]"!==String(r))return!0}return!!~t.indexOf(r)}for(var o=e.length;o--;)if(~t.indexOf(i(B0(e,o))))return!0;return!1}},$nin:function(t,e,n){const i=G0.$in(t,e,n);return function(t,e,n,r){return!i(t,e,n,r)}},$mod:function(t){return function(e){return e%t[0]==t[1]}},$ne:function(t,e,n){const i=G0.$eq(t,e,n);return W0((function(t,e,n,r){return!i(t,e,n,r)}))},$and:function(t,e,n){return t.map(Z0(n))},$all:function(t,e,n){return G0.$and(t,e,n)},$or:function(t,e,n){return t.map(Z0(n))},$nor:function(t,e,n){return t.map(Z0(n))},$not:function(t,e,n){const i=Z0(n)(t);return function(t,e,n){return!H0(i,t,e,n)}},$type:function(t){return function(e,n,i){return null!=e&&(e instanceof t||e.constructor==t)}},$regex:function(t,e){return new RegExp(t,e.$options)},$where:function(t){return"string"==typeof t?new Function("obj","return "+t):t},$elemMatch:function(t,e,n){return Z0(n)(t)},$exists:function(t){return!!t}};function q0(t,e){return{options:t,validate:e}}function X0({keyPath:t,child:e,query:n},i){const r=[];if(K0(i,t,0,i,r),1===r.length){const[t,n,i]=r[0];return H0(e,t,n,i)}return n&&n.$ne,r.map((([t])=>t)),H0(e,void 0,void 0,void 0,r)}function K0(t,e,n,i,r){if(n!==e.length&&null!=t){var s=B0(e,n);if(D0(t)&&isNaN(Number(s)))for(var o=0,a=t.length;o<a;o++)K0(B0(t,o),e,n,t,r);else K0(B0(t,s),e,n+1,t,r)}else r.push([t,e[n-1],i])}function Y0(t,e,n){return q0({keyPath:t,child:e,query:n},X0)}function Z0(t){const{comparable:e,expressions:n}=t;var i=function(t){var e;return t&&((e=t)&&(e.constructor===Object||e.constructor===Array||"function Object() { [native code] }"===e.constructor.toString()||"function Array() { [native code] }"===e.constructor.toString()))||(t={$eq:t}),t},r=function(i){i=e(i);var r=[];for(var o in i){var a=i[o];if("$options"!==o){var l=j0[o]||t&&n&&n[o];if(l)G0[o]&&(a=G0[o](a,i,t)),r.push(q0(e(a),l));else{if(36===o.charCodeAt(0))throw new Error("Unknown operation "+o);var c=o.split(".");r.push(Y0(c,s(a),a))}}}return 1===r.length?r[0]:q0(r,j0.$and)},s=function(t){return t=i(t),-1===Q0(t,[]).join(",").search(/[$.]/)?q0(t,J0):r(t)};return function(t){return r(i(t))}}function J0(t,e){if(Object.prototype.toString.call(t)!==Object.prototype.toString.call(e))return!1;if(F0(t)){if(Object.keys(t).length!==Object.keys(e).length)return!1;for(var n in t)if(!J0(t[n],e[n]))return!1;return!0}if(D0(t)){if(t.length!==e.length)return!1;for(var i=0,r=t.length;i<r;i++)if(!J0(t[i],e[i]))return!1;return!0}return t===e}function Q0(t,e){if(!F0(t))return e;for(var n in t)e.push(n),Q0(t[n],e);return e}function t1(t,e){var n=Z0(e)(t);return e&&e.select&&(n={options:n,validate:function(t,n,i,r){return H0(t,n&&e.select(n),i,r)}}),n}function e1(t,e){if(J0(t,e))return 0;if(typeof t==typeof e){if(t>e)return 1;if(t<e)return-1}}function n1(t){return t instanceof Date?t.getTime():D0(t)?t.map(n1):t&&"function"==typeof t.toJSON?t.toJSON():t}var i1=Object.freeze({__proto__:null,comparable:n1,compare:e1,default:function(t,e){var n=t1(t,e=Object.assign({compare:e1,comparable:n1},e));return function(t,e,i){return H0(n,t,e,i)}}}),r1=Ei(i1);const s1=YJ,{_:o1}=y0,{sorter:a1,select:l1,AdapterService:c1}=_0,u1=r1.default,h1=(t,...e)=>l1(...e)(JSON.parse(JSON.stringify(t)));let d1=class extends c1{constructor(t={}){super(o1.extend({id:"id",matcher:u1,sorter:a1},t)),this._uId=t.startId||0,this.store=t.store||{}}async getEntries(t={}){const{query:e}=this.filterQuery(t);return this._find(Object.assign({},t,{paginate:!1,query:e}))}async _find(t={}){const{query:e,filters:n,paginate:i}=this.filterQuery(t);let r=o1.values(this.store).filter(this.options.matcher(e));const s=r.length;void 0!==n.$sort&&r.sort(this.options.sorter(n.$sort)),void 0!==n.$skip&&(r=r.slice(n.$skip)),void 0!==n.$limit&&(r=r.slice(0,n.$limit));const o={total:s,limit:n.$limit,skip:n.$skip||0,data:r.map((e=>h1(e,t)))};return i&&i.default?o:o.data}async _get(t,e={}){if(t in this.store){const{query:n}=this.filterQuery(e),i=this.store[t];if(this.options.matcher(n)(i))return h1(i,e,this.id)}throw new s1.NotFound(`No record found for id '${t}'`)}async _create(t,e={}){if(Array.isArray(t))return Promise.all(t.map((t=>this._create(t,e))));const n=t[this.id]||this._uId++,i=o1.extend({},t,{[this.id]:n}),r=this.store[n]=i;return h1(r,e,this.id)}async _update(t,e,n={}){const i=(await this._get(t))[this.id];return t=i==t?i:t,this.store[t]=o1.extend({},e,{[this.id]:t}),this._get(t,n)}async _patch(t,e,n={}){const i=t=>{const i=t[this.id];return this.store[i]=o1.extend(this.store[i],o1.omit(e,this.id)),h1(this.store[i],n,this.id)};if(null===t){return(await this.getEntries(n)).map(i)}return i(await this._get(t,n))}async _remove(t,e={}){if(null===t){const t=await this.getEntries(e);return Promise.all(t.map((t=>this._remove(t[this.id],e))))}const n=await this._get(t,e);return delete this.store[t],n}};g0.exports=t=>new d1(t),g0.exports.Service=d1;var p1=g0.exports,f1=_i(p1),m1={exports:{}};const{Service:g1}=p1,y1=[];class b1 extends g1{constructor(t={}){if(super(t),this._storageKey=t.name||"feathers",this._storage=t.storage||"undefined"!=typeof window&&window.localStorage,this._throttle=t.throttle||200,this._reuseKeys=t.reuseKeys||!1,this.store=null,!this._storage)throw new Error("The `storage` option needs to be provided");if(-1===y1.indexOf(this._storageKey))y1.push(this._storageKey);else if(!this._reuseKeys)throw new Error(`The storage name '${this._storageKey}' is already in use by another instance.`);this.ready()}ready(){return this.store?Promise.resolve(this.store):Promise.resolve(this._storage.getItem(this._storageKey)).then((t=>JSON.parse(t||"{}"))).then((t=>{const e=Object.keys(t),n=t[e[e.length-1]];return this._uId=e.length&&void 0!==n[this.id]?n[this.id]+1:this._uId,this.store=t}))}flush(t){return this._timeout||(this._timeout=setTimeout((()=>{this._storage.setItem(this._storageKey,JSON.stringify(this.store)),delete this._timeout}),this._throttle)),t}execute(t,...e){return this.ready().then((()=>super[t](...e)))}find(...t){return this.execute("find",...t)}get(...t){return this.execute("get",...t)}create(...t){return this.execute("create",...t).then((t=>this.flush(t)))}patch(...t){return this.execute("patch",...t).then((t=>this.flush(t)))}update(...t){return this.execute("update",...t).then((t=>this.flush(t)))}remove(...t){return this.execute("remove",...t).then((t=>this.flush(t)))}}m1.exports=function(t){return new b1(t)},m1.exports.Service=b1;var v1=_i(m1.exports);let x1=~~(16777215*Math.random());const w1=parseInt((16777215*Math.random()).toString(),10);function S1(){const t=~~(Date.now()/1e3),e=Math.floor(1e5*Math.random());x1=(x1+1)%16777215;const n=x1,i=new Uint8Array(12);return i[3]=255&t,i[2]=t>>8&255,i[1]=t>>16&255,i[0]=t>>24&255,i[6]=255&w1,i[5]=w1>>8&255,i[4]=w1>>16&255,i[8]=255&e,i[7]=e>>8&255,i[11]=255&n,i[10]=n>>8&255,i[9]=n>>16&255,i.reduce(((t,e)=>t+`0${e.toString(16)}`.slice(-2)),"")}const k1=document.createElement("canvas"),C1=k1.getContext("2d"),T1=new Image;function _1(t){return new Promise(((e,n)=>{t?(T1.addEventListener("load",(()=>{k1.width=T1.width,k1.height=T1.height,null==C1||C1.drawImage(T1,0,0,k1.width,k1.height),e(null==C1?void 0:C1.getImageData(0,0,k1.width,k1.height))}),!1),T1.src=t):n()}))}function E1(t){const{data:e,service:n}=t;return t.data={[n.id]:S1(),...e},t}function M1(t){const{result:e,params:n}=t;if(e){if(e._id)e.id=e._id,delete e._id;else if(e.total&&Array.isArray(e.data))for(const[t,n]of e.data.entries())n._id&&(e.data[t].id=e.data[t]._id,delete e.data[t]._id)}else n&&n.query&&(n.query.id&&(t.params.query._id=t.params.query.id,delete t.params.query.id),n.query.$select&&n.query.$select.includes("id")&&!n.query.$select.includes("_id")&&t.params.query.$select.push("_id"));return t}function $1(t){return t.data||(t.data={}),t.data.createdAt=new Date,t.data.updatedAt=t.data.createdAt,t}function I1(t){return t.data&&t.data.createdAt?(t.data.updatedAt=new Date,t):t}function A1(t,e){return n=>{const{data:i}=n;return n.data={[t]:e,...i},n}}function N1(t,e){return n=>(n.params=n.params||{},n.params.query=n.params.query||{},n.params.query[t]=e,n)}const R1=document.createElement("canvas"),P1=R1.getContext("2d");async function O1(t){const{data:e}=t;for(const[n,i]of Object.entries(e))if(i instanceof ImageData){const e=i.width,r=i.height;R1.width=e,R1.height=r,P1.putImageData(i,0,0),t.data[n]=R1.toDataURL("image/jpeg")}return t}async function L1(t){if(!t.result)return t;const{result:e}=t,n=t=>t&&"string"==typeof t&&"data:image/jpeg;base64"===t.slice(0,22);if(e._id)for(const[t,i]of Object.entries(e).filter((([t])=>"thumbnail"!==t)))n(i)&&(e[t]=await _1(i));else if(e.total&&Array.isArray(e.data))for(const[t,i]of e.data.entries())for(const[r,s]of Object.entries(i).filter((([t])=>"thumbnail"!==t)))n(s)&&(e.data[t][r]=await _1(s));return t}async function D1(t){var e,n;if(!(null===(n=null===(e=t.params)||void 0===e?void 0:e.query)||void 0===n?void 0:n.$distinct)||"before"!==t.type||"find"!==t.method)return t;const{$distinct:i,...r}=t.params.query;r.$select=[i],r.$skip=0;let s=1;const o=new Set;for(;r.$skip<s;){const e=await t.service.find({query:r});for(const t of e.data)o.add(t[i]);r.$skip+=e.limit,s=e.total}return t.result=Array.from(o),t}function F1(t){let e;return{c(){e=IB("Register")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function z1(t){let e;return{c(){e=IB("Log In")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function B1(t){let e,n,i,r,s,o,a,l,c;return{c(){e=MB("div"),n=MB("span"),n.innerHTML='<i class="fas fa-bell"></i>',i=AB(),r=MB("span"),s=MB("b"),s.textContent="Login Error",o=AB(),a=IB(t[1]),l=AB(),c=MB("button"),c.innerHTML="<span></span>",OB(n,"class","text-xl inline-block mr-5 align-middle"),OB(s,"class","capitalize"),OB(r,"class","inline-block align-middle mr-8"),OB(c,"class","absolute bg-transparent text-2xl font-semibold leading-none right-0 top-0 mt-4 mr-6 outline-none focus:outline-none"),OB(e,"class","text-white px-6 py-4 border-0 rounded relative mb-4 bg-red-500")},m(t,u){TB(t,e,u),SB(e,n),SB(e,i),SB(e,r),SB(r,s),SB(r,o),SB(r,a),SB(e,l),SB(e,c)},p(t,e){2&e&&DB(a,t[1])},d(t){t&&_B(e)}}}function U1(t){let e;return{c(){e=IB("Register")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function V1(t){let e;return{c(){e=IB("Log In")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function W1(t){let e,n,i,r;return{c(){e=IB("Already have an account?\n        "),n=MB("button"),n.textContent="Log In",OB(n,"class","text-blue-500")},m(s,o){TB(s,e,o),TB(s,n,o),i||(r=RB(n,"click",t[2]),i=!0)},p:Jz,d(t){t&&_B(e),t&&_B(n),i=!1,r()}}}function H1(t){let e,n,i,r;return{c(){e=IB("Don't have an account?\n        "),n=MB("button"),n.textContent="Register Here",OB(n,"class","text-blue-500")},m(s,o){TB(s,e,o),TB(s,n,o),i||(r=RB(n,"click",t[2]),i=!0)},p:Jz,d(t){t&&_B(e),t&&_B(n),i=!1,r()}}}function j1(t){let e,n,i,r,s,o,a,l,c,u,h,d,p,f,m,g,y,b;function v(t,e){return"login"===t[0]?z1:F1}let x=v(t),w=x(t),S=t[1]&&B1(t);function k(t,e){return"login"===t[0]?V1:U1}let C=k(t),T=C(t);function _(t,e){return"login"===t[0]?H1:W1}let E=_(t),M=E(t);return{c(){e=MB("div"),n=MB("div"),i=MB("h2"),w.c(),r=AB(),s=MB("p"),s.textContent="This Marcelle application requires authentication.",o=AB(),S&&S.c(),a=AB(),l=MB("form"),c=MB("div"),c.innerHTML='<label class="block uppercase text-gray-700 text-xs font-bold mb-2" for="grid-password">Email</label> \n        <input type="email" name="email" class="bg-gray-200 appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500" placeholder="Email" style="transition: all 0.15s ease 0s;"/>',u=AB(),h=MB("div"),h.innerHTML='<label class="block uppercase text-gray-700 text-xs font-bold mb-2" for="grid-password">Password</label> \n        <input type="password" name="password" class="bg-gray-200 appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500" placeholder="Password" style="transition: all 0.15s ease 0s;"/>',d=AB(),p=MB("div"),f=MB("button"),T.c(),m=AB(),g=MB("p"),M.c(),OB(i,"class","text-xl"),OB(s,"class","text-gray-600"),OB(n,"class","p-4 text-center"),OB(c,"class","relative w-full mb-3"),OB(h,"class","relative w-full mb-3"),OB(f,"class","bg-gray-900 text-white active:bg-gray-700 text-sm font-bold uppercase px-6 py-3 rounded shadow hover:shadow-lg outline-none focus:outline-none mr-1 mb-1 w-full"),OB(f,"type","submit"),zB(f,"transition","all 0.15s ease 0s"),OB(p,"class","text-center mt-6"),OB(g,"class","my-4"),OB(e,"class","marcelle p-12")},m(v,x){TB(v,e,x),SB(e,n),SB(n,i),w.m(i,null),SB(n,r),SB(n,s),SB(e,o),S&&S.m(e,null),SB(e,a),SB(e,l),SB(l,c),SB(l,u),SB(l,h),SB(l,d),SB(l,p),SB(p,f),T.m(f,null),SB(e,m),SB(e,g),M.m(g,null),y||(b=RB(l,"submit",PB(t[7])),y=!0)},p(t,n){x!==(x=v(t))&&(w.d(1),w=x(t),w&&(w.c(),w.m(i,null))),t[1]?S?S.p(t,n):(S=B1(t),S.c(),S.m(e,a)):S&&(S.d(1),S=null),C!==(C=k(t))&&(T.d(1),T=C(t),T&&(T.c(),T.m(f,null))),E===(E=_(t))&&M?M.p(t,n):(M.d(1),M=E(t),M&&(M.c(),M.m(g,null)))},d(t){t&&_B(e),w.d(),S&&S.d(),T.d(),M.d(),y=!1,b()}}}function G1(t){let e,n;return e=new YU({props:{$$slots:{default:[j1]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};515&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function q1(t,e,n){const i=iU();let r,{dataStore:s}=e,{mode:o="login"}=e;function a(t){i("terminate",t)}async function l(t){const e=new FormData(t.target);try{a(await s.login(e.get("email"),e.get("password")))}catch(t){n(1,r=t)}}async function c(t){const e=new FormData(t.target);try{a(await s.signup(e.get("email"),e.get("password")))}catch(t){a(null)}}return t.$$set=t=>{"dataStore"in t&&n(5,s=t.dataStore),"mode"in t&&n(0,o=t.mode)},[o,r,function(){n(0,o="login"===o?"register":"login")},l,c,s,a,t=>"login"===o?l(t):c(t)]}class X1 extends UU{constructor(t){super(),BU(this,t,q1,G1,rB,{dataStore:5,mode:0,terminate:6})}get terminate(){return this.$$.ctx[6]}}class K1 extends pK{constructor(t,e={}){super((async function*(){const n={query:{},skip:0,take:-1,...e},i=n.take;let r=0,s=[];const o={...n.query,$skip:n.skip,$limit:10};for(;;)try{if(i>0&&r>=i)return;if(r++,s.length>0){const t=s.shift();yield t}else{const e=await t.find({query:o});if(o.$skip=e.skip+e.limit,s=e.data,!(s.length>0))return;{const t=s.shift();yield t}}}catch(t){throw t.message=`Error thrown while iterating through a service: ${t.message}`,t}})),this.service=t,this.params={query:{},skip:0,take:-1,...e}}skip(t){return new K1(this.service,{...this.params,skip:t})}take(t){return new K1(this.service,{...this.params,take:t})}select(t){const e=structuredClone(this.params);return e.query.$select=t,new K1(this.service,e)}query(t){return new K1(this.service,yK(this.params,{query:t}))}}function Y1(t){return new K1(t)}var Z1,J1,Q1,t2,e2,n2;!function(t){t[t.Memory=0]="Memory",t[t.LocalStorage=1]="LocalStorage",t[t.Remote=2]="Remote"}(n2||(n2={}));class i2{constructor(t="memory"){if(this.requiresAuth=!1,this.apiPrefix="",this.$services=new eK([],!0),Z1.set(this,void 0),J1.set(this,void 0),Q1.set(this,Promise.resolve()),t2.set(this,!1),e2.set(this,ZX),this.feathers=i0(),this.location=t,function(t){try{new URL(t)}catch(t){return!1}return!0}(t)){this.backend=n2.Remote;const e=new URL(t),n=e.host;this.apiPrefix=e.pathname.replace(/\/$/,"");const i=SJ(n,{transports:["websocket"],reconnectionAttempts:5,path:this.apiPrefix+"/socket.io"});this.feathers.configure(m0(i,{timeout:15e3})),WX(this,Z1,new Promise((t=>{this.feathers.io.on("init",(({auth:e})=>{this.requiresAuth=e,e&&this.feathers.configure(mQ()),t()}))})),"f"),WX(this,J1,new Promise(((t,e)=>{this.feathers.io.on("connect",(()=>{sK.log(`Connected to backend ${this.location}!`),t()})),this.feathers.io.on("reconnect_failed",(()=>{const t=new Error(`Cannot reach backend at location ${this.location}. Is the server running?\n          If using locally, run 'npm run backend'`);t.name="DataStore connection error",e(),cK(t,{duration:0})}))})),"f"),sK.log(`Connecting to backend ${this.location}`)}else if("localStorage"===t){this.backend=n2.LocalStorage;const t=t=>v1({storage:window.localStorage,name:t,id:"_id",multi:!0,paginate:{default:100,max:200}});WX(this,e2,(e=>{this.feathers.use(`/${e}`,t(e))}),"f")}else{if("memory"!==t)throw new Error(`Cannot process backend location '${t}'`);this.backend=n2.Memory,WX(this,e2,(t=>{this.feathers.use(`/${t}`,f1({id:"_id",paginate:{default:100,max:200}}))}),"f")}this.setupAppHooks()}async connect(){return this.backend!==n2.Remote?{email:null}:(await VX(this,Z1,"f"),await VX(this,J1,"f"),this.authenticate())}async authenticate(){if(!this.requiresAuth)return this.user={email:null},this.user;if(this.user)return this.user;const t=()=>(WX(this,t2,!0,"f"),new Promise(((t,e)=>{this.feathers.reAuthenticate().then((({user:e})=>{WX(this,t2,!1,"f"),this.user=e,sK.log(`Authenticated as ${e.email}`),t()})).catch((t=>{WX(this,t2,!1,"f"),e(t)}))})));return WX(this,Q1,VX(this,Q1,"f").then((()=>VX(this,t2,"f")?null:t())),"f"),VX(this,Q1,"f").then((()=>this.user))}async login(t,e){const n=await this.feathers.authenticate({strategy:"local",email:t,password:e});return this.user=n.user,this.user}async loginWithUI(){const t=new X1({target:document.body,props:{dataStore:this}});return new Promise(((e,n)=>{t.$on("terminate",(i=>{t.$destroy(),i?e(i):n()}))}))}async signup(t,e){try{return await this.service("users").create({email:t,password:e}),await this.login(t,e),this.user}catch(t){return sK.error("An error occurred during signup",t),{email:null}}}async logout(){await this.feathers.logout(),document.location.reload()}service(t){const e=Object.keys(this.feathers.services).includes(t);e||(VX(this,e2,"f").call(this,t),this.$services.set(Object.keys(this.feathers.services)));const n=this.feathers.service(t);return e||(n.items=()=>Y1(n)),n}async uploadAsset(t,e=""){this.backend!==n2.Remote&&cK(new Error("LocalStorage Backend does not yet support upload"));const n=t.type.split(";")[0].split("/")[1],i=e||`asset.${n}`,r=new FormData;r.append(i,t);const s={method:"POST",body:r};if(this.requiresAuth){const t=await this.feathers.authentication.getAccessToken(),e=new Headers({Authorization:`Bearer ${t}`});s.headers=e}const o=await fetch(`${this.location}/assets/upload`,s);return`/assets/${(await o.json()).blob}`}setupAppHooks(){const t=this.backend!==n2.Remote?[E1]:[],e=this.backend!==n2.Remote?[D1]:[];this.feathers.hooks({before:{find:[...e,M1],create:[...t,$1],update:[I1],patch:[I1]},after:{find:[M1],get:[M1],create:[M1],update:[M1],patch:[M1],remove:[M1]}})}}function r2(t){return new i2(t)}async function s2(t,e,n){const i=document.createElement("a");i.style.display="none",document.body.appendChild(i);const r=new Blob([t],{type:n});i.href=URL.createObjectURL(r),i.download=e,i.click()}async function o2(t){return new Promise(((e,n)=>{const i=new FileReader;i.onload=()=>{const t=JSON.parse(i.result);e(t)},i.onerror=t=>{n(t)},i.readAsText(t)}))}function a2(t){return t.replace(/([a-z])([A-Z])/g,"$1-$2").replace(/[\s_]+/g,"-").toLowerCase()}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */Z1=new WeakMap,J1=new WeakMap,Q1=new WeakMap,t2=new WeakMap,e2=new WeakMap;var l2=function(t,e){return l2=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])},l2(t,e)};function c2(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function n(){this.constructor=t}l2(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}var u2,h2,d2=function(t){var e="[object "+t+"]";return function(t){return p2(t)===e}},p2=function(t){return Object.prototype.toString.call(t)},f2=function(t){return t instanceof Date?t.getTime():m2(t)?t.map(f2):t&&"function"==typeof t.toJSON?t.toJSON():t},m2=d2("Array"),g2=d2("Object"),y2=d2("Function"),b2=function(t,e){if(null==t&&t==e)return!0;if(t===e)return!0;if(Object.prototype.toString.call(t)!==Object.prototype.toString.call(e))return!1;if(m2(t)){if(t.length!==e.length)return!1;for(var n=0,i=t.length;n<i;n++)if(!b2(t[n],e[n]))return!1;return!0}if(g2(t)){if(Object.keys(t).length!==Object.keys(e).length)return!1;for(var r in t)if(!b2(t[r],e[r]))return!1;return!0}return!1},v2=function(t,e,n,i,r,s){var o=e[i];if(m2(t)&&isNaN(Number(o)))for(var a=0,l=t.length;a<l;a++)if(!v2(t[a],e,n,i,a,t))return!1;return i===e.length||null==t?n(t,r,s,0===i):v2(t[o],e,n,i+1,o,t)},x2=function(){function t(t,e,n,i){this.params=t,this.owneryQuery=e,this.options=n,this.name=i,this.init()}return t.prototype.init=function(){},t.prototype.reset=function(){this.done=!1,this.keep=!1},t}(),w2=function(t){function e(e,n,i,r){var s=t.call(this,e,n,i)||this;return s.children=r,s}return c2(e,t),e.prototype.reset=function(){this.keep=!1,this.done=!1;for(var t=0,e=this.children.length;t<e;t++)this.children[t].reset()},e.prototype.childrenNext=function(t,e,n,i){for(var r=!0,s=!0,o=0,a=this.children.length;o<a;o++){var l=this.children[o];if(l.done||l.next(t,e,n,i),l.keep||(s=!1),l.done){if(!l.keep)break}else r=!1}this.done=r,this.keep=s},e}(x2),S2=function(t){function e(e,n,i,r,s){var o=t.call(this,e,n,i,r)||this;return o.name=s,o}return c2(e,t),e}(w2),k2=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.propop=!0,e}return c2(e,t),e.prototype.next=function(t,e,n,i){this.childrenNext(t,e,n,i)},e}(w2),C2=function(t){function e(e,n,i,r,s){var o=t.call(this,n,i,r,s)||this;return o.keyPath=e,o.propop=!0,o._nextNestedValue=function(t,e,n,i){return o.childrenNext(t,e,n,i),!o.done},o}return c2(e,t),e.prototype.next=function(t,e,n){v2(t,this.keyPath,this._nextNestedValue,0,e,n)},e}(w2),T2=function(t,e){if(t instanceof Function)return t;if(t instanceof RegExp)return function(e){var n="string"==typeof e&&t.test(e);return t.lastIndex=0,n};var n=f2(t);return function(t){return e(n,f2(t))}},_2=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.propop=!0,e}return c2(e,t),e.prototype.init=function(){this._test=T2(this.params,this.options.compare)},e.prototype.next=function(t,e,n){Array.isArray(n)&&!n.hasOwnProperty(e)||this._test(t,e,n)&&(this.done=!0,this.keep=!0)},e}(x2),E2=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.propop=!0,e}return c2(e,t),e.prototype.next=function(){this.done=!0,this.keep=!1},e}(x2),M2=function(t){return e=function(e,n,i,r){var s=typeof f2(e),o=t(e);return new _2((function(t){return typeof f2(t)===s&&o(t)}),n,i,r)},function(t,n,i,r){return null==t?new E2(t,n,i,r):e(t,n,i,r)};var e},$2=function(t,e,n,i){var r=i.operations[t];return r||I2(t),r(e,n,i,t)},I2=function(t){throw new Error("Unsupported operation: "+t)},A2=function(t,e){for(var n in t)if(e.operations.hasOwnProperty(n)||"$"===n.charAt(0))return!0;return!1},N2=function(t,e,n,i,r){if(A2(e,r)){var s=P2(e,n,r),o=s[0];if(s[1].length)throw new Error("Property queries must contain only operations, or exact objects.");return new C2(t,e,i,r,o)}return new C2(t,e,i,r,[new _2(e,i,r)])},R2=function(t,e,n){void 0===e&&(e=null);var i=void 0===n?{}:n,r=i.compare,s=i.operations,o={compare:r||b2,operations:Object.assign({},s||{})},a=P2(t,null,o),l=a[0],c=a[1],u=[];return l.length&&u.push(new C2([],t,e,o,l)),u.push.apply(u,c),1===u.length?u[0]:new k2(t,e,o,u)},P2=function(t,e,n){var i,r=[],s=[];if(!(i=t)||i.constructor!==Object&&i.constructor!==Array&&"function Object() { [native code] }"!==i.constructor.toString()&&"function Array() { [native code] }"!==i.constructor.toString()||i.toJSON)return r.push(new _2(t,t,n)),[r,s];for(var o in t)if(n.operations.hasOwnProperty(o)){var a=$2(o,t[o],t,n);if(a&&!a.propop&&e&&!n.operations[e])throw new Error("Malformed query. "+o+" cannot be matched against property.");null!=a&&r.push(a)}else"$"===o.charAt(0)?I2(o):s.push(N2(o.split("."),t[o],o,t,n));return[r,s]},O2=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.propop=!0,e}return c2(e,t),e.prototype.init=function(){this._test=T2(this.params,this.options.compare)},e.prototype.reset=function(){t.prototype.reset.call(this),this.keep=!0},e.prototype.next=function(t){this._test(t)&&(this.done=!0,this.keep=!1)},e}(x2),L2=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.propop=!0,e}return c2(e,t),e.prototype.init=function(){if(!this.params||"object"!=typeof this.params)throw new Error("Malformed query. $elemMatch must by an object.");this._queryOperation=R2(this.params,this.owneryQuery,this.options)},e.prototype.reset=function(){t.prototype.reset.call(this),this._queryOperation.reset()},e.prototype.next=function(t){if(m2(t)){for(var e=0,n=t.length;e<n;e++){this._queryOperation.reset();var i=t[e];this._queryOperation.next(i,e,t,!1),this.keep=this.keep||this._queryOperation.keep}this.done=!0}else this.done=!1,this.keep=!1},e}(x2),D2=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.propop=!0,e}return c2(e,t),e.prototype.init=function(){this._queryOperation=R2(this.params,this.owneryQuery,this.options)},e.prototype.reset=function(){t.prototype.reset.call(this),this._queryOperation.reset()},e.prototype.next=function(t,e,n,i){this._queryOperation.next(t,e,n,i),this.done=this._queryOperation.done,this.keep=!this._queryOperation.keep},e}(x2),F2=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.propop=!0,e}return c2(e,t),e.prototype.init=function(){},e.prototype.next=function(t){m2(t)&&t.length===this.params&&(this.done=!0,this.keep=!0)},e}(x2),z2=function(t){if(0===t.length)throw new Error("$and/$or/$nor must be a nonempty array")},B2=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.propop=!1,e}return c2(e,t),e.prototype.init=function(){var t=this;z2(this.params),this._ops=this.params.map((function(e){return R2(e,null,t.options)}))},e.prototype.reset=function(){this.done=!1,this.keep=!1;for(var t=0,e=this._ops.length;t<e;t++)this._ops[t].reset()},e.prototype.next=function(t,e,n){for(var i=!1,r=!1,s=0,o=this._ops.length;s<o;s++){var a=this._ops[s];if(a.next(t,e,n),a.keep){i=!0,r=a.keep;break}}this.keep=r,this.done=i},e}(x2),U2=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.propop=!1,e}return c2(e,t),e.prototype.next=function(e,n,i){t.prototype.next.call(this,e,n,i),this.keep=!this.keep},e}(B2),V2=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.propop=!0,e}return c2(e,t),e.prototype.init=function(){var t=this;this._testers=this.params.map((function(e){if(A2(e,t.options))throw new Error("cannot nest $ under "+t.name.toLowerCase());return T2(e,t.options.compare)}))},e.prototype.next=function(t,e,n){for(var i=!1,r=!1,s=0,o=this._testers.length;s<o;s++){if((0,this._testers[s])(t)){i=!0,r=!0;break}}this.keep=r,this.done=i},e}(x2),W2=function(t){function e(e,n,i,r){var s=t.call(this,e,n,i,r)||this;return s.propop=!0,s._in=new V2(e,n,i,r),s}return c2(e,t),e.prototype.next=function(t,e,n,i){this._in.next(t,e,n),m2(n)&&!i?this._in.keep?(this.keep=!1,this.done=!0):e==n.length-1&&(this.keep=!0,this.done=!0):(this.keep=!this._in.keep,this.done=!0)},e.prototype.reset=function(){t.prototype.reset.call(this),this._in.reset()},e}(x2),H2=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.propop=!0,e}return c2(e,t),e.prototype.next=function(t,e,n){n.hasOwnProperty(e)===this.params&&(this.done=!0,this.keep=!0)},e}(x2),j2=function(t){function e(e,n,i,r){var s=t.call(this,e,n,i,e.map((function(t){return R2(t,n,i)})),r)||this;return s.propop=!1,z2(e),s}return c2(e,t),e.prototype.next=function(t,e,n,i){this.childrenNext(t,e,n,i)},e}(S2),G2=function(t){function e(e,n,i,r){var s=t.call(this,e,n,i,e.map((function(t){return R2(t,n,i)})),r)||this;return s.propop=!0,s}return c2(e,t),e.prototype.next=function(t,e,n,i){this.childrenNext(t,e,n,i)},e}(S2),q2=M2((function(t){return function(e){return e<t}})),X2=M2((function(t){return function(e){return e<=t}})),K2=M2((function(t){return function(e){return e>t}})),Y2=M2((function(t){return function(e){return e>=t}})),Z2={number:function(t){return"number"==typeof t},string:function(t){return"string"==typeof t},bool:function(t){return"boolean"==typeof t},array:function(t){return Array.isArray(t)},null:function(t){return null===t},timestamp:function(t){return t instanceof Date}},J2=Object.freeze({__proto__:null,$Size:F2,$eq:function(t,e,n){return new _2(t,e,n)},$ne:function(t,e,n,i){return new O2(t,e,n,i)},$or:function(t,e,n,i){return new B2(t,e,n,i)},$nor:function(t,e,n,i){return new U2(t,e,n,i)},$elemMatch:function(t,e,n,i){return new L2(t,e,n,i)},$nin:function(t,e,n,i){return new W2(t,e,n,i)},$in:function(t,e,n,i){return new V2(t,e,n,i)},$lt:q2,$lte:X2,$gt:K2,$gte:Y2,$mod:function(t,e,n){var i=t[0],r=t[1];return new _2((function(t){return f2(t)%i===r}),e,n)},$exists:function(t,e,n,i){return new H2(t,e,n,i)},$regex:function(t,e,n){return new _2(new RegExp(t,e.$options),e,n)},$not:function(t,e,n,i){return new D2(t,e,n,i)},$type:function(t,e,n){return new _2((function(e){if("string"==typeof t){if(!Z2[t])throw new Error("Type alias does not exist");return Z2[t](e)}return null!=e&&(e instanceof t||e.constructor===t)}),e,n)},$and:function(t,e,n,i){return new j2(t,e,n,i)},$all:function(t,e,n,i){return new G2(t,e,n,i)},$size:function(t,e,n){return new F2(t,e,n,"$size")},$options:function(){return null},$where:function(t,e,n){var i;if(y2(t))i=t;else{if(process.env.CSP_ENABLED)throw new Error('In CSP mode, sift does not support strings in "$where" condition');i=new Function("obj","return "+t)}return new _2((function(t){return i.bind(t)(t)}),e,n)}}),Q2=function(t,e){void 0===e&&(e={});var n,i=function(t,e,n){var i=void 0===n?{}:n,r=i.compare,s=i.operations;return R2(t,e,{compare:r,operations:Object.assign({},J2,s||{})})}(t,null,e);return n=i,function(t,e,i){return n.reset(),n.next(t,e,i),n.keep}};let t3=class extends xK{constructor(t,e=r2()){super(),this.title="dataset",this.isDataset=!0,u2.set(this,void 0),this.query={},h2.set(this,new Set),this.$count=new eK(0,!0),this.$changes=new eK([]),this.name=t,this.title=`dataset (${t})`,WX(this,u2,e,"f"),this.start(),this.ready=new Promise(((e,n)=>{VX(this,u2,"f").connect().then((()=>this.setup())).then(e).catch((e=>{const i=new Error(null==e?void 0:e.message);i.name=`Dataset Error (${t}): datastore connection failed`,cK(i,{duration:0}),n(i)}))}))}async setup(){const t=a2(`instances-${this.name}`);this.instanceService=VX(this,u2,"f").service(t),void 0===this.instanceService.__hooks.before.find&&this.instanceService.hooks({before:{all:[],create:[A1("datasetName",this.name),O1],find:[N1("datasetName",this.name)],get:[N1("datasetName",this.name)],update:[N1("datasetName",this.name)],patch:[N1("datasetName",this.name)],remove:[N1("datasetName",this.name)]},after:{find:[L1],get:[L1]}}),this.instanceService.hooks({before:{update:[this.checkUpdates],patch:[this.checkUpdates]}}),await this.reset(),this.watchChanges()}async reset(){const{total:t}=await this.find({query:{...this.query,$limit:0}});this.$count.set(t),this.$changes.set([{level:"dataset",type:"created"}])}async checkUpdates(t){if(0===Object.keys(this.query).length)return;const e=Q2(this.query),n=e(t.data);try{const i=await this.get(t.id);e(i)&&!n&&(this.$count.set(this.$count.get()-1),this.$changes.set([{level:"instance",type:"removed",data:i}]))}catch(e){VX(this,h2,"f").add(t.id)}}watchChanges(){const t=Q2(this.query);this.instanceService.on("created",(e=>{if(!t(e))return;const n={...e,id:e.id||e._id};this.$count.set(this.$count.get()+1),this.$changes.set([{level:"instance",type:"created",data:n}])}));const e=e=>{if(!t(e))return;const n={...e,id:e.id||e._id};VX(this,h2,"f").has(n.id)?(this.$count.set(this.$count.get()+1),this.$changes.set([{level:"instance",type:"created",data:n}]),VX(this,h2,"f").delete(n.id)):this.$changes.set([{level:"instance",type:"updated",data:n}])};this.instanceService.on("updated",e),this.instanceService.on("patched",e),this.instanceService.on("removed",(e=>{if(!t(e))return;this.$count.set(this.$count.get()-1);const n={...e,id:e.id||e._id};this.$changes.set([{level:"instance",type:"removed",data:n}])}))}async sift(t={}){return this.query=t,this.ready.then((()=>this.reset()))}items(){return this.instanceService.items().query(this.query)}async find(t){const e=yK(t||{},{query:this.query});return this.instanceService.find(e)}async get(t,e){const n=yK(e||{},{query:this.query});return this.instanceService.get(t,n)}async create(t,e){const n=yK(e||{},{query:this.query});return this.instanceService.create(t,n)}async update(t,e,n){const i=yK(n||{},{query:this.query});return this.instanceService.update(t,e,i)}async patch(t,e,n){const i=yK(n||{},{query:this.query});return this.instanceService.patch(t,e,i)}async remove(t,e){const n=yK(e||{},{query:this.query});return this.instanceService.remove(t,n)}async clear(){await this.remove(null,{query:{}})}async distinct(t){const e={$distinct:t,...this.query};return this.instanceService.find({query:e})}async download(){const t={marcelleMeta:{type:"dataset"},instances:(await this.find()).data},e=new Date(Date.now()),n=`${this.title}-${e.toISOString()}.json`;await s2(JSON.stringify(t),n,"text/plain")}async upload(t){const e=t.filter((t=>"application/json"===t.type)).map((t=>o2(t))),n=(await Promise.all(e)).map((t=>t.instances.map((t=>{const{id:e,...n}=t;return this.create(n).catch((t=>{cK(t)}))}))));await Promise.all(n)}mount(){}};function e3(t,e){return new t3(t,e)}function n3(t){return"object"==typeof t&&null!==t&&t.isDataset}u2=new WeakMap,h2=new WeakMap;class i3 extends xK{constructor(){super(),this.ready=!1,this.$training=new eK({status:"idle"},!0),this.$training.start(),this.$training.subscribe((({status:t})=>{"success"!==t&&"loaded"!==t||(this.ready=!0)}))}sync(t,e){return this.syncData={name:e,store:t},this.syncData.store.connect().then((()=>{this.syncData.service=this.syncData.store.service(this.serviceName),this.setupSync()})).catch((t=>{const n=new Error(null==t?void 0:t.message);n.name=`Model Sync Error (${e}): datastore connection failed`,cK(n,{duration:0})})),this}async setupSync(){if(!this.syncData.service)return;const{data:t}=await this.syncData.service.find({query:{name:this.syncData.name,$select:["id"],$limit:1,$sort:{updatedAt:-1}}});let e=null;1===t.length&&(e=t[0].id,this.load(this.syncData.store,e));let n=!1;this.$training.subscribe((({status:t,data:i})=>{("success"===t||"loaded"===t&&"datastore"!==(null==i?void 0:i.source))&&(n=!0,this.save(this.syncData.store,this.syncData.name,{},e).then((t=>{e=t})))}));const i=t=>{(t._id===e||!e&&t.name===this.syncData.name)&&(e=t._id,n||this.load(this.syncData.store,e),n=!1)};this.syncData.service.on("created",i),this.syncData.service.on("updated",i),this.syncData.service.on("patched",i)}async saveToDatastore(t,e,n=null){await t.connect();const i=t.service(this.serviceName);if(!i)return null;if(!e)return null;let r=n;if(n)await i.update(n,e);else{r=(await i.create(e)).id}return sK.info(`Model was saved to data store at location ${t.location}`),r}async loadFromDatastore(t,e){await t.connect();const n=t.service(this.serviceName);if(!n||!e)return null;let i;try{i=await n.get(e)}catch(t){const{data:r}=await n.find({query:{name:e,$limit:1,$sort:{updatedAt:-1}}});1===r.length&&(i=r[0])}if(i){const e=i.name;sK.info(`Model ${e} was loaded from data store at location ${t.location}`)}return i}mount(){}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
var r3,s3;Y().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"}(r3||(r3={})),function(t){var e;(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(s3||(s3={}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const o3={};function a3(t){return o3[t]}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function l3(t,e,n,i,r){const s=e.inputParams[t];if(s&&void 0!==s.inputIndexStart){const t=s.inputIndexStart,o=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?t+1:s.inputIndexEnd,a=t<0?e.inputNames.length+t:t;if("tensor"===s.type)return c3(e.inputNames[a],n,i,r);if("tensors"===s.type){const s=e.inputs.slice(t,o),a=e.inputNames.slice(t,o).filter(((t,e)=>{var n;return"NoOp"!==(null===(n=s[e])||void 0===n?void 0:n.op)}));return a.map((t=>c3(t,n,i,r)))}const l=c3(e.inputNames[a],n,i,r),c=l.dataSync();return"number"===s.type?c[0]:F(l.shape,c)}const o=e.attrParams[t];return o&&o.value}function c3(t,e,n,i){const[r,s]=p3(t,n);if(null!=i){const t=i.getHashTableHandleByName(r);if(null!=t)return t}const o=n.currentContextIds.find((t=>!!e[d3(r,t)]));return void 0!==o?e[d3(r,o)][s]:void 0}function u3(t,e,n){return e[d3(t,n.currentContextId)]}function h3(t,e){const[n,i,r]=p3(t,e);return[d3(n,e&&e.currentContextId),i,r]}function d3(t,e){return e?`${t}-${e}`:t}function p3(t,e){if(""===t)return["",0,void 0];const n=null!=e&&null!=e.parseNodeNameCache;if(n){const n=e.parseNodeNameCache.get(t);if(null!=n)return n}const i=t.split(":");let r;if(1===i.length)r=[t,0,void 0];else{const t=i[0],e=3===i.length?i[1]:void 0;r=[t,Number(i[i.length-1]),e]}return n&&e.parseNodeNameCache.set(t,r),r}function f3(t,e,n){let i=l3("pad",t,e,n);if("explicit"===i){i=l3("explicitPaddings",t,e,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let t=0;t<4;t++)r[t][0]=i[2*t],r[t][1]=i[2*t+1];return r}return i}function m3(t){return t.kept?t:xo(t)}
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var g3=Object.freeze({__proto__:null,json:[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var y3=Object.freeze({__proto__:null,json:[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var b3=Object.freeze({__proto__:null,json:[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var v3=Object.freeze({__proto__:null,json:[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var x3=Object.freeze({__proto__:null,json:[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var w3=Object.freeze({__proto__:null,json:[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var S3=Object.freeze({__proto__:null,json:[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var k3=Object.freeze({__proto__:null,json:[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var C3=Object.freeze({__proto__:null,json:[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var T3=Object.freeze({__proto__:null,json:[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var _3=Object.freeze({__proto__:null,json:[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var E3=Object.freeze({__proto__:null,json:[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var M3=Object.freeze({__proto__:null,json:[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var $3=Object.freeze({__proto__:null,json:[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var I3=Object.freeze({__proto__:null,json:[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var A3=Object.freeze({__proto__:null,json:[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var N3=Object.freeze({__proto__:null,json:[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var R3=Object.freeze({__proto__:null,json:[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}]});
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var P3=Object.freeze({__proto__:null,json:[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}]});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O3{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[].concat(...[g3,y3,b3,v3,x3,w3,S3,k3,C3,T3,_3,E3,M3,$3,I3,A3,N3,R3,P3].map((t=>t.json)));this.opMappers=t.reduce(((t,e)=>(t[e.tfOpName]=e,t)),{})}transformGraph(t,e={}){const n=t.node,i=[],r=[],s=[],o=n.reduce(((t,e)=>(t[e.name]=this.mapNode(e),e.op.startsWith("Placeholder")?i.push(t[e.name]):"Const"===e.op?r.push(t[e.name]):null!=e.input&&0!==e.input.length||s.push(t[e.name]),t)),{});let a=[];const l=[];let c={},u={};null!=e&&(c=this.mapSignatureEntries(e.inputs),u=this.mapSignatureEntries(e.outputs));const h=Object.keys(o);h.forEach((t=>{const e=o[t];e.inputNames.forEach(((t,n)=>{const[i,,r]=h3(t),s=o[i];if(null!=s.outputs){const t=s.outputs.indexOf(r);if(-1!==t){const r=`${i}:${t}`;e.inputNames[n]=r}}e.inputs.push(s),s.children.push(e)}))})),0===Object.keys(u).length?h.forEach((t=>{const e=o[t];0===e.children.length&&l.push(e)})):Object.keys(u).forEach((t=>{const[e]=h3(t),n=o[e];null!=n&&(n.signatureKey=u[t],l.push(n))})),Object.keys(c).length>0?Object.keys(c).forEach((t=>{const[e]=h3(t),n=o[e];n&&(n.signatureKey=c[t],a.push(n))})):a=i;let d={};null!=t.library&&null!=t.library.function&&(d=t.library.function.reduce(((t,e)=>(t[e.signature.name]=this.mapFunction(e),t)),{}));const p={nodes:o,inputs:a,outputs:l,weights:r,placeholders:i,signature:e,functions:d};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(t){return Object.keys(t||{}).reduce(((e,n)=>(e[t[n].name]=n,e)),{})}mapNode(t){const e=a3(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const n={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map((t=>t.startsWith("^")?t.slice(1):t)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return null!=e.inputs&&(n.inputParams=e.inputs.reduce(((t,e)=>(t[e.name]={type:e.type,inputIndexStart:e.start,inputIndexEnd:e.end},t)),{})),null!=e.attrs&&(n.attrParams=e.attrs.reduce(((e,n)=>{const i=n.type;let r;switch(n.type){case"string":r=D3(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=D3(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=q3(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=q3(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=z3(t.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=z3(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=G3(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=G3(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=F3(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=F3(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=K3(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=K3(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=j3(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=j3(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=X3(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=X3(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=V3(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=V3(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=W3(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=W3(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=U3(t.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=U3(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${t.op}`)}return e[n.name]={value:r,type:i},e}),{})),n}mapFunction(t){const e=t.nodeDef,n=[];let i={};null!=e&&(i=e.reduce(((t,e)=>(t[e.name]=this.mapNode(e),"Const"===e.op&&n.push(t[e.name]),t)),{}));const r=[],s=[];t.signature.inputArg.forEach((t=>{const[e]=h3(t.name),n={name:e,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:B3(t.type),type:"dtype"}},children:[]};n.signatureKey=t.name,r.push(n),i[e]=n}));Object.keys(i).forEach((t=>{const e=i[t];e.inputNames.forEach(((t,n)=>{const[r,,s]=h3(t),o=i[r];if(null!=o.outputs){const t=o.outputs.indexOf(s);if(-1!==t){const i=`${r}:${t}`;e.inputNames[n]=i}}e.inputs.push(o),o.children.push(e)}))}));const o=t.ret;t.signature.outputArg.forEach((t=>{const[e,n]=h3(o[t.name]),r=i[e];null!=r&&(r.defaultOutput=n,s.push(r))}));const a=this.mapArgsToSignature(t);return{nodes:i,inputs:r,outputs:s,weights:n,placeholders:[],signature:a}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce(((t,e)=>(t[e.name]=this.mapArgToTensorInfo(e),t)),{}),outputs:t.signature.outputArg.reduce(((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n,t.ret),e)),{})}}mapArgToTensorInfo(t,e){let n=t.name;return null!=e&&(n=e[n]),{name:n,dtype:t.type}}}function L3(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):function(t){const e=Y().global;if(void 0!==e.atob)return e.atob(t);if("undefined"!=typeof Buffer)return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(t);return e?n:n.toLowerCase()}function D3(t,e,n,i=!1){const r=t[e];return null!=r?L3(r.s,i):n}function F3(t,e,n){const i=t[e];return i?i.b:n}function z3(t,e,n){const i=t[e]||{},r=null!=i.i?i.i:null!=i.f?i.f:n;return"number"==typeof r?r:parseInt(r,10)}function B3(t){switch("string"==typeof t&&(t=r3[t]),t){case r3.DT_FLOAT:case r3.DT_HALF:return"float32";case r3.DT_INT32:case r3.DT_INT64:case r3.DT_INT8:case r3.DT_UINT8:return"int32";case r3.DT_BOOL:return"bool";case r3.DT_DOUBLE:return"float32";case r3.DT_STRING:return"string";default:return null}}function U3(t,e,n){const i=t[e];return i&&i.func?i.func.name:n}function V3(t,e,n){const i=t[e];return i&&i.type?B3(i.type):n}function W3(t,e,n){const i=t[e];return i&&i.list&&i.list.type?i.list.type.map((t=>B3(t))):n}function H3(t){if(!t.unknownRank)return null!=t.dim?t.dim.map((t=>"number"==typeof t.size?t.size:parseInt(t.size,10))):[]}function j3(t,e,n){const i=t[e];return i&&i.shape?H3(i.shape):n}function G3(t,e,n){const i=t[e];return i?((i.list.f&&i.list.f.length?i.list.f:i.list.i)||[]).map((t=>"number"==typeof t?t:parseInt(t,10))):n}function q3(t,e,n,i=!1){const r=t[e];return r&&r.list&&r.list.s?r.list.s.map((t=>L3(t,i))):n}function X3(t,e,n){const i=t[e];return i&&i.list&&i.list.shape?i.list.shape.map((t=>H3(t))):n}function K3(t,e,n){const i=t[e];return i&&i.list&&i.list.b?i.list.b:n}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y3{constructor(t,e,n){this.node=t,this.tensorMap=e,this.context=n,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map((t=>this.getInput(t))),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce(((t,e)=>(t[e]=this.getAttr(e),t)),{}))}getInput(t){return c3(t,this.tensorMap,this.context)}getAttr(t,e){const n=this.node.rawAttrs[t];if(null!=n.tensor)return c3(t,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return z3(this.node.rawAttrs,t,e);if(null!=n.s)return D3(this.node.rawAttrs,t,e);if(null!=n.b)return F3(this.node.rawAttrs,t,e);if(null!=n.shape)return j3(this.node.rawAttrs,t,e);if(null!=n.type)return V3(this.node.rawAttrs,t,e);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return G3(this.node.rawAttrs,t,e);if(null!=n.list.s)return q3(this.node.rawAttrs,t,e);if(null!=n.list.shape)return X3(this.node.rawAttrs,t,e);if(null!=n.list.b)return K3(this.node.rawAttrs,t,e);if(null!=n.list.type)return W3(this.node.rawAttrs,t,e)}return e}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Z3=Object.freeze({__proto__:null,OP_SCOPE_SUFFIX:gs,abs:Oo,acos:Lo,acosh:Do,add:Ao,addN:Fo,all:zo,any:Bo,argMax:Uo,argMin:Vo,asin:Wo,asinh:Ho,atan:jo,atan2:Go,atanh:qo,avgPool:ua,avgPool3d:ha,basicLSTMCell:ya,batchNorm:va,batchNorm2d:xa,batchNorm3d:wa,batchNorm4d:Sa,batchToSpaceND:ba,bincount:ka,bitwiseAnd:Ca,booleanMaskAsync:kh,broadcastArgs:Ta,broadcastTo:_a,buffer:bo,cast:vo,ceil:Ea,clipByValue:$a,clone:xo,complex:bs,concat:da,concat1d:Ia,concat2d:Aa,concat3d:Na,concat4d:Ra,conv1d:Oa,conv2d:Pa,conv2dTranspose:Da,conv3d:Fa,conv3dTranspose:Ba,cos:Ua,cosh:Va,cosineWindow:Ah,cumprod:Wa,cumsum:Ha,denseBincount:ja,depthToSpace:Ga,depthwiseConv2d:qa,diag:Xa,dilation2d:Ka,div:Ro,divNoNan:il,dot:rl,dropout:$h,einsum:sl,elu:ol,enclosingPowerOfTwo:Ih,ensureShape:al,equal:tl,erf:ll,euclideanNorm:_l,exp:El,expandDims:Ml,expm1:$l,eye:Al,fft:Gu,fill:Ma,floor:Nl,floorDiv:No,fused:Wh,gather:Rl,gatherND:Mh,greater:Pl,greaterEqual:Ol,ifft:qu,imag:Ll,image:Bd,inTopKAsync:Nh,irfft:Xu,isFinite:Dl,isInf:Fl,isNaN:zl,leakyRelu:Bl,less:Ul,lessEqual:Vl,linalg:Ud,linspace:Wl,localResponseNormalization:Hl,log:jl,log1p:Gl,logSigmoid:Jl,logSoftmax:tc,logSumExp:ec,logicalAnd:nc,logicalNot:ic,logicalOr:rc,logicalXor:sc,losses:Vd,lowerBound:lc,matMul:pa,max:yl,maxPool:cc,maxPool3d:uc,maxPoolWithArgmax:hc,maximum:dc,mean:pc,meshgrid:gc,min:bl,minimum:yc,mirrorPad:bc,mod:vc,moments:xc,movingAverage:Th,mul:Po,multiRNNCell:wc,multinomial:Sc,neg:Yl,norm:Tl,notEqual:kc,oneHot:Cc,ones:mc,onesLike:Tc,op:ys,outerProduct:_c,pad:Ec,pad1d:Mc,pad2d:$c,pad3d:Ic,pad4d:Ac,pool:Rc,pow:vl,prelu:Pc,print:wo,prod:Oc,raggedGather:Lc,raggedRange:Dc,raggedTensorToTensor:Fc,rand:zc,randomGamma:bu,randomNormal:vu,randomStandardNormal:xu,randomUniform:wu,randomUniformInt:Su,range:ku,real:Cu,reciprocal:Tu,relu:_u,relu6:Eu,reshape:ca,reverse:Mu,reverse1d:$u,reverse2d:Iu,reverse3d:Au,reverse4d:Nu,rfft:Yu,round:Ru,rsqrt:Pu,scalar:xl,scatterND:_h,searchSorted:ac,selu:Ou,separableConv2d:Lu,setdiff1dAsync:Du,sigmoid:fa,sign:Fu,signal:zd,sin:zu,sinh:Bu,slice:ma,slice1d:Uu,slice2d:Vu,slice3d:Wu,slice4d:Hu,softmax:ju,softplus:Zl,spaceToBatchND:Nc,sparse:Wd,sparseToDense:Eh,spectral:Fd,split:Ku,sqrt:wl,square:Sl,squaredDifference:Zu,squeeze:Ju,stack:Qu,step:th,stridedSlice:eh,string:Hd,sub:Ql,sum:kl,tan:nh,tanh:ga,tensor:xs,tensor1d:ih,tensor2d:rh,tensor3d:sh,tensor4d:oh,tensor5d:ah,tensor6d:lh,tensorScatterUpdate:ph,tile:Il,topk:fh,transpose:Ch,truncatedNormal:mh,unique:gh,unsortedSegmentSum:yh,unstack:bh,upperBound:vh,variable:xh,where:el,whereAsync:Sh,zeros:fc,zerosLike:nl});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function J3(t,e,n=""){if("number"!=typeof t&&"number"!=typeof e){c(t.length===e.length,(()=>n+` Shapes ${t} and ${e} must match`));for(let i=0;i<t.length;i++){const r=t[i],s=e[i];c(r<0||s<0||r===s,(()=>n+` Shapes ${t} and ${e} must match`))}}}function Q3(t){return"number"!=typeof t&&!t.some((t=>t<0))}function t4(t,e,n){let i=e4(t,n);const r=!Q3(i);if(r&&0===e.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${i}`);if(r&&e.forEach((t=>{i=e4(t.shape,i)})),!Q3(i))throw new Error(`Non-fully-defined elementShape: ${i}`);return i}function e4(t,e){if("number"==typeof t)return e;if("number"==typeof e)return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let i=0;i<t.length;++i){const r=t[i],s=e[i];if(r>=0&&s>=0&&r!==s)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[i]=r>=0?r:s}return n}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n4{constructor(t,e,n,i,r,s,o){this.name=t,this.dtype=e,this.maxSize=n,this.elementShape=i,this.identicalElementShapes=r,this.dynamicSize=s,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=xl(0),_o(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach((e=>{null!=t&&t.has(e.tensor.id)||e.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map((t=>this.read(t)))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=e.shape),J3(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,_o(e),n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach(((t,n)=>this.write(t,e[n])))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let e=0;e<this.size();e++)t.push(e)}if(0===t.length)return xs([],[0].concat(this.elementShape));const n=this.readMany(t);return J3(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Qu(n,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return xs([],[0].concat(this.elementShape));const e=[];for(let t=0;t<this.size();t++)e.push(t);const n=this.readMany(e);return J3(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),da(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,bh(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0;const i=t.map((t=>(n+=t,n)));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const r=0===n?0:e.size/n,s=[];Co((()=>{e=ca(e,[1,n,r]);for(let n=0;n<t.length;++n){const o=[0,0===n?0:i[n-1],0],a=[1,t[n],r];s[n]=ca(ma(e,o,a),this.elementShape)}return s}));const o=[];for(let e=0;e<t.length;e++)o[e]=e;this.writeMany(o,s)}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i4{get id(){return this.idTensor.id}constructor(t,e,n,i=-1){this.tensors=t,this.elementShape=e,this.elementDtype=n,null!=t&&t.forEach((t=>{if(n!==t.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${t.dtype}`);J3(e,t.shape,"TensorList shape mismatch: "),_o(t)})),this.idTensor=xl(0),this.maxNumElements=i,_o(this.idTensor)}copy(){return new i4([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach((e=>{null!=t&&t.has(e.id)||e.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,n=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);J3(t,this.elementShape,"TensorList shape mismatch: ");const i=t4(this.elementShape,this.tensors,t);return Co((()=>{const t=this.tensors.map((t=>ca(t,i)));return Qu(t,0)}))}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=t4(this.elementShape,this.tensors,t),i=this.tensors.pop();return i.kept=!1,J3(i.shape,t,"TensorList shape mismatch: "),ca(i,n)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(J3(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");_o(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new i4([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let n=0;n<Math.min(this.tensors.length,t);++n)e.tensors[n]=this.tensors[n];return e}getItem(t,e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);J3(this.tensors[t].shape,e,"TensorList shape mismatch: ");const i=t4(this.elementShape,this.tensors,e);return ca(this.tensors[t],i)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);J3(this.elementShape,e.shape,"TensorList shape mismatch: "),_o(e),null!=this.tensors[t]&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,n){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);J3(this.elementShape,n,"TensorList shape mismatch: "),t=t.slice(0,this.size());const i=t4(this.elementShape,this.tensors,n);return 0===t.length?xs([],[0].concat(i)):Co((()=>{const e=t.map((t=>ca(this.tensors[t],i)));return Qu(e,0)}))}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);J3(this.elementShape,e,"TensorList shape mismatch: ");const n=t4(this.elementShape,this.tensors,e);return 0===this.size()?xs([],[0].concat(n)):Co((()=>{const t=this.tensors.map((t=>ca(t,n)));return da(t,0)}))}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r4=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const i=l3("thenBranch",t,e,n),r=l3("elseBranch",t,e,n),s=l3("cond",t,e,n),o=l3("args",t,e,n);return(await s.data())[0]?n.functionMap[i].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const i=l3("body",t,e,n),r=l3("cond",t,e,n),s=l3("args",t,e,n),o=await n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),a=s.map((t=>t.id));let l=await o[0].data();o.forEach((t=>{t.kept||-1!==a.indexOf(t.id)||t.dispose()}));let c=s;for(;l[0];){const t=c;c=await n.functionMap[i].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);const e=c.map((t=>t.id));t.forEach((t=>{t.kept||-1!==a.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()}));const s=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);l=await s[0].data(),s.forEach((t=>{t.kept||-1!==a.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()}))}return c}case"LoopCond":return[m3(l3("pred",t,e,n))];case"Switch":{const i=l3("pred",t,e,n);let r=l3("data",t,e,n);return r.kept||(r=m3(r)),(await i.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const i=t.inputNames.find((t=>void 0!==c3(t,e,n)));if(i){return[m3(c3(i,e,n))]}return}case"Enter":{const i=l3("frameName",t,e,n),r=l3("tensor",t,e,n);return n.enterFrame(i),[m3(r)]}case"Exit":{const i=l3("tensor",t,e,n);return n.exitFrame(),[m3(i)]}case"NextIteration":{const i=l3("tensor",t,e,n);return n.nextIteration(),[m3(i)]}case"TensorArrayV3":{const i=l3("size",t,e,n),r=l3("dtype",t,e,n),s=l3("elementShape",t,e,n),o=l3("dynamicSize",t,e,n),a=l3("clearAfterRead",t,e,n),l=l3("identicalElementShapes",t,e,n),c=l3("name",t,e,n),u=new n4(c,r,i,s,l,o,a);return n.addTensorArray(u),[u.idTensor,xl(1)]}case"TensorArrayWriteV3":{const i=l3("tensorArrayId",t,e,n),r=l3("index",t,e,n),s=l3("tensor",t,e,n),o=n.getTensorArray(i.id);return o.write(r,s),[o.idTensor]}case"TensorArrayReadV3":{const i=l3("tensorArrayId",t,e,n),r=l3("index",t,e,n);return[n.getTensorArray(i.id).read(r)]}case"TensorArrayGatherV3":{const i=l3("tensorArrayId",t,e,n),r=l3("indices",t,e,n),s=l3("dtype",t,e,n);return[n.getTensorArray(i.id).gather(r,s)]}case"TensorArrayScatterV3":{const i=l3("tensorArrayId",t,e,n),r=l3("indices",t,e,n),s=l3("tensor",t,e,n),o=n.getTensorArray(i.id);return o.scatter(r,s),[o.idTensor]}case"TensorArrayConcatV3":{const i=l3("tensorArrayId",t,e,n),r=n.getTensorArray(i.id),s=l3("dtype",t,e,n);return[r.concat(s)]}case"TensorArraySplitV3":{const i=l3("tensorArrayId",t,e,n),r=l3("tensor",t,e,n),s=l3("lengths",t,e,n),o=n.getTensorArray(i.id);return o.split(s,r),[o.idTensor]}case"TensorArraySizeV3":{const i=l3("tensorArrayId",t,e,n);return[xl(n.getTensorArray(i.id).size(),"int32")]}case"TensorArrayCloseV3":{const i=l3("tensorArrayId",t,e,n),r=n.getTensorArray(i.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const i=l3("tensorListId",t,e,n),r=l3("index",t,e,n),s=l3("tensor",t,e,n),o=n.getTensorList(i.id);return o.setItem(r,s),[o.idTensor]}case"TensorListGetItem":{const i=l3("tensorListId",t,e,n),r=l3("index",t,e,n),s=l3("elementShape",t,e,n),o=l3("elementDType",t,e,n);return[n.getTensorList(i.id).getItem(r,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const i=l3("indices",t,e,n),r=function(t,e,n,i){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(null!=i&&-1!==i&&r>=i)throw new Error(`Max index must be < array size (${r}  vs. ${i})`);const s=new i4([],n,t.dtype,i),o=bh(t,0);return e.forEach(((t,e)=>{s.setItem(t,o[e])})),s}(l3("tensor",t,e,n),i,l3("elementShape",t,e,n),l3("numElements",t,e,n));return n.addTensorList(r),[r.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const i=l3("elementShape",t,e,n),r=l3("elementDType",t,e,n);let s;s="TensorListReserve"===t.op?"numElements":"maxNumElements";const o=l3(s,t,e,n),a=function(t,e,n,i){return new i4([],t,e,i)}(i,r,0,"TensorListReserve"===t.op?-1:o);return n.addTensorList(a),[a.idTensor]}case"TensorListGather":{const i=l3("tensorListId",t,e,n),r=l3("indices",t,e,n),s=l3("elementShape",t,e,n),o=l3("elementDType",t,e,n);return[n.getTensorList(i.id).gather(r,o,s)]}case"TensorListStack":{const i=l3("tensorListId",t,e,n),r=l3("elementShape",t,e,n),s=l3("elementDType",t,e,n),o=l3("numElements",t,e,n);return[n.getTensorList(i.id).stack(r,s,o)]}case"TensorListFromTensor":{const i=function(t,e,n){const i=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);J3(t.shape.slice(1),e,"TensorList shape mismatch: ");const r=bh(t);return new i4(r,e,i)}(l3("tensor",t,e,n),l3("elementShape",t,e,n),l3("elementDType",t,e,n));return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const i=l3("tensorListId",t,e,n),r=n.getTensorList(i.id),s=l3("dtype",t,e,n),o=l3("elementShape",t,e,n);return[r.concat(s,o)]}case"TensorListPushBack":{const i=l3("tensorListId",t,e,n),r=l3("tensor",t,e,n),s=n.getTensorList(i.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{const i=l3("tensorListId",t,e,n),r=l3("elementShape",t,e,n),s=l3("elementDType",t,e,n);return[n.getTensorList(i.id).popBack(r,s)]}case"TensorListSplit":{const i=l3("tensor",t,e,n),r=l3("elementShape",t,e,n),s=function(t,e,n){let i=0;const r=e.map((t=>(i+=t,i)));if(i!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${i}, and tensor's shape is: ${t.shape}`);const s=e4(t.shape.slice(1),n),o=0===i?0:t.size/i,a=Co((()=>{const n=[];t=ca(t,[1,i,o]);for(let i=0;i<e.length;++i){const a=[0,0===i?0:r[i-1],0],l=[1,e[i],o];n[i]=ca(ma(t,a,l),s)}return t.dispose(),n})),l=new i4([],n,t.dtype,e.length);for(let t=0;t<a.length;t++)l.setItem(t,a[t]);return l}(i,l3("lengths",t,e,n),r);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{const i=l3("tensorListId",t,e,n);return[xl(n.getTensorList(i.id).size(),"int32")]}case"TensorListResize":{const i=l3("tensorListId",t,e,n),r=l3("size",t,e,n),s=n.getTensorList(i.id).resize(r);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s4(t,e,n){const[i,r]=l3("fusedOps",t,e,n),s="biasadd"===i,o=!s,a="prelu"===r,l="fusedbatchnorm"===i,c=l3("numArgs",t,e,n);if(s){if(a&&2!==c)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&1!==c)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=l3("strides",t,e,n),h=f3(t,e,n),d=l3("dataFormat",t,e,n).toUpperCase(),p=l3("dilations",t,e,n);let[f,m]=l3("args",t,e,n);o&&(m=f,f=void 0);return{stride:u,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:l3("leakyreluAlpha",t,e,n)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o4(t,e,n){return{boxes:l3("boxes",t,e,n),scores:l3("scores",t,e,n),maxOutputSize:l3("maxOutputSize",t,e,n),iouThreshold:l3("iouThreshold",t,e,n),scoreThreshold:l3("scoreThreshold",t,e,n),softNmsSigma:l3("softNmsSigma",t,e,n)}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class a4{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=xl(0),this.tensorMap=new Map,_o(this.handle)}clearAndClose(){this.tensorMap.forEach((t=>t.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return xl(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);const n=await t.data();return this.tensorMap.forEach((t=>t.dispose())),this.tensorMap.clear(),Co((()=>{const t=bh(e),i=n.length,r=t.length;c(i===r,(()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${r} elements.`));for(let e=0;e<i;e++){const i=n[e],r=t[e];_o(r),this.tensorMap.set(i,r)}return this.handle}))}async find(t,e){this.checkKeyAndValueTensor(t,e);const n=await t.data();return Co((()=>{const t=[];for(let i=0;i<n.length;i++){const r=n[i],s=this.findWithDefault(r,e);t.push(s)}return Qu(t)}))}findWithDefault(t,e){const n=this.tensorMap.get(t);return null!=n?n:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function l4(t,e,n,i,r=Co){const s=((t,e,n)=>{switch(t.category){case"arithmetic":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[i.add(l3("a",t,e,n),l3("b",t,e,n))];case"AddN":return[i.addN(l3("tensors",t,e,n))];case"FloorMod":case"Mod":return[i.mod(l3("a",t,e,n),l3("b",t,e,n))];case"Mul":return[i.mul(l3("a",t,e,n),l3("b",t,e,n))];case"RealDiv":case"Div":return[i.div(l3("a",t,e,n),l3("b",t,e,n))];case"DivNoNan":return[i.divNoNan(l3("a",t,e,n),l3("b",t,e,n))];case"FloorDiv":return[i.floorDiv(l3("a",t,e,n),l3("b",t,e,n))];case"Sub":return[i.sub(l3("a",t,e,n),l3("b",t,e,n))];case"Minimum":return[i.minimum(l3("a",t,e,n),l3("b",t,e,n))];case"Maximum":return[i.maximum(l3("a",t,e,n),l3("b",t,e,n))];case"Pow":return[i.pow(l3("a",t,e,n),l3("b",t,e,n))];case"SquaredDifference":return[i.squaredDifference(l3("a",t,e,n),l3("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"basic_math":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"Abs":case"ComplexAbs":return[i.abs(l3("x",t,e,n))];case"Acos":return[i.acos(l3("x",t,e,n))];case"Acosh":return[i.acosh(l3("x",t,e,n))];case"Asin":return[i.asin(l3("x",t,e,n))];case"Asinh":return[i.asinh(l3("x",t,e,n))];case"Atan":return[i.atan(l3("x",t,e,n))];case"Atan2":return[i.atan2(l3("x",t,e,n),l3("y",t,e,n))];case"Atanh":return[i.atanh(l3("x",t,e,n))];case"Ceil":return[i.ceil(l3("x",t,e,n))];case"Complex":return[i.complex(l3("real",t,e,n),l3("imag",t,e,n))];case"Cos":return[i.cos(l3("x",t,e,n))];case"Cosh":return[i.cosh(l3("x",t,e,n))];case"Elu":return[i.elu(l3("x",t,e,n))];case"Erf":return[i.erf(l3("x",t,e,n))];case"Exp":return[i.exp(l3("x",t,e,n))];case"Expm1":return[i.expm1(l3("x",t,e,n))];case"Floor":return[i.floor(l3("x",t,e,n))];case"Log":return[i.log(l3("x",t,e,n))];case"Log1p":return[i.log1p(l3("x",t,e,n))];case"Imag":return[i.imag(l3("x",t,e,n))];case"Neg":return[i.neg(l3("x",t,e,n))];case"Reciprocal":return[i.reciprocal(l3("x",t,e,n))];case"Real":return[i.real(l3("x",t,e,n))];case"Relu":return[i.relu(l3("x",t,e,n))];case"Round":return[i.round(l3("x",t,e,n))];case"Selu":return[i.selu(l3("x",t,e,n))];case"Sigmoid":return[i.sigmoid(l3("x",t,e,n))];case"Sin":return[i.sin(l3("x",t,e,n))];case"Sign":return[i.sign(l3("x",t,e,n))];case"Sinh":return[i.sinh(l3("x",t,e,n))];case"Softplus":return[i.softplus(l3("x",t,e,n))];case"Sqrt":return[i.sqrt(l3("x",t,e,n))];case"Square":return[i.square(l3("x",t,e,n))];case"Tanh":return[i.tanh(l3("x",t,e,n))];case"Tan":return[i.tan(l3("x",t,e,n))];case"ClipByValue":return[i.clipByValue(l3("x",t,e,n),l3("clipValueMin",t,e,n),l3("clipValueMax",t,e,n))];case"Relu6":return[i.relu6(l3("x",t,e,n))];case"Rsqrt":return[i.rsqrt(c3(t.inputNames[0],e,n))];case"LeakyRelu":return[i.leakyRelu(l3("x",t,e,n),l3("alpha",t,e,n))];case"Prelu":return[i.prelu(l3("x",t,e,n),l3("alpha",t,e,n))];case"IsNan":return[i.isNaN(c3(t.inputNames[0],e,n))];case"IsInf":return[i.isInf(c3(t.inputNames[0],e,n))];case"IsFinite":return[i.isFinite(c3(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"control":return r4(t,e,n);case"convolution":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"Conv1D":{const r=l3("stride",t,e,n),s=l3("pad",t,e,n),o=l3("dataFormat",t,e,n).toUpperCase(),a=l3("dilation",t,e,n);return[i.conv1d(l3("x",t,e,n),l3("filter",t,e,n),r,s,o,a)]}case"Conv2D":{const r=l3("strides",t,e,n),s=f3(t,e,n),o=l3("dataFormat",t,e,n).toUpperCase(),a=l3("dilations",t,e,n);return[i.conv2d(l3("x",t,e,n),l3("filter",t,e,n),[r[1],r[2]],s,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:r,pad:s,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=s4(t,e,n);return[i.fused.conv2d({x:l3("x",t,e,n),filter:l3("filter",t,e,n),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:s,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=s4(t,e,n);return[i.fused.depthwiseConv2d({x:l3("x",t,e,n),filter:l3("filter",t,e,n),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=l3("outputShape",t,e,n),s=l3("strides",t,e,n),o=f3(t,e,n);return[i.conv2dTranspose(l3("x",t,e,n),l3("filter",t,e,n),r,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=l3("strides",t,e,n),s=f3(t,e,n),o=l3("dilations",t,e,n),a=l3("dataFormat",t,e,n).toUpperCase();return[i.depthwiseConv2d(l3("input",t,e,n),l3("filter",t,e,n),[r[1],r[2]],s,a,[o[1],o[2]])]}case"Conv3D":{const r=l3("strides",t,e,n),s=l3("pad",t,e,n),o=l3("dataFormat",t,e,n).toUpperCase(),a=l3("dilations",t,e,n);return[i.conv3d(l3("x",t,e,n),l3("filter",t,e,n),[r[1],r[2],r[3]],s,o,[a[1],a[2],a[3]])]}case"AvgPool":{const r=l3("strides",t,e,n),s=l3("pad",t,e,n),o=l3("kernelSize",t,e,n);return[i.avgPool(l3("x",t,e,n),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=l3("strides",t,e,n),s=l3("pad",t,e,n),o=l3("kernelSize",t,e,n);return[i.maxPool(l3("x",t,e,n),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=l3("strides",t,e,n),s=l3("pad",t,e,n),o=l3("kernelSize",t,e,n),a=l3("includeBatchInIndex",t,e,n),{result:l,indexes:c}=i.maxPoolWithArgmax(l3("x",t,e,n),[o[1],o[2]],[r[1],r[2]],s,a);return[l,c]}case"AvgPool3D":{const r=l3("strides",t,e,n),s=l3("pad",t,e,n),o=l3("kernelSize",t,e,n);return[i.avgPool3d(l3("x",t,e,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=l3("strides",t,e,n),s=l3("pad",t,e,n),o=l3("kernelSize",t,e,n);return[i.maxPool3d(l3("x",t,e,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{const r=l3("strides",t,e,n),s=l3("pad",t,e,n),o=l3("dilations",t,e,n),a=r[1],l=r[2],c=o[1],u=o[2];return[i.dilation2d(l3("x",t,e,n),l3("filter",t,e,n),[a,l],s,[c,u],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"creation":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"Fill":{const r=l3("shape",t,e,n),s=l3("dtype",t,e,n),o=l3("value",t,e,n);return[i.fill(r,o,s)]}case"LinSpace":{const r=l3("start",t,e,n),s=l3("stop",t,e,n),o=l3("num",t,e,n);return[i.linspace(r,s,o)]}case"Multinomial":{const r=l3("logits",t,e,n),s=l3("numSamples",t,e,n),o=l3("seed",t,e,n);return[i.multinomial(r,s,o)]}case"OneHot":{const r=l3("indices",t,e,n),s=l3("depth",t,e,n),o=l3("onValue",t,e,n),a=l3("offValue",t,e,n),l=l3("dtype",t,e,n);return[i.oneHot(r,s,o,a,l)]}case"Ones":return[i.ones(l3("shape",t,e,n),l3("dtype",t,e,n))];case"OnesLike":return[i.onesLike(l3("x",t,e,n))];case"RandomStandardNormal":return[i.randomStandardNormal(l3("shape",t,e,n),l3("dtype",t,e,n),l3("seed",t,e,n))];case"RandomUniform":return[i.randomUniform(l3("shape",t,e,n),l3("minval",t,e,n),l3("maxval",t,e,n),l3("dtype",t,e,n))];case"RandomUniformInt":return[i.randomUniformInt(l3("shape",t,e,n),l3("minval",t,e,n),l3("maxval",t,e,n),l3("seed",t,e,n))];case"Range":{const r=l3("start",t,e,n),s=l3("stop",t,e,n),o=l3("step",t,e,n);return[i.range(r,s,o,l3("dtype",t,e,n))]}case"TruncatedNormal":{const r=l3("shape",t,e,n),s=l3("mean",t,e,n),o=l3("stdDev",t,e,n),a=l3("seed",t,e,n);return[i.truncatedNormal(r,s,o,l3("dtype",t,e,n),a)]}case"Zeros":return[i.zeros(l3("shape",t,e,n),l3("dtype",t,e,n))];case"ZerosLike":return[i.zerosLike(l3("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"dynamic":return(async(t,e,n,i,r=Z3)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=o4(t,e,n),u=await r.image.nonMaxSuppressionWithScoreAsync(i,s,o,a,l,c);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=o4(t,e,n),c=l3("padToMaxOutputSize",t,e,n),u=await r.image.nonMaxSuppressionPaddedAsync(i,s,o,a,l,c);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=o4(t,e,n);return[await r.image.nonMaxSuppressionAsync(i,s,o,a,l)]}case"Where":{const i=r.cast(l3("condition",t,e,n),"bool"),s=[await r.whereAsync(i)];return i.dispose(),s}case"ListDiff":return r.setdiff1dAsync(l3("x",t,e,n),l3("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n);case"evaluation":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"LowerBound":{const r=l3("sortedSequence",t,e,n),s=l3("values",t,e,n);return[i.lowerBound(r,s)]}case"TopKV2":{const r=l3("x",t,e,n),s=l3("k",t,e,n),o=l3("sorted",t,e,n),a=i.topk(r,s,o);return[a.values,a.indices]}case"UpperBound":{const r=l3("sortedSequence",t,e,n),s=l3("values",t,e,n);return[i.upperBound(r,s)]}case"Unique":{const r=l3("x",t,e,n),s=i.unique(r);return[s.values,s.indices]}case"UniqueV2":{const r=l3("x",t,e,n),s=l3("axis",t,e,n),o=i.unique(r,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"image":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"ResizeBilinear":{const r=l3("images",t,e,n),s=l3("size",t,e,n),o=l3("alignCorners",t,e,n),a=l3("halfPixelCenters",t,e,n);return[i.image.resizeBilinear(r,[s[0],s[1]],o,a)]}case"ResizeNearestNeighbor":{const r=l3("images",t,e,n),s=l3("size",t,e,n),o=l3("alignCorners",t,e,n),a=l3("halfPixelCenters",t,e,n);return[i.image.resizeNearestNeighbor(r,[s[0],s[1]],o,a)]}case"CropAndResize":{const r=l3("image",t,e,n),s=l3("boxes",t,e,n),o=l3("boxInd",t,e,n),a=l3("cropSize",t,e,n),l=l3("method",t,e,n),c=l3("extrapolationValue",t,e,n);return[i.image.cropAndResize(r,s,o,a,l,c)]}case"ImageProjectiveTransformV3":{const r=l3("images",t,e,n),s=l3("transforms",t,e,n),o=l3("outputShape",t,e,n),a=l3("fillValue",t,e,n),l=l3("interpolation",t,e,n),c=l3("fillMode",t,e,n);return[i.image.transform(r,s,l.toLowerCase(),c.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"graph":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const r=l3("default",t,e,n);return[c3(t.name,e,n)||r];case"Placeholder":return[c3(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[m3(l3("x",t,e,n))];case"IdentityN":return l3("x",t,e,n).map((t=>m3(t)));case"Shape":return[i.tensor1d(l3("x",t,e,n).shape,"int32")];case"ShapeN":return l3("x",t,e,n).map((t=>i.tensor1d(t.shape)));case"Size":return[i.scalar(l3("x",t,e,n).size,"int32")];case"Rank":return[i.scalar(l3("x",t,e,n).rank,"int32")];case"NoOp":return[i.scalar(1)];case"Print":const s=l3("x",t,e,n),o=l3("data",t,e,n),a=l3("message",t,e,n),l=l3("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(a);for(let t=0;t<o.length;t++)console.log(Array.prototype.slice.call(o[t].dataSync()).slice(0,l));return[s];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"logical":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"Equal":return[i.equal(l3("a",t,e,n),l3("b",t,e,n))];case"NotEqual":return[i.notEqual(l3("a",t,e,n),l3("b",t,e,n))];case"Greater":return[i.greater(l3("a",t,e,n),l3("b",t,e,n))];case"GreaterEqual":return[i.greaterEqual(l3("a",t,e,n),l3("b",t,e,n))];case"Less":return[i.less(l3("a",t,e,n),l3("b",t,e,n))];case"LessEqual":return[i.lessEqual(l3("a",t,e,n),l3("b",t,e,n))];case"LogicalAnd":return[i.logicalAnd(l3("a",t,e,n),l3("b",t,e,n))];case"LogicalNot":return[i.logicalNot(l3("a",t,e,n))];case"LogicalOr":return[i.logicalOr(l3("a",t,e,n),l3("b",t,e,n))];case"Select":case"SelectV2":return[i.where(l3("condition",t,e,n),l3("a",t,e,n),l3("b",t,e,n))];case"BitwiseAnd":return[i.bitwiseAnd(l3("a",t,e,n),l3("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"matrices":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[i.matMul(l3("a",t,e,n),l3("b",t,e,n),l3("transposeA",t,e,n),l3("transposeB",t,e,n))];case"Einsum":return[i.einsum(l3("equation",t,e,n),...l3("tensors",t,e,n))];case"Transpose":return[i.transpose(l3("x",t,e,n),l3("perm",t,e,n))];case"_FusedMatMul":const[r,s]=l3("fusedOps",t,e,n),o="biasadd"===r,a="prelu"===s,l=l3("numArgs",t,e,n),c=l3("leakyreluAlpha",t,e,n);if(o){if(a&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,h]=l3("args",t,e,n);return[i.fused.matMul({a:l3("a",t,e,n),b:l3("b",t,e,n),transposeA:l3("transposeA",t,e,n),transposeB:l3("transposeB",t,e,n),bias:u,activation:s,preluActivationWeights:h,leakyreluAlpha:c})];case"MatrixBandPart":return[i.linalg.bandPart(l3("a",t,e,n),l3("numLower",t,e,n),l3("numUpper",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"normalization":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"EuclideanNorm":return[i.euclideanNorm(l3("x",t,e,n),l3("axis",t,e,n),l3("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[i.batchNorm(l3("x",t,e,n),l3("mean",t,e,n),l3("variance",t,e,n),l3("offset",t,e,n),l3("scale",t,e,n),l3("epsilon",t,e,n))];case"LRN":return[i.localResponseNormalization(l3("x",t,e,n),l3("radius",t,e,n),l3("bias",t,e,n),l3("alpha",t,e,n),l3("beta",t,e,n))];case"Softmax":return[i.softmax(l3("x",t,e,n))];case"LogSoftmax":return[i.logSoftmax(l3("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"ragged":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:s}=i.raggedGather(l3("paramsNestedSplits",t,e,n),l3("paramsDenseValues",t,e,n),l3("indices",t,e,n),l3("outputRaggedRank",t,e,n));return r.concat(s)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:s}=i.raggedRange(l3("starts",t,e,n),l3("limits",t,e,n),l3("splits",t,e,n));return[r,s]}case"RaggedTensorToTensor":return[i.raggedTensorToTensor(l3("shape",t,e,n),l3("values",t,e,n),l3("defaultValue",t,e,n),l3("rowPartitionTensors",t,e,n),l3("rowPartitionTypes",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"reduction":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"Max":{const r=l3("axis",t,e,n),s=l3("keepDims",t,e,n);return[i.max(l3("x",t,e,n),r,s)]}case"Mean":{const r=l3("axis",t,e,n),s=l3("keepDims",t,e,n);return[i.mean(l3("x",t,e,n),r,s)]}case"Min":{const r=l3("axis",t,e,n),s=l3("keepDims",t,e,n);return[i.min(l3("x",t,e,n),r,s)]}case"Sum":{const r=l3("axis",t,e,n),s=l3("keepDims",t,e,n);return[i.sum(l3("x",t,e,n),r,s)]}case"All":{const r=l3("axis",t,e,n),s=l3("keepDims",t,e,n);return[i.all(l3("x",t,e,n),r,s)]}case"Any":{const r=l3("axis",t,e,n),s=l3("keepDims",t,e,n);return[i.any(l3("x",t,e,n),r,s)]}case"ArgMax":{const r=l3("axis",t,e,n);return[i.argMax(l3("x",t,e,n),r)]}case"ArgMin":{const r=l3("axis",t,e,n);return[i.argMin(l3("x",t,e,n),r)]}case"Prod":{const r=l3("axis",t,e,n),s=l3("keepDims",t,e,n);return[i.prod(l3("x",t,e,n),r,s)]}case"Cumprod":{const r=l3("axis",t,e,n),s=l3("exclusive",t,e,n),o=l3("reverse",t,e,n);return[i.cumprod(l3("x",t,e,n),r,s,o)]}case"Cumsum":{const r=l3("axis",t,e,n),s=l3("exclusive",t,e,n),o=l3("reverse",t,e,n);return[i.cumsum(l3("x",t,e,n),r,s,o)]}case"Bincount":const r=l3("x",t,e,n),s=l3("weights",t,e,n),o=l3("size",t,e,n);return[i.bincount(r,s,o)];case"DenseBincount":{const r=l3("x",t,e,n),s=l3("weights",t,e,n),o=l3("size",t,e,n),a=l3("binaryOutput",t,e,n);return[i.denseBincount(r,s,o,a)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"slice_join":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"ConcatV2":case"Concat":{const r=l3("n",t,e,n),s=l3("axis",t,e,n);let o=l3("tensors",t,e,n);return o=o.slice(0,r),[i.concat(o,s)]}case"Gather":{const r=l3("x",t,e,n),s=l3("indices",t,e,n);return[i.gather(r,i.cast(s,"int32"),0)]}case"GatherV2":{const r=l3("axis",t,e,n),s=l3("batchDims",t,e,n),o=l3("x",t,e,n),a=l3("indices",t,e,n);return[i.gather(o,i.cast(a,"int32"),r,s)]}case"Reverse":{const r=l3("dims",t,e,n),s=[];for(let t=0;t<r.length;t++)r[t]&&s.push(t);const o=l3("x",t,e,n);return[i.reverse(o,s)]}case"ReverseV2":{const r=l3("axis",t,e,n),s=l3("x",t,e,n);return[i.reverse(s,r)]}case"Slice":{const r=l3("begin",t,e,n),s=l3("size",t,e,n);return[i.slice(l3("x",t,e,n),r,s)]}case"StridedSlice":{const r=l3("begin",t,e,n),s=l3("end",t,e,n),o=l3("strides",t,e,n),a=l3("beginMask",t,e,n),l=l3("endMask",t,e,n),c=l3("ellipsisMask",t,e,n),u=l3("newAxisMask",t,e,n),h=l3("shrinkAxisMask",t,e,n),d=l3("x",t,e,n);return[i.stridedSlice(d,r,s,o,a,l,c,u,h)]}case"Pack":return Co((()=>{const r=l3("axis",t,e,n),s=l3("tensors",t,e,n),o=s[0].shape,a=i.squeeze(s[0]).shape,l=s.map((t=>{const e=m(t.shape,o);if(!e&&!m(i.squeeze(t).shape,a))throw new Error("the input tensors shape does not match");return e?t:i.reshape(t,o)}));return[i.stack(l,r)]}));case"Unpack":{const r=l3("axis",t,e,n),s=l3("tensor",t,e,n);return i.unstack(s,r)}case"Tile":{const r=l3("reps",t,e,n);return[i.tile(l3("x",t,e,n),r)]}case"Split":case"SplitV":{const r=l3("axis",t,e,n),s=l3("numOrSizeSplits",t,e,n),o=l3("x",t,e,n);return i.split(o,s,r)}case"ScatterNd":{const r=l3("indices",t,e,n),s=l3("values",t,e,n),o=l3("shape",t,e,n);return[i.scatterND(r,s,o)]}case"GatherNd":{const r=l3("x",t,e,n),s=l3("indices",t,e,n);return[i.gatherND(r,s)]}case"SparseToDense":{const r=l3("sparseIndices",t,e,n),s=l3("outputShape",t,e,n),o=l3("sparseValues",t,e,n),a=l3("defaultValue",t,e,n);return[i.sparseToDense(r,o,s,o.dtype===a.dtype?a:i.cast(a,o.dtype))]}case"TensorScatterUpdate":{const r=l3("indices",t,e,n),s=l3("values",t,e,n),o=l3("tensor",t,e,n);return[i.tensorScatterUpdate(o,r,s)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"sparse":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:s,emptyRowIndicator:o,reverseIndexMap:a}=i.sparse.sparseFillEmptyRows(l3("indices",t,e,n),l3("values",t,e,n),l3("denseShape",t,e,n),l3("defaultValue",t,e,n));return[r,s,o,a]}case"SparseReshape":{const{outputIndices:r,outputShape:s}=i.sparse.sparseReshape(l3("inputIndices",t,e,n),l3("inputShape",t,e,n),l3("newShape",t,e,n));return[r,s]}case"SparseSegmentMean":return[i.sparse.sparseSegmentMean(l3("data",t,e,n),l3("indices",t,e,n),l3("segmentIds",t,e,n))];case"SparseSegmentSum":return[i.sparse.sparseSegmentSum(l3("data",t,e,n),l3("indices",t,e,n),l3("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"spectral":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"FFT":return[i.fft(l3("x",t,e,n))];case"IFFT":return[i.ifft(l3("x",t,e,n))];case"RFFT":return[i.rfft(l3("x",t,e,n))];case"IRFFT":return[i.irfft(l3("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"string":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"StaticRegexReplace":return[i.string.staticRegexReplace(l3("input",t,e,n),l3("pattern",t,e,n),l3("rewrite",t,e,n),l3("replaceGlobal",t,e,n))];case"StringNGrams":{const{nGrams:r,nGramsSplits:s}=i.string.stringNGrams(l3("data",t,e,n),l3("dataSplits",t,e,n),l3("separator",t,e,n),l3("nGramWidths",t,e,n),l3("leftPad",t,e,n),l3("rightPad",t,e,n),l3("padWidth",t,e,n),l3("preserveShortSequences",t,e,n));return[r,s]}case"StringSplit":{const{indices:r,values:s,shape:o}=i.string.stringSplit(l3("input",t,e,n),l3("delimiter",t,e,n),l3("skipEmpty",t,e,n));return[r,s,o]}case"StringToHashBucketFast":return[i.string.stringToHashBucketFast(l3("input",t,e,n),l3("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"transformation":return r((()=>((t,e,n,i=Z3)=>{switch(t.op){case"Cast":return[i.cast(l3("x",t,e,n),l3("dtype",t,e,n))];case"ExpandDims":{const r=l3("axis",t,e,n);return[i.expandDims(l3("x",t,e,n),r)]}case"Squeeze":{const r=l3("axis",t,e,n);return[i.squeeze(l3("x",t,e,n),r)]}case"Reshape":return[i.reshape(l3("x",t,e,n),l3("shape",t,e,n))];case"EnsureShape":return[i.ensureShape(l3("x",t,e,n),l3("shape",t,e,n))];case"MirrorPad":return[i.mirrorPad(l3("x",t,e,n),l3("padding",t,e,n),l3("mode",t,e,n))];case"PadV2":case"Pad":return[i.pad(l3("x",t,e,n),l3("padding",t,e,n),l3("constantValue",t,e,n))];case"SpaceToBatchND":{const r=l3("blockShape",t,e,n),s=l3("paddings",t,e,n);return[i.spaceToBatchND(l3("x",t,e,n),r,s)]}case"BatchToSpaceND":{const r=l3("blockShape",t,e,n),s=l3("crops",t,e,n);return[i.batchToSpaceND(l3("x",t,e,n),r,s)]}case"DepthToSpace":{const r=l3("blockSize",t,e,n),s=l3("dataFormat",t,e,n).toUpperCase();return[i.depthToSpace(l3("x",t,e,n),r,s)]}case"BroadcastTo":return[i.broadcastTo(l3("x",t,e,n),l3("shape",t,e,n))];case"BroadcastArgs":return[i.broadcastArgs(l3("s0",t,e,n),l3("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"hash_table":return(async(t,e,n,i)=>{switch(t.op){case"HashTable":case"HashTableV2":{const r=i.getHashTableHandleByName(t.name);if(null!=r)return[r];{const r=l3("keyDType",t,e,n),s=l3("valueDType",t,e,n),o=new a4(r,s);return i.addHashTable(t.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=l3("tableHandle",t,e,n,i),s=l3("keys",t,e,n),o=l3("values",t,e,n),a=i.getHashTableById(r.id);return[await a.import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=l3("tableHandle",t,e,n,i),s=l3("keys",t,e,n),o=l3("defaultValue",t,e,n),a=i.getHashTableById(r.id);return[await a.find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=l3("tableHandle",t,e,n,i);return[i.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n,i);case"custom":const s=a3(t.op);if(s&&s.customExecutor)return s.customExecutor(new Y3(t,e,n));throw TypeError(`Custom op ${t.op} is not registered.`);default:throw TypeError(`Unknown op '${t.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return G(s)?s.then((t=>[].concat(t))):[].concat(s)}class c4{constructor(t={},e={},n={},i={},r){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=n,this.functionMap=i,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const n=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(n))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map((t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`)).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u4(t,e,n,i){const r=new Set,s=[];let o=null,a=null;const l=new Set,c=new Set(Object.keys(t).map((t=>p3(t)[0])));i=i||[];const u=new Set(i.map((t=>p3(t.name)[0]))),h=[...e];for(;h.length>0;){const t=h.pop();(g4(t)||y4(t)||b4(t))&&null==o&&(o=t,a=o.children.map((t=>t.name)).filter((t=>r.has(t)))),r.add(t.name),null==n[t.name]&&(c.has(t.name)||u.has(t.name)||(0!==t.inputs.length?t.inputs.forEach((t=>{l.has(t.name)||(l.add(t.name),h.push(t))})):s.push(t.name)))}return{inputs:t,outputs:e,usedNodes:r,missingInputs:s,dynamicNode:o,syncInputs:a}}function h4(t,e){const{usedNodes:n,inputs:i}=e,r=Object.keys(i).map((t=>p3(t)[0])).map((e=>t.nodes[e])),s=t.initNodes||[],o=t=>n.has("string"==typeof t?t:t.name);function a(t){return[...new Map(t.map((t=>[t.name,t]))).values()]}const l=a([...r,...t.weights,...s]).filter(o),c=a([...l,...Object.values(t.nodes)]).filter(o),u=new Map(c.map((t=>[t.name,t]))),h={};for(const t of c){h[t.name]=h[t.name]||0;for(const e of t.children)o(e)||(h[e.name]=Number.POSITIVE_INFINITY),h[e.name]=(h[e.name]||0)+1}const d=Object.entries(h).filter((([,t])=>0===t)).map((([t])=>t)),p=[...d];for(;d.length>0;){const t=d.pop(),e=u.get(t);for(const t of e.children.filter(o))0==--h[t.name]&&(p.push(t.name),d.push(t.name))}const f=function(t,e){const n=new Map(t.map((t=>[t.name,t]))),i=e.map((t=>t.name)),r=new Set(i);for(;i.length>0;){const t=i.pop(),e=n.get(t);for(const t of e.children)n.has(t.name)&&!r.has(t.name)&&(r.add(t.name),i.push(t.name))}const s=t.filter((t=>r.has(t.name)));return s}(p.map((t=>u.get(t))),l);return function(t,e){const n=new Map(t.map(((t,e)=>[t.name,e]))),i=new Set(e.map((t=>t.name))),r=t=>i.has("string"==typeof t?t:t.name),s=new Set(t.map((t=>t.name))),o=t=>s.has("string"==typeof t?t:t.name);for(const e of t){for(const t of e.children.filter(o)){if(!n.has(t.name))throw new d4(`Child ${t.name} of node ${e.name} is unreachable.`);if(n.get(e.name)>n.get(t.name))throw new d4(`Node ${e.name} is scheduled to run after its child ${t.name}.`)}if(!r(e))for(const t of e.inputs){if(!n.has(t.name))throw new d4(`Input ${t.name} of node ${e.name} is unreachable.`);if(n.get(t.name)>n.get(e.name))throw new d4(`Node ${e.name} is scheduled to run before its input ${t.name}.`)}}}(f,l),f}class d4 extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}const p4=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),f4=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),m4=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function g4(t){return p4.has(t.op)}function y4(t){return f4.has(t.op)}function b4(t){return m4.has(t.op)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class v4{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map((e=>t[e].map((t=>t.id))));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map((t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((t=>t.signatureKey||t.name))}get outputNodes(){return this._outputs.map((t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e}))}get functions(){return Object.keys(this._functions).reduce(((t,e)=>(t[e]=this._functions[e].signature,t)),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach((e=>{this._functionExecutorMap[e]=new v4(t.functions[e],this)}))}getCompilationKey(t,e){const n=t.map((t=>t.name)).sort(),i=e.map((t=>t.name)).sort();return n.join(this.SEPARATOR)+"--"+i.join(this.SEPARATOR)}compile(t,e){const n=u4(t,e,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:r,syncInputs:s}=n;if(null!=r)throw new Error(`This execution contains the node '${r.name}', which has the dynamic op '${r.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(i.length>0){const n=e.map((t=>t.name)),r=Object.keys(t);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${r}]. Missing the following inputs: [${i}]`)}const o=h4(this.graph,n),a=function(t){const e=new Map(t.map(((t,e)=>[t.name,e]))),n=Number.MAX_SAFE_INTEGER,i=t.map(((t,e)=>g4(t)?n:e)),r=t=>{const n=i[e.get(t.name)];return null==n?-1:n},s=t.map(((t,e)=>t.children.map(r).reduce(((t,e)=>Math.max(t,e)),i[e]))),o=new Map;for(let e=0;e<t.length;++e){const i=s[e];if(i===n)continue;const r=t[e],a=t[i];o.has(a.name)||o.set(a.name,[]),o.get(a.name).push(r)}return o}(o);return{orderedNodes:o,nodeLiveUntilMap:a}}cloneAndKeepTensor(t){if(null==t)return null;const e=t.clone();return _o(e),e}cloneTensorList(t){if(!t)return null;const e=t.map((t=>this.cloneAndKeepTensor(t)));return e}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map((([t,e])=>[t,this.cloneTensorList(e)])))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const i=n.map((t=>this.graph.nodes[p3(t)[0]])),r=e.map((t=>p3(t)[0])),s=new Set(r);let o=r.map((t=>this.graph.nodes[t]));0===o.length&&(o=this._outputs);const a=this.getCompilationKey(i,o);let l=this.compiledMap.get(a);null==l&&(l=this.compile(t,o),this.compiledMap.set(a,l));try{this.keepIntermediateTensors=Y().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(t){this.keepIntermediateTensors=!1,console.warn(t.message)}const c={},u={};return Co((()=>{const n=new c4(this.weightMap,c,u,this.functionExecutorMap,this.parseNodeNameCache),i=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach((e=>{const[r,s]=p3(e,n),o=[];o[s]=t[e],i[r]=o,this.keepIntermediateTensors&&(this.clonedTensorsMap[r]=this.cloneTensorList(o))}));const r=this.getFrozenTensorIds(i),{orderedNodes:o,nodeLiveUntilMap:a}=l;for(const t of o){if(i[t.name])continue;const e=l4(t,i,n,this._resourceManager);if(G(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);i[t.name]=e,this.keepIntermediateTensors&&(this.clonedTensorsMap[t.name]=this.cloneTensorList(e)),this.checkTensorForDisposalWithNodeLiveUntilInfo(t,i,n,r,s,a.get(t.name))}return null==this.parent&&n.dispose(r),e.map((t=>c3(t,i,n)))}))}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map((e=>t[e])).map((t=>t.map((t=>t.id)))));return new Set(e)}checkTensorForDisposal(t,e,n,i,r,s,o){if(!g4(e)&&!s.has(t)){for(const i of n[t])null!=i&&(o[i.id]=(o[i.id]||0)+e.children.length);for(const t of e.inputs){if(g4(t))continue;const e=u3(t.name,n,i);if(null!=e)for(const t of e){if(!t||t.kept||r.has(t.id))continue;const e=o[t.id];1===e?(t.dispose(),delete o[t.id]):null!=e&&o[t.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,n,i,r,s){function o(t){return g4(t)||r.has(t.name)}if(!g4(t)&&null!=s)for(const t of s){if(o(t))continue;const r=u3(t.name,e,n);for(const t of r)!t||t.kept||i.has(t.id)||t.dispose()}}async executeAsync(t,e){return this._executeAsync(t,e)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,e,n=!1,i={},r={}){this.disposeIntermediateTensors(),n||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepIntermediateTensors=Y().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(t){this.keepIntermediateTensors=!1,console.warn(t.message)}const s=new c4(this.weightMap,i,r,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(t,s,e,n),a=e.map((t=>c3(t,o,s))),l=a.map((t=>t.id)),c=Object.keys(t).map((e=>t[e].id)),u=new Set([...l,...c,...this.weightIds]);return Object.values(o).forEach((t=>{t.forEach((t=>{!t||t.isDisposed||u.has(t.id)||t.dispose()}))})),null==this.parent&&s.dispose(u),a}async executeFunctionAsync(t,e,n){const i=t.reduce(((t,e,n)=>(t[this.inputs[n].name]=e,t)),{});return this._executeAsync(i,this.outputNodes,!0,e,n)}async executeWithControlFlow(t,e,n,i){const r=Object.keys(t),s=r.map((t=>this.graph.nodes[p3(t)[0]])),o=n.map((t=>p3(t)[0])),a=new Set(o);let l=o.map((t=>this.graph.nodes[t]));0===l.length&&(l=this._outputs);const{usedNodes:c,missingInputs:u,dynamicNode:h,syncInputs:d}=u4(t,l,this.weightMap,this._initNodes),p=[...s,...this.graph.weights,...this._initNodes||[]].map((t=>({node:t,contexts:e.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(t).forEach((e=>{const[n,i]=p3(e),r=[];r[i]=t[e],f[n]=r}));const m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){const t=this.processStack(s,p,e,f,y,g,a,m,c);await Promise.all(t)}null!=h||i||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=l.filter((t=>!g4(t)&&!c3(t.name,f,e))).map((t=>t.name));if(b.length>0){let t="";throw null!=h&&(t=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${r}]. Consider providing the following inputs: [${u}]. ${t}`)}return f}processStack(t,e,n,i,r,s,o,a,l){const c=[];for(;e.length>0;){const t=e.pop();n.currentContext=t.contexts;let u="";if("Enter"===t.node.op&&l3("isConstant",t.node,i,n)&&([u]=h3(t.node.name,n)),null==i[t.node.name]){const h=l4(t.node,i,n,this._resourceManager);u||([u]=h3(t.node.name,n));const d=n.currentContext;G(h)?c.push(h.then((c=>(i[u]=c,this.keepIntermediateTensors&&(this.clonedTensorsMap[u]=this.cloneTensorList(c)),n.currentContext=d,this.checkTensorForDisposal(u,t.node,i,n,s,o,a),this.processChildNodes(t.node,e,n,i,r,l),c)))):(i[u]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[u]=this.cloneTensorList(h)),this.checkTensorForDisposal(u,t.node,i,n,s,o,a),this.processChildNodes(t.node,e,n,i,r,l))}else this.processChildNodes(t.node,e,n,i,r,l)}return c}processChildNodes(t,e,n,i,r,s){t.children.forEach((t=>{const[o]=h3(t.name,n);!r[o]&&s.has(t.name)&&("Merge"===t.op?t.inputNames.some((t=>!!c3(t,i,n)))&&(r[o]=!0,e.push({contexts:n.currentContext,node:t})):t.inputNames.every((t=>!!c3(t,i,n)))&&(r[o]=!0,e.push({contexts:n.currentContext,node:t})))}))}dispose(){Object.keys(this.weightMap).forEach((t=>this.weightMap[t].forEach((t=>t.dispose()))))}checkInputShapeAndType(t){Object.keys(t).forEach((e=>{const n=t[e],[i]=p3(e),r=this.graph.nodes[i];if(r.attrParams.shape&&r.attrParams.shape.value){const t=r.attrParams.shape.value,e=t.length===n.shape.length&&n.shape.every(((e,n)=>-1===t[n]||t[n]===e));c(e,(()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${t}], but was [${n.shape}]`))}r.attrParams.dtype&&r.attrParams.dtype.value&&c(n.dtype===r.attrParams.dtype.value,(()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(t){var e,n;const i={};for(const r in t){const s=null===(n=null===(e=this._signature)||void 0===e?void 0:e.inputs)||void 0===n?void 0:n[r];null!=s?i[s.name]=t[r]:i[r]=t[r]}return i}checkInputs(t){const e=Object.keys(t).filter((t=>{const[e]=p3(t);return null==this.graph.nodes[e]}));if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map((t=>{var e,n;const i=null===(n=null===(e=this._signature)||void 0===e?void 0:e.outputs)||void 0===n?void 0:n[t];return null!=i?i.name:t}),{})}checkOutputs(t){t.forEach((t=>{const[e]=p3(t);if(!this.graph.nodes[e])throw new Error(`The output '${t}' is not found in the graph`)}))}}class x4{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w4="?tfjs-format=file",S4="model.json";class k4{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},n=kp){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=n,null==e&&(this.loadOptions={}),this.resourceManager=new x4}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return G(t)?t.then((t=>this.loadSync(t))):this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const t=this.artifacts.userDefinedMetadata;null!=t.signature&&(n=t.signature),null!=t.structuredOutputKeys&&(this.structuredOutputKeys=t.structuredOutputKeys)}this.signature=n,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const i=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new v4(O3.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(i),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const e=O3.Instance.transformGraph(t.modelInitializer);this.initializer=new v4(e),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}async save(t,e){if("string"==typeof t){const e=this.io.getSaveHandlers(t);if(0===e.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new Error(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){const e={};return(t instanceof Or?[t]:t).forEach(((t,n)=>e[this.structuredOutputKeys[n]]=t)),e}return t}predict(t,e){const n=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(t,e){const n=await this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(t){var e;if(!(t instanceof Or||Array.isArray(t))){const n=null===(e=this.signature)||void 0===e?void 0:e.inputs;if(null!=n)for(const e in n){const i=n[e];null!=i.resourceId&&(t[e]=this.resourceIdToCapturedInput[i.resourceId])}return t}t=Array.isArray(t)?t:[t];const n=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${t.length} input tensors provided.`);let i=0;return this.inputNodes.reduce(((e,n)=>{var r,s,o;const a=null===(o=null===(s=null===(r=this.signature)||void 0===r?void 0:r.inputs)||void 0===s?void 0:s[n])||void 0===o?void 0:o.resourceId;return e[n]=null!=a?this.resourceIdToCapturedInput[a]:t[i++],e}),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,n=Object.keys(e);for(let i=0;i<n.length;i++){const r=e[n[i]];this.resourceIdToCapturedInput[r.resourceId]=t[i]}}}execute(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const n=this.executor.execute(t,e);return n.length>1?n:n[0]}async executeAsync(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const n=await this.executor.executeAsync(t,e);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce(((e,n)=>(e[n]=[t[n]],e)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&To(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function C4(t,e={},n=kp){if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==e&&(e={}),e.fromTFHub&&"string"==typeof t&&(t=function(t){t.endsWith("/")||(t+="/");return`${t}${S4}${w4}`}
/** @license See the LICENSE file. */(t));const i=new k4(t,e,n);return await i.load(),i}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var T4=Object.freeze({__proto__:null,GraphModel:k4,deregisterOp:function(t){delete o3[t]},loadGraphModel:C4,loadGraphModelSync:function(t){if(null==t)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(t instanceof Array){const[n,i]=t;if(!n)throw new Error("modelJSON must be the first element of the array");if(!(i&&i instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");e=wp(Ns(n,Os(n.weightsManifest),i))}else if("load"in t)e=t;else{if(!("modelTopology"in t&&"weightSpecs"in t&&"weightData"in t))throw new Error("Unknown model format");e=wp(t)}const n=new k4(e);return n.load(),n},registerOp:function(t,e){const n={tfOpName:t,category:"custom",inputs:[],attrs:[],customExecutor:e};o3[t]=n},version_converter:"4.11.0"});
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class _4 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,_4.prototype)}}class E4 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,E4.prototype)}}class M4 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,M4.prototype)}}class $4 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,$4.prototype)}}class I4 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,I4.prototype)}}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class A4{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const t=this.cache.keys().next().value;this.cache.delete(t)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const t=this.cache.keys().next().value;this.cache.delete(t)}this.maxEntries=t}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function N4(t,e){if(Array.isArray(t)){let n=[];for(let i=0;i<e;i++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function R4(t,e){if(!t)throw new I4(e)}function P4(t,e){let n=0;for(const i of t)i===e&&n++;return n}function O4(t){return 1===t.length?t[0]:t}function L4(t){return Array.isArray(t)?t:[t]}function D4(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function F4(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,((t,e)=>e.toUpperCase()))}let z4={};function B4(t){if(null==t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function U4(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach((t=>U4(t)));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"==typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!=typeof e.value?U4(e):t[n]=e.value)}}}function V4(t,e={},n={},i="object",r=!1){if("string"==typeof t){const r=t;let s;if(r in n)s=n[r];else if(r in z4)s=z4[r];else if(s=e[r],null==s)throw new M4(`Unknown ${i}: ${t}. This may be due to one of the following reasons:\n1. The ${i} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${i} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return s}{const s=t;if(null==s.className||null==s.config)throw new M4(`${i}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const o=s.className;let a,l;if(o in n?[a,l]=n[o]:o in z4?[a,l]=z4.className:o in e&&([a,l]=e[o]),null==a)throw new M4(`Unknown ${i}: ${o}. This may be due to one of the following reasons:\n1. The ${i} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${i} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const t={};for(const e of Object.keys(z4))t[e]=z4[e];for(const e of Object.keys(n))t[e]=n[e];s.config.customObjects=t;const e=Object.assign({},z4);for(const t of Object.keys(n))z4[t]=n[t];U4(s.config);const i=l(a,s.config,n,r);return z4=Object.assign({},e),i}{const t=Object.assign({},z4);for(const t of Object.keys(n))z4[t]=n[t];const e=new a(s.config);return z4=Object.assign({},t),e}}}function W4(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function H4(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function j4(t){if(null==t)throw new M4(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function G4(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new M4(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function q4(t,e,n=0,i=1/0){return R4(n>=0),R4(i>=n),Array.isArray(t)&&t.length>=n&&t.length<=i&&t.every((t=>typeof t===e))}function X4(t,e){Array.isArray(t)?(c(t.length>0,(()=>`${e} is unexpectedly an empty array.`)),t.forEach(((t,n)=>X4(t,`element ${n+1} of ${e}`)))):c(Number.isInteger(t)&&t>0,(()=>`Expected ${e} to be a positive integer, but got ${K4(t)}.`))}function K4(t){return null===t?"null":Array.isArray(t)?"["+t.map((t=>K4(t))).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function Y4(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Z4=0;function J4(){return Z4++}const Q4={};function t6(t=""){return t in Q4||(Q4[t]=0),Q4[t]+=1,t+Q4[t].toString()}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const e6=["channelsFirst","channelsLast"],n6=["nearest","bilinear"],i6=["valid","same","causal"],r6=["max","avg"],s6=["sum","mul","concat","ave"],o6=new Map;function a6(t){G4(e6,"DataFormat",t)}function l6(t){G4(i6,"PaddingMode",t)}function c6(t){G4(r6,"PoolMode",t)}const u6=[],h6="/";function d6(t,e){u6.push(t);try{const t=e();return u6.pop(),t}catch(t){throw u6.pop(),t}}function p6(t){if(!g6(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===u6.length?"":u6.join(h6)+h6)+t}function f6(t){if(!g6(t))throw new Error("Not a valid tensor name: '"+t+"'");o6.has(t)||o6.set(t,0);const e=o6.get(t);if(o6.set(t,o6.get(t)+1),e>0){const n=`${t}_${e}`;return o6.set(n,1),n}return t}const m6=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function g6(t){return!!t.match(m6)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function y6(t){return t===parseInt(t.toString(),10)}function b6(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let i=1;for(let r=e;r<n;++r)i*=t[r];return i}function v6(t){if(0===t.length)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const i=t[n];i<e&&(e=i)}return e}function x6(t){if(0===t.length)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const i=t[n];i>e&&(e=i)}return e}function w6(t,e){if(e<t)throw new M4(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let i=t;i<e;++i)n.push(i);return n}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let S6;function k6(){return null==S6&&(S6=Io().epsilon()),S6}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function C6(t,e){return vo(t,e)}function T6(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),ca(t,n)}function _6(t,e,n){return Co((()=>{switch(t.rank){case 1:return Uu(t,e,n);case 2:return Vu(t,[e,0],[n,t.shape[1]]);case 3:return Wu(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return Hu(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return ma(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return ma(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new M4(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}))}function E6(t,e,n){return Co((()=>{switch(t.rank){case 1:return Uu(t,e,n);case 2:return Vu(t,[0,e],[t.shape[0],n]);case 3:return Wu(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return Hu(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new M4(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}}))}function M6(t,e,n,i){return Co((()=>{switch(t.rank){case 1:return Uu(t,e,n);case 2:switch(i){case 1:return _6(t,e,n);case 2:return E6(t,e,n);default:throw new M4(`The axis is not within the rank of the tensor ${i}`)}case 3:switch(i){case 1:return _6(t,e,n);case 2:return Wu(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return E6(t,e,n);default:throw new M4(`The axis is not within the rank of the tensor ${i}`)}case 4:switch(i){case 1:return _6(t,e,n);case 2:return Hu(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return Hu(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return E6(t,e,n);default:throw new M4(`The axis is not within the rank of the tensor ${i}`)}default:throw new M4(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}}))}function $6(t,e=-1){let n;return e<0&&(n=t[0].rank,e=0!==n?n:0),e===t[0].rank&&(e=-1),da(t,e)}function I6(t,e){switch(t.rank){case 1:return Ia([t,e]);case 2:return Aa([t,e],0);case 3:return Na([t,e],0);case 4:return Ra([t,e],0);default:throw new M4(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function A6(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new M4(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return Il(t,e)}function N6(t,e=0,n=1,i,r){return vu(t,e,n,i,r)}function R6(t,e,n,i){if(t.rank<2||e.rank<2)throw new $4(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3){if(t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new $4(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`)}if(2===t.rank&&2===e.rank){return Vh({a:t,b:e,transposeA:!1,transposeB:!1,bias:i?L6(t.rank,i,"channelsLast"):null,activation:n})}{const r=t.shape.slice(),s=r.pop();t=ca(t,[-1,s]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],u=Array.from({length:e.rank},((t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n));e=ca(Ch(e,u),[l,-1]);const h=[...r,...c];return ca(Vh({a:t,b:e,transposeA:!1,transposeB:!1,bias:i?L6(t.rank,i,"channelsLast"):null,activation:n}),h)}}function P6(t,e,n){return Co((()=>(e=Array.isArray(e)?ih(e,"int32"):vo(e,"int32"),Rl(t,e,n))))}function O6(t){return Po(t,t)}function L6(t,e,n){const i=e.shape;if(1!==e.rank&&e.rank!==t)throw new M4(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===n)return 1===i.length?ca(e,[1,i[0],1,1,1]):ca(e,[1,i[3],i[0],i[1],i[2]]);if("channelsLast"===n)return 1===i.length?ca(e,[1,1,1,1,i[0]]):ca(e,[1].concat(i))}else if(4===t){if("channelsFirst"===n)return 1===i.length?ca(e,[1,i[0],1,1]):ca(e,[1,i[2],i[0],i[1]]);if("channelsLast"===n)return 1===i.length?ca(e,[1,1,1,i[0]]):ca(e,[1].concat(i))}else if(3===t){if("channelsFirst"===n)return 1===i.length?ca(e,[1,i[0],1]):ca(e,[1,i[1],i[0]]);if("channelsLast"===n)return 1===i.length?ca(e,[1,1,i[0]]):ca(e,[1].concat(i))}else if(t<3)return e;throw new M4(`Unsupported input rank by biasAdd: ${e.rank}`)}function D6(t,e,n){return Co((()=>(null==n&&(n="channelsLast"),a6(n),Ao(t,L6(t.rank,e,n)))))}function F6(t,e,n,i){return Co((()=>$h(t,e,n,i)))}function z6(t,e,n=!1){return n?t():e()}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const B6=["fanIn","fanOut","fanAvg"],U6=["normal","uniform","truncatedNormal"];class V6 extends qd{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class W6 extends V6{apply(t,e){return fc(t,e)}}W6.className="Zeros",Kd(W6);class H6 extends V6{apply(t,e){return mc(t,e)}}H6.className="Ones",Kd(H6);class j6 extends V6{constructor(t){if(super(),"object"!=typeof t)throw new M4(`Expected argument of type ConstantConfig but got ${t}`);if(void 0===t.value)throw new M4(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return Co((()=>Po(xl(this.value),mc(t,e))))}getConfig(){return{value:this.value}}}j6.className="Constant",Kd(j6);class G6 extends V6{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return wu(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}G6.className="RandomUniform",Kd(G6);class q6 extends V6{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new $4(`randomNormal does not support dType ${e}.`);return N6(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}q6.className="RandomNormal",Kd(q6);class X6 extends V6{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new $4(`truncatedNormal does not support dType ${e}.`);return mh(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}X6.className="TruncatedNormal",Kd(X6);class K6 extends V6{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return Co((()=>{if(2!==t.length||t[0]!==t[1])throw new M4("Identity matrix initializer can only be used for 2D square matrices.");return Po(this.gain,Al(t[0]))}))}getConfig(){return{gain:this.gain}}}K6.className="Identity",Kd(K6);class Y6 extends V6{constructor(t){if(super(),t.scale<0)throw new M4(`scale must be a positive float. Got: ${t.scale}`);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
var e;this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,e=this.mode,G4(B6,"FanMode",e),this.distribution=null==t.distribution?"normal":t.distribution,function(t){G4(U6,"Distribution",t)}(this.distribution),this.seed=t.seed}apply(t,e){const n=function(t,e="channelsLast"){let n,i;if(a6(e),2===t.length)n=t[0],i=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===e){const e=b6(t,2);n=t[1]*e,i=t[0]*e}else if("channelsLast"===e){const e=b6(t,0,t.length-2);n=t[t.length-2]*e,i=t[t.length-1]*e}}else{const e=b6(t);n=Math.sqrt(e),i=Math.sqrt(e)}return[n,i]}(t),i=n[0],r=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,i):"fanOut"===this.mode?s/=Math.max(1,r):s/=Math.max(1,(i+r)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new $4(`${this.getClassName()} does not support dType ${e}.`);return mh(t,0,n,e,this.seed)}{const n=Math.sqrt(3*s);return wu(t,-n,n,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Y6.className="VarianceScaling",Kd(Y6);class Z6 extends Y6{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Y6.className}}Z6.className="GlorotUniform",Kd(Z6);class J6 extends Y6{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Y6.className}}J6.className="GlorotNormal",Kd(J6);class Q6 extends Y6{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Y6.className}}Q6.className="HeNormal",Kd(Q6);class t5 extends Y6{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Y6.className}}t5.className="HeUniform",Kd(t5);class e5 extends Y6{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Y6.className}}e5.className="LeCunNormal",Kd(e5);class n5 extends Y6{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Y6.className}}n5.className="LeCunUniform",Kd(n5);class i5 extends V6{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return Co((()=>{if(t.length<2)throw new $4("Shape must be at least 2D.");if("int32"!==e&&"float32"!==e&&void 0!==e)throw new TypeError(`Unsupported data type ${e}.`);const n=d(t.slice(0,-1)),i=t[t.length-1],r=n*i;r>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);const s=N6([Math.max(i,n),Math.min(i,n)],0,1,e,this.seed),o=Ud.qr(s,!1);let a=o[0];const l=o[1].flatten().stridedSlice([0],[Math.min(i,n)*Math.min(i,n)],[Math.min(i,n)+1]);return a=Po(a,l.sign()),n<i&&(a=a.transpose()),Po(xl(this.gain),a.reshape(t))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}i5.className="Orthogonal",Kd(i5);const r5={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function s5(t,e={}){return V4(t,Xd.getMap().classNameMap,e,"initializer")}function o5(t){return B4(t)}function a5(t){if("string"==typeof t){const e=t in r5?r5[t]:t;if("GlorotNormal"===e)return new J6;if("GlorotUniform"===e)return new Z6;if("HeNormal"===e)return new Q6;if("HeUniform"===e)return new t5;if("LeCunNormal"===e)return new e5;if("LeCunUniform"===e)return new n5;{const t={};return t.className=e,t.config={},s5(t)}}return t instanceof V6?t:s5(t)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function l5(t){return Array.isArray(t)&&Array.isArray(t[0])}function c5(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function u5(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new M4(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function h5(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new M4(`Expected exactly 1 Shape; got ${t.length}`)}return t}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function d5(t){let e=0;for(const n of t)0===n.shape.length?e+=1:e+=n.shape.reduce(((t,e)=>t*e));return e}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const p5="Variable";class f5{constructor(t,e="float32",n=p5,i=!0,r=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=J4(),n=null==n?p5:n,this.originalName=p6(n),this.name=f6(this.originalName),this.trainable_=i,this.constraint=r,this.val=xh(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function m5(t){return t.map((t=>t.read()))}function g5(t){t.forEach((t=>{t[0].write(t[1])}))}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class y5{constructor(t){this.dtype=t.dtype,this.shape=t.shape,null!=t.shape?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class b5{constructor(t,e,n,i,r,s,o){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=i,this.callArgs=r,this.outputTensorIndex=o,this.id=J4(),null!=s&&(this.originalName=p6(s),this.name=f6(this.originalName)),this.rank=e.length}}let v5=0,x5=class{constructor(t,e){this.callArgs=e,this.id=v5++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const e of t.inboundLayers)null!=e&&e.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)null!=e?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},w5=0;class S5 extends qd{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=w5++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=D4(t)+"_"+t6(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}null!=t.weights?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new E4(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new M4(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return O4(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return O4(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new _4(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new _4(`Layer ${this.name} is not connected, no input to return.`);return O4(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new _4(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new _4(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return O4(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((t=>t()))}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach((e=>e.trainable=t)),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((t=>t.trainable)):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((t=>!t.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=L4(t);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=L4(this.inputSpec);if(e.length!==n.length)throw new M4(`Layer ${this.name} expects ${n.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let t=0;t<e.length;t++){const i=e[t],r=n[t];if(null==r)continue;const s=i.rank;if(null!=r.ndim&&s!==r.ndim)throw new M4(`Input ${t} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${s}`);if(null!=r.maxNDim&&s>r.maxNDim)throw new M4(`Input ${t} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${s}`);if(null!=r.minNDim&&s<r.minNDim)throw new M4(`Input ${t} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${s}.`);if(null!=r.dtype&&i.dtype!==r.dtype)throw new M4(`Input ${t} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${i.dtype}.`);if(r.axes){const e=i.shape;for(const n in r.axes){const i=Number(n),s=r.axes[n],o=i>=0?e[i]:e[e.length+i];if(null!=s&&-1===[s,null].indexOf(o))throw new M4(`Input ${t} is incompatible with layer ${this.name}: expected axis ${i} of input shape to have value ${s} but got shape ${e}.`)}}if(null!=r.shape)for(let e=0;e<r.shape.length;++e){const n=r.shape[e],s=i.shape[e];if(null!=n&&null!=s&&n!==s)throw new M4(`Input ${t} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${i.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=L4(t),i=function(t){let e=!0;for(const n of L4(t))if(!(n instanceof b5)){e=!1;break}return e}(t),r=function(t){let e=!0;for(const n of L4(t))if(n instanceof b5){e=!1;break}return e}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */(t);if(i===r)throw new M4("Arguments to apply() must be all SymbolicTensors or all Tensors");return d6(this.name,(()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of L4(t))e.push(n.shape);this.build(O4(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(t),r){let i=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,i);const r=L4(i),s=[];for(let t of r)-1!==n.indexOf(t)&&(t=t.clone()),s.push(t);if(i=O4(s),null!=this.activityRegularizer)throw new $4("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}{const n=function(t){t=L4(t);const e=[];for(const n of t)e.push(n.shape);return O4(e)}(t),i=this.computeOutputShape(n);let r;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),r=null!=i&&i.length>0&&Array.isArray(i[0])?i.map(((n,i)=>new b5(s,n,this,L4(t),e,this.name,i))):new b5(s,i,this,L4(t),e,this.name),this.addInboundNode(t,r,null,null,n,i,e),this._refCount++,null!=this.activityRegularizer)throw new $4("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}}))}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach(((n,i)=>{null!=n&&null!=t[i]&&t[i]!==n&&(e=!0)})),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new _4(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new _4(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new E4(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return d5(this.weights)}build(t){this.built=!0}getWeights(t=!1){return m5(t?this.trainableWeights:this.weights)}setWeights(t){Co((()=>{const e=this.weights;if(e.length!==t.length)throw new M4(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const n=[],i=m5(e);for(let r=0;r<i.length;++r){const s=i[r],o=e[r],a=t[r];if(!m(s.shape,a.shape))throw new M4(`Layer weight shape ${s.shape} not compatible with provided weight shape ${a.shape}`);n.push([o,a])}g5(n)}))}addWeight(t,e,n,i,r,s,o,a){if(-1!==this._addedWeightNames.indexOf(t))throw new M4(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(i=null!=a?a():a5("zeros"));const l=i.apply(e,n),c=new f5(l,n,t,s,o);return l.dispose(),null!=r&&this.addLoss((()=>r.apply(c.read()))),null==s&&(s=!0),s?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=L4(t),void 0!==this._losses&&null!==this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach((t=>{if(null!=t)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return e}setMaskMetadata(t,e,n){if(!this.supportsMasking)return;const i=this.computeMask(t,n);if(e instanceof Array&&i instanceof Array){if(e.length!==i.length)throw new Error(`${this.name} outputs ${e.length} tensors but ${i.length} masks for those tensors`);for(let t=0;t<e.length;t++)e[t].kerasMask=i[t]}else{if(i instanceof Array)throw new Error(`{this.name} outputs a single tensor but ${i.length} masks`);if(e instanceof Array)throw new Error(`{this.name} outputs ${e.length} tensors but only one mask`);e.kerasMask=i}}addInboundNode(t,e,n,i,r,s,o=null){const a=L4(t);e=L4(e),n=L4(n),i=L4(i),r=c5(r),s=c5(s);const l=[],c=[],u=[];for(const t of a)l.push(t.sourceLayer),c.push(t.nodeIndex),u.push(t.tensorIndex);new x5({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:u,inputTensors:a,outputTensors:e,inputMasks:n,outputMasks:i,inputShapes:r,outputShapes:s},o);for(let t=0;t<e.length;t++)e[t].sourceLayer=this,e[t].nodeIndex=this.inboundNodes.length-1,e[t].tensorIndex=t}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach((t=>t.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function k5(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const i=k5(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of i)-1===e.indexOf(t)&&e.push(t)}return e}}}class C5 extends S5{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:t6("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new M4("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new M4("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new M4("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const i=new b5(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new x5({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new M4(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}C5.className="InputLayer",Kd(C5);class T5{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof T5)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new M4(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return vo(e,t.dtype)}catch(n){throw new M4(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof b5){if(null==this.id2Value[t.id])throw new M4(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new M4(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof b5){if(null==this.id2Value[t.id])throw new M4(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new M4(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&To(this.id2Mask)}}const _5=new A4,E5=new A4;function M5(t,e,n,i){const r=null!=n&&n.training,s=Array.isArray(t),o=s?t:[t],a=o.map((t=>t.name)),l=[],u=e.names();for(const t of a)-1!==u.indexOf(t)?l.push(e.getValue(t)):l.push(null);null!=i&&(i.maxNumTensors=-1/0,i.minNumTensors=1/0);const h=a.join(",")+"|"+e.names().sort().join(",");let d,p=_5.get(h);if(null==p){const t=function(t,e){c(null!=t&&t.length>0,(()=>"Expected at least one fetch, got none"));let n=[],i={};if(1===t.length){const r=I5(t[0],e);n=r.sorted,i=r.recipientMap}else{const r=new Set;for(const s of t){const{sorted:t,recipientMap:o}=I5(s,e);for(const e of t)r.has(e.name)||(n.push(e),r.add(e.name));for(const t in o)null==i[t]&&(i[t]=new Set),o[t].forEach((e=>i[t].add(e)))}}return{sorted:n,recipientCounts:$5(i)}}(o,e);p=t.sorted,d=t.recipientCounts,_5.put(h,p),E5.put(h,d)}d={},r||Object.assign(d,E5.get(h));const f=new T5(e);for(let t=0;t<p.length;++t){if(null!=i){const t=ko().numTensors;t>i.maxNumTensors&&(i.maxNumTensors=t),t<i.minNumTensors&&(i.minNumTensors=t)}const s=p[t],o=s.sourceLayer;if(o instanceof C5)continue;const c=[],u=[],h=[];let m=!1;for(const t of s.inputs){const n=f.getValue(t),i=f.getMask(t);c.push(n),u.push(i),null!=i&&(m=!0),r||(d[t.name]--,0!==d[t.name]||e.hasKey(t)||-1!==a.indexOf(t.name)||n.isDisposed||!0===t.sourceLayer.stateful||h.push(n))}m&&((n=n||{}).mask=u[0]);const g=L4(o.apply(c,n));let y=null;o.supportsMasking&&(y=o.computeMask(c,u));const b=A5(s),v=Array.isArray(b)?b:[b];for(let t=0;t<v.length;++t){f.hasKey(v[t])||f.add(v[t],g[t],Array.isArray(y)?y[0]:y);const e=a.indexOf(v[t].name);-1!==e&&(l[e]=g[t])}r||To(h)}return f.disposeMasks(),s?l:l[0]}function $5(t){const e={};for(const n in t)e[n]=t[n].size;return e}function I5(t,e){const n=new Set,i=[],r={};for(const t of e.names())n.add(t);const s=[],o=[];for(s.push(t);s.length>0;){const t=s[s.length-1];if(n.has(t.name)){s.pop();continue}const e=o[o.length-1]===s.length-1;if(0===t.inputs.length||e)s.pop(),i.push(t),n.add(t.name),e&&o.pop();else{o.push(s.length-1);for(const e of t.inputs)null==r[e.name]&&(r[e.name]=new Set),r[e.name].add(t.name),n.has(e.name)||s.push(e)}}return{sorted:i,recipientMap:r}}function A5(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const i of t.sourceLayer.inboundNodes[e].outputTensors)if(i.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Y().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(t){null!=_5&&_5.setMaxEntries(t),null!=E5&&E5.setMaxEntries(t)}));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const N5={kernelName:et,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Po(t,th(vo(n,"float32"),-1))}}},R5={kernelName:nt,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=Sl(vo(n,"float32")),i=wl(Ql(xl(1),e));return Yl(Ro(t,i))}}}},P5={kernelName:it,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=wl(Ql(Sl(vo(n,"float32")),1));return Ro(t,e)}}}},O5={kernelName:rt,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=Ja(n.shape,i.shape);return{a:()=>{let e=t;const i=Za(n.shape,r);return i.length>0&&(e=kl(e,i)),ca(e,n.shape)},b:()=>{let e=t;const n=Za(i.shape,r);return n.length>0&&(e=kl(e,n)),ca(e,i.shape)}}}},L5={kernelName:st,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach(((e,i)=>{n[i]=()=>t.clone()})),n}},D5={kernelName:lt,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>nl(n)}}},F5={kernelName:ct,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>nl(n)}}},z5={kernelName:ut,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ro(t,wl(Ql(xl(1),Sl(vo(n,"float32")))))}}},B5={kernelName:ht,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=wl(Ao(xl(1),Sl(vo(n,"float32"))));return Ro(t,e)}}}},U5={kernelName:ft,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=Ja(n.shape,i.shape);return{a:()=>{const e=Ao(Sl(n),Sl(i));let s=Po(t,Ro(i,e));const o=Za(n.shape,r);return o.length>0&&(s=kl(s,o)),ca(s,n.shape)},b:()=>{const e=Ao(Sl(n),Sl(i));let s=Yl(Po(t,Ro(n,e)));const o=Za(i.shape,r);return o.length>0&&(s=kl(s,o)),ca(s,i.shape)}}}},V5={kernelName:dt,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ro(t,Ao(Sl(vo(n,"float32")),1))}}},W5={kernelName:pt,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ro(t,Ql(xl(1),Sl(vo(n,"float32"))))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H5=ys({avgPool3dGrad_:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t,e,n,i,r,s){const o=fs(t,"dy","avgPool3dGrad"),a=fs(e,"input","avgPool3dGrad");let l=o,u=a,h=!1;4===a.rank&&(h=!0,l=ca(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),u=ca(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),c(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),c(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),la("avgPool3dGrad",r,s);const d={dy:l,input:u},p={filterSize:n,strides:i,pad:r,dimRoundingMode:s},f=rs.runKernel(bt,d,p);return h?ca(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),j5={kernelName:yt,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{filterSize:r,strides:s,pad:o,dimRoundingMode:a}=n;return{x:()=>H5(t,i,r,s,o,a)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G5=ys({avgPoolGrad_:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t,e,n,i,r){const s=fs(t,"dy","avgPoolGrad"),o=fs(e,"input","avgPoolGrad");c(o.rank===s.rank,(()=>`Rank of input (${o.rank}) does not match rank of dy (${s.rank})`));let a=o,l=s,u=!1;3===o.rank&&(u=!0,a=ca(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=ca(s,[1,s.shape[0],s.shape[1],s.shape[2]])),c(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),c(4===a.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`));const h={dy:l,input:a},d={filterSize:n,strides:i,pad:r},p=rs.runKernel(gt,h,d);return u?ca(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),q5={kernelName:mt,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{filterSize:r,strides:s,pad:o}=n;return{x:()=>G5(t,i,r,s,o)}}},X5={kernelName:vt,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[i,r]=e,{transposeA:s,transposeB:o}=n;return s||o?!s&&o?{a:()=>pa(t,r,!1,!1),b:()=>pa(t,i,!0,!1)}:s&&!o?{a:()=>pa(r,t,!1,!0),b:()=>pa(i,t,!1,!1)}:{a:()=>pa(r,t,!0,!0),b:()=>pa(t,i,!0,!0)}:{a:()=>pa(t,r,!1,!0),b:()=>pa(i,t,!0,!1)}}},K5={kernelName:xt,gradFunc:(t,e,n)=>{const{blockShape:i,crops:r}=n;return{x:()=>Nc(t,i,r)}}},Y5={kernelName:kt,gradFunc:(t,e,n)=>{const i=n,r=i.inputShape,s=i.shape,o=Array.from(s);for(let t=r.length-1;t>=0;t--)if(r[t]===s[t])o[t]=1;else if(1!==r[t])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);const a=[];for(let t=0;t<o.length;t++)o[t]>1&&a.push(t);return{x:()=>kl(t,a,!0)}}},Z5={kernelName:Tt,gradFunc:t=>({x:()=>t.clone()})},J5={kernelName:_t,gradFunc:t=>({x:()=>nl(t)})},Q5={kernelName:Et,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{clipValueMin:r,clipValueMax:s}=n;return{x:()=>el(nc(Ol(i,r),Vl(i,s)),t,nl(t))}}},t9={kernelName:$t,inputsToSave:["x"],gradFunc:N5.gradFunc},e9={kernelName:It,saveAllInputs:!0,gradFunc:(t,e,n)=>{const i=e.map((t=>t.shape)),{axis:r}=n,s=w(r,e[0].shape)[0],o=i.map((t=>t[s]));return Ku(t,o,s).map((t=>()=>t))}},n9={kernelName:At,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[i,r]=e,{dilations:s,strides:o,pad:a,dataFormat:l}=n;return c(ra(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>La(i.shape,t,r,o,a,l),filter:()=>Rh(i,t,r.shape,o,a,l)}}},i9={kernelName:Rt,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[i,r]=e,{strides:s,pad:o,dataFormat:a,dimRoundingMode:l}=n;return{dy:()=>Pa(t,r,s,o,a,1,l),filter:()=>Rh(t,i,r.shape,s,o,a,l)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r9=ys({conv3DBackpropFilter_:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t,e,n,i,r){let s=t;4===t.rank&&(s=ca(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=e;4===o.rank&&(o=ca(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),c(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),c(5===o.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`)),c(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),c(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),c(o.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`));const a={x:s,dy:o},l={strides:i,pad:r,filterShape:n};return rs.runKernel(Ot,a,l)}}),s9={kernelName:Pt,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:i,strides:r,pad:s}=n;c(ra(i),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));const[o,a]=e;return{x:()=>za(o.shape,t,a,r,s),filter:()=>r9(o,t,a.shape,r,s)}}},o9={kernelName:Dt,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Po(Yl(zu(vo(n,"float32"))),t)}}},a9={kernelName:Ft,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Po(Bu(vo(n,"float32")),t)}}},l9={kernelName:Bt,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{axis:r,exclusive:s,reverse:o}=n;return{x:()=>{const e=fl([r],i.rank);let n=Ha(t,r,s,!o);return null!=e&&(n=Ch(n,e)),n}}}},c9={kernelName:Ht,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:i,strides:r,pad:s,dimRoundingMode:o}=n,a=null==i?[1,1]:i;c(ra(a),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`));const[l,u]=e;return c(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),c(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),c(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),c(sa(r,a),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`)),la("depthwiseConv2d",s,o),{x:()=>Bh(l.shape,t,u,r,s,a,o),filter:()=>zh(l,t,u.shape,r,s,a,o)}}},u9={kernelName:Xt,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[i,r]=e,s={x:i,filter:r,dy:t},o={x:i,filter:r,dy:t};return{x:()=>rs.runKernel(Kt,s,n),filter:()=>rs.runKernel(Yt,o,n)}}},h9={kernelName:te,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,i={dy:t,y:n};return{x:()=>rs.runKernel(ee,i)}}},d9={kernelName:ne,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,i=Po(El(Yl(Sl(n))),2/Math.sqrt(Math.PI));return{x:()=>Po(t,i)}}},p9={kernelName:re,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Po(t,n)}}},f9={kernelName:se,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>ca(t,n.shape)}}},m9={kernelName:oe,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Po(t,El(n))}}},g9={kernelName:ue,gradFunc:t=>({x:()=>nl(t)})},y9={kernelName:he,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=Ja(n.shape,i.shape);return{a:()=>{const e=Ro(t,vo(i,"float32")),s=Za(n.shape,r);return s.length>0?ca(kl(e,s),n.shape):e},b:()=>{let e=Po(t,vo(n,"float32"));const s=Za(i.shape,r);s.length>0&&(e=ca(kl(e,s),i.shape));const o=Sl(i);return Yl(Ro(e,vo(o,"float32")))}}}},b9={kernelName:de,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:i}=n,[r,s,o,a]=e,l=null==a?xl(1):a,c=Za(s.shape,r.shape),u=[];if(1===s.rank){for(let t=0;t<r.shape.length-1;++t)u.push(r.shape[t]);u.push(1)}const h=Ql(r,s),d=Po(t,l),p=Pu(Ao(o,xl(i))),f=Po(Po(Po(p,p),p),xl(-.5));return{x:()=>1===s.rank?ca(Po(Po(t,Il(ca(p,[1,1,1,s.shape[0]]),u)),l),r.shape):ca(Po(Po(t,p),l),r.shape),mean:()=>{let t=Po(Po(p,xl(-1)),d);return 1===s.rank&&(t=kl(t,c)),ca(t,s.shape)},variance:()=>{let t=Po(Po(f,h),d);return 1===s.rank&&(t=kl(t,c)),ca(t,s.shape)},scale:()=>{const e=Po(h,p);let n=Po(t,e);return 1===s.rank&&(n=kl(n,c)),ca(n,s.shape)},offset:()=>{let e=t;return 1===s.rank&&(e=kl(e,c)),ca(e,s.shape)}}}},v9={kernelName:pe,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[i,r]=e,{axis:s,batchDims:o}=n,a=w(s,i.shape)[0],l=(t,e,n)=>()=>{const i=t.shape,r=e.size,o=i.slice(0,a),l=o.length,c=i.slice(s,i.length).slice(1),u=c.length,h=x9(0,l),d=x9(l+1,l+1+u),p=w9([o,[r],c]),f=ca(n,p),m=ca(e,[r]),g=w9([[l],h,d]),y=Ch(f,g);let b=yh(y,m,t.shape[a]);const v=ml(g);return b=Ch(b,v),b};if(1===o){const e=i.shape[0],n=i.split(e,0),s=()=>{const e=Qu(n.map(((e,n)=>l(e,r.slice(n,1),t.slice(n,1))())));return e.reshape(i.shape)};return{x:s,indices:()=>r}}return{x:l(i,r,t),indices:()=>r}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x9(t,e){const n=[];for(let i=t;i<e;++i)n.push(i);return n}function w9(t){const e=[];for(let n=0;n<t.length;++n)for(let i=0;i<t[n].length;++i)e.push(t[n][i]);return e}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S9={kernelName:ge,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e;return{a:()=>nl(n),b:()=>nl(i)}}},k9={kernelName:ye,gradFunc:t=>({x:()=>vo(t,"float32")})},C9={kernelName:xe,gradFunc:t=>({x:()=>nl(t)})},T9={kernelName:we,gradFunc:t=>({x:()=>nl(t)})},_9={kernelName:Se,gradFunc:t=>({x:()=>nl(t)})},E9={kernelName:ke,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{alpha:r}=n,s=Pl(i,0);return{x:()=>el(s,t,Po(t,r))}}},M9={kernelName:Me,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ro(t,Ao(n,1))}}},$9={kernelName:Ee,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ro(t,vo(n,"float32"))}}},I9={kernelName:Ne,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[i]=e,{axis:r}=n;return{logits:()=>{const e=El(i);return Ql(t,Po(kl(t,r,!0),e))}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A9=ys({localResponseNormalizationBackprop_:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t,e,n,i=5,r=1,s=1,o=.5){const a={x:t,y:e,dy:n},l={depthRadius:i,bias:r,alpha:s,beta:o};return rs.runKernel(Pe,a,l)}}),N9={kernelName:Re,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[i,r]=e,{depthRadius:s,bias:o,alpha:a,beta:l}=n;return{x:()=>A9(i,r,t,s,o,a,l)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function R9(t,e,n,i){return e.rank<n.rank&&(e=ca(e,dl(e.shape,i))),t.rank<n.rank&&(t=ca(t,dl(t.shape,i))),{x:()=>Po(t,vo(tl(n,e),t.dtype))}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P9={kernelName:Oe,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const i=n,{reductionIndices:r}=i,s=e[0],o=R9(t,e[1],s,w(r,s.shape));return{x:()=>o.x()}}},O9={kernelName:Le,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e;return{a:()=>Po(t,vo(Ol(n,i),"float32")),b:()=>Po(t,vo(Ul(n,i),"float32"))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L9=ys({maxPool3dGrad_:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t,e,n,i,r,s,o){const a=fs(t,"dy","maxPool3dGrad"),l=fs(e,"input","maxPool3dGrad"),u=fs(n,"output","maxPool3dGrad");let h=a,d=l,p=u,f=!1;4===l.rank&&(f=!0,h=ca(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=ca(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=ca(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),c(5===h.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`)),c(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),c(5===p.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`)),la("maxPool3dGrad",s,o);const m={dy:h,input:d,output:p},g={filterSize:i,strides:r,pad:s,dimRoundingMode:o},y=rs.runKernel(Be,m,g);return f?ca(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}}),D9={kernelName:ze,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[i,r]=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=n;return{x:()=>L9(t,i,r,s,o,a,l)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F9=ys({maxPoolGrad_:
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t,e,n,i,r,s,o){const a=fs(t,"dy","maxPoolGrad"),l=fs(e,"input","maxPoolGrad"),u=fs(n,"output","maxPoolGrad");c(l.rank===a.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`)),c(4===a.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`)),c(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),la("maxPoolGrad",s,o);const h={dy:a,input:l,output:u},d={filterSize:i,strides:r,pad:s,dimRoundingMode:o};return rs.runKernel(Fe,h,d)}}),z9={kernelName:De,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[i,r]=e,{filterSize:s,strides:o,pad:a}=n;return{x:()=>F9(t,i,r,s,o,a)}}},B9={kernelName:Ve,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{axis:r}=n,s=w(r,i.shape),o=d(hl(i.shape,s)[1]);return{x:()=>{const e=i.shape.slice();s.forEach((t=>{e[t]=1}));const n=ca(t,e);return Ro(Po(n,mc(i.shape,"float32")),o)}}}},U9={kernelName:We,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const i=n,{axis:r}=i,[s,o]=e,a=R9(t,o,s,w(r,s.shape));return{x:()=>a.x()}}},V9={kernelName:He,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e;return{a:()=>Po(t,vo(Vl(n,i),"float32")),b:()=>Po(t,vo(Pl(n,i),"float32"))}}},W9={kernelName:je,inputsToSave:["x"],gradFunc:(t,e,n)=>{const i=e[0],{paddings:r}=n,s=r.map((t=>t[0]));return{x:()=>ma(t,s,i.shape)}}},H9={kernelName:Ge,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=Ja(n.shape,i.shape);return{a:()=>{const e=Za(n.shape,r);return e.length>0?ca(kl(t,e),n.shape):t},b:()=>{const e=Po(t,Yl(Nl(Ro(n,i)))),s=Za(i.shape,r);return s.length>0?ca(kl(e,s),i.shape):e}}}},j9={kernelName:Xe,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=Ja(n.shape,i.shape);return{a:()=>{const e=Po(t,vo(i,"float32")),s=Za(n.shape,r);return s.length>0?ca(kl(e,s),n.shape):e},b:()=>{const e=Po(t,vo(n,"float32")),s=Za(i.shape,r);return s.length>0?ca(kl(e,s),i.shape):e}}}},G9={kernelName:nn,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:i}=n;return bh(t,i).map((t=>()=>t))}},q9={kernelName:rn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const i=e[0],{paddings:r}=n,s=r.map((t=>t[0]));return{x:()=>ma(t,s,i.shape)}}},X9={kernelName:sn,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,i,r]=e,s=n,o=i,a=Ja(s.shape,o.shape);return{a:()=>{const e=vo(o,"float32");let n=Po(t,Po(e,vl(s,Ql(e,xl(1)))));const i=Za(s.shape,a);return i.length>0&&(n=kl(n,i)),ca(n,s.shape)},b:()=>{const e=Pl(s,0),n=el(e,jl(s),nl(s));let i=Po(t,Po(r,n));const l=Za(o.shape,a);return l.length>0&&(i=kl(i,l)),ca(i,o.shape)}}}},K9={kernelName:on,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,i]=e,r=Pl(n,0);return{x:()=>el(r,t,Po(t,i)),alpha:()=>{let e=el(r,nl(t),Po(t,n));const s=Za(i.shape,t.shape);return s.length>0&&(e=kl(e,s)),ca(e,i.shape)}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y9(t,e,n){const i=t.shape.length,r=i-n.length,s=fl(n,i);let o=t;null!=s&&(o=Ch(t,s));const a=o.shape.slice(),l=a.splice(i-n.length,n.length).reduce(((t,e)=>t*e),1);a.push(l);let c=
/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function(t,e,n){const i=t.shape.slice();i[n]=1;const r=ca(e,i),s=Wa(t,n,!0,!1),o=Wa(t,n,!0,!0),a=Po(s,o);return Po(r,a)}(o.reshape(a),e,r);if(c=c.reshape(o.shape),null!=s){const t=ml(s);c=Ch(c,t)}return c}const Z9={kernelName:an,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{axis:r}=n;let s=[];return s=null==r?i.shape.map(((t,e)=>e)):"number"==typeof r?[r]:r,{x:()=>Y9(i,t,s)}}},J9={kernelName:Jt,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=Ja(n.shape,i.shape);return{a:()=>{const e=Ro(t,vo(i,"float32")),s=Za(n.shape,r);return s.length>0?ca(kl(e,s),n.shape):e},b:()=>{let e=Po(t,vo(n,"float32"));const s=Za(i.shape,r);s.length>0&&(e=ca(kl(e,s),i.shape));const o=Sl(i);return Yl(Ro(e,vo(o,"float32")))}}}},Q9={kernelName:pn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ro(t,Yl(Sl(n)))}}},t8={kernelName:xn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,i=Po(Vl(n,6),th(n));return{x:()=>Po(t,vo(i,"float32"))}}},e8={kernelName:fn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Po(t,vo(th(n),"float32"))}}},n8={kernelName:mn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ca(t,n.shape)}}},i8={kernelName:kn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Yl(Ro(t,Po(vl(n,1.5),2)))}}},r8={kernelName:Mn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=Pl(n,xl(0)),i=xl(xf),r=xl(wf),s=Po(t,r),o=Po(Po(t,i),El(vo(n,"float32")));return el(e,s,o)}}}},s8={kernelName:Rn,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Po(t,Po(n,Ql(xl(1),n)))}}},o8={kernelName:In,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Po(Ua(vo(n,"float32")),t)}}},a8={kernelName:An,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Po(Va(vo(n,"float32")),t)}}},l8={kernelName:$n,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{begin:r,size:s}=n,o=i.shape,[a,l]=Yp(i,r,s),c=[];for(let e=0;e<t.rank;e++)c.push([a[e],o[e]-a[e]-l[e]]);return{x:()=>Ec(t,c)}}},c8={kernelName:zn,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[i]=e,{dim:r}=n,s=Po(t,i);return{logits:()=>Ql(s,Po(kl(s,[r],true),i))}}},u8={kernelName:Pn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Po(t,fa(n))}}},h8={kernelName:Dn,gradFunc:(t,e,n)=>{const{blockShape:i,paddings:r}=n;return{x:()=>ba(t,i,r)}}},d8={kernelName:Fn,gradFunc:(t,e,n)=>{const{axis:i}=n;return{x:()=>da(t,i)}}},p8={kernelName:On,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ro(t,Po(wl(vo(n,"float32")),2))}}},f8={kernelName:Gn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Po(t,Po(vo(n,"float32"),2))}}},m8={kernelName:jn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=xl(2);return{a:()=>Po(t,Po(r,Ql(n,i))),b:()=>Po(t,Po(r,Ql(i,n)))}}},g8={kernelName:Jn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,i]=e,r=Ja(n.shape,i.shape);return{a:()=>{let e=t;const i=Za(n.shape,r);return i.length>0&&(e=kl(e,i)),ca(e,n.shape)},b:()=>{let e=t;const n=Za(i.shape,r);return n.length>0&&(e=kl(e,n)),ca(Yl(e),i.shape)}}}},y8={kernelName:Ln,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,r=i.shape.slice(),{axis:s}=n;w(s,i.shape).forEach((t=>{r[t]=1}));const o=ca(t,r),a=Po(o,mc(i.shape,"float32"));return{x:()=>a}}},b8={kernelName:Qn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ro(t,Sl(Ua(n)))}}},v8={kernelName:ti,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Po(Ql(xl(1),Sl(n)),t)}}},x8={kernelName:ei,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[i]=e,{reps:r}=n;return{x:()=>{let e=nl(i);if(1===i.rank)for(let n=0;n<r[0];++n)e=Ao(e,ma(t,[n*i.shape[0]],[i.shape[0]]));else if(2===i.rank)for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)e=Ao(e,ma(t,[n*i.shape[0],s*i.shape[1]],[i.shape[0],i.shape[1]]));else if(3===i.rank)for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)for(let o=0;o<r[2];++o)e=Ao(e,ma(t,[n*i.shape[0],s*i.shape[1],o*i.shape[2]],[i.shape[0],i.shape[1],i.shape[2]]));else{if(4!==i.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${i.rank} tensors yet.`);for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)for(let o=0;o<r[2];++o)for(let a=0;a<r[3];++a)e=Ao(e,ma(t,[n*i.shape[0],s*i.shape[1],o*i.shape[2],a*i.shape[3]],[i.shape[0],i.shape[1],i.shape[2],i.shape[3]]))}return e}}}},w8={kernelName:ai,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=dc(e,nl(e)),i=Rl(t,n);let r=Ol(e,xl(0,"int32"));const s=i.rank-r.rank;for(let t=0;t<s;++t)r=Ml(r,t+1);r=nc(r,mc(i.shape,"bool"));const o=nl(i);return el(r,i,o)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(t,n)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S8=[N5,R5,P5,O5,L5,D5,F5,z5,B5,U5,V5,W5,j5,q5,X5,K5,Y5,Z5,J5,Q5,t9,e9,i9,n9,s9,o9,a9,l9,c9,u9,J9,h9,d9,p9,f9,m9,y9,g9,b9,v9,S9,k9,C9,T9,_9,E9,M9,$9,I9,N9,P9,P9,O9,D9,z9,B9,U9,V9,W9,H9,j9,{kernelName:Ke,gradFunc:t=>({x:()=>Yl(t)})},{kernelName:en,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>fc(n.shape,"float32")}}},{kernelName:tn,gradFunc:t=>({x:()=>nl(t)})},G9,q9,q9,X9,K9,Z9,Q9,t8,e8,n8,{kernelName:bn,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[i]=e,r={dy:t,images:i};return{images:()=>rs.runKernel(vn,r,n)}}},{kernelName:gn,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[i]=e,r={dy:t,images:i};return{images:()=>rs.runKernel(yn,r,n)}}},{kernelName:wn,gradFunc:(t,e,n)=>{const{dims:i}=n,r=w(i,t.shape);return{x:()=>Mu(t,r)}}},{kernelName:Sn,gradFunc:t=>({x:()=>nl(t)})},i8,{kernelName:En,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>vo(nl(n),"float32"),t:()=>Po(t,vo(n,t.dtype)),e:()=>Po(t,vo(ic(n),t.dtype))}}},r8,s8,{kernelName:Nn,gradFunc:t=>({x:()=>nl(t)})},o8,a8,l8,c8,u8,h8,h8,d8,d8,p8,m8,f8,{kernelName:ci,gradFunc:t=>({x:()=>nl(t)})},g8,y8,b8,v8,x8,{kernelName:ri,gradFunc:(t,e,n)=>{const i=n,{perm:r}=i,s=ml(r);return{x:()=>Ch(t,s)}}},{kernelName:oi,gradFunc:(t,e,n)=>{const i=n,{axis:r}=i;return{value:()=>Qu(t,r)}}},w8,{kernelName:li,gradFunc:t=>({x:()=>nl(t)})}];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */for(const t of S8)Si(t);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function k8(t,e){return Co((()=>wl(kl(Po(t,t),e,!0))))}class C8 extends qd{getConfig(){return{}}}class T8 extends C8{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return Co((()=>{const e=k8(t,this.axis),n=$a(e,0,this.maxValue);return Po(t,Ro(n,Ao(k6(),e)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}T8.className="MaxNorm",Kd(T8);class _8 extends C8{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return Co((()=>Ro(t,Ao(k6(),k8(t,this.axis)))))}getConfig(){return{axis:this.axis}}}_8.className="UnitNorm",Kd(_8);class E8 extends C8{apply(t){return _u(t)}}E8.className="NonNeg",Kd(E8);class M8 extends C8{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return Co((()=>{const e=k8(t,this.axis),n=Ao(Po(this.rate,$a(e,this.minValue,this.maxValue)),Po(1-this.rate,e));return Po(t,Ro(n,Ao(k6(),e)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}M8.className="MinMaxNorm",Kd(M8);const $8={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function I8(t){return B4(t)}function A8(t,e={}){return V4(t,Xd.getMap().classNameMap,e,"constraint")}function N8(t){if(null==t)return null;if("string"==typeof t){return A8({className:t in $8?$8[t]:t,config:{}})}return t instanceof C8?t:A8(t)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function R8(t){if(null==t)return;const e=[],n=[],i=[];for(const r in t){const s=t[r];if("number"!=typeof s){const t=s;e.push(t.data()),n.push(r),i.push(t)}}if(e.length>0){const r=await Promise.all(e);for(let e=0;e<r.length;++e)t[n[e]]=r[e][0];To(i)}}function P8(t){if(null!=t)for(const e in t){const n=t[e];"number"!=typeof n&&n.dispose()}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var O8;!function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(O8||(O8={}));class L8{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class D8{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class F8 extends L8{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const t in e){const i=e[t];if("number"==typeof i)this.totals.hasOwnProperty(t)||(this.totals[t]=0),this.totals[t]=this.totals[t]+i*n;else{let e;t in this.totals?e=this.totals[t]:this.totals[t]=0;const r=Co((()=>Ao(this.totals[t],Po(i,n))));this.totals[t]=r,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const t of this.params.metrics)null!=this.totals[t]&&("number"==typeof this.totals[t]?e[t]=this.totals[t]/this.seen:Co((()=>{const n=Po(Ro(1,this.seen),this.totals[t]);e[t]=n,this.totals[t].dispose(),_o(e[t])})))}}class z8 extends L8{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const t in e)null==this.history[t]&&(this.history[t]=[]),this.history[t].push(e[t])}async syncData(){const t=[],e=[],n=[];for(const i in this.history){const r=this.history[i];for(let s=0;s<r.length;++s)if("number"!=typeof r[s]){const o=r[s];t.push(o.data()),e.push(i),n.push(s)}}const i=await Promise.all(t);for(let t=0;t<i.length;++t){this.history[e[t]][n[t]].dispose(),this.history[e[t]][n[t]]=i[t][0]}}}class B8 extends L8{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||rf,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");N(this.yieldEvery)&&(this.maybeWait=function(t,e,n){let i,r=null!=n?n():mr();return(...s)=>{const o=null!=n?n():mr();return o-r<e||(r=o,i=t(...s)),i}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const i=[];null!=this.yield&&(await R8(n),i.push(this.yield(t,e,n))),i.push(this.nextFrameFunc()),await Promise.all(i)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await R8(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await R8(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await R8(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await R8(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):N(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await R8(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await R8(t),await this.trainEnd(t))}}function U8(t,e){if(null==t&&(t={}),t instanceof L8)return[t];if(Array.isArray(t)&&t[0]instanceof L8)return t;return L4(t).map((t=>new B8(t,e)))}class V8{constructor(){}static registerCallbackConstructor(t,e){c(t>=0&&Number.isInteger(t),(()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`)),V8.checkForDuplicate(e),null==V8.constructors[t]&&(V8.constructors[t]=[]),V8.constructors[t].push(e)}static checkForDuplicate(t){for(const e in V8.constructors){V8.constructors[+e].forEach((e=>{if(e===t)throw new M4("Duplicate callback constructor.")}))}}static clear(){V8.constructors={}}static createCallbacks(t){const e=[];for(const n in V8.constructors){const i=+n;t>=i&&e.push(...V8.constructors[i])}return e.map((t=>new t))}}function W8(t,e,n,i,r,s,o,a,l){const c=new z8,u=[new F8,...V8.createCallbacks(e)];null!=t&&u.push(...t),u.push(c);const h=new D8(u);return h.setParams({epochs:n,initialEpoch:i,samples:r,steps:s,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:c}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function H8(t,e={},n=!1){return V4(t,Xd.getMap().classNameMap,e,"layer",n)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function j8(t,e){return Co((()=>{"float32"!==t.dtype&&(t=vo(t,"float32"));const n=kl(O6(t),e,!0),i=Ma(n.shape,k6()),r=wl(dc(n,i));return Ro(t,r)}))}function G8(t,e){return Co((()=>pc(O6(Ql(e,t)),-1)))}function q8(t,e){return Co((()=>pc(Oo(Ql(e,t)),-1)))}function X8(t,e){return Co((()=>{const n=Ql(t,e),i=$a(Oo(t),k6(),Number.MAX_VALUE),r=Oo(Ro(n,i));return Po(100,pc(r,-1))}))}function K8(t,e,n=!1){return Co((()=>{if(n)e=ju(e);else{const t=kl(e,e.shape.length-1,!0);e=Ro(e,t)}return e=$a(e,k6(),1-k6()),Yl(kl(Po(vo(t,"float32"),jl(e)),e.shape.length-1))}))}function Y8(t,e,n=!1){return Co((()=>{const i=vo(Nl(function(t){const e=[b6(t.shape)];return ca(t,e)}(t)),"int32"),r=(e=$a(e,k6(),1-k6())).shape;return K8(ca(Cc(i,r[r.length-1]),r),e,n)}))}function Z8(t,e){return Co((()=>{let n;return n=$a(e,k6(),1-k6()),n=jl(Ro(n,Ql(1,n))),pc(function(t,e){if(!m(t.shape,e.shape))throw new M4(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return Co((()=>{const n=_u(e),i=Yl(Oo(e));return Ao(Ql(n,Po(e,t)),Gl(El(i)))}))}(t,n),-1)}))}function J8(t,e){return Co((()=>{const n=j8(t,-1),i=j8(e,-1),r=Po(n,i);return Yl(kl(r,-1))}))}V8.constructors={};const Q8={meanSquaredError:G8,meanAbsoluteError:q8,meanAbsolutePercentageError:X8,meanSquaredLogarithmicError:function(t,e){return Co((()=>{const n=$a(e,k6(),Number.MAX_VALUE),i=jl(Ao(1,n)),r=$a(t,k6(),Number.MAX_VALUE),s=jl(Ao(1,r));return pc(O6(Ql(i,s)),-1)}))},squaredHinge:function(t,e){return Co((()=>{const n=dc(0,Ql(1,Po(t,e)));return pc(O6(n),-1)}))},hinge:function(t,e){return Co((()=>{const n=dc(0,Ql(1,Po(t,e)));return pc(n,-1)}))},categoricalHinge:function(t,e){return Co((()=>{const n=kl(Po(t,e),-1),i=yl(Po(Ql(1,t),e),-1);return dc(0,Ao(1,Ql(i,n)))}))},logcosh:function(t,e){return Co((()=>{const n=Math.log(2),i=Ql(e,t),r=Ql(Ao(i,Zl(Po(-2,i))),n);return pc(r,-1)}))},categoricalCrossentropy:K8,sparseCategoricalCrossentropy:Y8,binaryCrossentropy:Z8,kullbackLeiblerDivergence:function(t,e){return Co((()=>{const n=$a(t,k6(),1),i=$a(e,k6(),1);return kl(Po(t,jl(Ro(n,i))),-1)}))},poisson:function(t,e){return Co((()=>{const n=jl(Ao(k6(),e));return pc(Ql(e,Po(t,n)),-1)}))},cosineProximity:J8};function t7(t){if("string"==typeof t){if(t in Q8)return Q8[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new M4(e)}return t}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function e7(t,e){return Co((()=>{const n=Po(.5,Tc(e)),i=C6(Pl(e,n),t.dtype);return pc(tl(t,i),-1)}))}function n7(t,e){return Co((()=>C6(tl(Uo(t,-1),Uo(e,-1)),"float32")))}function i7(t,e){return Z8(t,e)}function r7(t,e){return t.rank===e.rank&&(t=Ju(t,[t.rank-1])),(e=Uo(e,-1)).dtype!==t.dtype&&(e=vo(e,t.dtype)),vo(tl(t,e),"float32")}const s7=K8,o7=Y8,a7={binaryAccuracy:e7,categoricalAccuracy:n7,precision:function(t,e){return Co((()=>{const n=function(t,e){return Co((()=>vo(kl(nc(tl(t,1),tl(e,1))),"float32")))}(t,e),i=function(t,e){return Co((()=>vo(kl(nc(tl(t,0),tl(e,1))),"float32")))}(t,e),r=Ao(n,i);return vo(el(Pl(r,0),Ro(n,r),0),"float32")}))},categoricalCrossentropy:s7,sparseCategoricalCrossentropy:o7,mse:G8,MSE:G8,mae:q8,MAE:q8,mape:X8,MAPE:X8,cosine:J8};function l7(t){if("string"==typeof t&&t in a7)return a7[t];if("string"!=typeof t&&null!=t)return t;throw new M4(`Unknown metric ${t}`)}function c7(t){if(R4(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let e;for(const n of Object.keys(Q8))if(Q8[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(a7))if(a7[n]===t){e=n;break}return void 0!==e?e:t.name}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const u7=1048576;function h7(t,e,n=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!d7(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>u7&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function d7(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!=typeof n)return!1;if(!d7(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!d7(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function p7(t,e,n,i=console.log){const r=function(t){let e=!0;const n=[],i=[];for(const e in t.nodesByDepth)n.push(t.nodesByDepth[e]);for(const t of n){if(t.length>1||1===t.length&&t[0].inboundLayers.length>1){e=!1;break}i.push(...t)}if(e)for(const n of t.layers){let t=!1;for(const r of n.inboundNodes)if(-1!==i.indexOf(r)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),s=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(r?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((t=>Math.floor(e*t)))),!r){s.push("Receives inputs"),o=[];for(const e in t.nodesByDepth)o.push(...t.nodesByDepth[e])}i("_".repeat(e)),f7(s,n,i),i("=".repeat(e));const a=t.layers;for(let t=0;t<a.length;++t)r?m7(a[t],n,i):g7(a[t],n,o,i),i((t===a.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;e=null!=t.collectedTrainableWeights?d5(t.collectedTrainableWeights):d5(t.trainableWeights);return e}(t),c=d5(t.nonTrainableWeights);i(`Total params: ${l+c}`),i(`Trainable params: ${l}`),i(`Non-trainable params: ${c}`),i("_".repeat(e))}function f7(t,e,n=console.log){let i="";for(let n=0;n<t.length;++n)n>0&&(i=i.slice(0,i.length-1)+" "),i+=t[n],i=i.slice(0,e[n]),i+=" ".repeat(e[n]-i.length);n(i)}function m7(t,e,n){let i,r;try{r=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(t){r="multiple"}try{i=JSON.stringify(t.outputShape)}catch(t){i="multiple"}f7([`${t.name} (${t.getClassName()})`,r,i,t.countParams().toString()],e,n)}function g7(t,e,n,i){let r,s;try{s=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(t){s="multiple"}try{r=JSON.stringify(t.outputShape)}catch(t){r="multiple"}const o=[];for(const e of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(e)))for(let t=0;t<e.inboundLayers.length;++t){const n=e.inboundLayers[t].name,i=e.nodeIndices[t],r=e.tensorIndices[t];o.push(`${n}[${i}][${r}]`)}const a=t.name,l=t.getClassName(),c=0===o.length?"":o[0];f7([`${a} (${l})`,s,r,t.countParams().toString(),c],e,i);for(let t=1;t<o.length;++t)f7(["","","","",o[t]],e,i)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function y7(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"==typeof n}function b7(t,e){if(null===t)return null;if("string"==typeof t)return F4(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],i=t.length;for(let r=0;r<i;++r){const i=t[r];y7(e,r,i)?n.push(i):n.push(b7(i,e))}return n}{const e={};for(const n of Object.keys(t)){const i=t[n];if("name"===n&&"string"==typeof i)e[n]=i;else{const t=F4(n);e[t]=b7(i,t)}}return e}}function v7(t,e){if(null==t)return null;if("string"==typeof t)return D4(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],i=t.length;for(let r=0;r<i;++r){const i=t[r];y7(e,r,i)?n.push(i):n.push(v7(i,e))}return n}{const e={};for(const n of Object.keys(t)){const i=t[n],r=D4(n);e[r]="name"!==n&&"className"!==n||"string"!=typeof i?v7(i,n):i}return e}}
/** @license See the LICENSE file. */const x7="4.11.0";
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class w7 extends S5{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=t6(t)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],H4(this.inputs).length!==this.inputs.length)throw new M4(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((t=>t.name))}`);H4(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((t=>t.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const t of this.outputs){const e=t.sourceLayer,n=t.nodeIndex,i=t.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(i)}for(const t of this.inputs){const e=t.sourceLayer,n=t.nodeIndex,i=t.tensorIndex;R4(0===n,"input layer has >1 nodes"),R4(0===i,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(i)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let e=0;e<this.inputLayers.length;e++){const n=this.inputLayers[e];if(!(n instanceof C5))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${e} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(const t of this.outputLayers)this.outputNames.push(t.name);this.internalInputShapes=this.inputs.map((t=>t.shape)),this.internalOutputShapes=this.outputs.map((t=>t.shape));const e={},n={},i={},r={},s={},o=[],a=(t,e,n,i,r,l)=>{null!=i&&null!=r&&null!=l||(i=t.sourceLayer,r=t.nodeIndex,l=t.tensorIndex);const c=i.inboundNodes[r];if(-1!==n.indexOf(c))throw new E4(`The tensor ${t.name} at layer "${i.name}" is part of a cycle.`);if(-1!==e.indexOf(c))return;this.containerNodes.add(w7.nodeKey(i,r)),i.id in s||(s[i.id]=Object.keys(s).length),-1===n.indexOf(c)&&n.push(c);const u=c.inboundLayers.length;for(let t=0;t<u;t++){const i=c.inputTensors[t],r=c.inboundLayers[t],s=c.nodeIndices[t],o=c.tensorIndices[t];a(i,e,n,r,s,o)}for(e.push(c);n.indexOf(c)>=0;)n.splice(n.indexOf(c),1);o.push(c)},l=[],c=[];for(const t of this.outputs)a(t,l,c);const u=o.slice().reverse();for(const t of u){n[t.id]=t,t.id in e||(e[t.id]=0);let s=e[t.id];const o=null==i[t.outboundLayer.id]?0:i[t.outboundLayer.id];s=Math.max(s,o),i[t.outboundLayer.id]=s,r[t.outboundLayer.id]=t.outboundLayer,e[t.id]=s;for(let i=0;i<t.inboundLayers.length;i++){const r=t.inboundLayers[i],o=t.nodeIndices[i],a=r.inboundNodes[o],l=null==e[a.id]?0:e[a.id];e[a.id]=Math.max(s+1,l),n[a.id]=a}}const h={};for(const t in e){const i=e[t];i in h||(h[i]=[]),h[i].push(n[t])}const d={};for(const t in i){const e=i[t];e in d||(d[e]=[]),d[e].push(r[t])}let p=Object.keys(d).map((t=>parseInt(t,10))).sort(W4);this.layers=[];for(const t of p){const e=d[t];e.sort(((t,e)=>{const n=s[t.id],i=s[e.id];return n<i?-1:n>i?1:0}));for(const t of e)t instanceof w7&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map((t=>parseInt(t,10))).sort(W4);const f=this.inputs.slice(),m=[];for(const t of p)for(const e of h[t]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new E4(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=h;const g=this.layers.map((t=>t.name));for(const t of g){const e=g.filter((e=>e===t)).length;if(1!==e)throw new E4(`The name "${t}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new x5({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((t=>null)),outputMasks:this.outputs.map((t=>null)),inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs.map((t=>t.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach((e=>{e._trainableWeights.forEach((e=>e.trainable=t))})),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new M4("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const n={};let i=0;const r=(t=>{const e=Object.keys(t);if(0===e.length)return!1;const n=e[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(t);r&&this.parseWeights(t);for(const t of this.layers)for(const[e,s]of t.weights.entries()){const t=r?`${s.name.split("/").slice(0,-1).join("/")+"/"}${e}`:s.originalName;if(null!=n[t])throw new M4(`Duplicate weight name: ${t}`);n[t]=s,i++}const s=[];for(const i in t){let r=i;if(null==n[i]){const t=i.split("/");r=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[r])s.push([n[r],t[i]]);else if(e)throw new M4(`Provided weight data has no target variable: ${i}`);delete n[r]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new M4(`${t.length} of ${i} weights are not set: ${t}`)}g5(s)}parseWeights(t){for(const e in Object.keys(t)){const n=e.split("/"),i=["vars","layer_checkpoint_dependencies"],r=n.map((t=>t.startsWith("_")?t.slice(1):t)).filter((t=>!i.includes(t))).join("/");r!==e&&(t[r]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${x7}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const n=v7(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return Co((()=>{t=L4(t);const n=new T5;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return M5(this.outputs,n,e)}))}computeMask(t,e){return Co((()=>{let n;return t=L4(t),n=null==e?N4(null,t.length):L4(e),this.runInternalGraph(t,n)[1]}))}computeOutputShape(t){const e=c5(t);if(e.length!==this.inputLayers.length)throw new M4(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let t=0;t<e.length;t++){const i=this.inputLayers[t],r=e[t];n[i.name+"_0_0"]=r}const i=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(W4);if(i.length>1)for(const t of i){const e=this.nodesByDepth[t];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((t=>t.id)).indexOf(e.id))continue;const i=[];for(let e=0;e<t.inboundLayers.length;e++){const r=t.inboundLayers[e],s=t.nodeIndices[e],o=t.tensorIndices[e],a=n[`${r.name}_${s}_${o}`];i.push(a)}const r=c5(e.computeOutputShape(O4(i))),s=e.inboundNodes.indexOf(t);for(let t=0;t<r.length;t++){n[`${e.name}_${s}_${t}`]=r[t]}}}const r=[],s=[];for(let t=0;t<this.outputLayers.length;t++){const e=this.outputLayers[t],n=this.outputLayersNodeIndices[t],i=this.outputLayersTensorIndices[t],r=`${e.name}_${n}_${i}`;s.push(r)}for(let t=0;t<s.length;t++){const e=s[t];R4(e in n),r.push(n[e])}return O4(r)}runInternalGraph(t,e){null==e&&(e=N4(null,t.length));const n={};for(let i=0;i<this.inputs.length;++i){const r=this.inputs[i],s=t[i],o=e[i];n[r.id]=[s,o]}const i=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(W4);for(const t of i){const e=this.nodesByDepth[t];for(const t of e){const e=t.outboundLayer,i=t.inputTensors,r=t.outputTensors,s=new Array;for(const t of i)t.id in n&&s.push(n[t.id]);if(s.length===i.length){let i,o,a,l,c={};if(null!=t.callArgs&&(c=t.callArgs),1===s.length){const[t,n]=s[0];null==c.mask&&(c.mask=n),a=L4(e.call(t,c)),l=L4(e.computeMask(t,n)),i=[t],o=[n]}else i=s.map((t=>t[0])),o=s.map((t=>t[1])),null==c.mask&&(c.mask=o),a=L4(e.call(i,c)),l=L4(e.computeMask(i,o));if(e.activityRegularizer)throw new $4("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<r.length;++t){const e=r[t],i=a[t],s=l[t];n[e.id]=[i,s]}}}}const r=[],s=[],o=[];for(const t of this.outputs){R4(t.id in n,`Could not compute output ${t.name} : ${t.id}`);const[e,i]=n[t.id];o.push(e.shape),r.push(e),s.push(i)}return[r,s,o]}buildNodeConversionMap(t){const e={};let n;for(const t of this.layers){n=t instanceof w7?1:0;for(let i=0;i<t.inboundNodes.length;i++){const r=w7.nodeKey(t,i);this.containerNodes.has(r)&&(e[r]=n,n+=1)}}return e}getLayer(t,e){if(null!=e)return this.findLayer(e);if(null==t)throw new M4("Provide either a layer name or layer index");if("number"==typeof t)return this.findLayer(t);for(const e of this.layers)if(e.name===t)return e;throw new M4(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new M4(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return Co((()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const i=w7.nodeKey(e,n);this.containerNodes.has(i)&&t.push(...e.calculateLosses())}return t}))}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const t of this.layers){const i=t.getClassName(),r=t.getConfig(),s=[];for(let n=0;n<t.inboundNodes.length;n++){const i=t.inboundNodes[n],r=w7.nodeKey(t,n);let o={};if(this.containerNodes.has(r)){if(i.callArgs)try{JSON.stringify(i.callArgs),o=i.callArgs}catch(e){console.warn(`Layer ${t.name} was passed non-serializable keyword arguments: ${i.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),o={}}if(i.inboundLayers.length>0){const t=[];for(let n=0;n<i.inboundLayers.length;n++){const r=i.inboundLayers[n],s=i.nodeIndices[n],a=i.tensorIndices[n];let l=e[w7.nodeKey(r,s)];null==l&&(l=0),t.push([r.name,l,a,o])}s.push(t)}}}const o={};o.name=t.name,o.className=i,o.config=r,o.inboundNodes=s,n.push(o)}t.layers=n;const i=[];for(let t=0;t<this.inputLayers.length;t++){const n=this.inputLayers[t],r=this.inputLayersNodeIndices[t],s=w7.nodeKey(n,r);if(!this.containerNodes.has(s))continue;let o=e[s];null==o&&(o=0);const a=this.inputLayersTensorIndices[t];i.push([n.name,o,a])}t.inputLayers=i;const r=[];for(let t=0;t<this.outputLayers.length;t++){const n=this.outputLayers[t],i=this.outputLayersNodeIndices[t],s=w7.nodeKey(n,i);if(!this.containerNodes.has(s))continue;let o=e[s];null==o&&(o=0);const a=this.outputLayersTensorIndices[t];r.push([n.name,o,a])}return t.outputLayers=r,t}static fromConfig(t,e,n={},i=!1){const r={},s={};function o(t,e){t.name in s?s[t.name].push(e):s[t.name]=[e]}function a(t,e){const n=[];let i;for(const s of e){const a=s[0],l=s[1],c=s[2];if(i=null==s[3]?{}:s[3],!(a in r))return void o(t,e);const u=r[a];if(u.inboundNodes.length<=l)return void o(t,e);const h=u.inboundNodes[l];n.push(h.outputTensors[c])}n.length>0&&t.apply(O4(n),i)}function l(t){const n=t.name,s=H8(t,null!=e.customObjects?e.customObjects:{});s.setFastWeightInitDuringBuild(i),r[n]=s;t.inboundNodes.forEach((t=>{if(!(t instanceof Array))throw new M4(`Corrupted configuration, expected array for nodeData: ${t}`);o(s,t)}))}const c=e.name,u=e.layers;for(const t of u)l(t);for(;!j4(s);)for(const t of u){const e=r[t.name];if(e.name in s){const t=s[e.name];delete s[e.name];for(const n of t)a(e,n)}}const h=[],d=[],p=e.inputLayers;for(const t of p){const e=t[0],n=t[1],i=t[2];R4(e in r);const s=r[e].inboundNodes[n].outputTensors;h.push(s[i])}const f=e.outputLayers;for(const t of f){const e=t[0],n=t[1],i=t[2];R4(e in r);const s=r[e].inboundNodes[n].outputTensors;d.push(s[i])}return new t({inputs:h,outputs:d,name:c})}get stateful(){if(this._stateful)throw new M4("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){Co((()=>{this.layers.forEach((t=>{t.stateful&&t.resetStates()}))}))}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function S7(t,e){return function(t,e,n){const i=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>null));if(1===i)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==i)throw new Error(`Provided ${n} is an array of ${t.length} element(s), but the model has ${i} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const n=[];return e.forEach((e=>{e in t?n.push(t[e]):n.push(null)})),n}throw new Error(`The model has multiple (${i}) outputs, so ${n} must be either an array with ${i} elements or an object with ${e} keys. Provided ${n} not understood: ${JSON.stringify(t)}`)}(t,e,"classWeight")}async function k7(t,e,n,i){if(null!=e||null!=i)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=Co((()=>{if(1===t.shape.length)return xo(t);if(2===t.shape.length){if(t.shape[1]>1){return Uo(t,1)}if(1===t.shape[1])return ca(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),i=Array.from(await e.data());To(e);const r=[];return i.forEach((t=>{if(null==n[t])throw new Error(`classWeight must contain all classes in the training data. The class ${t} exists in the data but not in classWeight`);r.push(n[t])})),ih(r,"float32")}return null}function C7(t,e){return Po(t,e)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function T7(t,e){let n,i;const r=e;n=r.xs,i=r.ys,c(null!=n&&null!=i,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`));const s=_7("input",t.inputNames,n),o=_7("output",t.outputNames,i),a=s[0].shape[0];c(s.length===t.inputs.length,(()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`)),c(o.length===t.outputs.length,(()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`));for(let e=0;e<s.length;e++)c(s[e].shape[0]===a,(()=>`Batch size mismatch: input ${t.inputNames[e]} has ${s[e].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`));for(let e=0;e<o.length;e++)c(o[e].shape[0]===a,(()=>`Batch size mismatch: output ${t.outputNames[e]} has ${o[e].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`));return{xs:s,ys:o}}function _7(t,e,n){if(n instanceof Or)return[n];if(Array.isArray(n))return c(n.length===e.length,(()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`)),n;{const i=[];for(const r of e){if(null==n[r])throw new M4(`The feature data generated by the dataset lacks the required ${t} key '${r}'.`);i.push(n[r])}return i}}async function E7(t,e,n){const i=null!=n.batchesPerEpoch;if(c(null!=t.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),c(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),c(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),c(!i||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),c(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const r=null!=n.validationData;let s,o;if(r)if(M7(n.validationData))c(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const t=function(t){if(3===t.length)throw new $4("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);s=t.xs,o=t.ys}const a=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let u;u=r?l.slice().concat(l.map((t=>"val_"+t))):l.slice();const h=U8(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:p,history:f}=W8(h,d,n.epochs,null,null,function(t,e){let n=null;null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size);return n}(e,n),null,r,u);p.setModel(t),t.history=f,await p.onTrainBegin(),t.stopTraining_=!1;let m=null==n.initialEpoch?0:n.initialEpoch,g=await e.iterator();for(;m<n.epochs;){const c={};await p.onEpochBegin(m);let u=0,h=0;for(i||(g=await e.iterator());!i||u<n.batchesPerEpoch;){const e=await g.next();if(i&&e.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${u} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:i,ys:r}=T7(t,e.value),s={};s.batch=h,s.size=i[0].shape[0],await p.onBatchBegin(h,s);const o=[];if(null!=n.classWeight){const e=S7(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)o.push(await k7(r[t],null,e[t]))}const c=i.concat(r).concat(o),d=a(c);To(c);for(let t=0;t<l.length;++t){const e=l[t],n=d[t];s[e]=n,_o(n)}await p.onBatchEnd(h,s),P8(s),h++,u++}if(i?u>=n.batchesPerEpoch:e.done){if(r){let e;e=M7(n.validationData)?L4(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):L4(t.evaluate(s,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)c[`val_${t.metricsNames[n]}`]=e[n]}break}if(t.stopTraining_)break}if(await p.onEpochEnd(m,c),m++,t.stopTraining_)break}return await p.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function M7(t){return"function"==typeof t.iterator}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function $7(t){c(t>0&&Number.isInteger(t),(()=>`batchSize is required to be a positive integer, but got ${t}`))}function I7(t,e,n){return null==t?[null]:Array.isArray(t)?t.map((t=>_6(t,e,n-e))):_6(t,e,n-e)}function A7(t,e){return Co((()=>null==t?null:Array.isArray(t)?t.map((t=>A7(t,e))):P6(t,"int32"===e.dtype?e:vo(e,"int32"))))}function N7(t,e){const n=[];let i=0,r=null;for(;i<t;)r=i+e,r>=t&&(r=t),n.push([i,r]),i=r;return n}function R7(t){const e=[];t instanceof Or&&(t=[t]);for(let n=0;n<t.length;++n){const i=t[n];if(1===i.rank)e.push(T6(i,1));else{if(0===i.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(i)}}return e}function P7(t,e){if(null==t)return;const n=[];if(e instanceof Or)n.push(e.id);else if(Array.isArray(e))e.forEach((t=>n.push(t.id)));else if(null!=e)for(const t in e){const i=e[t];n.push(i.id)}const i=[];if(t instanceof Or)-1===n.indexOf(t.id)&&i.push(t);else if(Array.isArray(t))t.forEach((t=>{-1===n.indexOf(t.id)&&i.push(t)}));else if(null!=t)for(const e in t){const r=t[e];-1===n.indexOf(r.id)&&i.push(r)}i.forEach((t=>{t.isDisposed||t.dispose()}))}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function O7(t){return Array.isArray(t)}function L7(t){return!function(t){return t instanceof Or}(t)&&!O7(t)}function D7(t,e,n,i=!0,r=""){if(null==e||0===e.length){if(null!=t){let e=!1;if(O7(t)&&t.length>0)e=!0;else if(L7(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new M4(`Error when checking model ${r} expected no data, but got ${t}`)}return[]}if(null==t)return e.map((t=>null));let s;if(L7(t)){s=[];for(const n of e){if(null==t[n])throw new M4(`No data provided for "${n}". Need data for each key in: ${e}`);s.push(t[n])}}else if(O7(t)){if(t.length!==e.length)throw new M4(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);s=t}else{if(e.length>1)throw new M4(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);s=[t]}if(s=R7(s),null!=n)for(let t=0;t<e.length;++t){if(null==n[t])continue;const o=s[t];if(o.shape.length!==n[t].length)throw new M4(`Error when checking ${r}: expected ${e[t]} to have ${n[t].length} dimension(s). but got array with shape ${o.shape}`);for(let e=0;e<n[t].length;++e){if(0===e&&!i)continue;const s=o.shape[e],a=n[t][e];if(null!=a&&a>=0&&s!==a)throw new M4(`${r} expected a batch of elements where each example has shape [${n[t].slice(1,n[t].length)}] (i.e.,tensor shape [*,${n[t].slice(1,n[t].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function F7(t,e,n,i=!0,r=""){let s;if(Array.isArray(t)){if(t.length!==e.length)throw new M4(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);s=t}else{if(e.length>1)throw new M4(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);s=[t]}if(null!=n)for(let t=0;t<e.length;++t){if(null==n[t])continue;const o=s[t];if(o.shape.length!==n[t].length)throw new M4(`Error when checking ${r}: expected ${e[t]} to have ${n[t].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let s=0;s<n[t].length;++s){if(0===s&&!i)continue;const a=o.shape[s],l=n[t][s];if(null!=l&&l!==a)throw new M4(`Error when checking ${r}: expected ${e[t]} to have shape ${JSON.stringify(n[t])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}class z7 extends w7{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new M4("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");p7(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>ef.adagrad(.01),Adadelta:()=>ef.adadelta(1,.95,k6()),Adam:()=>ef.adam(.001,.9,.999,k6()),Adamax:()=>ef.adamax(.002,.9,.999,k6(),0),RMSProp:()=>ef.rmsprop(.001,.9,0,k6()),SGD:()=>ef.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new M4(`Unknown Optimizer ${t}`)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Zd))throw new M4("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new M4(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);const n=t.loss;e=n.map((t=>t7(t)))}else{const n=t7(t.loss);this.outputs.forEach((t=>{e.push(n)}))}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new M4(`Unknown entry in loss dictionary: "${e}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==t.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),e.push(t7(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let t=0;t<this.outputs.length;++t){const e=this.internalOutputShapes[t],n=this.outputNames[t];this.feedOutputNames.push(n),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[t])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],d6("loss",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}}));const i=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>[]));let n;if("string"==typeof t||"function"==typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);n=t}if(Array.isArray(n))return e.map((t=>n));{const t=[];for(const i of e){let e=n.hasOwnProperty(i)?n[i]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),r=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};d6("metric",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;(e=>{let n,i,s;for(const o of e){if("string"==typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const e=this.internalOutputShapes[t];let r;1===e[e.length-1]||this.lossFunctions[t]===Z8?-1!==["accuracy","acc"].indexOf(o)?i=e7:-1!==["crossentropy","ce"].indexOf(o)&&(i=i7):this.lossFunctions[t]===Y8?-1!==["accuracy","acc"].indexOf(o)?i=r7:-1!==["crossentropy","ce"].indexOf(o)&&(i=o7):-1!==["accuracy","acc"].indexOf(o)?i=n7:-1!==["crossentropy","ce"].indexOf(o)&&(i=s7),-1!==["accuracy","acc"].indexOf(o)?r="acc":-1!==["crossentropy","ce"].indexOf(o)&&(r="ce"),s=i,n=""+r}else{const t=l7(o);s=t,n=""+c7(o)}let e;d6(n,(()=>{e=s})),r(t,n,e)}})(i[t])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){const i=null==n.batchSize?32:n.batchSize;$7(i);const r=this.standardizeUserDataXY(t,e,!0,i);try{const t=r[0].concat(r[1]);this.makeTestFunction();const e=this.testFunction;return O4(this.testLoop(e,t,i,n.verbose,n.steps))}finally{P7(r[0],t),P7(r[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const i=null!=(n=n||{}).batches,r=t.testFunction;let s=[];if(n.verbose>0)throw new $4("Verbose mode is not implemented yet.");c(!i||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const o="function"==typeof e.next?e:await e.iterator();let a=0,l=0;for(;!i||l<n.batches;){const e=await o.next();if(s=Co((()=>{if(e.value){const{xs:n,ys:i}=T7(t,e.value),o=n.concat(i),c=Co((()=>r(o)));if(To(o),0===l)for(let t=0;t<c.length;++t)s.push(xl(0));const u=o[0].shape[0];for(let t=0;t<c.length;++t){const e=c[t],n=s[t];s[t]=Co((()=>Ao(s[t],Po(u,e)))),l>0&&To(n)}To(c),a+=u,++l}return s})),e.done){i&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let t=0;t<s.length;++t){const e=s[t];s[t]=Ro(s[t],a),To(e)}return O4(s)}(this,t,e)}checkNumSamples(t,e,n,i="steps"){let r;if(null!=n){if(r=null,null!=e)throw new M4(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else{if(null==t)throw new M4(`Either the input data should have a defined shape, or ${i} shoud be specified.`);r=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return r}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new M4("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),i=n?e:[e],r=this.retrieveSymbolicTensors(i),s=new T5;if(t instanceof Or&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new M4(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let e=0;e<this.inputs.length;++e)s.add(this.inputs[e],t[e])}else for(const e of this.inputs){const n=t[e.name];if(null==n)throw new M4(`No value is provided for the model's input ${e.name}`);s.add(e,n)}const o=M5(r,s);return n?o:o[0]}retrieveSymbolicTensors(t){const e=N4(null,t.length);let n=t.length;for(const i of this.layers){const r=Array.isArray(i.output)?i.output:[i.output],s=r.map((t=>t.name));for(let i=0;i<t.length;++i){const o=s.indexOf(t[i]);if(-1!==o&&(e[i]=r[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach(((e,i)=>{null==e&&n.push(t[i])})),new M4(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return e}predictLoop(t,e=32,n=!1){return Co((()=>{const i=this.checkNumSamples(t);if(n)throw new $4("Verbose predictLoop() is not implemented yet.");const r=N7(i,e),s=this.outputs.map((t=>[]));for(let e=0;e<r.length;++e){const n=Co((()=>{const n=r[e][0],i=r[e][1],s=I7(t,n,i),o=[];if(Array.isArray(s))for(let t=0;t<s.length;++t)o.push({key:this.inputs[t],value:s[t]});else o.push({key:this.inputs[0],value:s});const a=new T5(o);return M5(this.outputs,a)}));n.forEach(((t,e)=>s[e].push(t)))}return O4(s.map((t=>da(t,0))))}))}predict(t,e={}){const n=R7(t);F7(n,this.inputNames,this.feedInputShapes,!1);try{const t=null==e.batchSize?32:e.batchSize;return $7(t),this.predictLoop(n,t)}finally{P7(n,t)}}predictOnBatch(t){F7(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,i){if(null==this.optimizer_)throw new E4("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let t=0;t<this.feedOutputShapes.length;++t){const e=this.feedOutputShapes[t];this.feedLossFns[t]===Y8?r.push(e.slice(0,e.length-1).concat([1])):r.push(e)}if(function(t,e,n){const i=H4(t.map((t=>t.shape[0])));i.sort();const r=H4(e.map((t=>t.shape[0])));if(r.sort(),i.length>1)throw new M4(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((t=>t.shape)))}`);if(r.length>1)throw new M4(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((t=>t.shape)))}`);if(i.length>0&&r.length>0&&!m(i,r))throw new M4(`Input Tensors should have the same number of samples as target Tensors. Found ${i[0]} input sample(s) and ${r[0]} target sample(s).`)}(t=D7(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=D7(e,this.feedOutputNames,r,!1,"target")),function(t,e,n){const i=[G8,Z8,K8];for(let r=0;r<t.length;++r){const s=t[r],o=e[r],a=n[r];if(null!=o){if(o===K8&&1===s.shape[s.shape.length-1])throw new M4(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==i.indexOf(o)){const t=s.shape.slice(1),e=a.slice(1);for(let n=0;n<t.length;++n){const i=t[n],r=e[n];if(null!=r&&i!==r)throw new M4(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=i&&i>0&&t[0].shape[0]%i!=0)throw new M4(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,i,r=!0,s){const[o,a]=this.standardizeUserDataXY(t,e,r,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=i){const t=S7(i,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await k7(a[e],null,t[e]))}return[o,a,l]}testLoop(t,e,n,i=0,r){return Co((()=>{const s=this.checkNumSamples(e,n,r,"steps"),o=[];if(i>0)throw new $4("Verbose mode is not implemented yet.");if(null!=r)throw new $4("steps mode in testLoop() is not implemented yet");{const i=N7(s,n),r=ih(w6(0,s));for(let n=0;n<i.length;++n){const s=i[n][0],a=i[n][1],l=_6(r,s,a-s),c=A7(e,l),u=t(c);if(0===n)for(let t=0;t<u.length;++t)o.push(xl(0));for(let t=0;t<u.length;++t){const e=u[t];o[t]=Ao(o[t],Po(a-s,e))}}for(let t=0;t<o.length;++t)o[t]=Ro(o[t],s)}return o}))}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const i=t[n];let r=i;if(P4(t,i)>1){r+=`_${P4(t.slice(0,n),i)}`}e.push(r)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],o=this.collectedTrainableWeights.map((t=>t.read())),a=this.optimizer_.minimize((()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const o=new T5(t),a=M5(this.outputs,o,{training:!0});let l;for(let t=0;t<this.lossFunctions.length;++t){let n=(0,this.lossFunctions[t])(i[t],a[t]);null!=r[t]&&(n=C7(n,r[t]));const s=pc(n);e.push(s),l=0===t?n:Ao(l,n)}for(let t=0;t<this.metricsTensors.length;++t){let n;if(this.outputs.length>1&&t<this.outputs.length)n=e[t];else{const e=this.metricsTensors[t][0],r=this.metricsTensors[t][1];n=pc(e(i[r],a[r]))}_o(n),s.push(n)}return l=pc(l),this.calculateLosses().forEach((t=>{l=Ao(l,t)})),l}),!0,o);return[a].concat(s)}}makeTestFunction(){this.testFunction=t=>Co((()=>{const e=[];let n;const i=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let t=0;t<this.inputs.length;++t)s.push({key:this.inputs[t],value:i[t]});const o=new T5(s),a=M5(this.outputs,o);for(let t=0;t<this.lossFunctions.length;++t){const i=this.lossFunctions[t],s=pc(i(r[t],a[t]));n=0===t?s:Ao(n,s),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][0],i=this.metricsTensors[t][1],s=pc(n(r[i],a[i]));e.push(s)}return e}))}async fit(t,e,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let i,r,s,o,a,l,c,u,h;this.isTraining=!0;try{const d=null==n.batchSize?32:n.batchSize;$7(d);const p=!1,f=await this.standardizeUserData(t,e,n.sampleWeight,n.classWeight,p,d);i=f[0],r=f[1],h=f[2];let m,g=!1;if(null!=n.validationData&&n.validationData.length>0){if(g=!0,2!==n.validationData.length)throw 3===n.validationData.length?new $4("validationData including sample weights is not supported yet."):new M4(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);a=n.validationData[0],l=n.validationData[1];const t=!0,e=await this.standardizeUserData(a,l,null,null,t,d);c=e[0],u=e[1],m=c.concat(u)}else if(null!=n.validationSplit&&n.validationSplit>0&&n.validationSplit<1){g=!0;const t=Math.floor(i[0].shape[0]*(1-n.validationSplit)),e=i[0].shape[0];c=I7(i,t,e),s=i,i=I7(i,0,t),u=I7(r,t,e),o=r,r=I7(r,0,t),m=c.concat(u)}else null!=n.validationSteps&&(g=!0);const y=i.concat(r).concat(h);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let x,w;g?(this.makeTestFunction(),x=this.testFunction,w=v.slice().concat(v.map((t=>"val_"+t)))):(x=null,m=[],w=v.slice());const S=U8(n.callbacks,n.yieldEvery);return await this.fitLoop(b,y,v,d,n.epochs,n.verbose,S,x,m,n.shuffle,w,n.initialEpoch,null,null)}finally{this.isTraining=!1,P7(i,t),P7(r,e),P7(s,t),P7(o,e),P7(c,a),P7(u,l),null!=h&&To(h)}}async fitLoop(t,e,n,i,s,o,a,l,c,u,h,d,p,f){null==i&&(i=32),null==s&&(s=1),null==u&&(u=!0),null==d&&(d=0);let m=!1;if(null!=l&&null!=c&&(m=!0),null!=f&&(m=!0,null==p))throw new M4("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(e,i,p,"steps_per_epoch");let y;null!=g&&(y=w6(0,g)),null==o&&(o=1);const{callbackList:b,history:v}=W8(a,o,s,d,g,p,i,m,h);b.setModel(this),this.history=v,await b.onTrainBegin(),this.stopTraining_=!1;for(let o=d;o<s;++o){await b.onEpochBegin(o);const s={};if(null!=p)throw new $4("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new $4("batch shuffling is not implemneted yet");u&&r(y);const o=ih(y),a=N7(g,i);for(let r=0;r<a.length;++r){const u={};if(await b.onBatchBegin(r,u),Co((()=>{const h=a[r][0],d=a[r][1],p=_6(o,h,d-h);u.batch=r,u.size=d-h;const f=A7(e,p),g=t(f);for(let t=0;t<n.length;++t){const e=n[t],i=g[t];u[e]=i,_o(i)}if(r===a.length-1&&m){const t=this.testLoop(l,c,i);for(let e=0;e<n.length;++e){const i=n[e],r=t[e];_o(r),s["val_"+i]=r}}})),await b.onBatchEnd(r,u),P8(u),this.stopTraining_)break}o.dispose()}if(await b.onEpochEnd(o,s),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return E7(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),i=n[0],r=n[1],s=this.makeTrainFunction()(i.concat(r)),o=[];for(const t of s){const e=await t.data();o.push(e[0])}return To(s),P7(n[0],t),P7(n[1],e),O4(o)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,i=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let t=0;t<i.length;++t)n&&!i[t].trainable||e.push({name:i[t].originalName,tensor:r[t]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=ko().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-ko().numTensors}return t}getLossIdentifiers(){let t;if("string"==typeof this.loss)t=D4(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!=typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map((t=>D4(t)))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const i of e){if("string"!=typeof n[i])throw new Error("Serialization of non-string loss is not supported.");t[i]=D4(n[i])}}return t}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[D4(c7(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((t=>D4(c7(t))));{const t={};for(const e in this.metrics)t[e]=D4(c7(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=H8(b7(t.optimizer_config));let n,i;if("string"==typeof t.loss)n=F4(t.loss);else if(Array.isArray(t.loss))n=t.loss.map((t=>F4(t)));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=F4(t.loss[e])}if(Array.isArray(t.metrics))i=t.metrics.map((t=>F4(t)));else if(null!=t.metrics){i={};for(const e in t.metrics)i[e]=F4(t.metrics[e])}this.compile({loss:n,metrics:i,optimizer:e})}async save(t,e){if("string"==typeof t){const e=Fs(t);if(0===e.length)throw new M4(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new M4(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new M4("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await Cs(this.getNamedWeights(e)),i={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${x7}`,convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){i.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:r}=await Cs(await this.optimizer.getWeights(),t);n.specs.push(...r),n.data=$s([n.data,e])}if(null!=this.userDefinedMetadata){const t=!0;h7(this.userDefinedMetadata,this.name,t),i.userDefinedMetadata=this.userDefinedMetadata}return i.weightData=n.data,i.weightSpecs=n.specs,t.save(i)}setUserDefinedMetadata(t){h7(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}z7.className="Model",Kd(z7);class B7 extends z7{}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
async function U7(t,e){if(null==e&&(e={}),"string"==typeof t){const n=zs(t,e);if(0===n.length)n.push(yp(t,e));else if(n.length>1)throw new M4(`Found more than one (${n.length}) load handlers for URL '${t}'`);t=n[0]}return async function(t,e,n){null==n&&(n={});if(null==t.load)throw new M4("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const i=await t.load();let r=i.modelTopology;null!=r.model_config&&(r=r.model_config);const s=null==n.strict||n.strict,o=null!=i.weightData&&null!=i.weightSpecs&&s,a=H8(b7(r),e,o),l=i.trainingConfig;null!=l&&a.loadTrainingConfig(l);null!=i.userDefinedMetadata&&a.setUserDefinedMetadata(i.userDefinedMetadata);if(null!=i.weightData){if(null==i.weightSpecs)throw new M4("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:t,optimizerWeights:e}=function(t,e){const n=Ts(t,e),i={},r=[];return e.forEach((t=>{"optimizer"===t.group?r.push({name:t.name,tensor:n[t.name]}):i[t.name]=n[t.name]})),{modelWeights:i,optimizerWeights:r}}(i.weightData,i.weightSpecs);a.loadWeights(t,s),null!=a.optimizer&&e.length>0&&await a.optimizer.setWeights(e),To(t),To(e.map((t=>t.tensor)))}return a}(t,void 0,e)}B7.className="Functional",Kd(B7);class V7 extends z7{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:t6("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some((t=>t<0)))throw new M4(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof V7||t instanceof z7;let n;if(e){if(n=t,1!==n.outputs.length)throw new M4("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new M4("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new M4("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new M4("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;return null==n&&(n="float32"),new C5({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new M4(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new M4("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=k5(this.outputs[0])}this.inboundNodes=[],new x5({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:N4(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(h5(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new z7({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new E4("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new E4("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new E4("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new E4("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},i=!1){let r,s={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new M4("Legacy serialization format not supported yet.");r=e}else c(null!=e.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),r=e.layers,delete e.layers,s=e;const o=new t(s);if(!(o instanceof V7))throw new $4(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const t of r){const e=H8(t,void 0,i);i&&e.setFastWeightInitDuringBuild(!0),o.add(e)}return o}set stopTraining(t){if(null==this.model)throw new M4("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new M4("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function W7(t){return new V7(t)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */V7.className="Sequential",Kd(V7);let H7=class extends qd{getConfig(){return{}}};class j7 extends H7{apply(t,e=1){return function(t,e=1){if(1!==e)throw new $4(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return ol(t)}(t,e)}}j7.className="elu",Kd(j7);class G7 extends H7{apply(t){return Ou(t)}}G7.className="selu",Kd(G7);class q7 extends H7{apply(t){return _u(t)}}q7.className="relu",Kd(q7);class X7 extends H7{apply(t){return Co((()=>yc(6,_u(t))))}}X7.className="relu6",Kd(X7);class K7 extends H7{apply(t){return t}}K7.className="linear",Kd(K7);class Y7 extends H7{apply(t){return fa(t)}}Y7.className="sigmoid",Kd(Y7);class Z7 extends H7{apply(t){return function(t){return Co((()=>{const e=Ao(.5,Po(.2,t));return $a(e,0,1)}))}(t)}}Z7.className="hardSigmoid",Kd(Z7);class J7 extends H7{apply(t){return Zl(t)}}J7.className="softplus",Kd(J7);class Q7 extends H7{apply(t){return function(t){return Co((()=>Ro(t,Ao(Oo(t),1))))}(t)}}Q7.className="softsign",Kd(Q7);class ttt extends H7{apply(t){return ga(t)}}ttt.className="tanh",Kd(ttt);let ett=class extends H7{apply(t,e=-1){return ju(t,e)}};ett.className="softmax",Kd(ett);class ntt extends H7{apply(t,e=-1){return tc(t,e)}}ntt.className="logSoftmax",Kd(ntt);class itt extends H7{apply(t,e=1){return Co((()=>Po(fa(Po(t,e)),t)))}}itt.className="swish",Kd(itt);class rtt extends H7{apply(t){return Co((()=>Po(t,ga(Zl(t)))))}}function stt(t){return t.getClassName()}function ott(t,e={}){return V4(t,Xd.getMap().classNameMap,e,"activation")}function att(t){if(null==t){const t={className:"linear",config:{}};return ott(t)}if("string"==typeof t){const e={};return e.className=t,e.config={},ott(e)}return t instanceof H7?t:ott(t)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */rtt.className="mish",Kd(rtt);class ltt extends qd{}class ctt extends ltt{constructor(t){super(),function(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return Co((()=>{let e=fc([1]);return this.hasL1&&(e=Ao(e,kl(Po(this.l1,Oo(t))))),this.hasL2&&(e=Ao(e,kl(Po(this.l2,O6(t))))),ca(e,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}ctt.className="L1L2",Kd(ctt);const utt={l1l2:"L1L2"};function htt(t){return B4(t)}function dtt(t,e={}){return V4(t,Xd.getMap().classNameMap,e,"regularizer")}function ptt(t){if(null==t)return null;if("string"==typeof t){return dtt({className:t in utt?utt[t]:t,config:{}})}return t instanceof ltt?t:dtt(t)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ftt extends S5{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=u5(t);let n=_u(t);return null!=this.maxValue&&(n=$a(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}ftt.className="ReLU",Kd(ftt);class mtt extends S5{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=u5(t);return Bl(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}mtt.className="LeakyReLU",Kd(mtt);class gtt extends S5{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=a5(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ptt(t.alphaRegularizer),this.alphaConstraint=N8(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new M4(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=h5(t)).slice(1);if(null!=this.sharedAxes)for(const t of this.sharedAxes)e[t-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let e=1;e<t.length;++e)n[e]=t[e];this.inputSpec=[new y5({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=u5(t),Pc(t,this.alpha.read())}getConfig(){const t={alphaInitializer:o5(this.alphaInitializer),alphaRegularizer:htt(this.alphaRegularizer),alphaConstraint:I8(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}gtt.className="PReLU",Kd(gtt);class ytt extends S5{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new $4(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=u5(t);return ol(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}ytt.className="ELU",Kd(ytt);class btt extends S5{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=u5(t);return Po(n,vo(Pl(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}btt.className="ThresholdedReLU",Kd(btt);class vtt extends S5{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new ett).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){return Co((()=>{let n=u5(t);const i=e.mask;if(null!=i){const t=Po(Ql(mc(n.shape),vo(i,n.dtype)),xl(-1e9));n=Ao(n,t)}return this.axis instanceof Array?this.axis.length>1?El(Ql(n,ec(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function xtt(t,e,n){if("number"==typeof t)return N4(t,e);if(t.length!==e)throw new M4(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let i=0;i<e;++i){const r=t[i];if(!y6(r))throw new M4(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${r}`)}return t}function wtt(t,e,n,i,r=1){if(null==t)return t;let s;return s="same"===n?t:t-(e+(e-1)*(r-1))+1,Math.floor((s+i-1)/i)}function Stt(t,e,n,i){if(null==t)return null;if("valid"===i)t=t*e+x6([n-e,0]);else{if("same"!==i)throw new M4(`Unsupport padding mode: ${i}.`);t*=e}return t}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ktt(t,e){return Co((()=>(a6(e),"channelsFirst"===e?Ch(t,[0,2,3,1]):t)))}function Ctt(t,e){return Co((()=>(a6(e),"channelsFirst"===e?Ch(t,[0,2,3,4,1]):t)))}function Ttt(t,e,n,i=[1,1],r="valid",s,o,a=null){return Co((()=>{if(null==s&&(s="channelsLast"),a6(s),3!==t.rank&&4!==t.rank)throw new M4(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==e.rank&&4!==e.rank)throw new M4(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=ktt(t,s);if("causal"===r)throw new $4("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Fh({x:l,filter:e,strides:i,pad:"same"===r?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:a}),"channelsFirst"===s&&(l=Ch(l,[0,3,1,2])),l}))}vtt.className="Softmax",Kd(vtt);class _tt extends S5{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",_tt.verifyArgs(e),this.rank=t,X4(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new $4(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=xtt(e.kernelSize,t,"kernelSize"),this.strides=xtt(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,l6(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,a6(this.dataFormat),this.activation=att(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=a5(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=N8(e.biasConstraint),this.biasRegularizer=ptt(e.biasRegularizer),this.activityRegularizer=ptt(e.activityRegularizer),this.dilationRate=xtt(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new M4(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new M4(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new M4(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(R4("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!q4(t.kernelSize,"number",1,3))throw new M4(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:stt(this.activation),useBias:this.useBias,biasInitializer:o5(this.biasInitializer),biasRegularizer:htt(this.biasRegularizer),activityRegularizer:htt(this.activityRegularizer),biasConstraint:I8(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Ett extends _tt{constructor(t,e){super(t,e),this.kernel=null,Ett.verifyArgs(e),this.filters=e.filters,X4(this.filters,"filters"),this.kernelInitializer=a5(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=N8(e.kernelConstraint),this.kernelRegularizer=ptt(e.kernelRegularizer)}build(t){t=h5(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new M4(`The channel dimension of the input should be defined. Found ${t[e]}`);const n=t[e],i=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return Co((()=>{let e;t=u5(t);const n=null==this.bias?null:this.bias.read(),i=Y4(this.activation.getClassName());if(null!=i&&2===this.rank)e=Ttt(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(1===this.rank)e=function(t,e,n,i=1,r="valid",s,o=1){return Co((()=>{if(null==s&&(s="channelsLast"),a6(s),3!==t.shape.length)throw new M4(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==e.shape.length)throw new M4(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new M4(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if("channelsFirst"===s&&(t=Ch(t,[0,2,1])),"causal"===r)throw new $4("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=Oa(t,e,i,"same"===r?"same":"valid","NWC",o);return null!=n&&(a=D6(a,n)),a}))}(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=Ttt(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new $4("convolutions greater than 3D are not implemented yet.");e=function(t,e,n,i=[1,1,1],r="valid",s,o){return Co((()=>{if(null==s&&(s="channelsLast"),a6(s),4!==t.rank&&5!==t.rank)throw new M4(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==e.rank&&5!==e.rank)throw new M4(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=Ctt(t,s);if("causal"===r)throw new $4("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=Fa(a,e,i,"same"===r?"same":"valid","NDHWC",o),null!=n&&(a=D6(a,n)),"channelsFirst"===s&&(a=Ch(a,[0,4,1,2,3])),a}))}(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e}))}computeOutputShape(t){t=h5(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let t=0;t<n.length;++t){const i=wtt(n[t],this.kernelSize[t],this.padding,this.strides[t],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[t]);e.push(i)}let i=[t[0]];return"channelsLast"===this.dataFormat?(i=i.concat(e),i.push(this.filters)):(i.push(this.filters),i=i.concat(e)),i}getConfig(){const t={filters:this.filters,kernelInitializer:o5(this.kernelInitializer),kernelRegularizer:htt(this.kernelRegularizer),kernelConstraint:I8(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new M4(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class Mtt extends Ett{constructor(t){super(2,t),Mtt.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!q4(t.kernelSize,"number",1,2))throw new M4(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}Mtt.className="Conv2D",Kd(Mtt);class $tt extends Ett{constructor(t){super(3,t),$tt.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new M4(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}$tt.className="Conv3D",Kd($tt);class Itt extends Mtt{constructor(t){if(super(t),this.inputSpec=[new y5({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new M4(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(4!==(t=h5(t)).length)throw new M4("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new M4("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],i=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new y5({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return Co((()=>{let e=u5(t);if(4!==e.shape.length)throw new M4(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape,i=n[0];let r,s;"channelsFirst"===this.dataFormat?(r=2,s=3):(r=1,s=2);const o=n[r],a=n[s],l=this.kernelSize[0],c=this.kernelSize[1],u=this.strides[0],h=this.strides[1],d=[i,Stt(o,u,l,this.padding),Stt(a,h,c,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=Ch(e,[0,2,3,1]));let p=Da(e,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=Ch(p,[0,3,1,2])),null!=this.bias&&(p=D6(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(t){const e=(t=h5(t)).slice();let n,i,r;"channelsFirst"===this.dataFormat?(n=1,i=2,r=3):(n=3,i=1,r=2);const s=this.kernelSize[0],o=this.kernelSize[1],a=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[i]=Stt(e[i],a,s,this.padding),e[r]=Stt(e[r],l,o,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}Itt.className="Conv2DTranspose",Kd(Itt);class Att extends $tt{constructor(t){if(super(t),this.inputSpec=[new y5({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new M4(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(5!==(t=h5(t)).length)throw new M4("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new M4("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],i=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new y5({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return Co((()=>{let e=u5(t);if(5!==e.shape.length)throw new M4(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape,i=n[0];let r,s,o;"channelsFirst"===this.dataFormat?(o=2,r=3,s=4):(o=1,r=2,s=3);const a=n[o],l=n[r],c=n[s],u=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[i,Stt(a,p,u,this.padding),Stt(l,f,h,this.padding),Stt(c,m,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=Ch(e,[0,2,3,4,1]));let y=Ba(e,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=Ch(y,[0,4,1,2,3])),null!==this.bias&&(y=D6(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(t){const e=(t=h5(t)).slice();let n,i,r,s;"channelsFirst"===this.dataFormat?(n=1,i=2,r=3,s=4):(n=4,i=1,r=2,s=3);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],u=this.strides[1],h=this.strides[2];return e[n]=this.filters,e[i]=Stt(e[i],c,o,this.padding),e[r]=Stt(e[r],u,a,this.padding),e[s]=Stt(e[s],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}Att.className="Conv3DTranspose",Kd(Att);class Ntt extends Ett{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new M4("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new M4("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new M4(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=a5(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ptt(e.depthwiseRegularizer),this.depthwiseConstraint=N8(e.depthwiseConstraint),this.pointwiseInitializer=a5(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ptt(e.pointwiseRegularizer),this.pointwiseConstraint=N8(e.pointwiseConstraint)}build(t){if((t=h5(t)).length<this.rank+2)throw new M4(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new M4(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const n=t[e],i=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let t=0;t<this.rank;++t)r.push(1);r.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new y5({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return Co((()=>{let e;if(t=u5(t),1===this.rank)throw new $4("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=Ch(t,[0,2,3,1])),e=Lu(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=D6(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=Ch(e,[0,3,1,2])),e}))}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=o5(this.depthwiseInitializer),t.pointwiseInitializer=o5(this.pointwiseInitializer),t.depthwiseRegularizer=htt(this.depthwiseRegularizer),t.pointwiseRegularizer=htt(this.pointwiseRegularizer),t.depthwiseConstraint=I8(this.depthwiseConstraint),t.pointwiseConstraint=I8(this.pointwiseConstraint),t}}Ntt.className="SeparableConv";class Rtt extends Ntt{constructor(t){super(2,t)}}Rtt.className="SeparableConv2D",Kd(Rtt);class Ptt extends Ett{constructor(t){super(1,t),Ptt.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!q4(t.kernelSize,"number",1,1))throw new M4(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}Ptt.className="Conv1D",Kd(Ptt);class Ott extends S5{constructor(t){super(t),"number"==typeof t.cropping?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return Co((()=>{if(t=u5(t),"channelsLast"===this.dataFormat){const e=M6(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return M6(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=M6(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return M6(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}Ott.className="Cropping2D",Kd(Ott);class Ltt extends S5{constructor(t){var e;super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,a6(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,e=this.interpolation,G4(n6,"InterpolationFormat",e)}computeOutputShape(t){if("channelsFirst"===this.dataFormat){const e=null==t[2]?null:this.size[0]*t[2],n=null==t[3]?null:this.size[1]*t[3];return[t[0],t[1],e,n]}{const e=null==t[1]?null:this.size[0]*t[1],n=null==t[2]?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return Co((()=>{let e=u5(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=Ch(e,[0,2,3,1]);const t=this.size[0]*n[2],i=this.size[1]*n[3],r="nearest"===this.interpolation?Bd.resizeNearestNeighbor(e,[t,i]):Bd.resizeBilinear(e,[t,i]);return Ch(r,[0,3,1,2])}{const t=this.size[0]*n[1],i=this.size[1]*n[2];return"nearest"===this.interpolation?Bd.resizeNearestNeighbor(e,[t,i]):Bd.resizeBilinear(e,[t,i])}}))}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}Ltt.className="UpSampling2D",Kd(Ltt);class Dtt extends _tt{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=a5(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=N8(t.depthwiseConstraint),this.depthwiseRegularizer=ptt(t.depthwiseRegularizer)}build(t){if((t=h5(t)).length<4)throw new M4(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new M4(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const n=t[e],i=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",i,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return Co((()=>{let e=
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function(t,e,n=[1,1],i="valid",r,s){return Co((()=>{null==r&&(r="channelsLast"),a6(r);let o=ktt(t,r);if(4!==t.rank)throw new M4(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==e.rank)throw new M4(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=qa(o,e,n,"same"===i?"same":"valid","NHWC",s),"channelsFirst"===r&&(o=Ch(o,[0,3,1,2])),o}))}(t=u5(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=D6(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e}))}computeOutputShape(t){t=h5(t);const e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],i="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,r=wtt(e,this.kernelSize[0],this.padding,this.strides[0]),s=wtt(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],i,r,s]:[t[0],r,s,i]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=o5(this.depthwiseInitializer),t.depthwiseRegularizer=htt(this.depthwiseRegularizer),t.depthwiseConstraint=I8(this.depthwiseRegularizer),t}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Ftt(t,e,n,i){if(Array.isArray(t)){if(null!=e||null!=n)throw new M4("When inputs is an array, neither initialState or constants should be provided");null!=i&&(n=t.slice(t.length-i,t.length),t=t.slice(0,t.length-i)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function r(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=r(e),constants:n=r(n)}}function ztt(t,e,n,i=!1,r,s,o=!1,a=!1){return Co((()=>{const l=e.shape.length;if(l<3)throw new M4(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(w6(2,l));if(e=Ch(e,c),null!=s)throw new $4("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=vo(vo(r,"bool"),"float32")).rank===l-1&&(r=Ml(r,-1)),r=Ch(r,c)),i&&(e=Mu(e,0),null!=r&&(r=Mu(r,0)));const u=[];let h,d=n;const p=e.shape[0],f=bh(e);let m,g;null!=r&&(m=bh(r));for(let e=0;e<p;++e){const n=f[e],i=Co((()=>t(n,d)));if(null==r)h=i[0],d=i[1];else{const t=Co((()=>{const t=m[e],n=Ql(Tc(t),t),r=Ao(Po(i[0],t),Po(d[0],n)),s=d.map(((e,r)=>Ao(Po(i[1][r],t),Po(e,n))));return{output:r,newStates:s}}));h=t.output,d=t.newStates}a&&u.push(h)}if(a){g=Qu(u,1)}return[h,g,d]}))}Dtt.className="DepthwiseConv2D",Kd(Dtt);class Btt extends S5{constructor(t){let e;if(super(t),null==t.cell)throw new M4("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new Xtt({cells:t.cell}):t.cell,null==e.stateSize)throw new M4("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new y5({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return w6(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((t=>null))}return this.states_}setStates(t){this.states_=t}computeOutputShape(t){l5(t)&&(t=t[0]);let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let i;if(i=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const i of e)n.push([t[0],i]);return[i].concat(n)}return i}computeMask(t,e){return Co((()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map((t=>null));return[t].concat(e)}return t}))}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new $4("Constants support is not implemented in RNN yet.");l5(t)&&(t=t[0]);const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new y5({shape:[e,null,...n]});const i=[t[0]].concat(t.slice(2));let r;if(this.cell.build(i),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!m(this.stateSpec.map((t=>t.shape[t.shape.length-1])),r))throw new M4(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map((t=>new y5({shape:[null,t]})));this.stateful&&this.resetStates()}resetStates(t,e=!1){Co((()=>{if(!this.stateful)throw new _4("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new M4("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>fc([n,t]))):this.states_=[fc([n,this.cell.stateSize])];else if(null==t)To(this.states_),null!=this.keptStates&&(To(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>fc([n,t]))):this.states_[0]=fc([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new M4(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);!0===e?this.keptStates.push(this.states_.slice()):To(this.states_);for(let e=0;e<this.states_.length;++e){const i=t[e],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,s=[n,r];if(!m(i.shape,s))throw new M4(`State ${e} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${i.shape}`);this.states_[e]=i}}this.states_=this.states_.map((t=>_o(t.clone())))}))}apply(t,e){let n=null==e?null:e.initialState,i=null==e?null:e.constants;null==e&&(e={});const r=Ftt(t,n,i,this.numConstants);t=r.inputs,n=r.initialState,i=r.constants;let s=[],o=[];if(null!=n){e.initialState=n,s=s.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new y5({shape:t.shape}));o=o.concat(this.stateSpec)}null!=i&&(e.constants=i,s=s.concat(i),this.numConstants=i.length);if(s[0]instanceof b5){const n=[t].concat(s),i=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=i;const a=super.apply(n,e);return this.inputSpec=r,a}return super.apply(t,e)}call(t,e){return Co((()=>{const n=null==e?null:e.mask,i=null==e?null:e.training;let r=null==e?null:e.initialState;t=u5(t),null==r&&(r=this.stateful?this.states_:this.getInitialState(t));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==s)throw new M4(`RNN Layer has ${s} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:i},a=ztt(((t,e)=>{const n=this.cell.call([t].concat(e),o);return[n[0],n.slice(1)]}),t,r,this.goBackwards,n,null,this.unroll,this.returnSequences),l=a[0],c=a[1],u=a[2];this.stateful&&this.resetStates(u,i);const h=this.returnSequences?c:l;return this.returnState?[h].concat(u):h}))}getInitialState(t){return Co((()=>{let e=fc(t.shape);return e=kl(e,[1,2]),e=T6(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((t=>t>1?A6(e,[1,t]):e)):this.cell.stateSize>1?[A6(e,[1,this.cell.stateSize])]:[e]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===Btt.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),t),e)}static fromConfig(t,e,n={}){const i=H8(e.cell,n);return new t(Object.assign(e,{cell:i}))}}Btt.className="RNN",Kd(Btt);class Utt extends S5{}class Vtt extends Utt{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,X4(this.units,"units"),this.activation=att(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=a5(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=a5(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=a5(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ptt(t.kernelRegularizer),this.recurrentRegularizer=ptt(t.recurrentRegularizer),this.biasRegularizer=ptt(t.biasRegularizer),this.kernelConstraint=N8(t.kernelConstraint),this.recurrentConstraint=N8(t.recurrentConstraint),this.biasConstraint=N8(t.biasConstraint),this.dropout=v6([1,x6([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=v6([1,x6([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=h5(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return Co((()=>{if(2!==t.length)throw new M4(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];const i=null!=e.training&&e.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ktt({ones:()=>Tc(t),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ktt({ones:()=>Tc(n),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;r=R6(null!=s?Po(t,s):t,this.kernel.read()),null!=this.bias&&(r=D6(r,this.bias.read())),null!=o&&(n=Po(n,o));let a=Ao(r,R6(n,this.recurrentKernel.read()));return null!=this.activation&&(a=this.activation.apply(a)),[a,a]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:stt(this.activation),useBias:this.useBias,kernelInitializer:o5(this.kernelInitializer),recurrentInitializer:o5(this.recurrentInitializer),biasInitializer:o5(this.biasInitializer),kernelRegularizer:htt(this.kernelRegularizer),recurrentRegularizer:htt(this.recurrentRegularizer),biasRegularizer:htt(this.biasRegularizer),activityRegularizer:htt(this.activityRegularizer),kernelConstraint:I8(this.kernelConstraint),recurrentConstraint:I8(this.recurrentConstraint),biasConstraint:I8(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}Vtt.className="SimpleRNNCell",Kd(Vtt);class Wtt extends Btt{constructor(t){t.cell=new Vtt(t),super(t)}call(t,e){return Co((()=>{null!=this.cell.dropoutMask&&(To(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(To(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,i=null==e?null:e.training,r=null==e?null:e.initialState;return super.call(t,{mask:n,training:i,initialState:r})}))}static fromConfig(t,e){return new t(e)}}Wtt.className="SimpleRNN",Kd(Wtt);class Htt extends Utt{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new M4("GRUCell does not support reset_after parameter set to true.");this.units=t.units,X4(this.units,"units"),this.activation=att(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=att(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=a5(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=a5(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=a5(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ptt(t.kernelRegularizer),this.recurrentRegularizer=ptt(t.recurrentRegularizer),this.biasRegularizer=ptt(t.biasRegularizer),this.kernelConstraint=N8(t.kernelConstraint),this.recurrentConstraint=N8(t.recurrentConstraint),this.biasConstraint=N8(t.biasConstraint),this.dropout=v6([1,x6([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=v6([1,x6([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){const e=(t=h5(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return Co((()=>{if(2!==t.length)throw new M4(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const n=null!=e.training&&e.training;let i=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ktt({ones:()=>Tc(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ktt({ones:()=>Tc(i),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,s=this.recurrentDropoutMask;let o,a,l;0<this.dropout&&this.dropout<1&&(t=Po(t,r[0]));let c=R6(t,this.kernel.read());this.useBias&&(c=D6(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=Po(i,s[0]));const u=this.recurrentKernel.read(),[h,d]=Ku(u,[2*this.units,this.units],u.rank-1),p=R6(i,h),[f,m,g]=Ku(c,3,c.rank-1),[y,b]=Ku(p,2,p.rank-1);o=this.recurrentActivation.apply(Ao(f,y)),a=this.recurrentActivation.apply(Ao(m,b));const v=R6(Po(a,i),d);l=this.activation.apply(Ao(g,v));const x=Ao(Po(o,i),Po(Ao(1,Yl(o)),l));return[x,x]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:stt(this.activation),recurrentActivation:stt(this.recurrentActivation),useBias:this.useBias,kernelInitializer:o5(this.kernelInitializer),recurrentInitializer:o5(this.recurrentInitializer),biasInitializer:o5(this.biasInitializer),kernelRegularizer:htt(this.kernelRegularizer),recurrentRegularizer:htt(this.recurrentRegularizer),biasRegularizer:htt(this.biasRegularizer),activityRegularizer:htt(this.activityRegularizer),kernelConstraint:I8(this.kernelConstraint),recurrentConstraint:I8(this.recurrentConstraint),biasConstraint:I8(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}Htt.className="GRUCell",Kd(Htt);class jtt extends Btt{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Htt(t),super(t)}call(t,e){return Co((()=>{null!=this.cell.dropoutMask&&(To(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(To(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,i=null==e?null:e.training,r=null==e?null:e.initialState;return super.call(t,{mask:n,training:i,initialState:r})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}jtt.className="GRU",Kd(jtt);class Gtt extends Utt{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,X4(this.units,"units"),this.activation=att(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=att(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=a5(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=a5(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=a5(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=ptt(t.kernelRegularizer),this.recurrentRegularizer=ptt(t.recurrentRegularizer),this.biasRegularizer=ptt(t.biasRegularizer),this.kernelConstraint=N8(t.kernelConstraint),this.recurrentConstraint=N8(t.recurrentConstraint),this.biasConstraint=N8(t.biasConstraint),this.dropout=v6([1,x6([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=v6([1,x6([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;const n=(t=h5(t))[t.length-1];let i;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,n=this.units;i=new((e=class extends V6{apply(e,i){const r=t.apply([n]),s=(new H6).apply([n]),o=t.apply([2*n]);return I6(I6(r,s),o)}}).className="CustomInit",e)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return Co((()=>{const n=null!=e.training&&e.training;if(3!==t.length)throw new M4(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let i=t[1];const r=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ktt({ones:()=>Tc(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ktt({ones:()=>Tc(i),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,c,u;0<this.dropout&&this.dropout<1&&(t=Po(t,s[0]));let h=R6(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=Po(i,o[0])),h=Ao(h,R6(i,this.recurrentKernel.read())),this.useBias&&(h=D6(h,this.bias.read()));const[d,p,f,m]=Ku(h,4,h.rank-1);a=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),c=Ao(Po(l,r),Po(a,this.activation.apply(f))),u=this.recurrentActivation.apply(m);const g=Po(u,this.activation.apply(c));return[g,g,c]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:stt(this.activation),recurrentActivation:stt(this.recurrentActivation),useBias:this.useBias,kernelInitializer:o5(this.kernelInitializer),recurrentInitializer:o5(this.recurrentInitializer),biasInitializer:o5(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:htt(this.kernelRegularizer),recurrentRegularizer:htt(this.recurrentRegularizer),biasRegularizer:htt(this.biasRegularizer),activityRegularizer:htt(this.activityRegularizer),kernelConstraint:I8(this.kernelConstraint),recurrentConstraint:I8(this.recurrentConstraint),biasConstraint:I8(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}Gtt.className="LSTMCell",Kd(Gtt);class qtt extends Btt{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Gtt(t),super(t)}call(t,e){return Co((()=>{null!=this.cell.dropoutMask&&(To(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(To(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,i=null==e?null:e.training,r=null==e?null:e.initialState;return super.call(t,{mask:n,training:i,initialState:r})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}qtt.className="LSTM",Kd(qtt);class Xtt extends Utt{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return Co((()=>{let n=t.slice(1);const i=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?i.push(n.splice(0,t.stateSize.length)):i.push(n.splice(0,1));i.reverse();const r=[];let s;for(let o=0;o<this.cells.length;++o){const a=this.cells[o];n=i[o],s=0===o?[t[0]].concat(n):[s[0]].concat(n),s=a.call(s,e),r.push(s.slice(1))}n=[];for(const t of r.slice().reverse())n.push(...t);return[s[0]].concat(n)}))}build(t){let e;l5(t)&&(t=t[0]),this.cells.forEach(((n,i)=>{d6(`RNNCell_${i}`,(()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]}))})),this.built=!0}getConfig(){const t=super.getConfig(),e={cells:this.cells.map((t=>({className:t.getClassName(),config:t.getConfig()})))};return Object.assign(Object.assign({},t),e)}static fromConfig(t,e,n={}){const i=[];for(const t of e.cells)i.push(H8(t,n));return new t({cells:i})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return m5(t)}setWeights(t){const e=[];for(const n of this.cells){const i=n.weights.length,r=t.splice(i);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],r[t]])}g5(e)}}function Ktt(t){const{ones:e,rate:n,training:i=!1,count:r=1,dropoutFunc:s}=t,o=()=>null!=s?s(e(),n):F6(e(),n),a=()=>z6(o,e,i);if(!r||r<=1)return _o(a().clone());return Array(r).fill(void 0).map(a).map((t=>_o(t.clone())))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */Xtt.className="StackedRNNCells",Kd(Xtt);var Ytt=function(t,e){var n={};for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&e.indexOf(i)<0&&(n[i]=t[i]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(i=Object.getOwnPropertySymbols(t);r<i.length;r++)e.indexOf(i[r])<0&&Object.prototype.propertyIsEnumerable.call(t,i[r])&&(n[i[r]]=t[i[r]])}return n};class Ztt extends Btt{constructor(t){if(t.unroll)throw new $4("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new $4("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new y5({ndim:5})]}call(t,e){return Co((()=>{if(null!=this.cell.dropoutMask&&(To(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(To(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new M4("ConvRNN2D cell does not support constants");const n=null==e?null:e.mask,i=null==e?null:e.training,r=null==e?null:e.initialState;return super.call(t,{mask:n,training:i,initialState:r})}))}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return Co((()=>{const{stateSize:e}=this.cell,n=t.shape,i=this.computeSingleOutputShape(n),r=fc([i[0],...i.slice(2)]);return Array.isArray(e)?Array(e.length).fill(r):[r]}))}resetStates(t,e=!1){Co((()=>{if(!this.stateful)throw new _4("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,i=this.computeSingleOutputShape(n),r=[i[0],...i.slice(2)];if(null==n[0])throw new M4("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>fc(r))):this.states_=[fc(r)];else if(null==t)To(this.states_),null!=this.keptStates&&(To(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>fc(r))):this.states_[0]=fc(r);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new M4(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):To(this.states_);for(let e=0;e<this.states_.length;++e){const n=t[e],i=r;if(!m(n.shape,i))throw new M4(`State ${e} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${n.shape}`);this.states_[e]=n}}this.states_=this.states_.map((t=>_o(t.clone())))}))}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:i,padding:r,strides:s,dilationRate:o}=this.cell,a="channelsFirst"===e,l=t[a?3:2],c=t[a?4:3],u=wtt(l,i[0],r,s[0],o[0]),h=wtt(c,i[1],r,s[1],o[1]);return[...t.slice(0,2),...a?[n,u,h]:[u,h,n]]}}Ztt.className="ConvRNN2D";class Jtt extends Gtt{constructor(t){const{filters:e,kernelSize:n,strides:i,padding:r,dataFormat:s,dilationRate:o}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,X4(this.filters,"filters"),this.kernelSize=xtt(n,2,"kernelSize"),this.kernelSize.forEach((t=>X4(t,"kernelSize"))),this.strides=xtt(i||1,2,"strides"),this.strides.forEach((t=>X4(t,"strides"))),this.padding=r||"valid",l6(this.padding),this.dataFormat=s||"channelsLast",a6(this.dataFormat),this.dilationRate=xtt(o||1,2,"dilationRate"),this.dilationRate.forEach((t=>X4(t,"dilationRate")))}build(t){var e;t=h5(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new M4(`The channel dimension of the input should be defined. Found ${t[n]}`);const i=t[n],r=this.kernelSize.concat([i,4*this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const n=this.biasInitializer,i=this.filters;t=new((e=class extends V6{apply(t,e){return $6([n.apply([i]),mc([i]),n.apply([2*i])])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return Co((()=>{if(3!==t.length)throw new M4(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const n=e.training||!1,i=t[0],r=t[1],s=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ktt({ones:()=>Tc(i),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=(t,e,n)=>e&&e[n]?Po(e[n],t):t;let l=a(i,o,0),c=a(i,o,1),u=a(i,o,2),h=a(i,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ktt({ones:()=>Tc(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=a(r,d,0),f=a(r,d,1),m=a(r,d,2),g=a(r,d,3);const[y,b,v,x]=Ku(this.kernel.read(),4,3),[w,S,k,C]=this.useBias?Ku(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),c=this.inputConv(c,b,S,this.padding),u=this.inputConv(u,v,k,this.padding),h=this.inputConv(h,x,C,this.padding);const[T,_,E,M]=Ku(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,T),f=this.recurrentConv(f,_),m=this.recurrentConv(m,E),g=this.recurrentConv(g,M);const $=this.recurrentActivation.apply(Ao(l,p)),I=this.recurrentActivation.apply(Ao(c,f)),A=Ao(Po(I,s),Po($,this.activation.apply(Ao(u,m)))),N=Po(this.recurrentActivation.apply(Ao(h,g)),this.activation.apply(A));return[N,N,A]}))}getConfig(){const t=super.getConfig(),e=Ytt(t,["units"]),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},e),n)}inputConv(t,e,n,i){const r=Pa(t,e,this.strides,i||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?D6(r,n,this.dataFormat):r}recurrentConv(t,e){return Pa(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}Jtt.className="ConvLSTM2DCell",Kd(Jtt);class Qtt extends Ztt{constructor(t){const e=new Jtt(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}Qtt.className="ConvLSTM2D",Kd(Qtt);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class tet extends S5{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let t=0;t<this.noiseShape.length;++t)n.push(null==this.noiseShape[t]?e[t]:this.noiseShape[t]);return n}call(t,e){return Co((()=>{this.invokeCallHook(t,e);const n=u5(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,i=this.getNoiseShape(n);return z6((()=>F6(n,this.rate,i,this.seed)),(()=>n),t)}return t}))}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}tet.className="Dropout",Kd(tet);class eet extends tet{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}eet.className="SpatialDropout1D",Kd(eet);class net extends S5{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,X4(this.units,"units"),this.activation=att(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=a5(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=a5(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=N8(t.kernelConstraint),this.biasConstraint=N8(t.biasConstraint),this.kernelRegularizer=ptt(t.kernelRegularizer),this.biasRegularizer=ptt(t.biasRegularizer),this.activityRegularizer=ptt(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=h5(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=h5(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return Co((()=>{this.invokeCallHook(t,e);const n=u5(t),i=Y4(this.activation.getClassName());let r;return null!=i?r=R6(n,this.kernel.read(),i,this.bias?this.bias.read():null):(r=R6(n,this.kernel.read()),null!=this.bias&&(r=D6(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r}))}getConfig(){const t={units:this.units,activation:stt(this.activation),useBias:this.useBias,kernelInitializer:o5(this.kernelInitializer),biasInitializer:o5(this.biasInitializer),kernelRegularizer:htt(this.kernelRegularizer),biasRegularizer:htt(this.biasRegularizer),activityRegularizer:htt(this.activityRegularizer),kernelConstraint:I8(this.kernelConstraint),biasConstraint:I8(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}net.className="Dense",Kd(net);class iet extends S5{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=h5(t);for(const e of t.slice(1))if(null==e)throw new M4(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],b6(t,1)]}call(t,e){return Co((()=>{this.invokeCallHook(t,e);let n=u5(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=Ch(n,t)}return function(t){if(t.rank<=1)throw new M4(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],b6(t.shape,1)];return ca(t,e)}(n)}))}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}iet.className="Flatten",Kd(iet);class ret extends S5{constructor(t){super(t),this.supportsMasking=!0,this.activation=att(t.activation)}call(t,e){return Co((()=>{this.invokeCallHook(t,e);const n=u5(t);return this.activation.apply(n)}))}getConfig(){const t={activation:stt(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}ret.className="Activation",Kd(ret);class set extends S5{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return Co((()=>function(t,e){return Co((()=>{if(2!==t.shape.length)throw new M4(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return A6(T6(t,1),[1,e,1])}))}(t=u5(t),this.n)))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}set.className="RepeatVector",Kd(set);class oet extends S5{constructor(t){super(t),this.targetShape=t.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",i=e.slice();let r=1,s=null;for(let t=0;t<i.length;++t){const e=i[t];if(this.isUnknown(e)){if(null!==s)throw new M4("Can only specifiy one unknown dimension.");s=t}else r*=e}const o=b6(t);if(null!==s){if(0===r||o%r!=0)throw new M4(n);i[s]=o/r}else if(o!==r)throw new M4(n);return i}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return Co((()=>{this.invokeCallHook(t,e);const n=u5(t),i=n.shape,r=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return ca(n,r)}))}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}oet.className="Reshape",Kd(oet);class aet extends S5{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=w6(1,t.dims.length+1);if(!m(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new y5({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=h5(t)).slice();return this.dims.forEach(((n,i)=>{e[i+1]=t[n]})),e}call(t,e){return Ch(u5(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}aet.className="Permute",Kd(aet);class cet extends S5{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=u5(t);return Bo(kc(n,this.maskValue),-1)}call(t,e){return Co((()=>{this.invokeCallHook(t,e);const n=u5(t),i=Bo(kc(n,this.maskValue),-1,!0);return Po(n,vo(i,n.dtype))}))}}cet.className="Masking",Kd(cet);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class uet extends S5{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),null==t.inputLength?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(L4(t.inputLength))}this.inputDim=t.inputDim,X4(this.inputDim,"inputDim"),this.outputDim=t.outputDim,X4(this.outputDim,"outputDim"),this.embeddingsInitializer=a5(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ptt(t.embeddingsRegularizer),this.activityRegularizer=ptt(t.activityRegularizer),this.embeddingsConstraint=N8(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return Co((()=>this.maskZero?(t=u5(t),kc(t,nl(t))):null))}computeOutputShape(t){if(t=h5(t),null==this.inputLength)return[...t,this.outputDim];const e=L4(this.inputLength);if(e.length!==t.length-1)throw new M4(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let i=0;i<e.length;++i){const r=e[i],s=t[i+1];if(null!=r&&null!=s&&r!==s)throw new M4(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);null==r&&(e[n]=s),n++}}return[t[0],...e,this.outputDim]}call(t,e){return Co((()=>{this.invokeCallHook(t,e);let n=u5(t);"int32"!==n.dtype&&(n=C6(n,"int32"));const i=P6(this.embeddings.read(),ca(n,[n.size]));return ca(i,h5(this.computeOutputShape(n.shape)))}))}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:o5(this.embeddingsInitializer),embeddingsRegularizer:htt(this.embeddingsRegularizer),activityRegularizer:htt(this.activityRegularizer),embeddingsConstraint:I8(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}uet.className="Embedding",Kd(uet);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class het extends S5{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new $4}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let i=0;i<e.length;++i){const r=t[t.length-e.length+i],s=e[i];if(null==r||null==s||r<0||s<0)n.push(null);else if(1===r)n.push(s);else if(1===s)n.push(r);else{if(r!==s)throw new M4("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(r)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[h5(t)]),t.length<2)throw new M4(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const n of t)null!=n&&null!==n[0]&&e.push(n[0]);if(e=H4(e),e.length>1)throw new M4(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=null==t[0]?null:t[0].slice(1);for(let e=1;e<t.length;++e){const i=null==t[e]?null:t[e].slice(1);n=this.computeElementwiseOpOutputShape(n,i)}const i=t.map((t=>t.length));-1===t.indexOf(null)&&1===H4(i).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return Co((()=>{if(this.reshapeRequired){const e=[],n=t.map((t=>t.rank));if(-1===n.indexOf(null)){const i=x6(n);for(let n of t){const t=n.rank;for(let e=0;e<i-t;++e)n=T6(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const i of t){const t=i.rank;if(null==t){const t=i.shape,r=t[0],s=t.slice(1).concat([r]);let o=ca(i,[r].concat(b6(t.slice(1))));o=Ch(o,[1,0]),o=ca(o,s),e.push(o),n=!0}else if(t>1){const r=w6(1,t).concat([0]);e.push(Ch(i,r)),n=!0}else e.push(i)}let i=this.mergeFunction(e);const r=i.rank;if(n)if(null==r){const t=i.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));i=ca(Ch(ca(i,[-1,e]),[1,0]),n)}else if(r>1){const t=[r-1].concat(w6(0,r-1));i=Ch(i,t)}return i}}return this.mergeFunction(t)}))}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let n=1;n<t.length;++n){const i=null==t[n]?null:t[n].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let n=[];for(const e of t)null!=e&&null!==e[0]&&n.push(e[0]);return n=H4(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return Co((()=>{if(null==e)return null;if(!Array.isArray(e))throw new M4("`mask` should be an Array");if(!Array.isArray(t))throw new M4("`inputs` should be an Array");if(e.length!==t.length)throw new M4(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every((t=>null==t)))return null;e=e.map((t=>null==t?t:Ml(t,0)));let n=e[0];for(let t=1;t<e.length-1;++t)n=nc(n,e[t]);return n}))}}class det extends het{constructor(t){super(t)}mergeFunction(t){return Co((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=Ao(e,t[n]);return e}))}}det.className="Add",Kd(det);class pet extends het{constructor(t){super(t)}mergeFunction(t){return Co((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=Po(e,t[n]);return e}))}}pet.className="Multiply",Kd(pet);class fet extends het{constructor(t){super(t)}mergeFunction(t){return Co((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=Ao(e,t[n]);return Po(1/t.length,e)}))}}fet.className="Average",Kd(fet);class met extends het{constructor(t){super(t)}mergeFunction(t){return Co((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=dc(e,t[n]);return e}))}}met.className="Maximum",Kd(met);class get extends het{constructor(t){super(t)}mergeFunction(t){return Co((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=yc(e,t[n]);return e}))}}get.className="Minimum",Kd(get);class yet extends het{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new M4("A `Concatenate` layer should be called on a list of at least 2 inputs");let e=!0;for(const n of t)if(null!=n){e=!1;break}if(e)return;const n=[];for(let e=0;e<t.length;++e){const i=t[e].slice();i.splice(this.axis,1);let r=!1;for(const t of n)if(m(t,i)){r=!0;break}r||n.push(i)}if(n.length>1)throw new M4("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return Co((()=>$6(t,this.axis)))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new M4("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),i=this.axis<0?n.length+this.axis:this.axis;for(const t of e.slice(1)){if(null==n[i]||null==t[i]){n[i]=null;break}n[i]+=t[i]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new M4("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new M4("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new M4(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return Co((()=>{let n=!0;if(e.forEach((t=>{null==t||(n=!1)})),n)return null;const i=[];for(let n=0;n<t.length;++n)null==e[n]?i.push(vo(Tc(t[n]),"bool")):e[n].rank<t[n].rank?i.push(Ml(e[n],-1)):i.push(e[n]);const r=da(i,this.axis);return zo(r,-1,!1)}))}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function bet(t,e){for(;t<0;)t+=e;return t}yet.className="Concatenate",Kd(yet);class vet extends het{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){c(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new $4("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(e,n);if(e[i[0]]!==n[i[1]])throw new M4(`Dimension incompatibility: ${e[i[0]]} !== ${n[i[1]]}`)}mergeFunction(t){if(2!==t.length)throw new M4(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e,n=t[0],i=t[1];return e=Array.isArray(this.axes)?this.axes.map(((e,n)=>bet(e,t[n].shape.length))):[bet(this.axes,n.shape.length),bet(this.axes,i.shape.length)],this.normalize&&(n=j8(n,e[0]),i=j8(i,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new $4("batchDot is not implemented for tensors of 4D or higher rank yet");if(c(t.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`)),c(t.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new $4("batchDot is not implemented for complex64-type Tensors yet.");const i=t.shape.length,r=e.shape.length;null==n&&(n=[i-1,r-2]);const s=n;return Co((()=>{let n,o;if(i>r){n=i-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=ca(e,e.shape.concat(t))}else if(r>i){n=r-i;const e=[];for(let t=0;t<n;++t)e.push(1);t=ca(t,t.shape.concat(e))}else n=0;if(2===t.shape.length&&2===e.shape.length)o=s[0]===s[1]?kl(Po(t,e),s[0]):kl(Po(Ch(t,[1,0]),e),s[1]);else{const n=s[0]!==t.shape.length-1,i=s[1]===e.shape.length-1;o=pa(t,e,n,i)}if(n>0){let t;t=i>r?i+r-3:i-1;const e=[];for(let i=t;i<t+n;++i)e.push(i);o=Ju(o,e)}return 1===o.shape.length&&(o=Ml(o,1)),o}))}(n,i,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[bet(this.axes,t.length),bet(this.axes,e.length)],n}computeOutputShape(t){c(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new $4("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(e,n);e.splice(i[0],1),n.splice(i[1],1),n.splice(0,1);const r=e.concat(n);return 1===r.length&&r.push(1),r}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}vet.className="Dot",Kd(vet);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class xet extends S5{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return Co((()=>{this.invokeCallHook(t,e);const n=u5(t);return z6((()=>Ao(N6(n.shape,0,this.stddev),n)),(()=>n),e.training||!1)}))}}xet.className="GaussianNoise",Kd(xet);class wet extends S5{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return Co((()=>{this.invokeCallHook(t,e);const n=u5(t);if(this.rate>0&&this.rate<1){return z6((()=>{const t=Math.sqrt(this.rate/(1-this.rate));return Po(n,N6(n.shape,1,t))}),(()=>n),e.training||!1)}return n}))}}wet.className="GaussianDropout",Kd(wet);class ket extends S5{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||u5(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return Co((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t),i=()=>{const e=u5(t),i=-1.7580993408473766;let r=Ol(wu(n),this.rate);r=C6(r,"float32");const s=((1-this.rate)*(1+this.rate*i**2))**-.5,o=-s*i*this.rate,a=Ao(Po(e,r),Po(Ao(r,-1),i));return Ao(Po(a,s),o)};return z6(i,(()=>u5(t)),e.training||!1)}return t}))}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Cet(t,e,n,i,r,s=.001){let o;if(2===t.rank)o=xa(t,e,n,i,r,s);else if(3===t.rank)o=wa(t,e,n,i,r,s);else{if(4!==t.rank)throw new $4(`batchNormalization is not implemented for array of rank ${t.rank} yet`);o=Sa(t,e,n,i,r,s)}return o}function Tet(t,e,n,i,r=.001){return m(i.slice().sort(),w6(0,t.rank-1))?function(t,e,n,i,r=.001){return Co((()=>{const s=xc(t,i),o=s.mean,a=s.variance;return[Cet(t,o,a,n,e,r),o,a]}))}(t,e,n,i,r):function(t,e,n,i,r=.001){return Co((()=>{const s=xc(t,i),o=s.mean,a=s.variance,l=[];for(const e of w6(0,t.rank))-1!==i.indexOf(e)?l.push(1):l.push(t.shape[e]);const c=ca(o,l),u=ca(a,l),h=null==e?null:ca(e,l),d=null==n?null:ca(n,l);return[Cet(t,c,u,d,h,r),o,a]}))}(t,e,n,i,r)}ket.className="AlphaDropout",Kd(ket);class _et extends S5{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=a5(t.betaInitializer||"zeros"),this.gammaInitializer=a5(t.gammaInitializer||"ones"),this.movingMeanInitializer=a5(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=a5(t.movingVarianceInitializer||"ones"),this.betaConstraint=N8(t.betaConstraint),this.gammaConstraint=N8(t.gammaConstraint),this.betaRegularizer=ptt(t.betaRegularizer),this.gammaRegularizer=ptt(t.gammaRegularizer)}build(t){t=h5(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new M4(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new y5({ndim:t.length,axes:{[e]:n}})];const i=[n];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return Co((()=>{const n=null!=e.training&&e.training,i=u5(t),r=i.shape,s=r.length,o=w6(0,s),a=this.axis>=0?this.axis:this.axis+s;o.splice(a,1);const l=N4(1,s);l[a]=r[a];const c=o.slice();c.sort();const u=!m(c,w6(0,s).slice(0,s-1));if(!n)return(()=>{if(u){const t=ca(this.movingMean.read(),l),e=ca(this.movingVariance.read(),l),n=this.center?ca(this.beta.read(),l):null,r=this.scale?ca(this.gamma.read(),l):null;return Cet(i,t,e,n,r,this.epsilon)}return Cet(i,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=Tet(i,this.gamma.read(),this.beta.read(),o,this.epsilon),f=(t,e,n)=>{Co((()=>{const i=1-n,r=t.read(),s=Po(Ql(r,e),i);t.write(Ql(r,s))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:o5(this.betaInitializer),gammaInitializer:o5(this.gammaInitializer),movingMeanInitializer:o5(this.movingMeanInitializer),movingVarianceInitializer:o5(this.movingVarianceInitializer),betaRegularizer:htt(this.betaRegularizer),gammaRegularizer:htt(this.gammaRegularizer),betaConstraint:I8(this.betaConstraint),gammaConstraint:I8(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}_et.className="BatchNormalization",Kd(_et);class Eet extends S5{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=a5(t.betaInitializer||"zeros"),this.gammaInitializer=a5(t.gammaInitializer||"ones"),this.betaRegularizer=ptt(t.betaRegularizer),this.gammaRegularizer=ptt(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=h5(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let t=0;t<this.axis.length;++t)this.axis[t]<0&&(this.axis[t]+=e);for(const t of this.axis)if(t<0||t>=e)throw new Error(`Invalid axis: ${t}`);if(this.axis.length!==H4(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((e=>t[e]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0}call(t,e){const n=u5(t),i=n.shape,r=i.length;return Co((()=>{let{mean:t,variance:e}=xc(n,this.axis,!0);const s=N4(1,r);for(const t of this.axis)s[t]=i[t];const o=t=>null!=t&&t.shape.length!==r?ca(t,s):t;let a=this.scale?o(this.gamma.read()):null,l=this.center?o(this.beta.read()):null;const c=[],u=[];for(let t=0;t<r;++t)-1!==this.axis.indexOf(t)?(c.push(i[t]),u.push(1)):(c.push(1),u.push(i[t]));return t=Il(t,c),e=Il(e,c),null!=a&&(a=Il(a,u)),null!=l&&(l=Il(l,u)),Cet(n,t,e,l,a,this.epsilon)}))}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:o5(this.betaInitializer),gammaInitializer:o5(this.gammaInitializer),betaRegularizer:htt(this.betaRegularizer),gammaRegularizer:htt(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}Eet.className="LayerNormalization",Kd(Eet);class Met extends S5{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new M4(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if("number"==typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new M4(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],2!==t.padding[1].length)throw new M4(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new y5({ndim:4})]}computeOutputShape(t){let e,n;return t=h5(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return Co((()=>
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function(t,e,n){return Co((()=>{if(4!==t.rank)throw new M4(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==e&&(e=[[1,1],[1,1]]),2!==e.length||2!==e[0].length||2!==e[1].length)throw new M4("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new M4(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let i;return i="channelsFirst"===n?[[0,0],[0,0],e[0],e[1]]:[[0,0],e[0],e[1],[0,0]],Ec(t,i)}))}(u5(t),this.padding,this.dataFormat)))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function $et(t,e,n,i,r,s){return Co((()=>{let o;a6(r),c6(s),l6(i),null==n&&(n=[1,1]),null==i&&(i="valid"),null==r&&(r="channelsLast"),null==s&&(s="max"),t=ktt(t,r);const a="same"===i?"same":"valid";return o="max"===s?cc(t,e,n,a):ua(t,e,n,a),"channelsFirst"===r&&(o=Ch(o,[0,3,1,2])),o}))}function Iet(t,e,n,i,r,s){return Co((()=>{let o;a6(r),c6(s),l6(i),null==n&&(n=[1,1,1]),null==i&&(i="valid"),null==r&&(r="channelsLast"),null==s&&(s="max"),t=Ctt(t,r);const a="same"===i?"same":"valid";return o="max"===s?uc(t,e,n,a):ha(t,e,n,a),"channelsFirst"===r&&(o=Ch(o,[0,4,1,2,3])),o}))}Met.className="ZeroPadding2D",Kd(Met);class Aet extends S5{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new M4(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(X4(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new M4(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}X4(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,l6(this.padding),this.inputSpec=[new y5({ndim:3})]}computeOutputShape(t){const e=wtt((t=h5(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return Co((()=>{this.invokeCallHook(t,e),t=T6(u5(t),2);const n=this.poolingFunction(u5(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Ju(n,[2])}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class Net extends Aet{constructor(t){super(t)}poolingFunction(t,e,n,i,r){return a6(r),l6(i),$et(t,e,n,i,r,"max")}}Net.className="MaxPooling1D",Kd(Net);class Ret extends Aet{constructor(t){super(t)}poolingFunction(t,e,n,i,r){return a6(r),l6(i),$et(t,e,n,i,r,"avg")}}Ret.className="AveragePooling1D",Kd(Ret);class Pet extends S5{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new M4(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];X4(this.poolSize,"poolSize"),X4(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,a6(this.dataFormat),l6(this.padding),this.inputSpec=[new y5({ndim:4})]}computeOutputShape(t){t=h5(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=wtt(e,this.poolSize[0],this.padding,this.strides[0]),n=wtt(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return Co((()=>(this.invokeCallHook(t,e),this.poolingFunction(u5(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Oet extends Pet{constructor(t){super(t)}poolingFunction(t,e,n,i,r){return a6(r),l6(i),$et(t,e,n,i,r,"max")}}Oet.className="MaxPooling2D",Kd(Oet);class Let extends Pet{constructor(t){super(t)}poolingFunction(t,e,n,i,r){return a6(r),l6(i),$et(t,e,n,i,r,"avg")}}Let.className="AveragePooling2D",Kd(Let);class Det extends S5{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new M4(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];X4(this.poolSize,"poolSize"),X4(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,a6(this.dataFormat),l6(this.padding),this.inputSpec=[new y5({ndim:5})]}computeOutputShape(t){t=h5(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],i="channelsFirst"===this.dataFormat?t[4]:t[3];return e=wtt(e,this.poolSize[0],this.padding,this.strides[0]),n=wtt(n,this.poolSize[1],this.padding,this.strides[1]),i=wtt(i,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,i]:[t[0],e,n,i,t[4]]}call(t,e){return Co((()=>(this.invokeCallHook(t,e),this.poolingFunction(u5(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Fet extends Det{constructor(t){super(t)}poolingFunction(t,e,n,i,r){return a6(r),l6(i),Iet(t,e,n,i,r,"max")}}Fet.className="MaxPooling3D",Kd(Fet);class zet extends Det{constructor(t){super(t)}poolingFunction(t,e,n,i,r){return a6(r),l6(i),Iet(t,e,n,i,r,"avg")}}zet.className="AveragePooling3D",Kd(zet);class Bet extends S5{constructor(t){super(t),this.inputSpec=[new y5({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new $4}}class Uet extends Bet{constructor(t){super(t||{})}call(t,e){return Co((()=>{const e=u5(t);return pc(e,1)}))}}Uet.className="GlobalAveragePooling1D",Kd(Uet);class Vet extends Bet{constructor(t){super(t||{})}call(t,e){return Co((()=>{const e=u5(t);return yl(e,1)}))}}Vet.className="GlobalMaxPooling1D",Kd(Vet);class Wet extends S5{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,a6(this.dataFormat),this.inputSpec=[new y5({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new $4}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Het extends Wet{call(t,e){return Co((()=>{const e=u5(t);return"channelsLast"===this.dataFormat?pc(e,[1,2]):pc(e,[2,3])}))}}Het.className="GlobalAveragePooling2D",Kd(Het);class jet extends Wet{call(t,e){return Co((()=>{const e=u5(t);return"channelsLast"===this.dataFormat?yl(e,[1,2]):yl(e,[2,3])}))}}jet.className="GlobalMaxPooling2D",Kd(jet);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Get extends S5{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){const i=H8(e.layer,n);delete e.layer;const r={layer:i};return Object.assign(r,e),new t(r)}}class qet extends Get{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=h5(t)).length<3)throw new M4(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=h5(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),i=t[1];return[n[0],i].concat(n.slice(1))}call(t,e){return Co((()=>ztt(((t,n)=>[u5(this.layer.call(t,e)),[]]),t=u5(t),[],!1,null,null,!1,!0)[1]))}}qet.className="TimeDistributed",Kd(qet);class Xet extends Get{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=H8(n),e.goBackwards=!0!==e.goBackwards;const i={};var r;if(i.className=t.layer.getClassName(),i.config=e,this.backwardLayer=H8(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,r=this.mergeMode,G4(s6,"BidirectionalMergeMode",r),t.weights)throw new $4("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e,n,i,r=this.forwardLayer.computeOutputShape(t);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState?(i=r.slice(1),e=r[0]):e=r[0],"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(i).concat(i.slice()):[e].concat(i).concat(i.slice()):O4(n)}apply(t,e){let n=null==e?null:e.initialState,i=null==e?null:e.constants;null==e&&(e={});const r=Ftt(t,n,i,this.numConstants);if(t=r.inputs,n=r.initialState,i=r.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==i)return super.apply(t,e);const s=[],o=[];if(null!=n){const t=n.length;if(t%2>0)throw new M4("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,s.push(...n);const i=n.map((t=>new y5({shape:t.shape})));this.forwardLayer.stateSpec=i.slice(0,t/2),this.backwardLayer.stateSpec=i.slice(t/2),o.push(...i)}if(null!=i)throw new $4("Support for constants in Bidirectional layers is not implemented yet.");const a=s[0]instanceof b5;for(const t of s)if(t instanceof b5!==a)throw new M4("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(a){const n=[t].concat(s),i=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=i;const a=super.apply(n,e);return this.inputSpec=r,a}return super.apply(t,e)}call(t,e){return Co((()=>{const n=e.initialState;let i,r,s,o;if(null==n)i=this.forwardLayer.call(t,e),r=this.backwardLayer.call(t,e);else{const s=n.slice(0,n.length/2),o=n.slice(n.length/2);i=this.forwardLayer.call(t,Object.assign(e,{initialState:s})),r=this.backwardLayer.call(t,Object.assign(e,{initialState:o}))}return this.returnState&&(Array.isArray(i)&&(s=i.slice(1).concat(r.slice(1))),i=i[0],r=r[0]),this.returnSequences&&(r=Mu(r,1)),"concat"===this.mergeMode?o=$6([i,r]):"sum"===this.mergeMode?o=Ao(i,r):"ave"===this.mergeMode?o=Po(.5,Ao(i,r)):"mul"===this.mergeMode?o=Po(i,r):null==this.mergeMode&&(o=[i,r]),this.returnState?null==this.mergeMode?o.concat(s):[o].concat(s):o}))}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){d6(this.forwardLayer.name,(()=>{this.forwardLayer.build(t)})),d6(this.backwardLayer.name,(()=>{this.backwardLayer.build(t)})),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map((t=>null));return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=H8(e.layer);if(delete e.layer,null!=e.numConstants)throw new $4("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=e;return i.layer=n,new t(i)}}Xet.className="Bidirectional",Kd(Xet);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Ket extends S5{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return Co((()=>("float32"!==(t=u5(t)).dtype&&(t=C6(t,"float32")),Ao(Po(t,this.scale),this.offset))))}}Ket.className="Rescaling",Kd(Ket);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const{resizeBilinear:Yet,cropAndResize:Zet}=Bd;class Jet extends S5{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,n,i,r,s,o,a){return Co((()=>{let l,c=!1;const u=[e/s,n/o,(i+e)/s,(r+n)/o],h=[];3===t.rank?(c=!0,l=Qu([t])):l=t;for(let t=0;t<l.shape[0];t++)h.push(u);const d=xs(h,[h.length,4]),p=ku(0,h.length,1,"int32"),f=Zet(l,d,p,[i,r],"nearest");return C6(c?u5(bh(f)):f,a)}))}upsize(t,e,n,i){return Co((()=>C6(Yet(t,[e,n]),i)))}call(t,e){return Co((()=>{const e=u5(t),n=e.dtype,i=e.shape,r=i[i.length-3],s=i[i.length-2];let o=0;r!==this.height&&(o=Math.floor((r-this.height)/2));let a=0;return s!==this.width&&(a=Math.floor((s-this.width)/2),0===a&&(a=1)),o>=0&&a>=0?this.centerCrop(e,o,a,this.height,this.width,r,s,n):this.upsize(t,this.height,this.width,n)}))}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){const e=(t=h5(t)).length-3,n=t.length-2;return t[e]=this.height,t[n]=this.width,t}}Jet.className="CenterCrop",Kd(Jet);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Qet extends S5{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return null==(t=h5(t))?[this.numTokens]:"oneHot"===this.outputMode&&1!==t[t.length-1]?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return Co((()=>{let n;if("int32"!==(t=u5(t)).dtype&&(t=C6(t,"int32")),void 0!==e.countWeights){if("count"!==this.outputMode)throw new M4(`countWeights is not used when outputMode !== count.\n              Received countWeights=${e.countWeights}`);n=u5(e.countWeights)}const i=yl(t),r=bl(t),s=Pl(this.numTokens,i).bufferSync().get(0),o=Ol(r,0).bufferSync().get(0);if(!s||!o)throw new M4(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
return function(t,e,n,i){let r=u5(t);if("int32"!==r.dtype&&(r=C6(r,"int32")),"int"===e)return r;const s=r.shape;if(0===r.rank&&(r=Ml(r,-1)),"oneHot"===e&&1!==r.shape[r.shape.length-1]&&(r=Ml(r,-1)),r.rank>2)throw new M4(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${s} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(e);let a;if(a=ja(r,void 0!==i&&"count"===e?i:[],n,o),"tfIdf"!==e)return a;if(i)return Po(a,i);throw new M4("When outputMode is 'tfIdf', weights must be provided.")}(t,this.outputMode,this.numTokens,n)}))}}Qet.className="CategoryEncoding",Kd(Qet);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const tnt=new Set(["bilinear","nearest"]);class ent extends S5{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation){if(!tnt.has(t.interpolation))throw new M4(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);this.interpolation=t.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(t.cropToAspectRatio)}computeOutputShape(t){const e=(t=h5(t))[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return Co((()=>{const e=[this.height,this.width];if("bilinear"===this.interpolation)return Bd.resizeBilinear(t,e,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Bd.resizeNearestNeighbor(t,e,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...tnt]} are supported`)}))}}ent.className="Resizing",Kd(ent);
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class nnt{constructor(t){this.seed=t}next(){if(void 0!==this.seed)return this.seed++}}nnt.className="RandomSeed";
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class int extends S5{constructor(t){super(t),this.randomGenerator=new nnt(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}int.className="BaseRandomLayer";
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const rnt=new Set(["bilinear","nearest"]);class snt extends int{constructor(t){super(t);const{factor:e,interpolation:n="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new M4(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new M4(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new M4(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!rnt.has(n))throw new M4(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){const e=(t=h5(t))[2];return[this.imgHeight,-1,e]}call(t,e){return Co((()=>{const e=u5(t);this.imgHeight=e.shape[e.shape.length-3];const n=e.shape[e.shape.length-2];this.widthFactor=wu([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*n;i=Math.round(i);const r=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Bd.resizeBilinear(t,r);case"nearest":return Bd.resizeNearestNeighbor(t,r);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...rnt]} are supported`)}}))}}function ont(t){return new net(t)}function ant(t,e){return q8(t,e)}function lnt(t){if(!t.modelTopology.model_config||!t.modelTopology.model_config.config||!t.modelTopology.model_config.config.layers||t.modelTopology.model_config.config.layers.length>0&&!t.modelTopology.model_config.config.layers[0].class_name)return t;try{let e=!1;for(const[n,i]of t.modelTopology.model_config.config.layers.entries())if("SeparableConv2D"===i.class_name){const i=["kernel_constraint","kernel_initializer","kernel_regularizer"];for(const r of i)Object.keys(t.modelTopology.model_config.config.layers[n].config).includes(r)&&(e=!0),delete t.modelTopology.model_config.config.layers[n].config[r]}e&&sK.warning("TFJS Model loading: experimentally removing Kernel attributes from SeparableConv2D layers")}catch(t){sK.warning("TFJS Model loading: An error occurred whil experimentally removing Kernel attributes from SeparableConv2D layers",t)}return t}function cnt(...t){const e=gp(...t),n=e.load.bind(e);return e.load=async function(){return lnt(await n())},e}function unt(...t){const e=cp(...t),n=e.load.bind(e);return e.load=async function(){return lnt(await n())},e}snt.className="RandomWidth",Kd(snt);class hnt extends i3{constructor(){super(...arguments),this.serviceName="tfjs-models"}async warmup(){const t=this.model.inputs[0].shape.map((t=>t&&t>0?t:1)),e=this.model.predict(Co((()=>fc(t))));await e.data(),e.dispose()}async save(t,e,n,i=null){if(!this.model)return null;let r;if(t.backend===n2.LocalStorage)await this.model.save(`indexeddb://${e}`),r=[["main",`indexeddb://${e}`]];else if(t.backend===n2.Remote){const e={};if(t.requiresAuth){const n=await t.feathers.authentication.getAccessToken(),i=new Headers({Authorization:`Bearer ${n}`});e.requestInit={headers:i}}r=await this.model.save(cnt(`${t.location}/tfjs-models/upload`,e)).then((t=>t.responses[0].json()))}const s={name:e,files:r,format:"tfjs",metadata:{tfjsModelFormat:this.model instanceof z7?"layers-model":"graph-model",...this.labels&&{labels:this.labels},...n}};return this.saveToDatastore(t,s,i)}async load(t,e){if(!e)return null;this.$training.set({status:"loading"}),this.ready=!1,await Eo();try{const n=await this.loadFromDatastore(t,e);let i;if(this.loadFn="graph-model"===n.metadata.tfjsModelFormat?C4:U7,t.backend===n2.LocalStorage)i=await this.loadFn(n.files[0][1]);else if(t.backend===n2.Remote){const e={};if(t.requiresAuth){const n=await t.feathers.authentication.getAccessToken(),i=new Headers({Authorization:`Bearer ${n}`});e.requestInit={headers:i}}i=await this.loadFn(cnt(`${t.location}/tfjs-models/${n.id}/model.json`,e))}return i&&(this.model=i,await this.warmup()),n.metadata&&n.metadata.labels?this.labels=n.metadata.labels:this.labels=void 0,this.$training.set({status:"loaded",data:{source:"datastore",url:t.location}}),n}catch(t){throw console.log("[tfjs-model] Loading error",t),this.$training.set({status:"error"}),t}}async download(t){const e=a2(this.title),n={type:"tfjs-model",tfjsModelFormat:this.model instanceof z7?"layers-model":"graph-model",name:e,...this.labels&&{labels:this.labels},...t},i=new Date(Date.now());await this.model.save(Sp((async t=>{const r={modelTopology:t.modelTopology,weightsManifest:[{paths:[`./${e}.weights.bin`],weights:t.weightSpecs}],marcelle:n};return await s2(t.weightData,`${e}.weights.bin`,"application/octet-stream"),await s2(JSON.stringify(r),`${e}.json`,"text/plain"),{modelArtifactsInfo:{dateSaved:i,modelTopologyType:"JSON"}}})))}async upload(...t){this.$training.set({status:"loading"});try{const e=t.filter((t=>t.name.includes(".json"))),n=t.filter((t=>t.name.includes(".bin"))),{marcelle:i}=await new Promise(((t,n)=>{const i=new FileReader;i.onload=()=>{const e=JSON.parse(i.result);t(e)},i.onerror=t=>n(new Error(`The provided files are not a valid marcelle model ${t}`)),i.readAsText(e[0])}));if(this.loadFn="graph-model"===i.tfjsModelFormat?C4:U7,1===e.length&&t.length){const t=await this.loadFn(unt([e[0],...n]));return t&&(this.model=t,await this.warmup()),i&&i.labels?this.labels=i.labels:this.labels=null,this.$training.set({status:"loaded",data:{source:"file"}}),{name:i.name,format:"tfjs",files:[],metadata:i}}const r=new Error("The provided files are not compatible with this model");throw r.name="File upload error",r}catch(t){throw this.$training.set({status:"error"}),t}}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
function dnt(t,e){return pnt(t,e)}function pnt(t,e,n=new Map,i=new Set){if(null==t)return null;if("function"==typeof Blob&&t instanceof Blob)return t.slice();if(i.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const r=e(t);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(ynt(t)){const r=Array.isArray(t)?[]:{};i.add(t);for(const s in t){const o=pnt(t[s],e,n,i);r[s]=o}return i.delete(t),t.__proto__&&(r.__proto__=t.__proto__),r}throw new Error(`Can't recurse into non-iterable type: ${t}`)}return n.set(t,r.value),r.value}function fnt(t,e=gnt){return mnt(t,e)}function mnt(t,e,n=new Set){const i=t[0];if(n.has(i))throw new Error("Circular references are not supported.");const r=e(t);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(ynt(i)){const r=Array.isArray(i)?[]:{};n.add(i);for(const s in i){const i=t.map((t=>t[s])),o=mnt(i,e,n);r[s]=o}return n.delete(i),r}throw new Error(`Can't recurse into non-iterable type: ${i}`)}return r.value}function gnt(t){return null===t?null:ynt(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function ynt(t){let e=!1;if(Y().get("IS_BROWSER"))e=t instanceof TextDecoder;else{const{StringDecoder:n}=require("string_decoder");e=t instanceof n}return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof Or)&&!(t instanceof Promise)&&!e)}function bnt(t){return t instanceof Or?{value:t.clone(),recurse:!1}:ynt(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */UX([aK],hnt.prototype,"warmup",null),UX([aK],hnt.prototype,"upload",null),
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Lr().prototype.gather=function(t,e,n){return this.throwIfDisposed(),Rl(this,t,e,n)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Lr().prototype.argMax=function(t){return this.throwIfDisposed(),Uo(this,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Lr().prototype.squeeze=function(t){return this.throwIfDisposed(),Ju(this,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Lr().prototype.expandDims=function(t){return this.throwIfDisposed(),Ml(this,t)};class vnt{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class xnt extends vnt{constructor(){super(xnt.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let t=0;t<n;t++)e[t]=this.get(this.wrap(this.begin+t));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function wnt(t){return new Cnt(t)}xnt.INITIAL_CAPACITY=32;class Snt{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new Ant(this,t)}filter(t){return new $nt(this,t)}map(t){return new Int(this,t)}mapAsync(t){return new Nnt(this,t)}serialMapAsync(t){return new Nnt(this,t).serial()}flatmap(t){return new Pnt(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile((t=>!0===t))}rowMajorBatch(t,e=!0){return new Mnt(this,t,e)}columnMajorBatch(t,e=!0,n=gnt){return this.rowMajorBatch(t,e).map((t=>fnt(t,n)))}concatenate(t,e){return new Ont(new knt([this,t]),e)}take(t){return t<0||null==t?this:new Ent(this,t)}skip(t){return t<0||null==t?this:new _nt(this,t)}prefetch(t){return new Dnt(this,t)}shuffle(t,e){return new Fnt(this,t,e)}serial(){return new Tnt(this)}}class knt extends Snt{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:(e=t,dnt(e,bnt)),done:!1};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
var e}}class Cnt extends Snt{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}}class Tnt extends Snt{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class _nt extends Snt{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;To(t.value)}return this.upstream.next()}}class Ent extends Snt{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class Mnt extends Snt{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class $nt extends Snt{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;To(t.value)}}}class Int extends Snt{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Zr(t.value),n=this.transform(t.value),i=Zr(n);for(const t of e)Yr(t,i)||t.dispose();return{value:n,done:!1}}}class Ant extends Snt{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class Nnt extends Snt{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Zr(t.value),n=await this.transform(t.value),i=Zr(n);for(const t of e)Yr(t,i)||t.dispose();return{value:n,done:!1}}}class Rnt extends Snt{constructor(){super(),this.outputQueue=new xnt,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class Pnt extends Rnt{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=Zr(t.value),n=this.transform(t.value),i=Zr(n);this.outputQueue.pushAll(n);for(const t of e)Yr(t,i)||t.dispose();return!0}}class Ont extends Snt{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}var Lnt;!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(Lnt||(Lnt={}));class Dnt extends Snt{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new vnt(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class Fnt extends Dnt{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=lu.alea(n||mr().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let znt=class{constructor(){this.size=null}batch(t,e=!0){const n=this;let i;return c(t>0,(()=>`batchSize needs to be positive, but it is\n      ${t}`)),i=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),Bnt((async()=>(await n.iterator()).columnMajorBatch(t,e,Unt)),i)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,Bnt((async()=>(await e.iterator()).concatenate(await t.iterator())),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,Bnt((async()=>(await e.iterator()).filter((e=>Co((()=>t(e)))))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return Bnt((async()=>(await e.iterator()).map((e=>Co((()=>t(e)))))),this.size)}mapAsync(t){const e=this;return Bnt((async()=>(await e.iterator()).mapAsync(t)),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return Bnt((async()=>(await e.iterator()).prefetch(t)),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,Bnt((async()=>{const n=wnt((async()=>({value:await e.iterator(),done:!1})));return i=n.take(t),new Ont(i,r);var i,r}),n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,Bnt((async()=>(await e.iterator()).skip(t)),n)}shuffle(t,e,n=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const i=this,r=lu.alea(e||mr().toString());return Bnt((async()=>{let e=r.int32();return n&&(e+=r.int32()),(await i.iterator()).shuffle(t,e.toString())}),this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,Bnt((async()=>(await e.iterator()).take(t)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};function Bnt(t,e=null){return new class extends znt{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function Unt(t){if(null===t)return null;const e=t[0];if(null==(n=e)||null===(i=n)||"object"!=typeof i&&"function"!=typeof i||Array.isArray(n)||"object"==typeof n&&n instanceof Or||br(n)){return{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof Or?Qu(t):xs(t)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */(t),recurse:!1}}var n,i;return{value:null,recurse:!0}}function Vnt(t,e=null,n=!1){const i=e?{$select:e}:{},r=n3(t)?t.items().query(i):t,s=n?r.toArray():Promise.resolve(r);return function(t){return Bnt((async()=>{const e=await t();return wnt((()=>e.next()))}))}((async function*(){const t=await s;for await(const e of t)yield e}))}function Wnt(t){const e={};for(const[n,i]of Object.entries(t)){e[n.startsWith("val_")?n.replace("val_","")+"Val":n]=i}return e}znt.MAX_BUFFER_SIZE=1e4;class Hnt extends hnt{constructor({epochs:t=20,batchSize:e=8,validationSplit:n=.2}={}){super(),this.title="TFJSCustomModel",this.loadFn=U7,this.validationSplit=Math.max(Math.min(n,1),0),this.parameters={epochs:new eK(t,!0),batchSize:new eK(e,!0)}}transformDataset(t){return t.map((t=>({xs:xs(t.x),ys:xs(t.y)})))}async train(t,e){this.$training.set({status:"start",epochs:this.parameters.epochs.get()}),await Eo();const n=n3(t)?t.$count.value:(await t.toArray()).length,i=Math.min(200,n),r=this.transformDataset(Vnt(t,["x","y"],n<200)).shuffle(i);let s,o;if(e)s=r,o=this.transformDataset(Vnt(e,["x","y"],n<200)).shuffle(i);else{const t=Math.floor(n*(1-this.validationSplit));s=r.take(t),o=this.validationSplit>0&&r.skip(t)}const[{xs:a,ys:l}]=await s.take(1).toArray();this.buildModel(a.shape,l.shape),this.fit(s,o)}_predict(t){return this.model?Co((()=>this.model.predict(xs(t).expandDims(0)).gather(0))):null}clear(){delete this.model}fit(t,e){this.model.fitDataset(t.batch(this.parameters.batchSize.get()),{...e?{validationData:e.batch(this.parameters.batchSize.get())}:{},epochs:this.parameters.epochs.get(),callbacks:{onEpochEnd:(t,e)=>{this.$training.set({status:"epoch",epoch:t+1,epochs:this.parameters.epochs.get(),data:Wnt(e)})}}}).then((t=>{this.$training.set({status:"success",data:Wnt(t.history)})})).catch((t=>{throw this.$training.set({status:"error",data:t}),new lK(t.message)}))}}UX([aK],Hnt.prototype,"train",null);class jnt extends Hnt{constructor(){super(...arguments),this.title="TFJSCustomClassifier"}async train(t,e){const n=n3(t);if(this.labels=n?await t.distinct("y"):this.labels=Array.from(new Set(await t.map((({y:t})=>t)).toArray())),0===this.labels.length)return cK(new lK("This dataset is empty or is missing labels")),void this.$training.set({status:"error"});if(1===this.labels.length)return cK(new lK("At least two classes are needed to train the classifier")),void this.$training.set({status:"error"});const i=this.labels.length;this.transformDataset=t=>t.map((t=>({xs:xs(t.x),ys:Cc(this.labels.indexOf(t.y),i)}))),super.train(t,e)}async predict(t){return this.model?Co((()=>{const e=this._predict(t),n=this.labels[e.argMax().arraySync()],i=e.arraySync().reduce(((t,e,n)=>({...t,[this.labels[n]]:e})),{});return{label:n,confidences:i}})):{label:void 0,confidences:{}}}}function Gnt(t){let e;return{c(){e=MB("div"),e.textContent="This dataStore does not require authentication"},m(t,n){TB(t,e,n)},p:Jz,i:Jz,o:Jz,d(t){t&&_B(e)}}}function qnt(t){let e,n,i,r={ctx:t,current:null,token:null,hasCatch:!1,pending:Ynt,then:Knt,catch:Xnt,value:3,blocks:[,,,]};return AU(n=t[1].connect(),r),{c(){e=NB(),r.block.c()},m(t,n){TB(t,e,n),r.block.m(t,r.anchor=n),r.mount=()=>e.parentNode,r.anchor=e,i=!0},p(e,i){t=e,r.ctx=t,2&i&&n!==(n=t[1].connect())&&AU(n,r)||NU(r,t,i)},i(t){i||(EU(r.block),i=!0)},o(t){for(let t=0;t<3;t+=1){MU(r.blocks[t])}i=!1},d(t){t&&_B(e),r.block.d(t),r.token=null,r=null}}}function Xnt(t){return{c:Jz,m:Jz,p:Jz,i:Jz,o:Jz,d:Jz}}function Knt(t){let e,n,i,r,s,o,a,l,c=t[3].email+"";return{c(){e=MB("p"),n=IB("Hello, "),i=IB(c),r=AB(),s=MB("div"),o=MB("button"),o.textContent="Log out",OB(e,"class","pb-2"),OB(o,"class","btn danger"),OB(s,"class","flex")},m(c,u){TB(c,e,u),SB(e,n),SB(e,i),TB(c,r,u),TB(c,s,u),SB(s,o),a||(l=RB(o,"click",t[2]),a=!0)},p(t,e){2&e&&c!==(c=t[3].email+"")&&DB(i,c)},i:Jz,o:Jz,d(t){t&&_B(e),t&&_B(r),t&&_B(s),a=!1,l()}}}function Ynt(t){let e,n;return e=new LV({}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p:Jz,i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function Znt(t){let e,n,i,r;const s=[qnt,Gnt],o=[];function a(t,e){return t[1].requiresAuth?0:1}return e=a(t),n=o[e]=s[e](t),{c(){n.c(),i=NB()},m(t,n){o[e].m(t,n),TB(t,i,n),r=!0},p(t,r){let l=e;e=a(t),e===l?o[e].p(t,r):(TU(),MU(o[l],1,1,(()=>{o[l]=null})),_U(),n=o[e],n?n.p(t,r):(n=o[e]=s[e](t),n.c()),EU(n,1),n.m(i.parentNode,i))},i(t){r||(EU(n),r=!0)},o(t){MU(n),r=!1},d(t){o[e].d(t),t&&_B(i)}}}function Jnt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[Znt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),18&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function Qnt(t,e,n){let{title:i}=e,{dataStore:r}=e;return t.$$set=t=>{"title"in t&&n(0,i=t.title),"dataStore"in t&&n(1,r=t.dataStore)},[i,r,function(){r.logout()}]}UX([aK],jnt.prototype,"train",null);class tit extends UU{constructor(t){super(),BU(this,t,Qnt,Jnt,rB,{title:0,dataStore:1})}}var eit,nit;class iit extends xK{constructor(t){super(),this.title="account manager",eit.set(this,void 0),WX(this,eit,t,"f")}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new tit({target:e,props:{title:this.title,dataStore:VX(this,eit,"f")}}))}}function rit(...t){return new iit(...t)}function sit(t){let e,n,i,r,s,o,a,l,c,u,h,d,p,f=t[2]?.message+"",m=Math.floor(100*t[2]?.progress)+"";return d=new MV({props:{progress:t[2]?.progress,type:t[2]?.type}}),{c(){e=MB("div"),n=MB("div"),i=MB("div"),r=MB("span"),s=IB(f),o=AB(),a=MB("div"),l=MB("span"),c=IB(m),u=IB("%"),h=AB(),DU(d.$$.fragment),OB(r,"class","text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200 svelte-1c8hye1"),WB(r,"gray","idle"===t[2]?.type),WB(r,"green","success"===t[2]?.type),WB(r,"red","danger"===t[2]?.type),OB(l,"class","text-xs font-semibold inline-block text-blue-600 svelte-1c8hye1"),WB(l,"tgray","idle"===t[2]?.type),WB(l,"tgreen","success"===t[2]?.type),WB(l,"tred","danger"===t[2]?.type),OB(a,"class","text-right"),OB(n,"class","flex mb-2 items-center justify-between"),OB(e,"class","relative pt-6 w-full"),zB(e,"min-width","250px")},m(t,f){TB(t,e,f),SB(e,n),SB(n,i),SB(i,r),SB(r,s),SB(n,o),SB(n,a),SB(a,l),SB(l,c),SB(l,u),SB(e,h),FU(d,e,null),p=!0},p(t,e){(!p||4&e)&&f!==(f=t[2]?.message+"")&&DB(s,f),(!p||4&e)&&WB(r,"gray","idle"===t[2]?.type),(!p||4&e)&&WB(r,"green","success"===t[2]?.type),(!p||4&e)&&WB(r,"red","danger"===t[2]?.type),(!p||4&e)&&m!==(m=Math.floor(100*t[2]?.progress)+"")&&DB(c,m),(!p||4&e)&&WB(l,"tgray","idle"===t[2]?.type),(!p||4&e)&&WB(l,"tgreen","success"===t[2]?.type),(!p||4&e)&&WB(l,"tred","danger"===t[2]?.type);const n={};4&e&&(n.progress=t[2]?.progress),4&e&&(n.type=t[2]?.type),d.$set(n)},i(t){p||(EU(d.$$.fragment,t),p=!0)},o(t){MU(d.$$.fragment,t),p=!1},d(t){t&&_B(e),zU(d)}}}function oit(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[sit]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),12&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function ait(t,e,n){let i,r=Jz,s=()=>(r(),r=aB(a,(t=>n(2,i=t))),a);t.$$.on_destroy.push((()=>r()));let{title:o}=e,{progress:a}=e;return s(),t.$$set=t=>{"title"in t&&n(0,o=t.title),"progress"in t&&s(n(1,a=t.progress))},[o,a,i]}eit=new WeakMap;class lit extends UU{constructor(t){super(),BU(this,t,ait,oit,rB,{title:0,progress:1})}}class cit extends xK{constructor(t){super(),this.$progress=t,this.title="progress bar",this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new lit({target:e,props:{title:this.title,progress:this.$progress}}))}}function uit(...t){return new cit(...t)}function hit(t){if(!t.$training)throw new Error("The argument is not a valid MLP");const e=t.$training.map((({status:t,epoch:e,epochs:n})=>{let i="default",r=n>0?e/n:null;return"error"===t&&(i="danger"),"idle"===t&&(i="idle",r=0),["success","loaded"].includes(t)&&(i="success",r=1),["start","loading"].includes(t)&&(r=null),{message:`Status: ${t}`,progress:r,type:i}})).hold(),n=new cit(e);return n.title="Training Progress",n}class dit extends xK{constructor(t,e=r2()){super(),this.title="batch prediction",nit.set(this,void 0),this.$status=new eK({status:"loading"},!0),this.name=t,this.title=`batch prediction (${t})`,WX(this,nit,e||new i2,"f"),this.start(),VX(this,nit,"f").connect().then((()=>{this.setup()})).catch((e=>{const n=new Error(null==e?void 0:e.message);n.name=`Batch Prediction Error (${t}): Datastore connection failed`,cK(n,{duration:0})}))}async setup(){const t=a2(`predictions-${this.name}`);this.predictionService=VX(this,nit,"f").service(t);const{total:e}=await this.predictionService.find({query:{$limit:1,$select:["id"]}});this.$status.set({status:e>0?"loaded":"idle"})}async predict(t,e){try{const n=n3(e)?e.$count.value:(await e.toArray()).length;this.$status.set({status:"start"});const i=n3(e)?e.items():e;let r=0;for await(const{id:e,x:s,y:o}of i){const i=await t.predict(s),a=await this.predictionService.create({...i,instanceId:e,yTrue:o});this.$status.set({status:"running",count:++r,total:n,data:a})}this.$status.set({status:"success",count:r,total:n})}catch(t){this.$status.set({status:"error",data:{error:t}})}}async clear(){await this.predictionService.remove(null,{query:{}})}items(){return this.predictionService.items()}mount(){}}function pit(...t){return new dit(...t)}function fit(t){if(!t.$status)throw new Error("The argument is not a valid Batch Prediction");const e=t.$status.map((({status:t,count:e,total:n})=>{let i="default",r=n>0?(e+1)/n:null;return"error"===t&&(i="danger"),"idle"===t&&(i="idle",r=0),["success","loaded"].includes(t)&&(i="success",r=1),["start","loading"].includes(t)&&(r=null),{message:`Status: ${t}`,progress:r,type:i}})).hold(),n=uit(e);return n.title="Prediction Progress",n}function mit(t){let e;return{c(){e=IB(t[10])},m(t,n){TB(t,e,n)},p(t,n){1024&n&&DB(e,t[10])},d(t){t&&_B(e)}}}function git(t){let e,n,i,r;function s(e){t[11](e)}let o={disabled:t[7],type:t[8],$$slots:{default:[mit]},$$scope:{ctx:t}};return void 0!==t[9]&&(o.pressed=t[9]),n=new HU({props:o}),aU.push((()=>LU(n,"pressed",s))),n.$on("click",t[12]),{c(){e=MB("div"),DU(n.$$.fragment)},m(t,i){TB(t,e,i),FU(n,e,null),r=!0},p(t,e){const r={};128&e&&(r.disabled=t[7]),256&e&&(r.type=t[8]),9216&e&&(r.$$scope={dirty:e,ctx:t}),!i&&512&e&&(i=!0,r.pressed=t[9],mU((()=>i=!1))),n.$set(r)},i(t){r||(EU(n.$$.fragment,t),r=!0)},o(t){MU(n.$$.fragment,t),r=!1},d(t){t&&_B(e),zU(n)}}}function yit(t){let e,n;return e=new DH({props:{title:t[0],loading:t[6],$$slots:{default:[git]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),64&n&&(i.loading=t[6]),10112&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function bit(t,e,n){let i,r,s,o,a,l=Jz,c=()=>(l(),l=aB(w,(t=>n(6,i=t))),w),u=Jz,h=()=>(u(),u=aB(S,(t=>n(7,r=t))),S),d=Jz,p=()=>(d(),d=aB(k,(t=>n(8,s=t))),k),f=Jz,m=()=>(f(),f=aB(x,(t=>n(9,o=t))),x),g=Jz,y=()=>(g(),g=aB(v,(t=>n(10,a=t))),v);t.$$.on_destroy.push((()=>l())),t.$$.on_destroy.push((()=>u())),t.$$.on_destroy.push((()=>d())),t.$$.on_destroy.push((()=>f())),t.$$.on_destroy.push((()=>g()));let{title:b}=e,{text:v}=e;y();let{pressed:x}=e;m();let{loading:w}=e;c();let{disabled:S}=e;h();let{type:k}=e;return p(),t.$$set=t=>{"title"in t&&n(0,b=t.title),"text"in t&&y(n(1,v=t.text)),"pressed"in t&&m(n(2,x=t.pressed)),"loading"in t&&c(n(3,w=t.loading)),"disabled"in t&&h(n(4,S=t.disabled)),"type"in t&&p(n(5,k=t.type))},[b,v,x,w,S,k,i,r,s,o,a,function(t){o=t,x.set(o)},function(e){sU.call(this,t,e)}]}nit=new WeakMap;class vit extends UU{constructor(t){super(),BU(this,t,bit,yit,rB,{title:0,text:1,pressed:2,loading:3,disabled:4,type:5})}}class xit extends xK{constructor(t="click me"){super(),this.title="button",this.$click=new eK(Yj()),this.$pressed=new eK(!1,!0),this.$loading=new eK(!1,!0),this.$disabled=new eK(!1,!0),this.$type=new eK("default",!0),this.$text=new eK(t,!0),this.start(),this.$loading.skip(1).subscribe((t=>{this.$disabled.set(t)}))}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new vit({target:e,props:{title:this.title,text:this.$text,pressed:this.$pressed,loading:this.$loading,disabled:this.$disabled,type:this.$type}}),this.$$.app.$on("click",this.$click.set))}}function wit(...t){return new xit(...t)}var Sit={exports:{}};!function(t,e,n){const i={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class r{constructor(t,e){this.modelPath=e||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(t)}/model.json`}getPrefix(t){return"lite_mobilenet_v2"===t?`ssd${t}`:`ssd_${t}`}async load(){this.model=await e.loadGraphModel(this.modelPath);const t=n.zeros([1,300,300,3],"int32"),i=await this.model.executeAsync(t);await Promise.all(i.map((t=>t.data()))),i.map((t=>t.dispose())),t.dispose()}async infer(t,e,i){const r=n.tidy((()=>(t instanceof n.Tensor||(t=n.browser.fromPixels(t)),n.expandDims(t)))),s=r.shape[1],o=r.shape[2],a=await this.model.executeAsync(r),l=a[0].dataSync(),c=a[1].dataSync();r.dispose(),n.dispose(a);const[u,h]=this.calculateMaxScores(l,a[0].shape[1],a[0].shape[2]),d=n.getBackend();"webgl"===n.getBackend()&&n.setBackend("cpu");const p=n.tidy((()=>{const t=n.tensor2d(c,[a[1].shape[1],a[1].shape[3]]);return n.image.nonMaxSuppression(t,u,e,i,i)})),f=p.dataSync();return p.dispose(),d!==n.getBackend()&&n.setBackend(d),this.buildDetectedObjects(o,s,c,u,f,h)}buildDetectedObjects(t,e,n,r,s,o){const a=s.length,l=[];for(let c=0;c<a;c++){const a=[];for(let t=0;t<4;t++)a[t]=n[4*s[c]+t];const u=a[0]*e,h=a[1]*t,d=a[2]*e,p=a[3]*t;a[0]=h,a[1]=u,a[2]=p-h,a[3]=d-u,l.push({bbox:a,class:i[o[s[c]]+1].displayName,score:r[s[c]]})}return l}calculateMaxScores(t,e,n){const i=[],r=[];for(let s=0;s<e;s++){let e=Number.MIN_VALUE,o=-1;for(let i=0;i<n;i++)t[s*n+i]>e&&(e=t[s*n+i],o=i);i[s]=e,r[s]=o}return[i,r]}async detect(t,e=20,n=.5){return this.infer(t,e,n)}dispose(){null!=this.model&&this.model.dispose()}}t.ObjectDetection=r,t.load=async function(t={}){if(null==n)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const e=t.base||"lite_mobilenet_v2",i=t.modelUrl;if(-1===["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(e))throw new Error(`ObjectDetection constructed with invalid base model ${e}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const s=new r(e,i);return await s.load(),s},t.version="2.2.3",Object.defineProperty(t,"__esModule",{value:!0})}(Sit.exports,Ei(T4),Ei(pm));var kit,Cit,Tit=Sit.exports;function _it(t){let e,n;return{c(){e=IB("COCO-SSD loaded with base "),n=IB(t[2])},m(t,i){TB(t,e,i),TB(t,n,i)},p(t,e){4&e&&DB(n,t[2])},d(t){t&&_B(e),t&&_B(n)}}}function Eit(t){let e;return{c(){e=IB("")},m(t,n){TB(t,e,n)},p:Jz,d(t){t&&_B(e)}}}function Mit(t){let e;function n(t,e){return t[3]?Eit:_it}let i=n(t),r=i(t);return{c(){e=MB("p"),r.c(),OB(e,"class","p-2 text-sm text-gray-600")},m(t,n){TB(t,e,n),r.m(e,null)},p(t,s){i===(i=n(t))&&r?r.p(t,s):(r.d(1),r=i(t),r&&(r.c(),r.m(e,null)))},d(t){t&&_B(e),r.d()}}}function $it(t){let e,n;return e=new DH({props:{title:t[0],loading:t[3],$$slots:{default:[Mit]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),8&n&&(i.loading=t[3]),28&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function Iit(t,e,n){let i,r=Jz,s=()=>(r(),r=aB(a,(t=>n(3,i=t))),a);t.$$.on_destroy.push((()=>r()));let{title:o}=e,{loading:a}=e;s();let{base:l}=e;return t.$$set=t=>{"title"in t&&n(0,o=t.title),"loading"in t&&s(n(1,a=t.loading)),"base"in t&&n(2,l=t.base)},[o,a,l,i]}class Ait extends UU{constructor(t){super(),BU(this,t,Iit,$it,rB,{title:0,loading:1,base:2})}}class Nit extends i3{constructor({base:t="lite_mobilenet_v2"}={}){super(),this.title="COCO-SSD Object Detection",this.parameters={},this.serviceName="undefined",kit.set(this,void 0),Cit.set(this,void 0),this.$loading=new eK(!0,!0),WX(this,Cit,t,"f"),this.setup()}async setup(){await Eo();const t=await ho(),e=Object.keys(t).filter((t=>t.includes("cocossd")));try{WX(this,kit,await Tit.load({base:VX(this,Cit,"f"),modelUrl:`indexeddb://cocossd-${VX(this,Cit,"f")}`}),"f")}catch(t){e.length>0&&await po(e[0]),WX(this,kit,await Tit.load({base:VX(this,Cit,"f")}),"f"),await VX(this,kit,"f").model.save(`indexeddb://cocossd-${VX(this,Cit,"f")}`)}sK.info("COCO-SSD loaded with base `lite_mobilenet_v2`"),this.$loading.set(!1),this.start()}train(){throw new lK("Model `CocoSsd` cannot be trained")}async predict(t){if(!VX(this,kit,"f"))throw new Error("Model is not loaded");const e=(await VX(this,kit,"f").detect(t)).map((t=>({bbox:t.bbox,class:t.class,confidence:t.score})));return{outputs:e}}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new Ait({target:e,props:{title:this.title,loading:this.$loading,base:VX(this,Cit,"f")}}))}save(){throw new Error("CocoSsd does not support saving")}load(){throw new Error("CocoSsd does not support loading")}download(){throw new Error("CocoSsd does not support downloading")}upload(){throw new Error("CocoSsd does not support uploading")}}function Rit(...t){return new Nit(...t)}
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */function Pit(t){return t+.5|0}kit=new WeakMap,Cit=new WeakMap,UX([aK],Nit.prototype,"train",null),UX([aK],Nit.prototype,"predict",null),UX([aK],Nit.prototype,"save",null),UX([aK],Nit.prototype,"load",null),UX([aK],Nit.prototype,"download",null),UX([aK],Nit.prototype,"upload",null);const Oit=(t,e,n)=>Math.max(Math.min(t,n),e);function Lit(t){return Oit(Pit(2.55*t),0,255)}function Dit(t){return Oit(Pit(255*t),0,255)}function Fit(t){return Oit(Pit(t/2.55)/100,0,1)}function zit(t){return Oit(Pit(100*t),0,100)}const Bit={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},Uit=[..."0123456789ABCDEF"],Vit=t=>Uit[15&t],Wit=t=>Uit[(240&t)>>4]+Uit[15&t],Hit=t=>(240&t)>>4==(15&t);function jit(t){var e=(t=>Hit(t.r)&&Hit(t.g)&&Hit(t.b)&&Hit(t.a))(t)?Vit:Wit;return t?"#"+e(t.r)+e(t.g)+e(t.b)+((t,e)=>t<255?e(t):"")(t.a,e):void 0}const Git=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function qit(t,e,n){const i=e*Math.min(n,1-n),r=(e,r=(e+t/30)%12)=>n-i*Math.max(Math.min(r-3,9-r,1),-1);return[r(0),r(8),r(4)]}function Xit(t,e,n){const i=(i,r=(i+t/60)%6)=>n-n*e*Math.max(Math.min(r,4-r,1),0);return[i(5),i(3),i(1)]}function Kit(t,e,n){const i=qit(t,1,.5);let r;for(e+n>1&&(r=1/(e+n),e*=r,n*=r),r=0;r<3;r++)i[r]*=1-e-n,i[r]+=e;return i}function Yit(t){const e=t.r/255,n=t.g/255,i=t.b/255,r=Math.max(e,n,i),s=Math.min(e,n,i),o=(r+s)/2;let a,l,c;return r!==s&&(c=r-s,l=o>.5?c/(2-r-s):c/(r+s),a=function(t,e,n,i,r){return t===r?(e-n)/i+(e<n?6:0):e===r?(n-t)/i+2:(t-e)/i+4}(e,n,i,c,r),a=60*a+.5),[0|a,l||0,o]}function Zit(t,e,n,i){return(Array.isArray(e)?t(e[0],e[1],e[2]):t(e,n,i)).map(Dit)}function Jit(t,e,n){return Zit(qit,t,e,n)}function Qit(t){return(t%360+360)%360}function trt(t){const e=Git.exec(t);let n,i=255;if(!e)return;e[5]!==n&&(i=e[6]?Lit(+e[5]):Dit(+e[5]));const r=Qit(+e[2]),s=+e[3]/100,o=+e[4]/100;return n="hwb"===e[1]?function(t,e,n){return Zit(Kit,t,e,n)}(r,s,o):"hsv"===e[1]?function(t,e,n){return Zit(Xit,t,e,n)}(r,s,o):Jit(r,s,o),{r:n[0],g:n[1],b:n[2],a:i}}const ert={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},nrt={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};let irt;function rrt(t){irt||(irt=function(){const t={},e=Object.keys(nrt),n=Object.keys(ert);let i,r,s,o,a;for(i=0;i<e.length;i++){for(o=a=e[i],r=0;r<n.length;r++)s=n[r],a=a.replace(s,ert[s]);s=parseInt(nrt[o],16),t[a]=[s>>16&255,s>>8&255,255&s]}return t}(),irt.transparent=[0,0,0,0]);const e=irt[t.toLowerCase()];return e&&{r:e[0],g:e[1],b:e[2],a:4===e.length?e[3]:255}}const srt=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;const art=t=>t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055,lrt=t=>t<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4);function crt(t,e,n){if(t){let i=Yit(t);i[e]=Math.max(0,Math.min(i[e]+i[e]*n,0===e?360:1)),i=Jit(i),t.r=i[0],t.g=i[1],t.b=i[2]}}function urt(t,e){return t?Object.assign(e||{},t):t}function hrt(t){var e={r:0,g:0,b:0,a:255};return Array.isArray(t)?t.length>=3&&(e={r:t[0],g:t[1],b:t[2],a:255},t.length>3&&(e.a=Dit(t[3]))):(e=urt(t,{r:0,g:0,b:0,a:1})).a=Dit(e.a),e}function drt(t){return"r"===t.charAt(0)?function(t){const e=srt.exec(t);let n,i,r,s=255;if(e){if(e[7]!==n){const t=+e[7];s=e[8]?Lit(t):Oit(255*t,0,255)}return n=+e[1],i=+e[3],r=+e[5],n=255&(e[2]?Lit(n):Oit(n,0,255)),i=255&(e[4]?Lit(i):Oit(i,0,255)),r=255&(e[6]?Lit(r):Oit(r,0,255)),{r:n,g:i,b:r,a:s}}}(t):trt(t)}let prt=class t{constructor(e){if(e instanceof t)return e;const n=typeof e;let i;var r,s,o;"object"===n?i=hrt(e):"string"===n&&(o=(r=e).length,"#"===r[0]&&(4===o||5===o?s={r:255&17*Bit[r[1]],g:255&17*Bit[r[2]],b:255&17*Bit[r[3]],a:5===o?17*Bit[r[4]]:255}:7!==o&&9!==o||(s={r:Bit[r[1]]<<4|Bit[r[2]],g:Bit[r[3]]<<4|Bit[r[4]],b:Bit[r[5]]<<4|Bit[r[6]],a:9===o?Bit[r[7]]<<4|Bit[r[8]]:255})),i=s||rrt(e)||drt(e)),this._rgb=i,this._valid=!!i}get valid(){return this._valid}get rgb(){var t=urt(this._rgb);return t&&(t.a=Fit(t.a)),t}set rgb(t){this._rgb=hrt(t)}rgbString(){return this._valid?function(t){return t&&(t.a<255?`rgba(${t.r}, ${t.g}, ${t.b}, ${Fit(t.a)})`:`rgb(${t.r}, ${t.g}, ${t.b})`)}(this._rgb):void 0}hexString(){return this._valid?jit(this._rgb):void 0}hslString(){return this._valid?function(t){if(!t)return;const e=Yit(t),n=e[0],i=zit(e[1]),r=zit(e[2]);return t.a<255?`hsla(${n}, ${i}%, ${r}%, ${Fit(t.a)})`:`hsl(${n}, ${i}%, ${r}%)`}(this._rgb):void 0}mix(t,e){if(t){const n=this.rgb,i=t.rgb;let r;const s=e===r?.5:e,o=2*s-1,a=n.a-i.a,l=((o*a==-1?o:(o+a)/(1+o*a))+1)/2;r=1-l,n.r=255&l*n.r+r*i.r+.5,n.g=255&l*n.g+r*i.g+.5,n.b=255&l*n.b+r*i.b+.5,n.a=s*n.a+(1-s)*i.a,this.rgb=n}return this}interpolate(t,e){return t&&(this._rgb=function(t,e,n){const i=lrt(Fit(t.r)),r=lrt(Fit(t.g)),s=lrt(Fit(t.b));return{r:Dit(art(i+n*(lrt(Fit(e.r))-i))),g:Dit(art(r+n*(lrt(Fit(e.g))-r))),b:Dit(art(s+n*(lrt(Fit(e.b))-s))),a:t.a+n*(e.a-t.a)}}(this._rgb,t._rgb,e)),this}clone(){return new t(this.rgb)}alpha(t){return this._rgb.a=Dit(t),this}clearer(t){return this._rgb.a*=1-t,this}greyscale(){const t=this._rgb,e=Pit(.3*t.r+.59*t.g+.11*t.b);return t.r=t.g=t.b=e,this}opaquer(t){return this._rgb.a*=1+t,this}negate(){const t=this._rgb;return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}lighten(t){return crt(this._rgb,2,t),this}darken(t){return crt(this._rgb,2,-t),this}saturate(t){return crt(this._rgb,1,t),this}desaturate(t){return crt(this._rgb,1,-t),this}rotate(t){return function(t,e){var n=Yit(t);n[0]=Qit(n[0]+e),n=Jit(n),t.r=n[0],t.g=n[1],t.b=n[2]}(this._rgb,t),this}};
/*!
 * Chart.js v4.4.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
function frt(){}const mrt=(()=>{let t=0;return()=>t++})();function grt(t){return null==t}function yrt(t){if(Array.isArray&&Array.isArray(t))return!0;const e=Object.prototype.toString.call(t);return"[object"===e.slice(0,7)&&"Array]"===e.slice(-6)}function brt(t){return null!==t&&"[object Object]"===Object.prototype.toString.call(t)}function vrt(t){return("number"==typeof t||t instanceof Number)&&isFinite(+t)}function xrt(t,e){return vrt(t)?t:e}function wrt(t,e){return void 0===t?e:t}const Srt=(t,e)=>"string"==typeof t&&t.endsWith("%")?parseFloat(t)/100*e:+t;function krt(t,e,n){if(t&&"function"==typeof t.call)return t.apply(n,e)}function Crt(t,e,n,i){let r,s,o;if(yrt(t))if(s=t.length,i)for(r=s-1;r>=0;r--)e.call(n,t[r],r);else for(r=0;r<s;r++)e.call(n,t[r],r);else if(brt(t))for(o=Object.keys(t),s=o.length,r=0;r<s;r++)e.call(n,t[o[r]],o[r])}function Trt(t,e){let n,i,r,s;if(!t||!e||t.length!==e.length)return!1;for(n=0,i=t.length;n<i;++n)if(r=t[n],s=e[n],r.datasetIndex!==s.datasetIndex||r.index!==s.index)return!1;return!0}function _rt(t){if(yrt(t))return t.map(_rt);if(brt(t)){const e=Object.create(null),n=Object.keys(t),i=n.length;let r=0;for(;r<i;++r)e[n[r]]=_rt(t[n[r]]);return e}return t}function Ert(t){return-1===["__proto__","prototype","constructor"].indexOf(t)}function Mrt(t,e,n,i){if(!Ert(t))return;const r=e[t],s=n[t];brt(r)&&brt(s)?$rt(r,s,i):e[t]=_rt(s)}function $rt(t,e,n){const i=yrt(e)?e:[e],r=i.length;if(!brt(t))return t;const s=(n=n||{}).merger||Mrt;let o;for(let e=0;e<r;++e){if(o=i[e],!brt(o))continue;const r=Object.keys(o);for(let e=0,i=r.length;e<i;++e)s(r[e],t,o,n)}return t}function Irt(t,e){return $rt(t,e,{merger:Art})}function Art(t,e,n){if(!Ert(t))return;const i=e[t],r=n[t];brt(i)&&brt(r)?Irt(i,r):Object.prototype.hasOwnProperty.call(e,t)||(e[t]=_rt(r))}const Nrt={"":t=>t,x:t=>t.x,y:t=>t.y};function Rrt(t,e){const n=Nrt[e]||(Nrt[e]=function(t){const e=function(t){const e=t.split("."),n=[];let i="";for(const t of e)i+=t,i.endsWith("\\")?i=i.slice(0,-1)+".":(n.push(i),i="");return n}(t);return t=>{for(const n of e){if(""===n)break;t=t&&t[n]}return t}}(e));return n(t)}function Prt(t){return t.charAt(0).toUpperCase()+t.slice(1)}const Ort=t=>void 0!==t,Lrt=t=>"function"==typeof t,Drt=(t,e)=>{if(t.size!==e.size)return!1;for(const n of t)if(!e.has(n))return!1;return!0};const Frt=Math.PI,zrt=2*Frt,Brt=zrt+Frt,Urt=Number.POSITIVE_INFINITY,Vrt=Frt/180,Wrt=Frt/2,Hrt=Frt/4,jrt=2*Frt/3,Grt=Math.log10,qrt=Math.sign;function Xrt(t,e,n){return Math.abs(t-e)<n}function Krt(t){const e=Math.round(t);t=Xrt(t,e,t/1e3)?e:t;const n=Math.pow(10,Math.floor(Grt(t))),i=t/n;return(i<=1?1:i<=2?2:i<=5?5:10)*n}function Yrt(t){return!isNaN(parseFloat(t))&&isFinite(t)}function Zrt(t,e,n){let i,r,s;for(i=0,r=t.length;i<r;i++)s=t[i][n],isNaN(s)||(e.min=Math.min(e.min,s),e.max=Math.max(e.max,s))}function Jrt(t){return t*(Frt/180)}function Qrt(t){return t*(180/Frt)}function tst(t){if(!vrt(t))return;let e=1,n=0;for(;Math.round(t*e)/e!==t;)e*=10,n++;return n}function est(t,e){const n=e.x-t.x,i=e.y-t.y,r=Math.sqrt(n*n+i*i);let s=Math.atan2(i,n);return s<-.5*Frt&&(s+=zrt),{angle:s,distance:r}}function nst(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}function ist(t,e){return(t-e+Brt)%zrt-Frt}function rst(t){return(t%zrt+zrt)%zrt}function sst(t,e,n,i){const r=rst(t),s=rst(e),o=rst(n),a=rst(s-r),l=rst(o-r),c=rst(r-s),u=rst(r-o);return r===s||r===o||i&&s===o||a>l&&c<u}function ost(t,e,n){return Math.max(e,Math.min(n,t))}function ast(t,e,n,i=1e-6){return t>=Math.min(e,n)-i&&t<=Math.max(e,n)+i}function lst(t,e,n){n=n||(n=>t[n]<e);let i,r=t.length-1,s=0;for(;r-s>1;)i=s+r>>1,n(i)?s=i:r=i;return{lo:s,hi:r}}const cst=(t,e,n,i)=>lst(t,n,i?i=>{const r=t[i][e];return r<n||r===n&&t[i+1][e]===n}:i=>t[i][e]<n),ust=(t,e,n)=>lst(t,n,(i=>t[i][e]>=n));const hst=["push","pop","shift","splice","unshift"];function dst(t,e){const n=t._chartjs;if(!n)return;const i=n.listeners,r=i.indexOf(e);-1!==r&&i.splice(r,1),i.length>0||(hst.forEach((e=>{delete t[e]})),delete t._chartjs)}function pst(t){const e=new Set(t);return e.size===t.length?t:Array.from(e)}const fst="undefined"==typeof window?function(t){return t()}:window.requestAnimationFrame;function mst(t,e){let n=[],i=!1;return function(...r){n=r,i||(i=!0,fst.call(window,(()=>{i=!1,t.apply(e,n)})))}}const gst=t=>"start"===t?"left":"end"===t?"right":"center",yst=(t,e,n)=>"start"===t?e:"end"===t?n:(e+n)/2;function bst(t,e,n){const i=e.length;let r=0,s=i;if(t._sorted){const{iScale:o,_parsed:a}=t,l=o.axis,{min:c,max:u,minDefined:h,maxDefined:d}=o.getUserBounds();h&&(r=ost(Math.min(cst(a,l,c).lo,n?i:cst(e,l,o.getPixelForValue(c)).lo),0,i-1)),s=d?ost(Math.max(cst(a,o.axis,u,!0).hi+1,n?0:cst(e,l,o.getPixelForValue(u),!0).hi+1),r,i)-r:i-r}return{start:r,count:s}}function vst(t){const{xScale:e,yScale:n,_scaleRanges:i}=t,r={xmin:e.min,xmax:e.max,ymin:n.min,ymax:n.max};if(!i)return t._scaleRanges=r,!0;const s=i.xmin!==e.min||i.xmax!==e.max||i.ymin!==n.min||i.ymax!==n.max;return Object.assign(i,r),s}const xst=t=>0===t||1===t,wst=(t,e,n)=>-Math.pow(2,10*(t-=1))*Math.sin((t-e)*zrt/n),Sst=(t,e,n)=>Math.pow(2,-10*t)*Math.sin((t-e)*zrt/n)+1,kst={linear:t=>t,easeInQuad:t=>t*t,easeOutQuad:t=>-t*(t-2),easeInOutQuad:t=>(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1),easeInCubic:t=>t*t*t,easeOutCubic:t=>(t-=1)*t*t+1,easeInOutCubic:t=>(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2),easeInQuart:t=>t*t*t*t,easeOutQuart:t=>-((t-=1)*t*t*t-1),easeInOutQuart:t=>(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2),easeInQuint:t=>t*t*t*t*t,easeOutQuint:t=>(t-=1)*t*t*t*t+1,easeInOutQuint:t=>(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2),easeInSine:t=>1-Math.cos(t*Wrt),easeOutSine:t=>Math.sin(t*Wrt),easeInOutSine:t=>-.5*(Math.cos(Frt*t)-1),easeInExpo:t=>0===t?0:Math.pow(2,10*(t-1)),easeOutExpo:t=>1===t?1:1-Math.pow(2,-10*t),easeInOutExpo:t=>xst(t)?t:t<.5?.5*Math.pow(2,10*(2*t-1)):.5*(2-Math.pow(2,-10*(2*t-1))),easeInCirc:t=>t>=1?t:-(Math.sqrt(1-t*t)-1),easeOutCirc:t=>Math.sqrt(1-(t-=1)*t),easeInOutCirc:t=>(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1),easeInElastic:t=>xst(t)?t:wst(t,.075,.3),easeOutElastic:t=>xst(t)?t:Sst(t,.075,.3),easeInOutElastic(t){const e=.1125;return xst(t)?t:t<.5?.5*wst(2*t,e,.45):.5+.5*Sst(2*t-1,e,.45)},easeInBack(t){const e=1.70158;return t*t*((e+1)*t-e)},easeOutBack(t){const e=1.70158;return(t-=1)*t*((e+1)*t+e)+1},easeInOutBack(t){let e=1.70158;return(t/=.5)<1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)},easeInBounce:t=>1-kst.easeOutBounce(1-t),easeOutBounce(t){const e=7.5625,n=2.75;return t<1/n?e*t*t:t<2/n?e*(t-=1.5/n)*t+.75:t<2.5/n?e*(t-=2.25/n)*t+.9375:e*(t-=2.625/n)*t+.984375},easeInOutBounce:t=>t<.5?.5*kst.easeInBounce(2*t):.5*kst.easeOutBounce(2*t-1)+.5};function Cst(t){if(t&&"object"==typeof t){const e=t.toString();return"[object CanvasPattern]"===e||"[object CanvasGradient]"===e}return!1}function Tst(t){return Cst(t)?t:new prt(t)}function _st(t){return Cst(t)?t:new prt(t).saturate(.5).darken(.1).hexString()}const Est=["x","y","borderWidth","radius","tension"],Mst=["color","borderColor","backgroundColor"];const $st=new Map;function Ist(t,e,n){return function(t,e){e=e||{};const n=t+JSON.stringify(e);let i=$st.get(n);return i||(i=new Intl.NumberFormat(t,e),$st.set(n,i)),i}(e,n).format(t)}const Ast={values:t=>yrt(t)?t:""+t,numeric(t,e,n){if(0===t)return"0";const i=this.chart.options.locale;let r,s=t;if(n.length>1){const e=Math.max(Math.abs(n[0].value),Math.abs(n[n.length-1].value));(e<1e-4||e>1e15)&&(r="scientific"),s=function(t,e){let n=e.length>3?e[2].value-e[1].value:e[1].value-e[0].value;Math.abs(n)>=1&&t!==Math.floor(t)&&(n=t-Math.floor(t));return n}(t,n)}const o=Grt(Math.abs(s)),a=isNaN(o)?1:Math.max(Math.min(-1*Math.floor(o),20),0),l={notation:r,minimumFractionDigits:a,maximumFractionDigits:a};return Object.assign(l,this.options.ticks.format),Ist(t,i,l)},logarithmic(t,e,n){if(0===t)return"0";const i=n[e].significand||t/Math.pow(10,Math.floor(Grt(t)));return[1,2,3,5,10,15].includes(i)||e>.8*n.length?Ast.numeric.call(this,t,e,n):""}};var Nst={formatters:Ast};const Rst=Object.create(null),Pst=Object.create(null);function Ost(t,e){if(!e)return t;const n=e.split(".");for(let e=0,i=n.length;e<i;++e){const i=n[e];t=t[i]||(t[i]=Object.create(null))}return t}function Lst(t,e,n){return"string"==typeof e?$rt(Ost(t,e),n):$rt(Ost(t,""),e)}class Dst{constructor(t,e){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=t=>t.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(t,e)=>_st(e.backgroundColor),this.hoverBorderColor=(t,e)=>_st(e.borderColor),this.hoverColor=(t,e)=>_st(e.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t),this.apply(e)}set(t,e){return Lst(this,t,e)}get(t){return Ost(this,t)}describe(t,e){return Lst(Pst,t,e)}override(t,e){return Lst(Rst,t,e)}route(t,e,n,i){const r=Ost(this,t),s=Ost(this,n),o="_"+e;Object.defineProperties(r,{[o]:{value:r[e],writable:!0},[e]:{enumerable:!0,get(){const t=this[o],e=s[i];return brt(t)?Object.assign({},e,t):wrt(t,e)},set(t){this[o]=t}}})}apply(t){t.forEach((t=>t(this)))}}var Fst=new Dst({_scriptable:t=>!t.startsWith("on"),_indexable:t=>"events"!==t,hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[function(t){t.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),t.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:t=>"onProgress"!==t&&"onComplete"!==t&&"fn"!==t}),t.set("animations",{colors:{type:"color",properties:Mst},numbers:{type:"number",properties:Est}}),t.describe("animations",{_fallback:"animation"}),t.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:t=>0|t}}}})},function(t){t.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})},function(t){t.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",clip:!0,grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(t,e)=>e.lineWidth,tickColor:(t,e)=>e.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:Nst.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),t.route("scale.ticks","color","","color"),t.route("scale.grid","color","","borderColor"),t.route("scale.border","color","","borderColor"),t.route("scale.title","color","","color"),t.describe("scale",{_fallback:!1,_scriptable:t=>!t.startsWith("before")&&!t.startsWith("after")&&"callback"!==t&&"parser"!==t,_indexable:t=>"borderDash"!==t&&"tickBorderDash"!==t&&"dash"!==t}),t.describe("scales",{_fallback:"scale"}),t.describe("scale.ticks",{_scriptable:t=>"backdropPadding"!==t&&"callback"!==t,_indexable:t=>"backdropPadding"!==t})}]);function zst(t,e,n,i,r){let s=e[r];return s||(s=e[r]=t.measureText(r).width,n.push(r)),s>i&&(i=s),i}function Bst(t,e,n,i){let r=(i=i||{}).data=i.data||{},s=i.garbageCollect=i.garbageCollect||[];i.font!==e&&(r=i.data={},s=i.garbageCollect=[],i.font=e),t.save(),t.font=e;let o=0;const a=n.length;let l,c,u,h,d;for(l=0;l<a;l++)if(h=n[l],null==h||yrt(h)){if(yrt(h))for(c=0,u=h.length;c<u;c++)d=h[c],null==d||yrt(d)||(o=zst(t,r,s,o,d))}else o=zst(t,r,s,o,h);t.restore();const p=s.length/2;if(p>n.length){for(l=0;l<p;l++)delete r[s[l]];s.splice(0,p)}return o}function Ust(t,e,n){const i=t.currentDevicePixelRatio,r=0!==n?Math.max(n/2,.5):0;return Math.round((e-r)*i)/i+r}function Vst(t,e){(e=e||t.getContext("2d")).save(),e.resetTransform(),e.clearRect(0,0,t.width,t.height),e.restore()}function Wst(t,e,n,i){Hst(t,e,n,i,null)}function Hst(t,e,n,i,r){let s,o,a,l,c,u,h,d;const p=e.pointStyle,f=e.rotation,m=e.radius;let g=(f||0)*Vrt;if(p&&"object"==typeof p&&(s=p.toString(),"[object HTMLImageElement]"===s||"[object HTMLCanvasElement]"===s))return t.save(),t.translate(n,i),t.rotate(g),t.drawImage(p,-p.width/2,-p.height/2,p.width,p.height),void t.restore();if(!(isNaN(m)||m<=0)){switch(t.beginPath(),p){default:r?t.ellipse(n,i,r/2,m,0,0,zrt):t.arc(n,i,m,0,zrt),t.closePath();break;case"triangle":u=r?r/2:m,t.moveTo(n+Math.sin(g)*u,i-Math.cos(g)*m),g+=jrt,t.lineTo(n+Math.sin(g)*u,i-Math.cos(g)*m),g+=jrt,t.lineTo(n+Math.sin(g)*u,i-Math.cos(g)*m),t.closePath();break;case"rectRounded":c=.516*m,l=m-c,o=Math.cos(g+Hrt)*l,h=Math.cos(g+Hrt)*(r?r/2-c:l),a=Math.sin(g+Hrt)*l,d=Math.sin(g+Hrt)*(r?r/2-c:l),t.arc(n-h,i-a,c,g-Frt,g-Wrt),t.arc(n+d,i-o,c,g-Wrt,g),t.arc(n+h,i+a,c,g,g+Wrt),t.arc(n-d,i+o,c,g+Wrt,g+Frt),t.closePath();break;case"rect":if(!f){l=Math.SQRT1_2*m,u=r?r/2:l,t.rect(n-u,i-l,2*u,2*l);break}g+=Hrt;case"rectRot":h=Math.cos(g)*(r?r/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,d=Math.sin(g)*(r?r/2:m),t.moveTo(n-h,i-a),t.lineTo(n+d,i-o),t.lineTo(n+h,i+a),t.lineTo(n-d,i+o),t.closePath();break;case"crossRot":g+=Hrt;case"cross":h=Math.cos(g)*(r?r/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,d=Math.sin(g)*(r?r/2:m),t.moveTo(n-h,i-a),t.lineTo(n+h,i+a),t.moveTo(n+d,i-o),t.lineTo(n-d,i+o);break;case"star":h=Math.cos(g)*(r?r/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,d=Math.sin(g)*(r?r/2:m),t.moveTo(n-h,i-a),t.lineTo(n+h,i+a),t.moveTo(n+d,i-o),t.lineTo(n-d,i+o),g+=Hrt,h=Math.cos(g)*(r?r/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,d=Math.sin(g)*(r?r/2:m),t.moveTo(n-h,i-a),t.lineTo(n+h,i+a),t.moveTo(n+d,i-o),t.lineTo(n-d,i+o);break;case"line":o=r?r/2:Math.cos(g)*m,a=Math.sin(g)*m,t.moveTo(n-o,i-a),t.lineTo(n+o,i+a);break;case"dash":t.moveTo(n,i),t.lineTo(n+Math.cos(g)*(r?r/2:m),i+Math.sin(g)*m);break;case!1:t.closePath()}t.fill(),e.borderWidth>0&&t.stroke()}}function jst(t,e,n){return n=n||.5,!e||t&&t.x>e.left-n&&t.x<e.right+n&&t.y>e.top-n&&t.y<e.bottom+n}function Gst(t,e){t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()}function qst(t){t.restore()}function Xst(t,e,n,i,r){if(!e)return t.lineTo(n.x,n.y);if("middle"===r){const i=(e.x+n.x)/2;t.lineTo(i,e.y),t.lineTo(i,n.y)}else"after"===r!=!!i?t.lineTo(e.x,n.y):t.lineTo(n.x,e.y);t.lineTo(n.x,n.y)}function Kst(t,e,n,i){if(!e)return t.lineTo(n.x,n.y);t.bezierCurveTo(i?e.cp1x:e.cp2x,i?e.cp1y:e.cp2y,i?n.cp2x:n.cp1x,i?n.cp2y:n.cp1y,n.x,n.y)}function Yst(t,e,n,i,r){if(r.strikethrough||r.underline){const s=t.measureText(i),o=e-s.actualBoundingBoxLeft,a=e+s.actualBoundingBoxRight,l=n-s.actualBoundingBoxAscent,c=n+s.actualBoundingBoxDescent,u=r.strikethrough?(l+c)/2:c;t.strokeStyle=t.fillStyle,t.beginPath(),t.lineWidth=r.decorationWidth||2,t.moveTo(o,u),t.lineTo(a,u),t.stroke()}}function Zst(t,e){const n=t.fillStyle;t.fillStyle=e.color,t.fillRect(e.left,e.top,e.width,e.height),t.fillStyle=n}function Jst(t,e,n,i,r,s={}){const o=yrt(e)?e:[e],a=s.strokeWidth>0&&""!==s.strokeColor;let l,c;for(t.save(),t.font=r.string,function(t,e){e.translation&&t.translate(e.translation[0],e.translation[1]),grt(e.rotation)||t.rotate(e.rotation),e.color&&(t.fillStyle=e.color),e.textAlign&&(t.textAlign=e.textAlign),e.textBaseline&&(t.textBaseline=e.textBaseline)}(t,s),l=0;l<o.length;++l)c=o[l],s.backdrop&&Zst(t,s.backdrop),a&&(s.strokeColor&&(t.strokeStyle=s.strokeColor),grt(s.strokeWidth)||(t.lineWidth=s.strokeWidth),t.strokeText(c,n,i,s.maxWidth)),t.fillText(c,n,i,s.maxWidth),Yst(t,n,i,c,s),i+=Number(r.lineHeight);t.restore()}function Qst(t,e){const{x:n,y:i,w:r,h:s,radius:o}=e;t.arc(n+o.topLeft,i+o.topLeft,o.topLeft,1.5*Frt,Frt,!0),t.lineTo(n,i+s-o.bottomLeft),t.arc(n+o.bottomLeft,i+s-o.bottomLeft,o.bottomLeft,Frt,Wrt,!0),t.lineTo(n+r-o.bottomRight,i+s),t.arc(n+r-o.bottomRight,i+s-o.bottomRight,o.bottomRight,Wrt,0,!0),t.lineTo(n+r,i+o.topRight),t.arc(n+r-o.topRight,i+o.topRight,o.topRight,0,-Wrt,!0),t.lineTo(n+o.topLeft,i)}const tot=/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,eot=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function not(t,e){const n=(""+t).match(tot);if(!n||"normal"===n[1])return 1.2*e;switch(t=+n[2],n[3]){case"px":return t;case"%":t/=100}return e*t}const iot=t=>+t||0;function rot(t,e){const n={},i=brt(e),r=i?Object.keys(e):e,s=brt(t)?i?n=>wrt(t[n],t[e[n]]):e=>t[e]:()=>t;for(const t of r)n[t]=iot(s(t));return n}function sot(t){return rot(t,{top:"y",right:"x",bottom:"y",left:"x"})}function oot(t){return rot(t,["topLeft","topRight","bottomLeft","bottomRight"])}function aot(t){const e=sot(t);return e.width=e.left+e.right,e.height=e.top+e.bottom,e}function lot(t,e){t=t||{},e=e||Fst.font;let n=wrt(t.size,e.size);"string"==typeof n&&(n=parseInt(n,10));let i=wrt(t.style,e.style);i&&!(""+i).match(eot)&&(console.warn('Invalid font style specified: "'+i+'"'),i=void 0);const r={family:wrt(t.family,e.family),lineHeight:not(wrt(t.lineHeight,e.lineHeight),n),size:n,style:i,weight:wrt(t.weight,e.weight),string:""};return r.string=function(t){return!t||grt(t.size)||grt(t.family)?null:(t.style?t.style+" ":"")+(t.weight?t.weight+" ":"")+t.size+"px "+t.family}(r),r}function cot(t,e,n,i){let r,s,o,a=!0;for(r=0,s=t.length;r<s;++r)if(o=t[r],void 0!==o&&(void 0!==e&&"function"==typeof o&&(o=o(e),a=!1),void 0!==n&&yrt(o)&&(o=o[n%o.length],a=!1),void 0!==o))return i&&!a&&(i.cacheable=!1),o}function uot(t,e){return Object.assign(Object.create(t),e)}function hot(t,e=[""],n,i,r=(()=>t[0])){const s=n||t;void 0===i&&(i=Sot("_fallback",t));const o={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:t,_rootScopes:s,_fallback:i,_getTarget:r,override:n=>hot([n,...t],e,s,i)};return new Proxy(o,{deleteProperty:(e,n)=>(delete e[n],delete e._keys,delete t[0][n],!0),get:(n,i)=>got(n,i,(()=>function(t,e,n,i){let r;for(const s of e)if(r=Sot(fot(s,t),n),void 0!==r)return mot(t,r)?xot(n,i,t,r):r}(i,e,t,n))),getOwnPropertyDescriptor:(t,e)=>Reflect.getOwnPropertyDescriptor(t._scopes[0],e),getPrototypeOf:()=>Reflect.getPrototypeOf(t[0]),has:(t,e)=>kot(t).includes(e),ownKeys:t=>kot(t),set(t,e,n){const i=t._storage||(t._storage=r());return t[e]=i[e]=n,delete t._keys,!0}})}function dot(t,e,n,i){const r={_cacheable:!1,_proxy:t,_context:e,_subProxy:n,_stack:new Set,_descriptors:pot(t,i),setContext:e=>dot(t,e,n,i),override:r=>dot(t.override(r),e,n,i)};return new Proxy(r,{deleteProperty:(e,n)=>(delete e[n],delete t[n],!0),get:(t,e,n)=>got(t,e,(()=>function(t,e,n){const{_proxy:i,_context:r,_subProxy:s,_descriptors:o}=t;let a=i[e];Lrt(a)&&o.isScriptable(e)&&(a=function(t,e,n,i){const{_proxy:r,_context:s,_subProxy:o,_stack:a}=n;if(a.has(t))throw new Error("Recursion detected: "+Array.from(a).join("->")+"->"+t);a.add(t);let l=e(s,o||i);a.delete(t),mot(t,l)&&(l=xot(r._scopes,r,t,l));return l}(e,a,t,n));yrt(a)&&a.length&&(a=function(t,e,n,i){const{_proxy:r,_context:s,_subProxy:o,_descriptors:a}=n;if(void 0!==s.index&&i(t))return e[s.index%e.length];if(brt(e[0])){const n=e,i=r._scopes.filter((t=>t!==n));e=[];for(const l of n){const n=xot(i,r,t,l);e.push(dot(n,s,o&&o[t],a))}}return e}(e,a,t,o.isIndexable));mot(e,a)&&(a=dot(a,r,s&&s[e],o));return a}(t,e,n))),getOwnPropertyDescriptor:(e,n)=>e._descriptors.allKeys?Reflect.has(t,n)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(t,n),getPrototypeOf:()=>Reflect.getPrototypeOf(t),has:(e,n)=>Reflect.has(t,n),ownKeys:()=>Reflect.ownKeys(t),set:(e,n,i)=>(t[n]=i,delete e[n],!0)})}function pot(t,e={scriptable:!0,indexable:!0}){const{_scriptable:n=e.scriptable,_indexable:i=e.indexable,_allKeys:r=e.allKeys}=t;return{allKeys:r,scriptable:n,indexable:i,isScriptable:Lrt(n)?n:()=>n,isIndexable:Lrt(i)?i:()=>i}}const fot=(t,e)=>t?t+Prt(e):e,mot=(t,e)=>brt(e)&&"adapters"!==t&&(null===Object.getPrototypeOf(e)||e.constructor===Object);function got(t,e,n){if(Object.prototype.hasOwnProperty.call(t,e))return t[e];const i=n();return t[e]=i,i}function yot(t,e,n){return Lrt(t)?t(e,n):t}const bot=(t,e)=>!0===t?e:"string"==typeof t?Rrt(e,t):void 0;function vot(t,e,n,i,r){for(const s of e){const e=bot(n,s);if(e){t.add(e);const s=yot(e._fallback,n,r);if(void 0!==s&&s!==n&&s!==i)return s}else if(!1===e&&void 0!==i&&n!==i)return null}return!1}function xot(t,e,n,i){const r=e._rootScopes,s=yot(e._fallback,n,i),o=[...t,...r],a=new Set;a.add(i);let l=wot(a,o,n,s||n,i);return null!==l&&((void 0===s||s===n||(l=wot(a,o,s,l,i),null!==l))&&hot(Array.from(a),[""],r,s,(()=>function(t,e,n){const i=t._getTarget();e in i||(i[e]={});const r=i[e];if(yrt(r)&&brt(n))return n;return r||{}}(e,n,i))))}function wot(t,e,n,i,r){for(;n;)n=vot(t,e,n,i,r);return n}function Sot(t,e){for(const n of e){if(!n)continue;const e=n[t];if(void 0!==e)return e}}function kot(t){let e=t._keys;return e||(e=t._keys=function(t){const e=new Set;for(const n of t)for(const t of Object.keys(n).filter((t=>!t.startsWith("_"))))e.add(t);return Array.from(e)}(t._scopes)),e}function Cot(t,e,n,i){const{iScale:r}=t,{key:s="r"}=this._parsing,o=new Array(i);let a,l,c,u;for(a=0,l=i;a<l;++a)c=a+n,u=e[c],o[a]={r:r.parse(Rrt(u,s),c)};return o}const Tot=Number.EPSILON||1e-14,_ot=(t,e)=>e<t.length&&!t[e].skip&&t[e],Eot=t=>"x"===t?"y":"x";function Mot(t,e,n,i){const r=t.skip?e:t,s=e,o=n.skip?e:n,a=nst(s,r),l=nst(o,s);let c=a/(a+l),u=l/(a+l);c=isNaN(c)?0:c,u=isNaN(u)?0:u;const h=i*c,d=i*u;return{previous:{x:s.x-h*(o.x-r.x),y:s.y-h*(o.y-r.y)},next:{x:s.x+d*(o.x-r.x),y:s.y+d*(o.y-r.y)}}}function $ot(t,e="x"){const n=Eot(e),i=t.length,r=Array(i).fill(0),s=Array(i);let o,a,l,c=_ot(t,0);for(o=0;o<i;++o)if(a=l,l=c,c=_ot(t,o+1),l){if(c){const t=c[e]-l[e];r[o]=0!==t?(c[n]-l[n])/t:0}s[o]=a?c?qrt(r[o-1])!==qrt(r[o])?0:(r[o-1]+r[o])/2:r[o-1]:r[o]}!function(t,e,n){const i=t.length;let r,s,o,a,l,c=_ot(t,0);for(let u=0;u<i-1;++u)l=c,c=_ot(t,u+1),l&&c&&(Xrt(e[u],0,Tot)?n[u]=n[u+1]=0:(r=n[u]/e[u],s=n[u+1]/e[u],a=Math.pow(r,2)+Math.pow(s,2),a<=9||(o=3/Math.sqrt(a),n[u]=r*o*e[u],n[u+1]=s*o*e[u])))}(t,r,s),function(t,e,n="x"){const i=Eot(n),r=t.length;let s,o,a,l=_ot(t,0);for(let c=0;c<r;++c){if(o=a,a=l,l=_ot(t,c+1),!a)continue;const r=a[n],u=a[i];o&&(s=(r-o[n])/3,a[`cp1${n}`]=r-s,a[`cp1${i}`]=u-s*e[c]),l&&(s=(l[n]-r)/3,a[`cp2${n}`]=r+s,a[`cp2${i}`]=u+s*e[c])}}(t,s,e)}function Iot(t,e,n){return Math.max(Math.min(t,n),e)}function Aot(t,e,n,i,r){let s,o,a,l;if(e.spanGaps&&(t=t.filter((t=>!t.skip))),"monotone"===e.cubicInterpolationMode)$ot(t,r);else{let n=i?t[t.length-1]:t[0];for(s=0,o=t.length;s<o;++s)a=t[s],l=Mot(n,a,t[Math.min(s+1,o-(i?0:1))%o],e.tension),a.cp1x=l.previous.x,a.cp1y=l.previous.y,a.cp2x=l.next.x,a.cp2y=l.next.y,n=a}e.capBezierPoints&&function(t,e){let n,i,r,s,o,a=jst(t[0],e);for(n=0,i=t.length;n<i;++n)o=s,s=a,a=n<i-1&&jst(t[n+1],e),s&&(r=t[n],o&&(r.cp1x=Iot(r.cp1x,e.left,e.right),r.cp1y=Iot(r.cp1y,e.top,e.bottom)),a&&(r.cp2x=Iot(r.cp2x,e.left,e.right),r.cp2y=Iot(r.cp2y,e.top,e.bottom)))}(t,n)}function Not(){return"undefined"!=typeof window&&"undefined"!=typeof document}function Rot(t){let e=t.parentNode;return e&&"[object ShadowRoot]"===e.toString()&&(e=e.host),e}function Pot(t,e,n){let i;return"string"==typeof t?(i=parseInt(t,10),-1!==t.indexOf("%")&&(i=i/100*e.parentNode[n])):i=t,i}const Oot=t=>t.ownerDocument.defaultView.getComputedStyle(t,null);const Lot=["top","right","bottom","left"];function Dot(t,e,n){const i={};n=n?"-"+n:"";for(let r=0;r<4;r++){const s=Lot[r];i[s]=parseFloat(t[e+"-"+s+n])||0}return i.width=i.left+i.right,i.height=i.top+i.bottom,i}const Fot=(t,e,n)=>(t>0||e>0)&&(!n||!n.shadowRoot);function zot(t,e){if("native"in t)return t;const{canvas:n,currentDevicePixelRatio:i}=e,r=Oot(n),s="border-box"===r.boxSizing,o=Dot(r,"padding"),a=Dot(r,"border","width"),{x:l,y:c,box:u}=function(t,e){const n=t.touches,i=n&&n.length?n[0]:t,{offsetX:r,offsetY:s}=i;let o,a,l=!1;if(Fot(r,s,t.target))o=r,a=s;else{const t=e.getBoundingClientRect();o=i.clientX-t.left,a=i.clientY-t.top,l=!0}return{x:o,y:a,box:l}}(t,n),h=o.left+(u&&a.left),d=o.top+(u&&a.top);let{width:p,height:f}=e;return s&&(p-=o.width+a.width,f-=o.height+a.height),{x:Math.round((l-h)/p*n.width/i),y:Math.round((c-d)/f*n.height/i)}}const Bot=t=>Math.round(10*t)/10;function Uot(t,e,n,i){const r=Oot(t),s=Dot(r,"margin"),o=Pot(r.maxWidth,t,"clientWidth")||Urt,a=Pot(r.maxHeight,t,"clientHeight")||Urt,l=function(t,e,n){let i,r;if(void 0===e||void 0===n){const s=Rot(t);if(s){const t=s.getBoundingClientRect(),o=Oot(s),a=Dot(o,"border","width"),l=Dot(o,"padding");e=t.width-l.width-a.width,n=t.height-l.height-a.height,i=Pot(o.maxWidth,s,"clientWidth"),r=Pot(o.maxHeight,s,"clientHeight")}else e=t.clientWidth,n=t.clientHeight}return{width:e,height:n,maxWidth:i||Urt,maxHeight:r||Urt}}(t,e,n);let{width:c,height:u}=l;if("content-box"===r.boxSizing){const t=Dot(r,"border","width"),e=Dot(r,"padding");c-=e.width+t.width,u-=e.height+t.height}c=Math.max(0,c-s.width),u=Math.max(0,i?c/i:u-s.height),c=Bot(Math.min(c,o,l.maxWidth)),u=Bot(Math.min(u,a,l.maxHeight)),c&&!u&&(u=Bot(c/2));return(void 0!==e||void 0!==n)&&i&&l.height&&u>l.height&&(u=l.height,c=Bot(Math.floor(u*i))),{width:c,height:u}}function Vot(t,e,n){const i=e||1,r=Math.floor(t.height*i),s=Math.floor(t.width*i);t.height=Math.floor(t.height),t.width=Math.floor(t.width);const o=t.canvas;return o.style&&(n||!o.style.height&&!o.style.width)&&(o.style.height=`${t.height}px`,o.style.width=`${t.width}px`),(t.currentDevicePixelRatio!==i||o.height!==r||o.width!==s)&&(t.currentDevicePixelRatio=i,o.height=r,o.width=s,t.ctx.setTransform(i,0,0,i,0,0),!0)}const Wot=function(){let t=!1;try{const e={get passive(){return t=!0,!1}};window.addEventListener("test",null,e),window.removeEventListener("test",null,e)}catch(t){}return t}();function Hot(t,e){const n=function(t,e){return Oot(t).getPropertyValue(e)}(t,e),i=n&&n.match(/^(\d+)(\.\d+)?px$/);return i?+i[1]:void 0}function jot(t,e,n,i){return{x:t.x+n*(e.x-t.x),y:t.y+n*(e.y-t.y)}}function Got(t,e,n,i){return{x:t.x+n*(e.x-t.x),y:"middle"===i?n<.5?t.y:e.y:"after"===i?n<1?t.y:e.y:n>0?e.y:t.y}}function qot(t,e,n,i){const r={x:t.cp2x,y:t.cp2y},s={x:e.cp1x,y:e.cp1y},o=jot(t,r,n),a=jot(r,s,n),l=jot(s,e,n),c=jot(o,a,n),u=jot(a,l,n);return jot(c,u,n)}function Xot(t,e,n){return t?function(t,e){return{x:n=>t+t+e-n,setWidth(t){e=t},textAlign:t=>"center"===t?t:"right"===t?"left":"right",xPlus:(t,e)=>t-e,leftForLtr:(t,e)=>t-e}}(e,n):{x:t=>t,setWidth(t){},textAlign:t=>t,xPlus:(t,e)=>t+e,leftForLtr:(t,e)=>t}}function Kot(t,e){let n,i;"ltr"!==e&&"rtl"!==e||(n=t.canvas.style,i=[n.getPropertyValue("direction"),n.getPropertyPriority("direction")],n.setProperty("direction",e,"important"),t.prevTextDirection=i)}function Yot(t,e){void 0!==e&&(delete t.prevTextDirection,t.canvas.style.setProperty("direction",e[0],e[1]))}function Zot(t){return"angle"===t?{between:sst,compare:ist,normalize:rst}:{between:ast,compare:(t,e)=>t-e,normalize:t=>t}}function Jot({start:t,end:e,count:n,loop:i,style:r}){return{start:t%n,end:e%n,loop:i&&(e-t+1)%n==0,style:r}}function Qot(t,e,n){if(!n)return[t];const{property:i,start:r,end:s}=n,o=e.length,{compare:a,between:l,normalize:c}=Zot(i),{start:u,end:h,loop:d,style:p}=function(t,e,n){const{property:i,start:r,end:s}=n,{between:o,normalize:a}=Zot(i),l=e.length;let c,u,{start:h,end:d,loop:p}=t;if(p){for(h+=l,d+=l,c=0,u=l;c<u&&o(a(e[h%l][i]),r,s);++c)h--,d--;h%=l,d%=l}return d<h&&(d+=l),{start:h,end:d,loop:p,style:t.style}}(t,e,n),f=[];let m,g,y,b=!1,v=null;const x=()=>b||l(r,y,m)&&0!==a(r,y),w=()=>!b||0===a(s,m)||l(s,y,m);for(let t=u,n=u;t<=h;++t)g=e[t%o],g.skip||(m=c(g[i]),m!==y&&(b=l(m,r,s),null===v&&x()&&(v=0===a(m,r)?t:n),null!==v&&w()&&(f.push(Jot({start:v,end:t,loop:d,count:o,style:p})),v=null),n=t,y=m));return null!==v&&f.push(Jot({start:v,end:h,loop:d,count:o,style:p})),f}function tat(t,e){const n=[],i=t.segments;for(let r=0;r<i.length;r++){const s=Qot(i[r],t.points,e);s.length&&n.push(...s)}return n}function eat(t,e,n,i){return i&&i.setContext&&n?function(t,e,n,i){const r=t._chart.getContext(),s=nat(t.options),{_datasetIndex:o,options:{spanGaps:a}}=t,l=n.length,c=[];let u=s,h=e[0].start,d=h;function p(t,e,i,r){const s=a?-1:1;if(t!==e){for(t+=l;n[t%l].skip;)t-=s;for(;n[e%l].skip;)e+=s;t%l!=e%l&&(c.push({start:t%l,end:e%l,loop:i,style:r}),u=r,h=e%l)}}for(const t of e){h=a?h:t.start;let e,s=n[h%l];for(d=h+1;d<=t.end;d++){const a=n[d%l];e=nat(i.setContext(uot(r,{type:"segment",p0:s,p1:a,p0DataIndex:(d-1)%l,p1DataIndex:d%l,datasetIndex:o}))),iat(e,u)&&p(h,d-1,t.loop,u),s=a,u=e}h<d-1&&p(h,d-1,t.loop,u)}return c}(t,e,n,i):e}function nat(t){return{backgroundColor:t.backgroundColor,borderCapStyle:t.borderCapStyle,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderJoinStyle:t.borderJoinStyle,borderWidth:t.borderWidth,borderColor:t.borderColor}}function iat(t,e){if(!e)return!1;const n=[],i=function(t,e){return Cst(e)?(n.includes(e)||n.push(e),n.indexOf(e)):e};return JSON.stringify(t,i)!==JSON.stringify(e,i)}
/*!
 * Chart.js v4.4.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */class rat{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(t,e,n,i){const r=e.listeners[i],s=e.duration;r.forEach((i=>i({chart:t,initial:e.initial,numSteps:s,currentStep:Math.min(n-e.start,s)})))}_refresh(){this._request||(this._running=!0,this._request=fst.call(window,(()=>{this._update(),this._request=null,this._running&&this._refresh()})))}_update(t=Date.now()){let e=0;this._charts.forEach(((n,i)=>{if(!n.running||!n.items.length)return;const r=n.items;let s,o=r.length-1,a=!1;for(;o>=0;--o)s=r[o],s._active?(s._total>n.duration&&(n.duration=s._total),s.tick(t),a=!0):(r[o]=r[r.length-1],r.pop());a&&(i.draw(),this._notify(i,n,t,"progress")),r.length||(n.running=!1,this._notify(i,n,t,"complete"),n.initial=!1),e+=r.length})),this._lastDate=t,0===e&&(this._running=!1)}_getAnims(t){const e=this._charts;let n=e.get(t);return n||(n={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,n)),n}listen(t,e,n){this._getAnims(t).listeners[e].push(n)}add(t,e){e&&e.length&&this._getAnims(t).items.push(...e)}has(t){return this._getAnims(t).items.length>0}start(t){const e=this._charts.get(t);e&&(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce(((t,e)=>Math.max(t,e._duration)),0),this._refresh())}running(t){if(!this._running)return!1;const e=this._charts.get(t);return!!(e&&e.running&&e.items.length)}stop(t){const e=this._charts.get(t);if(!e||!e.items.length)return;const n=e.items;let i=n.length-1;for(;i>=0;--i)n[i].cancel();e.items=[],this._notify(t,e,Date.now(),"complete")}remove(t){return this._charts.delete(t)}}var sat=new rat;const oat="transparent",aat={boolean:(t,e,n)=>n>.5?e:t,color(t,e,n){const i=Tst(t||oat),r=i.valid&&Tst(e||oat);return r&&r.valid?r.mix(i,n).hexString():e},number:(t,e,n)=>t+(e-t)*n};class lat{constructor(t,e,n,i){const r=e[n];i=cot([t.to,i,r,t.from]);const s=cot([t.from,r,i]);this._active=!0,this._fn=t.fn||aat[t.type||typeof s],this._easing=kst[t.easing]||kst.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=n,this._from=s,this._to=i,this._promises=void 0}active(){return this._active}update(t,e,n){if(this._active){this._notify(!1);const i=this._target[this._prop],r=n-this._start,s=this._duration-r;this._start=n,this._duration=Math.floor(Math.max(s,t.duration)),this._total+=r,this._loop=!!t.loop,this._to=cot([t.to,e,i,t.from]),this._from=cot([t.from,i,e])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(t){const e=t-this._start,n=this._duration,i=this._prop,r=this._from,s=this._loop,o=this._to;let a;if(this._active=r!==o&&(s||e<n),!this._active)return this._target[i]=o,void this._notify(!0);e<0?this._target[i]=r:(a=e/n%2,a=s&&a>1?2-a:a,a=this._easing(Math.min(1,Math.max(0,a))),this._target[i]=this._fn(r,o,a))}wait(){const t=this._promises||(this._promises=[]);return new Promise(((e,n)=>{t.push({res:e,rej:n})}))}_notify(t){const e=t?"res":"rej",n=this._promises||[];for(let t=0;t<n.length;t++)n[t][e]()}}class cat{constructor(t,e){this._chart=t,this._properties=new Map,this.configure(e)}configure(t){if(!brt(t))return;const e=Object.keys(Fst.animation),n=this._properties;Object.getOwnPropertyNames(t).forEach((i=>{const r=t[i];if(!brt(r))return;const s={};for(const t of e)s[t]=r[t];(yrt(r.properties)&&r.properties||[i]).forEach((t=>{t!==i&&n.has(t)||n.set(t,s)}))}))}_animateOptions(t,e){const n=e.options,i=function(t,e){if(!e)return;let n=t.options;if(!n)return void(t.options=e);n.$shared&&(t.options=n=Object.assign({},n,{$shared:!1,$animations:{}}));return n}(t,n);if(!i)return[];const r=this._createAnimations(i,n);return n.$shared&&function(t,e){const n=[],i=Object.keys(e);for(let e=0;e<i.length;e++){const r=t[i[e]];r&&r.active()&&n.push(r.wait())}return Promise.all(n)}(t.options.$animations,n).then((()=>{t.options=n}),(()=>{})),r}_createAnimations(t,e){const n=this._properties,i=[],r=t.$animations||(t.$animations={}),s=Object.keys(e),o=Date.now();let a;for(a=s.length-1;a>=0;--a){const l=s[a];if("$"===l.charAt(0))continue;if("options"===l){i.push(...this._animateOptions(t,e));continue}const c=e[l];let u=r[l];const h=n.get(l);if(u){if(h&&u.active()){u.update(h,c,o);continue}u.cancel()}h&&h.duration?(r[l]=u=new lat(h,t,l,c),i.push(u)):t[l]=c}return i}update(t,e){if(0===this._properties.size)return void Object.assign(t,e);const n=this._createAnimations(t,e);return n.length?(sat.add(this._chart,n),!0):void 0}}function uat(t,e){const n=t&&t.options||{},i=n.reverse,r=void 0===n.min?e:0,s=void 0===n.max?e:0;return{start:i?s:r,end:i?r:s}}function hat(t,e){const n=[],i=t._getSortedDatasetMetas(e);let r,s;for(r=0,s=i.length;r<s;++r)n.push(i[r].index);return n}function dat(t,e,n,i={}){const r=t.keys,s="single"===i.mode;let o,a,l,c;if(null!==e){for(o=0,a=r.length;o<a;++o){if(l=+r[o],l===n){if(i.all)continue;break}c=t.values[l],vrt(c)&&(s||0===e||qrt(e)===qrt(c))&&(e+=c)}return e}}function pat(t,e){const n=t&&t.options.stacked;return n||void 0===n&&void 0!==e.stack}function fat(t,e,n){const i=t[e]||(t[e]={});return i[n]||(i[n]={})}function mat(t,e,n,i){for(const r of e.getMatchingVisibleMetas(i).reverse()){const e=t[r.index];if(n&&e>0||!n&&e<0)return r.index}return null}function gat(t,e){const{chart:n,_cachedMeta:i}=t,r=n._stacks||(n._stacks={}),{iScale:s,vScale:o,index:a}=i,l=s.axis,c=o.axis,u=function(t,e,n){return`${t.id}.${e.id}.${n.stack||n.type}`}(s,o,i),h=e.length;let d;for(let t=0;t<h;++t){const n=e[t],{[l]:s,[c]:h}=n;d=(n._stacks||(n._stacks={}))[c]=fat(r,u,s),d[a]=h,d._top=mat(d,o,!0,i.type),d._bottom=mat(d,o,!1,i.type);(d._visualValues||(d._visualValues={}))[a]=h}}function yat(t,e){const n=t.scales;return Object.keys(n).filter((t=>n[t].axis===e)).shift()}function bat(t,e){const n=t.controller.index,i=t.vScale&&t.vScale.axis;if(i){e=e||t._parsed;for(const t of e){const e=t._stacks;if(!e||void 0===e[i]||void 0===e[i][n])return;delete e[i][n],void 0!==e[i]._visualValues&&void 0!==e[i]._visualValues[n]&&delete e[i]._visualValues[n]}}}const vat=t=>"reset"===t||"none"===t,xat=(t,e)=>e?t:Object.assign({},t);class wat{static defaults={};static datasetElementType=null;static dataElementType=null;constructor(t,e){this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const t=this._cachedMeta;this.configure(),this.linkScales(),t._stacked=pat(t.vScale,t),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled("filler")&&console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}updateIndex(t){this.index!==t&&bat(this._cachedMeta),this.index=t}linkScales(){const t=this.chart,e=this._cachedMeta,n=this.getDataset(),i=(t,e,n,i)=>"x"===t?e:"r"===t?i:n,r=e.xAxisID=wrt(n.xAxisID,yat(t,"x")),s=e.yAxisID=wrt(n.yAxisID,yat(t,"y")),o=e.rAxisID=wrt(n.rAxisID,yat(t,"r")),a=e.indexAxis,l=e.iAxisID=i(a,r,s,o),c=e.vAxisID=i(a,s,r,o);e.xScale=this.getScaleForId(r),e.yScale=this.getScaleForId(s),e.rScale=this.getScaleForId(o),e.iScale=this.getScaleForId(l),e.vScale=this.getScaleForId(c)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(t){return this.chart.scales[t]}_getOtherScale(t){const e=this._cachedMeta;return t===e.iScale?e.vScale:e.iScale}reset(){this._update("reset")}_destroy(){const t=this._cachedMeta;this._data&&dst(this._data,this),t._stacked&&bat(t)}_dataCheck(){const t=this.getDataset(),e=t.data||(t.data=[]),n=this._data;if(brt(e))this._data=function(t){const e=Object.keys(t),n=new Array(e.length);let i,r,s;for(i=0,r=e.length;i<r;++i)s=e[i],n[i]={x:s,y:t[s]};return n}(e);else if(n!==e){if(n){dst(n,this);const t=this._cachedMeta;bat(t),t._parsed=[]}e&&Object.isExtensible(e)&&(r=this,(i=e)._chartjs?i._chartjs.listeners.push(r):(Object.defineProperty(i,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[r]}}),hst.forEach((t=>{const e="_onData"+Prt(t),n=i[t];Object.defineProperty(i,t,{configurable:!0,enumerable:!1,value(...t){const r=n.apply(this,t);return i._chartjs.listeners.forEach((n=>{"function"==typeof n[e]&&n[e](...t)})),r}})})))),this._syncList=[],this._data=e}var i,r}addElements(){const t=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(t.dataset=new this.datasetElementType)}buildOrUpdateElements(t){const e=this._cachedMeta,n=this.getDataset();let i=!1;this._dataCheck();const r=e._stacked;e._stacked=pat(e.vScale,e),e.stack!==n.stack&&(i=!0,bat(e),e.stack=n.stack),this._resyncElements(t),(i||r!==e._stacked)&&gat(this,e._parsed)}configure(){const t=this.chart.config,e=t.datasetScopeKeys(this._type),n=t.getOptionScopes(this.getDataset(),e,!0);this.options=t.createResolver(n,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(t,e){const{_cachedMeta:n,_data:i}=this,{iScale:r,_stacked:s}=n,o=r.axis;let a,l,c,u=0===t&&e===i.length||n._sorted,h=t>0&&n._parsed[t-1];if(!1===this._parsing)n._parsed=i,n._sorted=!0,c=i;else{c=yrt(i[t])?this.parseArrayData(n,i,t,e):brt(i[t])?this.parseObjectData(n,i,t,e):this.parsePrimitiveData(n,i,t,e);const r=()=>null===l[o]||h&&l[o]<h[o];for(a=0;a<e;++a)n._parsed[a+t]=l=c[a],u&&(r()&&(u=!1),h=l);n._sorted=u}s&&gat(this,c)}parsePrimitiveData(t,e,n,i){const{iScale:r,vScale:s}=t,o=r.axis,a=s.axis,l=r.getLabels(),c=r===s,u=new Array(i);let h,d,p;for(h=0,d=i;h<d;++h)p=h+n,u[h]={[o]:c||r.parse(l[p],p),[a]:s.parse(e[p],p)};return u}parseArrayData(t,e,n,i){const{xScale:r,yScale:s}=t,o=new Array(i);let a,l,c,u;for(a=0,l=i;a<l;++a)c=a+n,u=e[c],o[a]={x:r.parse(u[0],c),y:s.parse(u[1],c)};return o}parseObjectData(t,e,n,i){const{xScale:r,yScale:s}=t,{xAxisKey:o="x",yAxisKey:a="y"}=this._parsing,l=new Array(i);let c,u,h,d;for(c=0,u=i;c<u;++c)h=c+n,d=e[h],l[c]={x:r.parse(Rrt(d,o),h),y:s.parse(Rrt(d,a),h)};return l}getParsed(t){return this._cachedMeta._parsed[t]}getDataElement(t){return this._cachedMeta.data[t]}applyStack(t,e,n){const i=this.chart,r=this._cachedMeta,s=e[t.axis];return dat({keys:hat(i,!0),values:e._stacks[t.axis]._visualValues},s,r.index,{mode:n})}updateRangeFromParsed(t,e,n,i){const r=n[e.axis];let s=null===r?NaN:r;const o=i&&n._stacks[e.axis];i&&o&&(i.values=o,s=dat(i,r,this._cachedMeta.index)),t.min=Math.min(t.min,s),t.max=Math.max(t.max,s)}getMinMax(t,e){const n=this._cachedMeta,i=n._parsed,r=n._sorted&&t===n.iScale,s=i.length,o=this._getOtherScale(t),a=((t,e,n)=>t&&!e.hidden&&e._stacked&&{keys:hat(n,!0),values:null})(e,n,this.chart),l={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:c,max:u}=function(t){const{min:e,max:n,minDefined:i,maxDefined:r}=t.getUserBounds();return{min:i?e:Number.NEGATIVE_INFINITY,max:r?n:Number.POSITIVE_INFINITY}}(o);let h,d;function p(){d=i[h];const e=d[o.axis];return!vrt(d[t.axis])||c>e||u<e}for(h=0;h<s&&(p()||(this.updateRangeFromParsed(l,t,d,a),!r));++h);if(r)for(h=s-1;h>=0;--h)if(!p()){this.updateRangeFromParsed(l,t,d,a);break}return l}getAllParsedValues(t){const e=this._cachedMeta._parsed,n=[];let i,r,s;for(i=0,r=e.length;i<r;++i)s=e[i][t.axis],vrt(s)&&n.push(s);return n}getMaxOverflow(){return!1}getLabelAndValue(t){const e=this._cachedMeta,n=e.iScale,i=e.vScale,r=this.getParsed(t);return{label:n?""+n.getLabelForValue(r[n.axis]):"",value:i?""+i.getLabelForValue(r[i.axis]):""}}_update(t){const e=this._cachedMeta;this.update(t||"default"),e._clip=function(t){let e,n,i,r;return brt(t)?(e=t.top,n=t.right,i=t.bottom,r=t.left):e=n=i=r=t,{top:e,right:n,bottom:i,left:r,disabled:!1===t}}(wrt(this.options.clip,function(t,e,n){if(!1===n)return!1;const i=uat(t,n),r=uat(e,n);return{top:r.end,right:i.end,bottom:r.start,left:i.start}}(e.xScale,e.yScale,this.getMaxOverflow())))}update(t){}draw(){const t=this._ctx,e=this.chart,n=this._cachedMeta,i=n.data||[],r=e.chartArea,s=[],o=this._drawStart||0,a=this._drawCount||i.length-o,l=this.options.drawActiveElementsOnTop;let c;for(n.dataset&&n.dataset.draw(t,r,o,a),c=o;c<o+a;++c){const e=i[c];e.hidden||(e.active&&l?s.push(e):e.draw(t,r))}for(c=0;c<s.length;++c)s[c].draw(t,r)}getStyle(t,e){const n=e?"active":"default";return void 0===t&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(n):this.resolveDataElementOptions(t||0,n)}getContext(t,e,n){const i=this.getDataset();let r;if(t>=0&&t<this._cachedMeta.data.length){const e=this._cachedMeta.data[t];r=e.$context||(e.$context=function(t,e,n){return uot(t,{active:!1,dataIndex:e,parsed:void 0,raw:void 0,element:n,index:e,mode:"default",type:"data"})}(this.getContext(),t,e)),r.parsed=this.getParsed(t),r.raw=i.data[t],r.index=r.dataIndex=t}else r=this.$context||(this.$context=function(t,e){return uot(t,{active:!1,dataset:void 0,datasetIndex:e,index:e,mode:"default",type:"dataset"})}(this.chart.getContext(),this.index)),r.dataset=i,r.index=r.datasetIndex=this.index;return r.active=!!e,r.mode=n,r}resolveDatasetElementOptions(t){return this._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,e){return this._resolveElementOptions(this.dataElementType.id,e,t)}_resolveElementOptions(t,e="default",n){const i="active"===e,r=this._cachedDataOpts,s=t+"-"+e,o=r[s],a=this.enableOptionSharing&&Ort(n);if(o)return xat(o,a);const l=this.chart.config,c=l.datasetElementScopeKeys(this._type,t),u=i?[`${t}Hover`,"hover",t,""]:[t,""],h=l.getOptionScopes(this.getDataset(),c),d=Object.keys(Fst.elements[t]),p=l.resolveNamedOptions(h,d,(()=>this.getContext(n,i,e)),u);return p.$shared&&(p.$shared=a,r[s]=Object.freeze(xat(p,a))),p}_resolveAnimations(t,e,n){const i=this.chart,r=this._cachedDataOpts,s=`animation-${e}`,o=r[s];if(o)return o;let a;if(!1!==i.options.animation){const i=this.chart.config,r=i.datasetAnimationScopeKeys(this._type,e),s=i.getOptionScopes(this.getDataset(),r);a=i.createResolver(s,this.getContext(t,n,e))}const l=new cat(i,a&&a.animations);return a&&a._cacheable&&(r[s]=Object.freeze(l)),l}getSharedOptions(t){if(t.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}includeOptions(t,e){return!e||vat(t)||this.chart._animationsDisabled}_getSharedOptions(t,e){const n=this.resolveDataElementOptions(t,e),i=this._sharedOptions,r=this.getSharedOptions(n),s=this.includeOptions(e,r)||r!==i;return this.updateSharedOptions(r,e,n),{sharedOptions:r,includeOptions:s}}updateElement(t,e,n,i){vat(i)?Object.assign(t,n):this._resolveAnimations(e,i).update(t,n)}updateSharedOptions(t,e,n){t&&!vat(e)&&this._resolveAnimations(void 0,e).update(t,n)}_setStyle(t,e,n,i){t.active=i;const r=this.getStyle(e,i);this._resolveAnimations(e,n,i).update(t,{options:!i&&this.getSharedOptions(r)||r})}removeHoverStyle(t,e,n){this._setStyle(t,n,"active",!1)}setHoverStyle(t,e,n){this._setStyle(t,n,"active",!0)}_removeDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"active",!1)}_setDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"active",!0)}_resyncElements(t){const e=this._data,n=this._cachedMeta.data;for(const[t,e,n]of this._syncList)this[t](e,n);this._syncList=[];const i=n.length,r=e.length,s=Math.min(r,i);s&&this.parse(0,s),r>i?this._insertElements(i,r-i,t):r<i&&this._removeElements(r,i-r)}_insertElements(t,e,n=!0){const i=this._cachedMeta,r=i.data,s=t+e;let o;const a=t=>{for(t.length+=e,o=t.length-1;o>=s;o--)t[o]=t[o-e]};for(a(r),o=t;o<s;++o)r[o]=new this.dataElementType;this._parsing&&a(i._parsed),this.parse(t,e),n&&this.updateElements(r,t,e,"reset")}updateElements(t,e,n,i){}_removeElements(t,e){const n=this._cachedMeta;if(this._parsing){const i=n._parsed.splice(t,e);n._stacked&&bat(n,i)}n.data.splice(t,e)}_sync(t){if(this._parsing)this._syncList.push(t);else{const[e,n,i]=t;this[e](n,i)}this.chart._dataChanges.push([this.index,...t])}_onDataPush(){const t=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-t,t])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(t,e){e&&this._sync(["_removeElements",t,e]);const n=arguments.length-2;n&&this._sync(["_insertElements",t,n])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}function Sat(t){const e=t.iScale,n=function(t,e){if(!t._cache.$bar){const n=t.getMatchingVisibleMetas(e);let i=[];for(let e=0,r=n.length;e<r;e++)i=i.concat(n[e].controller.getAllParsedValues(t));t._cache.$bar=pst(i.sort(((t,e)=>t-e)))}return t._cache.$bar}(e,t.type);let i,r,s,o,a=e._length;const l=()=>{32767!==s&&-32768!==s&&(Ort(o)&&(a=Math.min(a,Math.abs(s-o)||a)),o=s)};for(i=0,r=n.length;i<r;++i)s=e.getPixelForValue(n[i]),l();for(o=void 0,i=0,r=e.ticks.length;i<r;++i)s=e.getPixelForTick(i),l();return a}function kat(t,e,n,i){return yrt(t)?function(t,e,n,i){const r=n.parse(t[0],i),s=n.parse(t[1],i),o=Math.min(r,s),a=Math.max(r,s);let l=o,c=a;Math.abs(o)>Math.abs(a)&&(l=a,c=o),e[n.axis]=c,e._custom={barStart:l,barEnd:c,start:r,end:s,min:o,max:a}}(t,e,n,i):e[n.axis]=n.parse(t,i),e}function Cat(t,e,n,i){const r=t.iScale,s=t.vScale,o=r.getLabels(),a=r===s,l=[];let c,u,h,d;for(c=n,u=n+i;c<u;++c)d=e[c],h={},h[r.axis]=a||r.parse(o[c],c),l.push(kat(d,h,s,c));return l}function Tat(t){return t&&void 0!==t.barStart&&void 0!==t.barEnd}function _at(t,e,n,i){let r=e.borderSkipped;const s={};if(!r)return void(t.borderSkipped=s);if(!0===r)return void(t.borderSkipped={top:!0,right:!0,bottom:!0,left:!0});const{start:o,end:a,reverse:l,top:c,bottom:u}=function(t){let e,n,i,r,s;return t.horizontal?(e=t.base>t.x,n="left",i="right"):(e=t.base<t.y,n="bottom",i="top"),e?(r="end",s="start"):(r="start",s="end"),{start:n,end:i,reverse:e,top:r,bottom:s}}(t);"middle"===r&&n&&(t.enableBorderRadius=!0,(n._top||0)===i?r=c:(n._bottom||0)===i?r=u:(s[Eat(u,o,a,l)]=!0,r=c)),s[Eat(r,o,a,l)]=!0,t.borderSkipped=s}function Eat(t,e,n,i){var r,s,o;return i?(o=n,t=Mat(t=(r=t)===(s=e)?o:r===o?s:r,n,e)):t=Mat(t,e,n),t}function Mat(t,e,n){return"start"===t?e:"end"===t?n:t}function $at(t,{inflateAmount:e},n){t.inflateAmount="auto"===e?1===n?.33:0:e}class Iat extends wat{static id="bar";static defaults={datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}};static overrides={scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}};parsePrimitiveData(t,e,n,i){return Cat(t,e,n,i)}parseArrayData(t,e,n,i){return Cat(t,e,n,i)}parseObjectData(t,e,n,i){const{iScale:r,vScale:s}=t,{xAxisKey:o="x",yAxisKey:a="y"}=this._parsing,l="x"===r.axis?o:a,c="x"===s.axis?o:a,u=[];let h,d,p,f;for(h=n,d=n+i;h<d;++h)f=e[h],p={},p[r.axis]=r.parse(Rrt(f,l),h),u.push(kat(Rrt(f,c),p,s,h));return u}updateRangeFromParsed(t,e,n,i){super.updateRangeFromParsed(t,e,n,i);const r=n._custom;r&&e===this._cachedMeta.vScale&&(t.min=Math.min(t.min,r.min),t.max=Math.max(t.max,r.max))}getMaxOverflow(){return 0}getLabelAndValue(t){const e=this._cachedMeta,{iScale:n,vScale:i}=e,r=this.getParsed(t),s=r._custom,o=Tat(s)?"["+s.start+", "+s.end+"]":""+i.getLabelForValue(r[i.axis]);return{label:""+n.getLabelForValue(r[n.axis]),value:o}}initialize(){this.enableOptionSharing=!0,super.initialize();this._cachedMeta.stack=this.getDataset().stack}update(t){const e=this._cachedMeta;this.updateElements(e.data,0,e.data.length,t)}updateElements(t,e,n,i){const r="reset"===i,{index:s,_cachedMeta:{vScale:o}}=this,a=o.getBasePixel(),l=o.isHorizontal(),c=this._getRuler(),{sharedOptions:u,includeOptions:h}=this._getSharedOptions(e,i);for(let d=e;d<e+n;d++){const e=this.getParsed(d),n=r||grt(e[o.axis])?{base:a,head:a}:this._calculateBarValuePixels(d),p=this._calculateBarIndexPixels(d,c),f=(e._stacks||{})[o.axis],m={horizontal:l,base:n.base,enableBorderRadius:!f||Tat(e._custom)||s===f._top||s===f._bottom,x:l?n.head:p.center,y:l?p.center:n.head,height:l?p.size:Math.abs(n.size),width:l?Math.abs(n.size):p.size};h&&(m.options=u||this.resolveDataElementOptions(d,t[d].active?"active":i));const g=m.options||t[d].options;_at(m,g,f,s),$at(m,g,c.ratio),this.updateElement(t[d],d,m,i)}}_getStacks(t,e){const{iScale:n}=this._cachedMeta,i=n.getMatchingVisibleMetas(this._type).filter((t=>t.controller.options.grouped)),r=n.options.stacked,s=[],o=t=>{const n=t.controller.getParsed(e),i=n&&n[t.vScale.axis];if(grt(i)||isNaN(i))return!0};for(const n of i)if((void 0===e||!o(n))&&((!1===r||-1===s.indexOf(n.stack)||void 0===r&&void 0===n.stack)&&s.push(n.stack),n.index===t))break;return s.length||s.push(void 0),s}_getStackCount(t){return this._getStacks(void 0,t).length}_getStackIndex(t,e,n){const i=this._getStacks(t,n),r=void 0!==e?i.indexOf(e):-1;return-1===r?i.length-1:r}_getRuler(){const t=this.options,e=this._cachedMeta,n=e.iScale,i=[];let r,s;for(r=0,s=e.data.length;r<s;++r)i.push(n.getPixelForValue(this.getParsed(r)[n.axis],r));const o=t.barThickness;return{min:o||Sat(e),pixels:i,start:n._startPixel,end:n._endPixel,stackCount:this._getStackCount(),scale:n,grouped:t.grouped,ratio:o?1:t.categoryPercentage*t.barPercentage}}_calculateBarValuePixels(t){const{_cachedMeta:{vScale:e,_stacked:n,index:i},options:{base:r,minBarLength:s}}=this,o=r||0,a=this.getParsed(t),l=a._custom,c=Tat(l);let u,h,d=a[e.axis],p=0,f=n?this.applyStack(e,a,n):d;f!==d&&(p=f-d,f=d),c&&(d=l.barStart,f=l.barEnd-l.barStart,0!==d&&qrt(d)!==qrt(l.barEnd)&&(p=0),p+=d);const m=grt(r)||c?p:r;let g=e.getPixelForValue(m);if(u=this.chart.getDataVisibility(t)?e.getPixelForValue(p+f):g,h=u-g,Math.abs(h)<s){h=function(t,e,n){return 0!==t?qrt(t):(e.isHorizontal()?1:-1)*(e.min>=n?1:-1)}(h,e,o)*s,d===o&&(g-=h/2);const t=e.getPixelForDecimal(0),r=e.getPixelForDecimal(1),l=Math.min(t,r),p=Math.max(t,r);g=Math.max(Math.min(g,p),l),u=g+h,n&&!c&&(a._stacks[e.axis]._visualValues[i]=e.getValueForPixel(u)-e.getValueForPixel(g))}if(g===e.getPixelForValue(o)){const t=qrt(h)*e.getLineWidthForValue(o)/2;g+=t,h-=t}return{size:h,base:g,head:u,center:u+h/2}}_calculateBarIndexPixels(t,e){const n=e.scale,i=this.options,r=i.skipNull,s=wrt(i.maxBarThickness,1/0);let o,a;if(e.grouped){const n=r?this._getStackCount(t):e.stackCount,l="flex"===i.barThickness?function(t,e,n,i){const r=e.pixels,s=r[t];let o=t>0?r[t-1]:null,a=t<r.length-1?r[t+1]:null;const l=n.categoryPercentage;null===o&&(o=s-(null===a?e.end-e.start:a-s)),null===a&&(a=s+s-o);const c=s-(s-Math.min(o,a))/2*l;return{chunk:Math.abs(a-o)/2*l/i,ratio:n.barPercentage,start:c}}(t,e,i,n):function(t,e,n,i){const r=n.barThickness;let s,o;return grt(r)?(s=e.min*n.categoryPercentage,o=n.barPercentage):(s=r*i,o=1),{chunk:s/i,ratio:o,start:e.pixels[t]-s/2}}(t,e,i,n),c=this._getStackIndex(this.index,this._cachedMeta.stack,r?t:void 0);o=l.start+l.chunk*c+l.chunk/2,a=Math.min(s,l.chunk*l.ratio)}else o=n.getPixelForValue(this.getParsed(t)[n.axis],t),a=Math.min(s,e.min*e.ratio);return{base:o-a/2,head:o+a/2,center:o,size:a}}draw(){const t=this._cachedMeta,e=t.vScale,n=t.data,i=n.length;let r=0;for(;r<i;++r)null!==this.getParsed(r)[e.axis]&&n[r].draw(this._ctx)}}class Aat extends wat{static id="bubble";static defaults={datasetElementType:!1,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}};static overrides={scales:{x:{type:"linear"},y:{type:"linear"}}};initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(t,e,n,i){const r=super.parsePrimitiveData(t,e,n,i);for(let t=0;t<r.length;t++)r[t]._custom=this.resolveDataElementOptions(t+n).radius;return r}parseArrayData(t,e,n,i){const r=super.parseArrayData(t,e,n,i);for(let t=0;t<r.length;t++){const i=e[n+t];r[t]._custom=wrt(i[2],this.resolveDataElementOptions(t+n).radius)}return r}parseObjectData(t,e,n,i){const r=super.parseObjectData(t,e,n,i);for(let t=0;t<r.length;t++){const i=e[n+t];r[t]._custom=wrt(i&&i.r&&+i.r,this.resolveDataElementOptions(t+n).radius)}return r}getMaxOverflow(){const t=this._cachedMeta.data;let e=0;for(let n=t.length-1;n>=0;--n)e=Math.max(e,t[n].size(this.resolveDataElementOptions(n))/2);return e>0&&e}getLabelAndValue(t){const e=this._cachedMeta,n=this.chart.data.labels||[],{xScale:i,yScale:r}=e,s=this.getParsed(t),o=i.getLabelForValue(s.x),a=r.getLabelForValue(s.y),l=s._custom;return{label:n[t]||"",value:"("+o+", "+a+(l?", "+l:"")+")"}}update(t){const e=this._cachedMeta.data;this.updateElements(e,0,e.length,t)}updateElements(t,e,n,i){const r="reset"===i,{iScale:s,vScale:o}=this._cachedMeta,{sharedOptions:a,includeOptions:l}=this._getSharedOptions(e,i),c=s.axis,u=o.axis;for(let h=e;h<e+n;h++){const e=t[h],n=!r&&this.getParsed(h),d={},p=d[c]=r?s.getPixelForDecimal(.5):s.getPixelForValue(n[c]),f=d[u]=r?o.getBasePixel():o.getPixelForValue(n[u]);d.skip=isNaN(p)||isNaN(f),l&&(d.options=a||this.resolveDataElementOptions(h,e.active?"active":i),r&&(d.options.radius=0)),this.updateElement(e,h,d,i)}}resolveDataElementOptions(t,e){const n=this.getParsed(t);let i=super.resolveDataElementOptions(t,e);i.$shared&&(i=Object.assign({},i,{$shared:!1}));const r=i.radius;return"active"!==e&&(i.radius=0),i.radius+=wrt(n&&n._custom,r),i}}class Nat extends wat{static id="doughnut";static defaults={datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"};static descriptors={_scriptable:t=>"spacing"!==t,_indexable:t=>"spacing"!==t&&!t.startsWith("borderDash")&&!t.startsWith("hoverBorderDash")};static overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:n,color:i}}=t.legend.options;return e.labels.map(((e,r)=>{const s=t.getDatasetMeta(0).controller.getStyle(r);return{text:e,fillStyle:s.backgroundColor,strokeStyle:s.borderColor,fontColor:i,lineWidth:s.borderWidth,pointStyle:n,hidden:!t.getDataVisibility(r),index:r}}))}return[]}},onClick(t,e,n){n.chart.toggleDataVisibility(e.index),n.chart.update()}}}};constructor(t,e){super(t,e),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(t,e){const n=this.getDataset().data,i=this._cachedMeta;if(!1===this._parsing)i._parsed=n;else{let r,s,o=t=>+n[t];if(brt(n[t])){const{key:t="value"}=this._parsing;o=e=>+Rrt(n[e],t)}for(r=t,s=t+e;r<s;++r)i._parsed[r]=o(r)}}_getRotation(){return Jrt(this.options.rotation-90)}_getCircumference(){return Jrt(this.options.circumference)}_getRotationExtents(){let t=zrt,e=-zrt;for(let n=0;n<this.chart.data.datasets.length;++n)if(this.chart.isDatasetVisible(n)&&this.chart.getDatasetMeta(n).type===this._type){const i=this.chart.getDatasetMeta(n).controller,r=i._getRotation(),s=i._getCircumference();t=Math.min(t,r),e=Math.max(e,r+s)}return{rotation:t,circumference:e-t}}update(t){const e=this.chart,{chartArea:n}=e,i=this._cachedMeta,r=i.data,s=this.getMaxBorderWidth()+this.getMaxOffset(r)+this.options.spacing,o=Math.max((Math.min(n.width,n.height)-s)/2,0),a=Math.min((l=this.options.cutout,c=o,"string"==typeof l&&l.endsWith("%")?parseFloat(l)/100:+l/c),1);var l,c;const u=this._getRingWeight(this.index),{circumference:h,rotation:d}=this._getRotationExtents(),{ratioX:p,ratioY:f,offsetX:m,offsetY:g}=function(t,e,n){let i=1,r=1,s=0,o=0;if(e<zrt){const a=t,l=a+e,c=Math.cos(a),u=Math.sin(a),h=Math.cos(l),d=Math.sin(l),p=(t,e,i)=>sst(t,a,l,!0)?1:Math.max(e,e*n,i,i*n),f=(t,e,i)=>sst(t,a,l,!0)?-1:Math.min(e,e*n,i,i*n),m=p(0,c,h),g=p(Wrt,u,d),y=f(Frt,c,h),b=f(Frt+Wrt,u,d);i=(m-y)/2,r=(g-b)/2,s=-(m+y)/2,o=-(g+b)/2}return{ratioX:i,ratioY:r,offsetX:s,offsetY:o}}(d,h,a),y=(n.width-s)/p,b=(n.height-s)/f,v=Math.max(Math.min(y,b)/2,0),x=Srt(this.options.radius,v),w=(x-Math.max(x*a,0))/this._getVisibleDatasetWeightTotal();this.offsetX=m*x,this.offsetY=g*x,i.total=this.calculateTotal(),this.outerRadius=x-w*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-w*u,0),this.updateElements(r,0,r.length,t)}_circumference(t,e){const n=this.options,i=this._cachedMeta,r=this._getCircumference();return e&&n.animation.animateRotate||!this.chart.getDataVisibility(t)||null===i._parsed[t]||i.data[t].hidden?0:this.calculateCircumference(i._parsed[t]*r/zrt)}updateElements(t,e,n,i){const r="reset"===i,s=this.chart,o=s.chartArea,a=s.options.animation,l=(o.left+o.right)/2,c=(o.top+o.bottom)/2,u=r&&a.animateScale,h=u?0:this.innerRadius,d=u?0:this.outerRadius,{sharedOptions:p,includeOptions:f}=this._getSharedOptions(e,i);let m,g=this._getRotation();for(m=0;m<e;++m)g+=this._circumference(m,r);for(m=e;m<e+n;++m){const e=this._circumference(m,r),n=t[m],s={x:l+this.offsetX,y:c+this.offsetY,startAngle:g,endAngle:g+e,circumference:e,outerRadius:d,innerRadius:h};f&&(s.options=p||this.resolveDataElementOptions(m,n.active?"active":i)),g+=e,this.updateElement(n,m,s,i)}}calculateTotal(){const t=this._cachedMeta,e=t.data;let n,i=0;for(n=0;n<e.length;n++){const r=t._parsed[n];null===r||isNaN(r)||!this.chart.getDataVisibility(n)||e[n].hidden||(i+=Math.abs(r))}return i}calculateCircumference(t){const e=this._cachedMeta.total;return e>0&&!isNaN(t)?zrt*(Math.abs(t)/e):0}getLabelAndValue(t){const e=this._cachedMeta,n=this.chart,i=n.data.labels||[],r=Ist(e._parsed[t],n.options.locale);return{label:i[t]||"",value:r}}getMaxBorderWidth(t){let e=0;const n=this.chart;let i,r,s,o,a;if(!t)for(i=0,r=n.data.datasets.length;i<r;++i)if(n.isDatasetVisible(i)){s=n.getDatasetMeta(i),t=s.data,o=s.controller;break}if(!t)return 0;for(i=0,r=t.length;i<r;++i)a=o.resolveDataElementOptions(i),"inner"!==a.borderAlign&&(e=Math.max(e,a.borderWidth||0,a.hoverBorderWidth||0));return e}getMaxOffset(t){let e=0;for(let n=0,i=t.length;n<i;++n){const t=this.resolveDataElementOptions(n);e=Math.max(e,t.offset||0,t.hoverOffset||0)}return e}_getRingWeightOffset(t){let e=0;for(let n=0;n<t;++n)this.chart.isDatasetVisible(n)&&(e+=this._getRingWeight(n));return e}_getRingWeight(t){return Math.max(wrt(this.chart.data.datasets[t].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}class Rat extends wat{static id="line";static defaults={datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1};static overrides={scales:{_index_:{type:"category"},_value_:{type:"linear"}}};initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(t){const e=this._cachedMeta,{dataset:n,data:i=[],_dataset:r}=e,s=this.chart._animationsDisabled;let{start:o,count:a}=bst(e,i,s);this._drawStart=o,this._drawCount=a,vst(e)&&(o=0,a=i.length),n._chart=this.chart,n._datasetIndex=this.index,n._decimated=!!r._decimated,n.points=i;const l=this.resolveDatasetElementOptions(t);this.options.showLine||(l.borderWidth=0),l.segment=this.options.segment,this.updateElement(n,void 0,{animated:!s,options:l},t),this.updateElements(i,o,a,t)}updateElements(t,e,n,i){const r="reset"===i,{iScale:s,vScale:o,_stacked:a,_dataset:l}=this._cachedMeta,{sharedOptions:c,includeOptions:u}=this._getSharedOptions(e,i),h=s.axis,d=o.axis,{spanGaps:p,segment:f}=this.options,m=Yrt(p)?p:Number.POSITIVE_INFINITY,g=this.chart._animationsDisabled||r||"none"===i,y=e+n,b=t.length;let v=e>0&&this.getParsed(e-1);for(let n=0;n<b;++n){const p=t[n],b=g?p:{};if(n<e||n>=y){b.skip=!0;continue}const x=this.getParsed(n),w=grt(x[d]),S=b[h]=s.getPixelForValue(x[h],n),k=b[d]=r||w?o.getBasePixel():o.getPixelForValue(a?this.applyStack(o,x,a):x[d],n);b.skip=isNaN(S)||isNaN(k)||w,b.stop=n>0&&Math.abs(x[h]-v[h])>m,f&&(b.parsed=x,b.raw=l.data[n]),u&&(b.options=c||this.resolveDataElementOptions(n,p.active?"active":i)),g||this.updateElement(p,n,b,i),v=x}}getMaxOverflow(){const t=this._cachedMeta,e=t.dataset,n=e.options&&e.options.borderWidth||0,i=t.data||[];if(!i.length)return n;const r=i[0].size(this.resolveDataElementOptions(0)),s=i[i.length-1].size(this.resolveDataElementOptions(i.length-1));return Math.max(n,r,s)/2}draw(){const t=this._cachedMeta;t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis),super.draw()}}class Pat extends wat{static id="polarArea";static defaults={dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0};static overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:n,color:i}}=t.legend.options;return e.labels.map(((e,r)=>{const s=t.getDatasetMeta(0).controller.getStyle(r);return{text:e,fillStyle:s.backgroundColor,strokeStyle:s.borderColor,fontColor:i,lineWidth:s.borderWidth,pointStyle:n,hidden:!t.getDataVisibility(r),index:r}}))}return[]}},onClick(t,e,n){n.chart.toggleDataVisibility(e.index),n.chart.update()}}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}};constructor(t,e){super(t,e),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(t){const e=this._cachedMeta,n=this.chart,i=n.data.labels||[],r=Ist(e._parsed[t].r,n.options.locale);return{label:i[t]||"",value:r}}parseObjectData(t,e,n,i){return Cot.bind(this)(t,e,n,i)}update(t){const e=this._cachedMeta.data;this._updateRadius(),this.updateElements(e,0,e.length,t)}getMinMax(){const t=this._cachedMeta,e={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return t.data.forEach(((t,n)=>{const i=this.getParsed(n).r;!isNaN(i)&&this.chart.getDataVisibility(n)&&(i<e.min&&(e.min=i),i>e.max&&(e.max=i))})),e}_updateRadius(){const t=this.chart,e=t.chartArea,n=t.options,i=Math.min(e.right-e.left,e.bottom-e.top),r=Math.max(i/2,0),s=(r-Math.max(n.cutoutPercentage?r/100*n.cutoutPercentage:1,0))/t.getVisibleDatasetCount();this.outerRadius=r-s*this.index,this.innerRadius=this.outerRadius-s}updateElements(t,e,n,i){const r="reset"===i,s=this.chart,o=s.options.animation,a=this._cachedMeta.rScale,l=a.xCenter,c=a.yCenter,u=a.getIndexAngle(0)-.5*Frt;let h,d=u;const p=360/this.countVisibleElements();for(h=0;h<e;++h)d+=this._computeAngle(h,i,p);for(h=e;h<e+n;h++){const e=t[h];let n=d,f=d+this._computeAngle(h,i,p),m=s.getDataVisibility(h)?a.getDistanceFromCenterForValue(this.getParsed(h).r):0;d=f,r&&(o.animateScale&&(m=0),o.animateRotate&&(n=f=u));const g={x:l,y:c,innerRadius:0,outerRadius:m,startAngle:n,endAngle:f,options:this.resolveDataElementOptions(h,e.active?"active":i)};this.updateElement(e,h,g,i)}}countVisibleElements(){const t=this._cachedMeta;let e=0;return t.data.forEach(((t,n)=>{!isNaN(this.getParsed(n).r)&&this.chart.getDataVisibility(n)&&e++})),e}_computeAngle(t,e,n){return this.chart.getDataVisibility(t)?Jrt(this.resolveDataElementOptions(t,e).angle||n):0}}class Oat extends Nat{static id="pie";static defaults={cutout:0,rotation:0,circumference:360,radius:"100%"}}class Lat extends wat{static id="radar";static defaults={datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}};static overrides={aspectRatio:1,scales:{r:{type:"radialLinear"}}};getLabelAndValue(t){const e=this._cachedMeta.vScale,n=this.getParsed(t);return{label:e.getLabels()[t],value:""+e.getLabelForValue(n[e.axis])}}parseObjectData(t,e,n,i){return Cot.bind(this)(t,e,n,i)}update(t){const e=this._cachedMeta,n=e.dataset,i=e.data||[],r=e.iScale.getLabels();if(n.points=i,"resize"!==t){const e=this.resolveDatasetElementOptions(t);this.options.showLine||(e.borderWidth=0);const s={_loop:!0,_fullLoop:r.length===i.length,options:e};this.updateElement(n,void 0,s,t)}this.updateElements(i,0,i.length,t)}updateElements(t,e,n,i){const r=this._cachedMeta.rScale,s="reset"===i;for(let o=e;o<e+n;o++){const e=t[o],n=this.resolveDataElementOptions(o,e.active?"active":i),a=r.getPointPositionForValue(o,this.getParsed(o).r),l=s?r.xCenter:a.x,c=s?r.yCenter:a.y,u={x:l,y:c,angle:a.angle,skip:isNaN(l)||isNaN(c),options:n};this.updateElement(e,o,u,i)}}}class Dat extends wat{static id="scatter";static defaults={datasetElementType:!1,dataElementType:"point",showLine:!1,fill:!1};static overrides={interaction:{mode:"point"},scales:{x:{type:"linear"},y:{type:"linear"}}};getLabelAndValue(t){const e=this._cachedMeta,n=this.chart.data.labels||[],{xScale:i,yScale:r}=e,s=this.getParsed(t),o=i.getLabelForValue(s.x),a=r.getLabelForValue(s.y);return{label:n[t]||"",value:"("+o+", "+a+")"}}update(t){const e=this._cachedMeta,{data:n=[]}=e,i=this.chart._animationsDisabled;let{start:r,count:s}=bst(e,n,i);if(this._drawStart=r,this._drawCount=s,vst(e)&&(r=0,s=n.length),this.options.showLine){this.datasetElementType||this.addElements();const{dataset:r,_dataset:s}=e;r._chart=this.chart,r._datasetIndex=this.index,r._decimated=!!s._decimated,r.points=n;const o=this.resolveDatasetElementOptions(t);o.segment=this.options.segment,this.updateElement(r,void 0,{animated:!i,options:o},t)}else this.datasetElementType&&(delete e.dataset,this.datasetElementType=!1);this.updateElements(n,r,s,t)}addElements(){const{showLine:t}=this.options;!this.datasetElementType&&t&&(this.datasetElementType=this.chart.registry.getElement("line")),super.addElements()}updateElements(t,e,n,i){const r="reset"===i,{iScale:s,vScale:o,_stacked:a,_dataset:l}=this._cachedMeta,c=this.resolveDataElementOptions(e,i),u=this.getSharedOptions(c),h=this.includeOptions(i,u),d=s.axis,p=o.axis,{spanGaps:f,segment:m}=this.options,g=Yrt(f)?f:Number.POSITIVE_INFINITY,y=this.chart._animationsDisabled||r||"none"===i;let b=e>0&&this.getParsed(e-1);for(let c=e;c<e+n;++c){const e=t[c],n=this.getParsed(c),f=y?e:{},v=grt(n[p]),x=f[d]=s.getPixelForValue(n[d],c),w=f[p]=r||v?o.getBasePixel():o.getPixelForValue(a?this.applyStack(o,n,a):n[p],c);f.skip=isNaN(x)||isNaN(w)||v,f.stop=c>0&&Math.abs(n[d]-b[d])>g,m&&(f.parsed=n,f.raw=l.data[c]),h&&(f.options=u||this.resolveDataElementOptions(c,e.active?"active":i)),y||this.updateElement(e,c,f,i),b=n}this.updateSharedOptions(u,i,c)}getMaxOverflow(){const t=this._cachedMeta,e=t.data||[];if(!this.options.showLine){let t=0;for(let n=e.length-1;n>=0;--n)t=Math.max(t,e[n].size(this.resolveDataElementOptions(n))/2);return t>0&&t}const n=t.dataset,i=n.options&&n.options.borderWidth||0;if(!e.length)return i;const r=e[0].size(this.resolveDataElementOptions(0)),s=e[e.length-1].size(this.resolveDataElementOptions(e.length-1));return Math.max(i,r,s)/2}}function Fat(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}class zat{static override(t){Object.assign(zat.prototype,t)}options;constructor(t){this.options=t||{}}init(){}formats(){return Fat()}parse(){return Fat()}format(){return Fat()}add(){return Fat()}diff(){return Fat()}startOf(){return Fat()}endOf(){return Fat()}}var Bat={_date:zat};function Uat(t,e,n,i){const{controller:r,data:s,_sorted:o}=t,a=r._cachedMeta.iScale;if(a&&e===a.axis&&"r"!==e&&o&&s.length){const t=a._reversePixels?ust:cst;if(!i)return t(s,e,n);if(r._sharedOptions){const i=s[0],r="function"==typeof i.getRange&&i.getRange(e);if(r){const i=t(s,e,n-r),o=t(s,e,n+r);return{lo:i.lo,hi:o.hi}}}}return{lo:0,hi:s.length-1}}function Vat(t,e,n,i,r){const s=t.getSortedVisibleDatasetMetas(),o=n[e];for(let t=0,n=s.length;t<n;++t){const{index:n,data:a}=s[t],{lo:l,hi:c}=Uat(s[t],e,o,r);for(let t=l;t<=c;++t){const e=a[t];e.skip||i(e,n,t)}}}function Wat(t,e,n,i,r){const s=[];if(!r&&!t.isPointInArea(e))return s;return Vat(t,n,e,(function(n,o,a){(r||jst(n,t.chartArea,0))&&n.inRange(e.x,e.y,i)&&s.push({element:n,datasetIndex:o,index:a})}),!0),s}function Hat(t,e,n,i,r,s){let o=[];const a=function(t){const e=-1!==t.indexOf("x"),n=-1!==t.indexOf("y");return function(t,i){const r=e?Math.abs(t.x-i.x):0,s=n?Math.abs(t.y-i.y):0;return Math.sqrt(Math.pow(r,2)+Math.pow(s,2))}}(n);let l=Number.POSITIVE_INFINITY;return Vat(t,n,e,(function(n,c,u){const h=n.inRange(e.x,e.y,r);if(i&&!h)return;const d=n.getCenterPoint(r);if(!(!!s||t.isPointInArea(d))&&!h)return;const p=a(e,d);p<l?(o=[{element:n,datasetIndex:c,index:u}],l=p):p===l&&o.push({element:n,datasetIndex:c,index:u})})),o}function jat(t,e,n,i,r,s){return s||t.isPointInArea(e)?"r"!==n||i?Hat(t,e,n,i,r,s):function(t,e,n,i){let r=[];return Vat(t,n,e,(function(t,n,s){const{startAngle:o,endAngle:a}=t.getProps(["startAngle","endAngle"],i),{angle:l}=est(t,{x:e.x,y:e.y});sst(l,o,a)&&r.push({element:t,datasetIndex:n,index:s})})),r}(t,e,n,r):[]}function Gat(t,e,n,i,r){const s=[],o="x"===n?"inXRange":"inYRange";let a=!1;return Vat(t,n,e,((t,i,l)=>{t[o](e[n],r)&&(s.push({element:t,datasetIndex:i,index:l}),a=a||t.inRange(e.x,e.y,r))})),i&&!a?[]:s}var qat={evaluateInteractionItems:Vat,modes:{index(t,e,n,i){const r=zot(e,t),s=n.axis||"x",o=n.includeInvisible||!1,a=n.intersect?Wat(t,r,s,i,o):jat(t,r,s,!1,i,o),l=[];return a.length?(t.getSortedVisibleDatasetMetas().forEach((t=>{const e=a[0].index,n=t.data[e];n&&!n.skip&&l.push({element:n,datasetIndex:t.index,index:e})})),l):[]},dataset(t,e,n,i){const r=zot(e,t),s=n.axis||"xy",o=n.includeInvisible||!1;let a=n.intersect?Wat(t,r,s,i,o):jat(t,r,s,!1,i,o);if(a.length>0){const e=a[0].datasetIndex,n=t.getDatasetMeta(e).data;a=[];for(let t=0;t<n.length;++t)a.push({element:n[t],datasetIndex:e,index:t})}return a},point:(t,e,n,i)=>Wat(t,zot(e,t),n.axis||"xy",i,n.includeInvisible||!1),nearest(t,e,n,i){const r=zot(e,t),s=n.axis||"xy",o=n.includeInvisible||!1;return jat(t,r,s,n.intersect,i,o)},x:(t,e,n,i)=>Gat(t,zot(e,t),"x",n.intersect,i),y:(t,e,n,i)=>Gat(t,zot(e,t),"y",n.intersect,i)}};const Xat=["left","top","right","bottom"];function Kat(t,e){return t.filter((t=>t.pos===e))}function Yat(t,e){return t.filter((t=>-1===Xat.indexOf(t.pos)&&t.box.axis===e))}function Zat(t,e){return t.sort(((t,n)=>{const i=e?n:t,r=e?t:n;return i.weight===r.weight?i.index-r.index:i.weight-r.weight}))}function Jat(t,e){const n=function(t){const e={};for(const n of t){const{stack:t,pos:i,stackWeight:r}=n;if(!t||!Xat.includes(i))continue;const s=e[t]||(e[t]={count:0,placed:0,weight:0,size:0});s.count++,s.weight+=r}return e}(t),{vBoxMaxWidth:i,hBoxMaxHeight:r}=e;let s,o,a;for(s=0,o=t.length;s<o;++s){a=t[s];const{fullSize:o}=a.box,l=n[a.stack],c=l&&a.stackWeight/l.weight;a.horizontal?(a.width=c?c*i:o&&e.availableWidth,a.height=r):(a.width=i,a.height=c?c*r:o&&e.availableHeight)}return n}function Qat(t,e,n,i){return Math.max(t[n],e[n])+Math.max(t[i],e[i])}function tlt(t,e){t.top=Math.max(t.top,e.top),t.left=Math.max(t.left,e.left),t.bottom=Math.max(t.bottom,e.bottom),t.right=Math.max(t.right,e.right)}function elt(t,e,n,i){const{pos:r,box:s}=n,o=t.maxPadding;if(!brt(r)){n.size&&(t[r]-=n.size);const e=i[n.stack]||{size:0,count:1};e.size=Math.max(e.size,n.horizontal?s.height:s.width),n.size=e.size/e.count,t[r]+=n.size}s.getPadding&&tlt(o,s.getPadding());const a=Math.max(0,e.outerWidth-Qat(o,t,"left","right")),l=Math.max(0,e.outerHeight-Qat(o,t,"top","bottom")),c=a!==t.w,u=l!==t.h;return t.w=a,t.h=l,n.horizontal?{same:c,other:u}:{same:u,other:c}}function nlt(t,e){const n=e.maxPadding;function i(t){const i={left:0,top:0,right:0,bottom:0};return t.forEach((t=>{i[t]=Math.max(e[t],n[t])})),i}return i(t?["left","right"]:["top","bottom"])}function ilt(t,e,n,i){const r=[];let s,o,a,l,c,u;for(s=0,o=t.length,c=0;s<o;++s){a=t[s],l=a.box,l.update(a.width||e.w,a.height||e.h,nlt(a.horizontal,e));const{same:o,other:h}=elt(e,n,a,i);c|=o&&r.length,u=u||h,l.fullSize||r.push(a)}return c&&ilt(r,e,n,i)||u}function rlt(t,e,n,i,r){t.top=n,t.left=e,t.right=e+i,t.bottom=n+r,t.width=i,t.height=r}function slt(t,e,n,i){const r=n.padding;let{x:s,y:o}=e;for(const a of t){const t=a.box,l=i[a.stack]||{count:1,placed:0,weight:1},c=a.stackWeight/l.weight||1;if(a.horizontal){const i=e.w*c,s=l.size||t.height;Ort(l.start)&&(o=l.start),t.fullSize?rlt(t,r.left,o,n.outerWidth-r.right-r.left,s):rlt(t,e.left+l.placed,o,i,s),l.start=o,l.placed+=i,o=t.bottom}else{const i=e.h*c,o=l.size||t.width;Ort(l.start)&&(s=l.start),t.fullSize?rlt(t,s,r.top,o,n.outerHeight-r.bottom-r.top):rlt(t,s,e.top+l.placed,o,i),l.start=s,l.placed+=i,s=t.right}}e.x=s,e.y=o}var olt={addBox(t,e){t.boxes||(t.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||"top",e.weight=e.weight||0,e._layers=e._layers||function(){return[{z:0,draw(t){e.draw(t)}}]},t.boxes.push(e)},removeBox(t,e){const n=t.boxes?t.boxes.indexOf(e):-1;-1!==n&&t.boxes.splice(n,1)},configure(t,e,n){e.fullSize=n.fullSize,e.position=n.position,e.weight=n.weight},update(t,e,n,i){if(!t)return;const r=aot(t.options.layout.padding),s=Math.max(e-r.width,0),o=Math.max(n-r.height,0),a=function(t){const e=function(t){const e=[];let n,i,r,s,o,a;for(n=0,i=(t||[]).length;n<i;++n)r=t[n],({position:s,options:{stack:o,stackWeight:a=1}}=r),e.push({index:n,box:r,pos:s,horizontal:r.isHorizontal(),weight:r.weight,stack:o&&s+o,stackWeight:a});return e}(t),n=Zat(e.filter((t=>t.box.fullSize)),!0),i=Zat(Kat(e,"left"),!0),r=Zat(Kat(e,"right")),s=Zat(Kat(e,"top"),!0),o=Zat(Kat(e,"bottom")),a=Yat(e,"x"),l=Yat(e,"y");return{fullSize:n,leftAndTop:i.concat(s),rightAndBottom:r.concat(l).concat(o).concat(a),chartArea:Kat(e,"chartArea"),vertical:i.concat(r).concat(l),horizontal:s.concat(o).concat(a)}}(t.boxes),l=a.vertical,c=a.horizontal;Crt(t.boxes,(t=>{"function"==typeof t.beforeLayout&&t.beforeLayout()}));const u=l.reduce(((t,e)=>e.box.options&&!1===e.box.options.display?t:t+1),0)||1,h=Object.freeze({outerWidth:e,outerHeight:n,padding:r,availableWidth:s,availableHeight:o,vBoxMaxWidth:s/2/u,hBoxMaxHeight:o/2}),d=Object.assign({},r);tlt(d,aot(i));const p=Object.assign({maxPadding:d,w:s,h:o,x:r.left,y:r.top},r),f=Jat(l.concat(c),h);ilt(a.fullSize,p,h,f),ilt(l,p,h,f),ilt(c,p,h,f)&&ilt(l,p,h,f),function(t){const e=t.maxPadding;function n(n){const i=Math.max(e[n]-t[n],0);return t[n]+=i,i}t.y+=n("top"),t.x+=n("left"),n("right"),n("bottom")}(p),slt(a.leftAndTop,p,h,f),p.x+=p.w,p.y+=p.h,slt(a.rightAndBottom,p,h,f),t.chartArea={left:p.left,top:p.top,right:p.left+p.w,bottom:p.top+p.h,height:p.h,width:p.w},Crt(a.chartArea,(e=>{const n=e.box;Object.assign(n,t.chartArea),n.update(p.w,p.h,{left:0,top:0,right:0,bottom:0})}))}};class alt{acquireContext(t,e){}releaseContext(t){return!1}addEventListener(t,e,n){}removeEventListener(t,e,n){}getDevicePixelRatio(){return 1}getMaximumSize(t,e,n,i){return e=Math.max(0,e||t.width),n=n||t.height,{width:e,height:Math.max(0,i?Math.floor(e/i):n)}}isAttached(t){return!0}updateConfig(t){}}class llt extends alt{acquireContext(t){return t&&t.getContext&&t.getContext("2d")||null}updateConfig(t){t.options.animation=!1}}const clt="$chartjs",ult={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},hlt=t=>null===t||""===t;const dlt=!!Wot&&{passive:!0};function plt(t,e,n){t.canvas.removeEventListener(e,n,dlt)}function flt(t,e){for(const n of t)if(n===e||n.contains(e))return!0}function mlt(t,e,n){const i=t.canvas,r=new MutationObserver((t=>{let e=!1;for(const n of t)e=e||flt(n.addedNodes,i),e=e&&!flt(n.removedNodes,i);e&&n()}));return r.observe(document,{childList:!0,subtree:!0}),r}function glt(t,e,n){const i=t.canvas,r=new MutationObserver((t=>{let e=!1;for(const n of t)e=e||flt(n.removedNodes,i),e=e&&!flt(n.addedNodes,i);e&&n()}));return r.observe(document,{childList:!0,subtree:!0}),r}const ylt=new Map;let blt=0;function vlt(){const t=window.devicePixelRatio;t!==blt&&(blt=t,ylt.forEach(((e,n)=>{n.currentDevicePixelRatio!==t&&e()})))}function xlt(t,e,n){const i=t.canvas,r=i&&Rot(i);if(!r)return;const s=mst(((t,e)=>{const i=r.clientWidth;n(t,e),i<r.clientWidth&&n()}),window),o=new ResizeObserver((t=>{const e=t[0],n=e.contentRect.width,i=e.contentRect.height;0===n&&0===i||s(n,i)}));return o.observe(r),function(t,e){ylt.size||window.addEventListener("resize",vlt),ylt.set(t,e)}(t,s),o}function wlt(t,e,n){n&&n.disconnect(),"resize"===e&&function(t){ylt.delete(t),ylt.size||window.removeEventListener("resize",vlt)}(t)}function Slt(t,e,n){const i=t.canvas,r=mst((e=>{null!==t.ctx&&n(function(t,e){const n=ult[t.type]||t.type,{x:i,y:r}=zot(t,e);return{type:n,chart:e,native:t,x:void 0!==i?i:null,y:void 0!==r?r:null}}(e,t))}),t);return function(t,e,n){t.addEventListener(e,n,dlt)}(i,e,r),r}class klt extends alt{acquireContext(t,e){const n=t&&t.getContext&&t.getContext("2d");return n&&n.canvas===t?(function(t,e){const n=t.style,i=t.getAttribute("height"),r=t.getAttribute("width");if(t[clt]={initial:{height:i,width:r,style:{display:n.display,height:n.height,width:n.width}}},n.display=n.display||"block",n.boxSizing=n.boxSizing||"border-box",hlt(r)){const e=Hot(t,"width");void 0!==e&&(t.width=e)}if(hlt(i))if(""===t.style.height)t.height=t.width/(e||2);else{const e=Hot(t,"height");void 0!==e&&(t.height=e)}}(t,e),n):null}releaseContext(t){const e=t.canvas;if(!e[clt])return!1;const n=e[clt].initial;["height","width"].forEach((t=>{const i=n[t];grt(i)?e.removeAttribute(t):e.setAttribute(t,i)}));const i=n.style||{};return Object.keys(i).forEach((t=>{e.style[t]=i[t]})),e.width=e.width,delete e[clt],!0}addEventListener(t,e,n){this.removeEventListener(t,e);const i=t.$proxies||(t.$proxies={}),r={attach:mlt,detach:glt,resize:xlt}[e]||Slt;i[e]=r(t,e,n)}removeEventListener(t,e){const n=t.$proxies||(t.$proxies={}),i=n[e];if(!i)return;({attach:wlt,detach:wlt,resize:wlt}[e]||plt)(t,e,i),n[e]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(t,e,n,i){return Uot(t,e,n,i)}isAttached(t){const e=Rot(t);return!(!e||!e.isConnected)}}let Clt=class{static defaults={};static defaultRoutes=void 0;x;y;active=!1;options;$animations;tooltipPosition(t){const{x:e,y:n}=this.getProps(["x","y"],t);return{x:e,y:n}}hasValue(){return Yrt(this.x)&&Yrt(this.y)}getProps(t,e){const n=this.$animations;if(!e||!n)return this;const i={};return t.forEach((t=>{i[t]=n[t]&&n[t].active()?n[t]._to:this[t]})),i}};function Tlt(t,e){const n=t.options.ticks,i=function(t){const e=t.options.offset,n=t._tickSize(),i=t._length/n+(e?0:1),r=t._maxLength/n;return Math.floor(Math.min(i,r))}(t),r=Math.min(n.maxTicksLimit||i,i),s=n.major.enabled?function(t){const e=[];let n,i;for(n=0,i=t.length;n<i;n++)t[n].major&&e.push(n);return e}(e):[],o=s.length,a=s[0],l=s[o-1],c=[];if(o>r)return function(t,e,n,i){let r,s=0,o=n[0];for(i=Math.ceil(i),r=0;r<t.length;r++)r===o&&(e.push(t[r]),s++,o=n[s*i])}(e,c,s,o/r),c;const u=function(t,e,n){const i=function(t){const e=t.length;let n,i;if(e<2)return!1;for(i=t[0],n=1;n<e;++n)if(t[n]-t[n-1]!==i)return!1;return i}(t),r=e.length/n;if(!i)return Math.max(r,1);const s=function(t){const e=[],n=Math.sqrt(t);let i;for(i=1;i<n;i++)t%i==0&&(e.push(i),e.push(t/i));return n===(0|n)&&e.push(n),e.sort(((t,e)=>t-e)).pop(),e}(i);for(let t=0,e=s.length-1;t<e;t++){const e=s[t];if(e>r)return e}return Math.max(r,1)}(s,e,r);if(o>0){let t,n;const i=o>1?Math.round((l-a)/(o-1)):null;for(_lt(e,c,u,grt(i)?0:a-i,a),t=0,n=o-1;t<n;t++)_lt(e,c,u,s[t],s[t+1]);return _lt(e,c,u,l,grt(i)?e.length:l+i),c}return _lt(e,c,u),c}function _lt(t,e,n,i,r){const s=wrt(i,0),o=Math.min(wrt(r,t.length),t.length);let a,l,c,u=0;for(n=Math.ceil(n),r&&(a=r-i,n=a/Math.floor(a/n)),c=s;c<0;)u++,c=Math.round(s+u*n);for(l=Math.max(s,0);l<o;l++)l===c&&(e.push(t[l]),u++,c=Math.round(s+u*n))}const Elt=(t,e,n)=>"top"===e||"left"===e?t[e]+n:t[e]-n,Mlt=(t,e)=>Math.min(e||t,t);function $lt(t,e){const n=[],i=t.length/e,r=t.length;let s=0;for(;s<r;s+=i)n.push(t[Math.floor(s)]);return n}function Ilt(t,e,n){const i=t.ticks.length,r=Math.min(e,i-1),s=t._startPixel,o=t._endPixel,a=1e-6;let l,c=t.getPixelForTick(r);if(!(n&&(l=1===i?Math.max(c-s,o-c):0===e?(t.getPixelForTick(1)-c)/2:(c-t.getPixelForTick(r-1))/2,c+=r<e?l:-l,c<s-a||c>o+a)))return c}function Alt(t){return t.drawTicks?t.tickLength:0}function Nlt(t,e){if(!t.display)return 0;const n=lot(t.font,e),i=aot(t.padding);return(yrt(t.text)?t.text.length:1)*n.lineHeight+i.height}function Rlt(t,e,n){let i=gst(t);return(n&&"right"!==e||!n&&"right"===e)&&(i=(t=>"left"===t?"right":"right"===t?"left":t)(i)),i}class Plt extends Clt{constructor(t){super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(t){this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}parse(t,e){return t}getUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:n,_suggestedMax:i}=this;return t=xrt(t,Number.POSITIVE_INFINITY),e=xrt(e,Number.NEGATIVE_INFINITY),n=xrt(n,Number.POSITIVE_INFINITY),i=xrt(i,Number.NEGATIVE_INFINITY),{min:xrt(t,n),max:xrt(e,i),minDefined:vrt(t),maxDefined:vrt(e)}}getMinMax(t){let e,{min:n,max:i,minDefined:r,maxDefined:s}=this.getUserBounds();if(r&&s)return{min:n,max:i};const o=this.getMatchingVisibleMetas();for(let a=0,l=o.length;a<l;++a)e=o[a].controller.getMinMax(this,t),r||(n=Math.min(n,e.min)),s||(i=Math.max(i,e.max));return n=s&&n>i?i:n,i=r&&n>i?n:i,{min:xrt(n,xrt(i,n)),max:xrt(i,xrt(n,i))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}getLabelItems(t=this.chart.chartArea){return this._labelItems||(this._labelItems=this._computeLabelItems(t))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){krt(this.options.beforeUpdate,[this])}update(t,e,n){const{beginAtZero:i,grace:r,ticks:s}=this.options,o=s.sampleSize;this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=n=Object.assign({left:0,right:0,top:0,bottom:0},n),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+n.left+n.right:this.height+n.top+n.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=function(t,e,n){const{min:i,max:r}=t,s=Srt(e,(r-i)/2),o=(t,e)=>n&&0===t?0:t+e;return{min:o(i,-Math.abs(s)),max:o(r,s)}}(this,r,i),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const a=o<this.ticks.length;this._convertTicksToLabels(a?$lt(this.ticks,o):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),s.display&&(s.autoSkip||"auto"===s.source)&&(this.ticks=Tlt(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),a&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let t,e,n=this.options.reverse;this.isHorizontal()?(t=this.left,e=this.right):(t=this.top,e=this.bottom,n=!n),this._startPixel=t,this._endPixel=e,this._reversePixels=n,this._length=e-t,this._alignToPixels=this.options.alignToPixels}afterUpdate(){krt(this.options.afterUpdate,[this])}beforeSetDimensions(){krt(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){krt(this.options.afterSetDimensions,[this])}_callHooks(t){this.chart.notifyPlugins(t,this.getContext()),krt(this.options[t],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){krt(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(t){const e=this.options.ticks;let n,i,r;for(n=0,i=t.length;n<i;n++)r=t[n],r.label=krt(e.callback,[r.value,n,t],this)}afterTickToLabelConversion(){krt(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){krt(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const t=this.options,e=t.ticks,n=Mlt(this.ticks.length,t.ticks.maxTicksLimit),i=e.minRotation||0,r=e.maxRotation;let s,o,a,l=i;if(!this._isVisible()||!e.display||i>=r||n<=1||!this.isHorizontal())return void(this.labelRotation=i);const c=this._getLabelSizes(),u=c.widest.width,h=c.highest.height,d=ost(this.chart.width-u,0,this.maxWidth);s=t.offset?this.maxWidth/n:d/(n-1),u+6>s&&(s=d/(n-(t.offset?.5:1)),o=this.maxHeight-Alt(t.grid)-e.padding-Nlt(t.title,this.chart.options.font),a=Math.sqrt(u*u+h*h),l=Qrt(Math.min(Math.asin(ost((c.highest.height+6)/s,-1,1)),Math.asin(ost(o/a,-1,1))-Math.asin(ost(h/a,-1,1)))),l=Math.max(i,Math.min(r,l))),this.labelRotation=l}afterCalculateLabelRotation(){krt(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){krt(this.options.beforeFit,[this])}fit(){const t={width:0,height:0},{chart:e,options:{ticks:n,title:i,grid:r}}=this,s=this._isVisible(),o=this.isHorizontal();if(s){const s=Nlt(i,e.options.font);if(o?(t.width=this.maxWidth,t.height=Alt(r)+s):(t.height=this.maxHeight,t.width=Alt(r)+s),n.display&&this.ticks.length){const{first:e,last:i,widest:r,highest:s}=this._getLabelSizes(),a=2*n.padding,l=Jrt(this.labelRotation),c=Math.cos(l),u=Math.sin(l);if(o){const e=n.mirror?0:u*r.width+c*s.height;t.height=Math.min(this.maxHeight,t.height+e+a)}else{const e=n.mirror?0:c*r.width+u*s.height;t.width=Math.min(this.maxWidth,t.width+e+a)}this._calculatePadding(e,i,u,c)}}this._handleMargins(),o?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}_calculatePadding(t,e,n,i){const{ticks:{align:r,padding:s},position:o}=this.options,a=0!==this.labelRotation,l="top"!==o&&"x"===this.axis;if(this.isHorizontal()){const o=this.getPixelForTick(0)-this.left,c=this.right-this.getPixelForTick(this.ticks.length-1);let u=0,h=0;a?l?(u=i*t.width,h=n*e.height):(u=n*t.height,h=i*e.width):"start"===r?h=e.width:"end"===r?u=t.width:"inner"!==r&&(u=t.width/2,h=e.width/2),this.paddingLeft=Math.max((u-o+s)*this.width/(this.width-o),0),this.paddingRight=Math.max((h-c+s)*this.width/(this.width-c),0)}else{let n=e.height/2,i=t.height/2;"start"===r?(n=0,i=t.height):"end"===r&&(n=e.height,i=0),this.paddingTop=n+s,this.paddingBottom=i+s}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){krt(this.options.afterFit,[this])}isHorizontal(){const{axis:t,position:e}=this.options;return"top"===e||"bottom"===e||"x"===t}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){let e,n;for(this.beforeTickToLabelConversion(),this.generateTickLabels(t),e=0,n=t.length;e<n;e++)grt(t[e].label)&&(t.splice(e,1),n--,e--);this.afterTickToLabelConversion()}_getLabelSizes(){let t=this._labelSizes;if(!t){const e=this.options.ticks.sampleSize;let n=this.ticks;e<n.length&&(n=$lt(n,e)),this._labelSizes=t=this._computeLabelSizes(n,n.length,this.options.ticks.maxTicksLimit)}return t}_computeLabelSizes(t,e,n){const{ctx:i,_longestTextCache:r}=this,s=[],o=[],a=Math.floor(e/Mlt(e,n));let l,c,u,h,d,p,f,m,g,y,b,v=0,x=0;for(l=0;l<e;l+=a){if(h=t[l].label,d=this._resolveTickFontOptions(l),i.font=p=d.string,f=r[p]=r[p]||{data:{},gc:[]},m=d.lineHeight,g=y=0,grt(h)||yrt(h)){if(yrt(h))for(c=0,u=h.length;c<u;++c)b=h[c],grt(b)||yrt(b)||(g=zst(i,f.data,f.gc,g,b),y+=m)}else g=zst(i,f.data,f.gc,g,h),y=m;s.push(g),o.push(y),v=Math.max(g,v),x=Math.max(y,x)}!function(t,e){Crt(t,(t=>{const n=t.gc,i=n.length/2;let r;if(i>e){for(r=0;r<i;++r)delete t.data[n[r]];n.splice(0,i)}}))}(r,e);const w=s.indexOf(v),S=o.indexOf(x),k=t=>({width:s[t]||0,height:o[t]||0});return{first:k(0),last:k(e-1),widest:k(w),highest:k(S),widths:s,heights:o}}getLabelForValue(t){return t}getPixelForValue(t,e){return NaN}getValueForPixel(t){}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getPixelForDecimal(t){this._reversePixels&&(t=1-t);const e=this._startPixel+t*this._length;return ost(this._alignToPixels?Ust(this.chart,e,0):e,-32768,32767)}getDecimalForPixel(t){const e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:t,max:e}=this;return t<0&&e<0?e:t>0&&e>0?t:0}getContext(t){const e=this.ticks||[];if(t>=0&&t<e.length){const n=e[t];return n.$context||(n.$context=function(t,e,n){return uot(t,{tick:n,index:e,type:"tick"})}(this.getContext(),t,n))}return this.$context||(this.$context=function(t,e){return uot(t,{scale:e,type:"scale"})}(this.chart.getContext(),this))}_tickSize(){const t=this.options.ticks,e=Jrt(this.labelRotation),n=Math.abs(Math.cos(e)),i=Math.abs(Math.sin(e)),r=this._getLabelSizes(),s=t.autoSkipPadding||0,o=r?r.widest.width+s:0,a=r?r.highest.height+s:0;return this.isHorizontal()?a*n>o*i?o/n:a/i:a*i<o*n?a/n:o/i}_isVisible(){const t=this.options.display;return"auto"!==t?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){const e=this.axis,n=this.chart,i=this.options,{grid:r,position:s,border:o}=i,a=r.offset,l=this.isHorizontal(),c=this.ticks.length+(a?1:0),u=Alt(r),h=[],d=o.setContext(this.getContext()),p=d.display?d.width:0,f=p/2,m=function(t){return Ust(n,t,p)};let g,y,b,v,x,w,S,k,C,T,_,E;if("top"===s)g=m(this.bottom),w=this.bottom-u,k=g-f,T=m(t.top)+f,E=t.bottom;else if("bottom"===s)g=m(this.top),T=t.top,E=m(t.bottom)-f,w=g+f,k=this.top+u;else if("left"===s)g=m(this.right),x=this.right-u,S=g-f,C=m(t.left)+f,_=t.right;else if("right"===s)g=m(this.left),C=t.left,_=m(t.right)-f,x=g+f,S=this.left+u;else if("x"===e){if("center"===s)g=m((t.top+t.bottom)/2+.5);else if(brt(s)){const t=Object.keys(s)[0],e=s[t];g=m(this.chart.scales[t].getPixelForValue(e))}T=t.top,E=t.bottom,w=g+f,k=w+u}else if("y"===e){if("center"===s)g=m((t.left+t.right)/2);else if(brt(s)){const t=Object.keys(s)[0],e=s[t];g=m(this.chart.scales[t].getPixelForValue(e))}x=g-f,S=x-u,C=t.left,_=t.right}const M=wrt(i.ticks.maxTicksLimit,c),$=Math.max(1,Math.ceil(c/M));for(y=0;y<c;y+=$){const t=this.getContext(y),e=r.setContext(t),i=o.setContext(t),s=e.lineWidth,c=e.color,u=i.dash||[],d=i.dashOffset,p=e.tickWidth,f=e.tickColor,m=e.tickBorderDash||[],g=e.tickBorderDashOffset;b=Ilt(this,y,a),void 0!==b&&(v=Ust(n,b,s),l?x=S=C=_=v:w=k=T=E=v,h.push({tx1:x,ty1:w,tx2:S,ty2:k,x1:C,y1:T,x2:_,y2:E,width:s,color:c,borderDash:u,borderDashOffset:d,tickWidth:p,tickColor:f,tickBorderDash:m,tickBorderDashOffset:g}))}return this._ticksLength=c,this._borderValue=g,h}_computeLabelItems(t){const e=this.axis,n=this.options,{position:i,ticks:r}=n,s=this.isHorizontal(),o=this.ticks,{align:a,crossAlign:l,padding:c,mirror:u}=r,h=Alt(n.grid),d=h+c,p=u?-c:d,f=-Jrt(this.labelRotation),m=[];let g,y,b,v,x,w,S,k,C,T,_,E,M="middle";if("top"===i)w=this.bottom-p,S=this._getXAxisLabelAlignment();else if("bottom"===i)w=this.top+p,S=this._getXAxisLabelAlignment();else if("left"===i){const t=this._getYAxisLabelAlignment(h);S=t.textAlign,x=t.x}else if("right"===i){const t=this._getYAxisLabelAlignment(h);S=t.textAlign,x=t.x}else if("x"===e){if("center"===i)w=(t.top+t.bottom)/2+d;else if(brt(i)){const t=Object.keys(i)[0],e=i[t];w=this.chart.scales[t].getPixelForValue(e)+d}S=this._getXAxisLabelAlignment()}else if("y"===e){if("center"===i)x=(t.left+t.right)/2-d;else if(brt(i)){const t=Object.keys(i)[0],e=i[t];x=this.chart.scales[t].getPixelForValue(e)}S=this._getYAxisLabelAlignment(h).textAlign}"y"===e&&("start"===a?M="top":"end"===a&&(M="bottom"));const $=this._getLabelSizes();for(g=0,y=o.length;g<y;++g){b=o[g],v=b.label;const t=r.setContext(this.getContext(g));k=this.getPixelForTick(g)+r.labelOffset,C=this._resolveTickFontOptions(g),T=C.lineHeight,_=yrt(v)?v.length:1;const e=_/2,n=t.color,a=t.textStrokeColor,c=t.textStrokeWidth;let h,d=S;if(s?(x=k,"inner"===S&&(d=g===y-1?this.options.reverse?"left":"right":0===g?this.options.reverse?"right":"left":"center"),E="top"===i?"near"===l||0!==f?-_*T+T/2:"center"===l?-$.highest.height/2-e*T+T:-$.highest.height+T/2:"near"===l||0!==f?T/2:"center"===l?$.highest.height/2-e*T:$.highest.height-_*T,u&&(E*=-1),0===f||t.showLabelBackdrop||(x+=T/2*Math.sin(f))):(w=k,E=(1-_)*T/2),t.showLabelBackdrop){const e=aot(t.backdropPadding),n=$.heights[g],i=$.widths[g];let r=E-e.top,s=0-e.left;switch(M){case"middle":r-=n/2;break;case"bottom":r-=n}switch(S){case"center":s-=i/2;break;case"right":s-=i}h={left:s,top:r,width:i+e.width,height:n+e.height,color:t.backdropColor}}m.push({label:v,font:C,textOffset:E,options:{rotation:f,color:n,strokeColor:a,strokeWidth:c,textAlign:d,textBaseline:M,translation:[x,w],backdrop:h}})}return m}_getXAxisLabelAlignment(){const{position:t,ticks:e}=this.options;if(-Jrt(this.labelRotation))return"top"===t?"left":"right";let n="center";return"start"===e.align?n="left":"end"===e.align?n="right":"inner"===e.align&&(n="inner"),n}_getYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:n,mirror:i,padding:r}}=this.options,s=t+r,o=this._getLabelSizes().widest.width;let a,l;return"left"===e?i?(l=this.right+r,"near"===n?a="left":"center"===n?(a="center",l+=o/2):(a="right",l+=o)):(l=this.right-s,"near"===n?a="right":"center"===n?(a="center",l-=o/2):(a="left",l=this.left)):"right"===e?i?(l=this.left+r,"near"===n?a="right":"center"===n?(a="center",l-=o/2):(a="left",l-=o)):(l=this.left+s,"near"===n?a="left":"center"===n?(a="center",l+=o/2):(a="right",l=this.right)):a="right",{textAlign:a,x:l}}_computeLabelArea(){if(this.options.ticks.mirror)return;const t=this.chart,e=this.options.position;return"left"===e||"right"===e?{top:0,left:this.left,bottom:t.height,right:this.right}:"top"===e||"bottom"===e?{top:this.top,left:0,bottom:this.bottom,right:t.width}:void 0}drawBackground(){const{ctx:t,options:{backgroundColor:e},left:n,top:i,width:r,height:s}=this;e&&(t.save(),t.fillStyle=e,t.fillRect(n,i,r,s),t.restore())}getLineWidthForValue(t){const e=this.options.grid;if(!this._isVisible()||!e.display)return 0;const n=this.ticks.findIndex((e=>e.value===t));if(n>=0){return e.setContext(this.getContext(n)).lineWidth}return 0}drawGrid(t){const e=this.options.grid,n=this.ctx,i=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));let r,s;const o=(t,e,i)=>{i.width&&i.color&&(n.save(),n.lineWidth=i.width,n.strokeStyle=i.color,n.setLineDash(i.borderDash||[]),n.lineDashOffset=i.borderDashOffset,n.beginPath(),n.moveTo(t.x,t.y),n.lineTo(e.x,e.y),n.stroke(),n.restore())};if(e.display)for(r=0,s=i.length;r<s;++r){const t=i[r];e.drawOnChartArea&&o({x:t.x1,y:t.y1},{x:t.x2,y:t.y2},t),e.drawTicks&&o({x:t.tx1,y:t.ty1},{x:t.tx2,y:t.ty2},{color:t.tickColor,width:t.tickWidth,borderDash:t.tickBorderDash,borderDashOffset:t.tickBorderDashOffset})}}drawBorder(){const{chart:t,ctx:e,options:{border:n,grid:i}}=this,r=n.setContext(this.getContext()),s=n.display?r.width:0;if(!s)return;const o=i.setContext(this.getContext(0)).lineWidth,a=this._borderValue;let l,c,u,h;this.isHorizontal()?(l=Ust(t,this.left,s)-s/2,c=Ust(t,this.right,o)+o/2,u=h=a):(u=Ust(t,this.top,s)-s/2,h=Ust(t,this.bottom,o)+o/2,l=c=a),e.save(),e.lineWidth=r.width,e.strokeStyle=r.color,e.beginPath(),e.moveTo(l,u),e.lineTo(c,h),e.stroke(),e.restore()}drawLabels(t){if(!this.options.ticks.display)return;const e=this.ctx,n=this._computeLabelArea();n&&Gst(e,n);const i=this.getLabelItems(t);for(const t of i){const n=t.options,i=t.font;Jst(e,t.label,0,t.textOffset,i,n)}n&&qst(e)}drawTitle(){const{ctx:t,options:{position:e,title:n,reverse:i}}=this;if(!n.display)return;const r=lot(n.font),s=aot(n.padding),o=n.align;let a=r.lineHeight/2;"bottom"===e||"center"===e||brt(e)?(a+=s.bottom,yrt(n.text)&&(a+=r.lineHeight*(n.text.length-1))):a+=s.top;const{titleX:l,titleY:c,maxWidth:u,rotation:h}=function(t,e,n,i){const{top:r,left:s,bottom:o,right:a,chart:l}=t,{chartArea:c,scales:u}=l;let h,d,p,f=0;const m=o-r,g=a-s;if(t.isHorizontal()){if(d=yst(i,s,a),brt(n)){const t=Object.keys(n)[0],i=n[t];p=u[t].getPixelForValue(i)+m-e}else p="center"===n?(c.bottom+c.top)/2+m-e:Elt(t,n,e);h=a-s}else{if(brt(n)){const t=Object.keys(n)[0],i=n[t];d=u[t].getPixelForValue(i)-g+e}else d="center"===n?(c.left+c.right)/2-g+e:Elt(t,n,e);p=yst(i,o,r),f="left"===n?-Wrt:Wrt}return{titleX:d,titleY:p,maxWidth:h,rotation:f}}(this,a,e,o);Jst(t,n.text,0,0,r,{color:n.color,maxWidth:u,rotation:h,textAlign:Rlt(o,e,i),textBaseline:"middle",translation:[l,c]})}draw(t){this._isVisible()&&(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}_layers(){const t=this.options,e=t.ticks&&t.ticks.z||0,n=wrt(t.grid&&t.grid.z,-1),i=wrt(t.border&&t.border.z,0);return this._isVisible()&&this.draw===Plt.prototype.draw?[{z:n,draw:t=>{this.drawBackground(),this.drawGrid(t),this.drawTitle()}},{z:i,draw:()=>{this.drawBorder()}},{z:e,draw:t=>{this.drawLabels(t)}}]:[{z:e,draw:t=>{this.draw(t)}}]}getMatchingVisibleMetas(t){const e=this.chart.getSortedVisibleDatasetMetas(),n=this.axis+"AxisID",i=[];let r,s;for(r=0,s=e.length;r<s;++r){const s=e[r];s[n]!==this.id||t&&s.type!==t||i.push(s)}return i}_resolveTickFontOptions(t){return lot(this.options.ticks.setContext(this.getContext(t)).font)}_maxDigits(){const t=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/t}}class Olt{constructor(t,e,n){this.type=t,this.scope=e,this.override=n,this.items=Object.create(null)}isForType(t){return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}register(t){const e=Object.getPrototypeOf(t);let n;(function(t){return"id"in t&&"defaults"in t})(e)&&(n=this.register(e));const i=this.items,r=t.id,s=this.scope+"."+r;if(!r)throw new Error("class does not have id: "+t);return r in i||(i[r]=t,function(t,e,n){const i=$rt(Object.create(null),[n?Fst.get(n):{},Fst.get(e),t.defaults]);Fst.set(e,i),t.defaultRoutes&&function(t,e){Object.keys(e).forEach((n=>{const i=n.split("."),r=i.pop(),s=[t].concat(i).join("."),o=e[n].split("."),a=o.pop(),l=o.join(".");Fst.route(s,r,l,a)}))}(e,t.defaultRoutes);t.descriptors&&Fst.describe(e,t.descriptors)}(t,s,n),this.override&&Fst.override(t.id,t.overrides)),s}get(t){return this.items[t]}unregister(t){const e=this.items,n=t.id,i=this.scope;n in e&&delete e[n],i&&n in Fst[i]&&(delete Fst[i][n],this.override&&delete Rst[n])}}class Llt{constructor(){this.controllers=new Olt(wat,"datasets",!0),this.elements=new Olt(Clt,"elements"),this.plugins=new Olt(Object,"plugins"),this.scales=new Olt(Plt,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...t){this._each("register",t)}remove(...t){this._each("unregister",t)}addControllers(...t){this._each("register",t,this.controllers)}addElements(...t){this._each("register",t,this.elements)}addPlugins(...t){this._each("register",t,this.plugins)}addScales(...t){this._each("register",t,this.scales)}getController(t){return this._get(t,this.controllers,"controller")}getElement(t){return this._get(t,this.elements,"element")}getPlugin(t){return this._get(t,this.plugins,"plugin")}getScale(t){return this._get(t,this.scales,"scale")}removeControllers(...t){this._each("unregister",t,this.controllers)}removeElements(...t){this._each("unregister",t,this.elements)}removePlugins(...t){this._each("unregister",t,this.plugins)}removeScales(...t){this._each("unregister",t,this.scales)}_each(t,e,n){[...e].forEach((e=>{const i=n||this._getRegistryForType(e);n||i.isForType(e)||i===this.plugins&&e.id?this._exec(t,i,e):Crt(e,(e=>{const i=n||this._getRegistryForType(e);this._exec(t,i,e)}))}))}_exec(t,e,n){const i=Prt(t);krt(n["before"+i],[],n),e[t](n),krt(n["after"+i],[],n)}_getRegistryForType(t){for(let e=0;e<this._typedRegistries.length;e++){const n=this._typedRegistries[e];if(n.isForType(t))return n}return this.plugins}_get(t,e,n){const i=e.get(t);if(void 0===i)throw new Error('"'+t+'" is not a registered '+n+".");return i}}var Dlt=new Llt;class Flt{constructor(){this._init=[]}notify(t,e,n,i){"beforeInit"===e&&(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,"install"));const r=i?this._descriptors(t).filter(i):this._descriptors(t),s=this._notify(r,t,e,n);return"afterDestroy"===e&&(this._notify(r,t,"stop"),this._notify(this._init,t,"uninstall")),s}_notify(t,e,n,i){i=i||{};for(const r of t){const t=r.plugin;if(!1===krt(t[n],[e,i,r.options],t)&&i.cancelable)return!1}return!0}invalidate(){grt(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(t){if(this._cache)return this._cache;const e=this._cache=this._createDescriptors(t);return this._notifyStateChanges(t),e}_createDescriptors(t,e){const n=t&&t.config,i=wrt(n.options&&n.options.plugins,{}),r=function(t){const e={},n=[],i=Object.keys(Dlt.plugins.items);for(let t=0;t<i.length;t++)n.push(Dlt.getPlugin(i[t]));const r=t.plugins||[];for(let t=0;t<r.length;t++){const i=r[t];-1===n.indexOf(i)&&(n.push(i),e[i.id]=!0)}return{plugins:n,localIds:e}}(n);return!1!==i||e?function(t,{plugins:e,localIds:n},i,r){const s=[],o=t.getContext();for(const a of e){const e=a.id,l=zlt(i[e],r);null!==l&&s.push({plugin:a,options:Blt(t.config,{plugin:a,local:n[e]},l,o)})}return s}(t,r,i,e):[]}_notifyStateChanges(t){const e=this._oldCache||[],n=this._cache,i=(t,e)=>t.filter((t=>!e.some((e=>t.plugin.id===e.plugin.id))));this._notify(i(e,n),t,"stop"),this._notify(i(n,e),t,"start")}}function zlt(t,e){return e||!1!==t?!0===t?{}:t:null}function Blt(t,{plugin:e,local:n},i,r){const s=t.pluginScopeKeys(e),o=t.getOptionScopes(i,s);return n&&e.defaults&&o.push(e.defaults),t.createResolver(o,r,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function Ult(t,e){const n=Fst.datasets[t]||{};return((e.datasets||{})[t]||{}).indexAxis||e.indexAxis||n.indexAxis||"x"}function Vlt(t){if("x"===t||"y"===t||"r"===t)return t}function Wlt(t,...e){if(Vlt(t))return t;for(const i of e){const e=i.axis||("top"===(n=i.position)||"bottom"===n?"x":"left"===n||"right"===n?"y":void 0)||t.length>1&&Vlt(t[0].toLowerCase());if(e)return e}var n;throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`)}function Hlt(t,e,n){if(n[e+"AxisID"]===t)return{axis:e}}function jlt(t,e){const n=Rst[t.type]||{scales:{}},i=e.scales||{},r=Ult(t.type,e),s=Object.create(null);return Object.keys(i).forEach((e=>{const o=i[e];if(!brt(o))return console.error(`Invalid scale configuration for scale: ${e}`);if(o._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${e}`);const a=Wlt(e,o,function(t,e){if(e.data&&e.data.datasets){const n=e.data.datasets.filter((e=>e.xAxisID===t||e.yAxisID===t));if(n.length)return Hlt(t,"x",n[0])||Hlt(t,"y",n[0])}return{}}(e,t),Fst.scales[o.type]),l=function(t,e){return t===e?"_index_":"_value_"}(a,r),c=n.scales||{};s[e]=Irt(Object.create(null),[{axis:a},o,c[a],c[l]])})),t.data.datasets.forEach((n=>{const r=n.type||t.type,o=n.indexAxis||Ult(r,e),a=(Rst[r]||{}).scales||{};Object.keys(a).forEach((t=>{const e=function(t,e){let n=t;return"_index_"===t?n=e:"_value_"===t&&(n="x"===e?"y":"x"),n}(t,o),r=n[e+"AxisID"]||e;s[r]=s[r]||Object.create(null),Irt(s[r],[{axis:e},i[r],a[t]])}))})),Object.keys(s).forEach((t=>{const e=s[t];Irt(e,[Fst.scales[e.type],Fst.scale])})),s}function Glt(t){const e=t.options||(t.options={});e.plugins=wrt(e.plugins,{}),e.scales=jlt(t,e)}function qlt(t){return(t=t||{}).datasets=t.datasets||[],t.labels=t.labels||[],t}const Xlt=new Map,Klt=new Set;function Ylt(t,e){let n=Xlt.get(t);return n||(n=e(),Xlt.set(t,n),Klt.add(n)),n}const Zlt=(t,e,n)=>{const i=Rrt(e,n);void 0!==i&&t.add(i)};class Jlt{constructor(t){this._config=function(t){return(t=t||{}).data=qlt(t.data),Glt(t),t}(t),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(t){this._config.type=t}get data(){return this._config.data}set data(t){this._config.data=qlt(t)}get options(){return this._config.options}set options(t){this._config.options=t}get plugins(){return this._config.plugins}update(){const t=this._config;this.clearCache(),Glt(t)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(t){return Ylt(t,(()=>[[`datasets.${t}`,""]]))}datasetAnimationScopeKeys(t,e){return Ylt(`${t}.transition.${e}`,(()=>[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,""]]))}datasetElementScopeKeys(t,e){return Ylt(`${t}-${e}`,(()=>[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,""]]))}pluginScopeKeys(t){const e=t.id;return Ylt(`${this.type}-plugin-${e}`,(()=>[[`plugins.${e}`,...t.additionalOptionScopes||[]]]))}_cachedScopes(t,e){const n=this._scopeCache;let i=n.get(t);return i&&!e||(i=new Map,n.set(t,i)),i}getOptionScopes(t,e,n){const{options:i,type:r}=this,s=this._cachedScopes(t,n),o=s.get(e);if(o)return o;const a=new Set;e.forEach((e=>{t&&(a.add(t),e.forEach((e=>Zlt(a,t,e)))),e.forEach((t=>Zlt(a,i,t))),e.forEach((t=>Zlt(a,Rst[r]||{},t))),e.forEach((t=>Zlt(a,Fst,t))),e.forEach((t=>Zlt(a,Pst,t)))}));const l=Array.from(a);return 0===l.length&&l.push(Object.create(null)),Klt.has(e)&&s.set(e,l),l}chartOptionScopes(){const{options:t,type:e}=this;return[t,Rst[e]||{},Fst.datasets[e]||{},{type:e},Fst,Pst]}resolveNamedOptions(t,e,n,i=[""]){const r={$shared:!0},{resolver:s,subPrefixes:o}=Qlt(this._resolverCache,t,i);let a=s;if(function(t,e){const{isScriptable:n,isIndexable:i}=pot(t);for(const r of e){const e=n(r),s=i(r),o=(s||e)&&t[r];if(e&&(Lrt(o)||tct(o))||s&&yrt(o))return!0}return!1}(s,e)){r.$shared=!1;a=dot(s,n=Lrt(n)?n():n,this.createResolver(t,n,o))}for(const t of e)r[t]=a[t];return r}createResolver(t,e,n=[""],i){const{resolver:r}=Qlt(this._resolverCache,t,n);return brt(e)?dot(r,e,void 0,i):r}}function Qlt(t,e,n){let i=t.get(e);i||(i=new Map,t.set(e,i));const r=n.join();let s=i.get(r);if(!s){s={resolver:hot(e,n),subPrefixes:n.filter((t=>!t.toLowerCase().includes("hover")))},i.set(r,s)}return s}const tct=t=>brt(t)&&Object.getOwnPropertyNames(t).reduce(((e,n)=>e||Lrt(t[n])),!1);const ect=["top","bottom","left","right","chartArea"];function nct(t,e){return"top"===t||"bottom"===t||-1===ect.indexOf(t)&&"x"===e}function ict(t,e){return function(n,i){return n[t]===i[t]?n[e]-i[e]:n[t]-i[t]}}function rct(t){const e=t.chart,n=e.options.animation;e.notifyPlugins("afterRender"),krt(n&&n.onComplete,[t],e)}function sct(t){const e=t.chart,n=e.options.animation;krt(n&&n.onProgress,[t],e)}function oct(t){return Not()&&"string"==typeof t?t=document.getElementById(t):t&&t.length&&(t=t[0]),t&&t.canvas&&(t=t.canvas),t}const act={},lct=t=>{const e=oct(t);return Object.values(act).filter((t=>t.canvas===e)).pop()};function cct(t,e,n){const i=Object.keys(t);for(const r of i){const i=+r;if(i>=e){const s=t[r];delete t[r],(n>0||i>e)&&(t[i+n]=s)}}}function uct(t,e,n){return t.options.clip?t[n]:e[n]}class hct{static defaults=Fst;static instances=act;static overrides=Rst;static registry=Dlt;static version="4.4.0";static getChart=lct;static register(...t){Dlt.add(...t),dct()}static unregister(...t){Dlt.remove(...t),dct()}constructor(t,e){const n=this.config=new Jlt(e),i=oct(t),r=lct(i);if(r)throw new Error("Canvas is already in use. Chart with ID '"+r.id+"' must be destroyed before the canvas with ID '"+r.canvas.id+"' can be reused.");const s=n.createResolver(n.chartOptionScopes(),this.getContext());this.platform=new(n.platform||function(t){return!Not()||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas?llt:klt}(i)),this.platform.updateConfig(n);const o=this.platform.acquireContext(i,s.aspectRatio),a=o&&o.canvas,l=a&&a.height,c=a&&a.width;this.id=mrt(),this.ctx=o,this.canvas=a,this.width=c,this.height=l,this._options=s,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new Flt,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=function(t,e){let n;return function(...i){return e?(clearTimeout(n),n=setTimeout(t,e,i)):t.apply(this,i),e}}((t=>this.update(t)),s.resizeDelay||0),this._dataChanges=[],act[this.id]=this,o&&a?(sat.listen(this,"complete",rct),sat.listen(this,"progress",sct),this._initialize(),this.attached&&this.update()):console.error("Failed to create chart: can't acquire context from the given item")}get aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:n,height:i,_aspectRatio:r}=this;return grt(t)?e&&r?r:i?n/i:null:t}get data(){return this.config.data}set data(t){this.config.data=t}get options(){return this._options}set options(t){this.config.options=t}get registry(){return Dlt}_initialize(){return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():Vot(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}clear(){return Vst(this.canvas,this.ctx),this}stop(){return sat.stop(this),this}resize(t,e){sat.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}_resize(t,e){const n=this.options,i=this.canvas,r=n.maintainAspectRatio&&this.aspectRatio,s=this.platform.getMaximumSize(i,t,e,r),o=n.devicePixelRatio||this.platform.getDevicePixelRatio(),a=this.width?"resize":"attach";this.width=s.width,this.height=s.height,this._aspectRatio=this.aspectRatio,Vot(this,o,!0)&&(this.notifyPlugins("resize",{size:s}),krt(n.onResize,[this,s],this),this.attached&&this._doResize(a)&&this.render())}ensureScalesHaveIDs(){Crt(this.options.scales||{},((t,e)=>{t.id=e}))}buildOrUpdateScales(){const t=this.options,e=t.scales,n=this.scales,i=Object.keys(n).reduce(((t,e)=>(t[e]=!1,t)),{});let r=[];e&&(r=r.concat(Object.keys(e).map((t=>{const n=e[t],i=Wlt(t,n),r="r"===i,s="x"===i;return{options:n,dposition:r?"chartArea":s?"bottom":"left",dtype:r?"radialLinear":s?"category":"linear"}})))),Crt(r,(e=>{const r=e.options,s=r.id,o=Wlt(s,r),a=wrt(r.type,e.dtype);void 0!==r.position&&nct(r.position,o)===nct(e.dposition)||(r.position=e.dposition),i[s]=!0;let l=null;if(s in n&&n[s].type===a)l=n[s];else{l=new(Dlt.getScale(a))({id:s,type:a,ctx:this.ctx,chart:this}),n[l.id]=l}l.init(r,t)})),Crt(i,((t,e)=>{t||delete n[e]})),Crt(n,(t=>{olt.configure(this,t,t.options),olt.addBox(this,t)}))}_updateMetasets(){const t=this._metasets,e=this.data.datasets.length,n=t.length;if(t.sort(((t,e)=>t.index-e.index)),n>e){for(let t=e;t<n;++t)this._destroyDatasetMeta(t);t.splice(e,n-e)}this._sortedMetasets=t.slice(0).sort(ict("order","index"))}_removeUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=this;t.length>e.length&&delete this._stacks,t.forEach(((t,n)=>{0===e.filter((e=>e===t._dataset)).length&&this._destroyDatasetMeta(n)}))}buildOrUpdateControllers(){const t=[],e=this.data.datasets;let n,i;for(this._removeUnreferencedMetasets(),n=0,i=e.length;n<i;n++){const i=e[n];let r=this.getDatasetMeta(n);const s=i.type||this.config.type;if(r.type&&r.type!==s&&(this._destroyDatasetMeta(n),r=this.getDatasetMeta(n)),r.type=s,r.indexAxis=i.indexAxis||Ult(s,this.options),r.order=i.order||0,r.index=n,r.label=""+i.label,r.visible=this.isDatasetVisible(n),r.controller)r.controller.updateIndex(n),r.controller.linkScales();else{const e=Dlt.getController(s),{datasetElementType:i,dataElementType:o}=Fst.datasets[s];Object.assign(e,{dataElementType:Dlt.getElement(o),datasetElementType:i&&Dlt.getElement(i)}),r.controller=new e(this,n),t.push(r.controller)}}return this._updateMetasets(),t}_resetElements(){Crt(this.data.datasets,((t,e)=>{this.getDatasetMeta(e).controller.reset()}),this)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(t){const e=this.config;e.update();const n=this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),i=this._animationsDisabled=!n.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),!1===this.notifyPlugins("beforeUpdate",{mode:t,cancelable:!0}))return;const r=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let s=0;for(let t=0,e=this.data.datasets.length;t<e;t++){const{controller:e}=this.getDatasetMeta(t),n=!i&&-1===r.indexOf(e);e.buildOrUpdateElements(n),s=Math.max(+e.getMaxOverflow(),s)}s=this._minPadding=n.layout.autoPadding?s:0,this._updateLayout(s),i||Crt(r,(t=>{t.reset()})),this._updateDatasets(t),this.notifyPlugins("afterUpdate",{mode:t}),this._layers.sort(ict("z","_idx"));const{_active:o,_lastEvent:a}=this;a?this._eventHandler(a,!0):o.length&&this._updateHoverStyles(o,o,!0),this.render()}_updateScales(){Crt(this.scales,(t=>{olt.removeBox(this,t)})),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const t=this.options,e=new Set(Object.keys(this._listeners)),n=new Set(t.events);Drt(e,n)&&!!this._responsiveListeners===t.responsive||(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:t}=this,e=this._getUniformDataChanges()||[];for(const{method:n,start:i,count:r}of e){cct(t,i,"_removeElements"===n?-r:r)}}_getUniformDataChanges(){const t=this._dataChanges;if(!t||!t.length)return;this._dataChanges=[];const e=this.data.datasets.length,n=e=>new Set(t.filter((t=>t[0]===e)).map(((t,e)=>e+","+t.splice(1).join(",")))),i=n(0);for(let t=1;t<e;t++)if(!Drt(i,n(t)))return;return Array.from(i).map((t=>t.split(","))).map((t=>({method:t[1],start:+t[2],count:+t[3]})))}_updateLayout(t){if(!1===this.notifyPlugins("beforeLayout",{cancelable:!0}))return;olt.update(this,this.width,this.height,t);const e=this.chartArea,n=e.width<=0||e.height<=0;this._layers=[],Crt(this.boxes,(t=>{n&&"chartArea"===t.position||(t.configure&&t.configure(),this._layers.push(...t._layers()))}),this),this._layers.forEach(((t,e)=>{t._idx=e})),this.notifyPlugins("afterLayout")}_updateDatasets(t){if(!1!==this.notifyPlugins("beforeDatasetsUpdate",{mode:t,cancelable:!0})){for(let t=0,e=this.data.datasets.length;t<e;++t)this.getDatasetMeta(t).controller.configure();for(let e=0,n=this.data.datasets.length;e<n;++e)this._updateDataset(e,Lrt(t)?t({datasetIndex:e}):t);this.notifyPlugins("afterDatasetsUpdate",{mode:t})}}_updateDataset(t,e){const n=this.getDatasetMeta(t),i={meta:n,index:t,mode:e,cancelable:!0};!1!==this.notifyPlugins("beforeDatasetUpdate",i)&&(n.controller._update(e),i.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",i))}render(){!1!==this.notifyPlugins("beforeRender",{cancelable:!0})&&(sat.has(this)?this.attached&&!sat.running(this)&&sat.start(this):(this.draw(),rct({chart:this})))}draw(){let t;if(this._resizeBeforeDraw){const{width:t,height:e}=this._resizeBeforeDraw;this._resize(t,e),this._resizeBeforeDraw=null}if(this.clear(),this.width<=0||this.height<=0)return;if(!1===this.notifyPlugins("beforeDraw",{cancelable:!0}))return;const e=this._layers;for(t=0;t<e.length&&e[t].z<=0;++t)e[t].draw(this.chartArea);for(this._drawDatasets();t<e.length;++t)e[t].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(t){const e=this._sortedMetasets,n=[];let i,r;for(i=0,r=e.length;i<r;++i){const r=e[i];t&&!r.visible||n.push(r)}return n}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(!1===this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0}))return;const t=this.getSortedVisibleDatasetMetas();for(let e=t.length-1;e>=0;--e)this._drawDataset(t[e]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(t){const e=this.ctx,n=t._clip,i=!n.disabled,r=function(t,e){const{xScale:n,yScale:i}=t;return n&&i?{left:uct(n,e,"left"),right:uct(n,e,"right"),top:uct(i,e,"top"),bottom:uct(i,e,"bottom")}:e}(t,this.chartArea),s={meta:t,index:t.index,cancelable:!0};!1!==this.notifyPlugins("beforeDatasetDraw",s)&&(i&&Gst(e,{left:!1===n.left?0:r.left-n.left,right:!1===n.right?this.width:r.right+n.right,top:!1===n.top?0:r.top-n.top,bottom:!1===n.bottom?this.height:r.bottom+n.bottom}),t.controller.draw(),i&&qst(e),s.cancelable=!1,this.notifyPlugins("afterDatasetDraw",s))}isPointInArea(t){return jst(t,this.chartArea,this._minPadding)}getElementsAtEventForMode(t,e,n,i){const r=qat.modes[e];return"function"==typeof r?r(this,t,n,i):[]}getDatasetMeta(t){const e=this.data.datasets[t],n=this._metasets;let i=n.filter((t=>t&&t._dataset===e)).pop();return i||(i={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&&e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},n.push(i)),i}getContext(){return this.$context||(this.$context=uot(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(t){const e=this.data.datasets[t];if(!e)return!1;const n=this.getDatasetMeta(t);return"boolean"==typeof n.hidden?!n.hidden:!e.hidden}setDatasetVisibility(t,e){this.getDatasetMeta(t).hidden=!e}toggleDataVisibility(t){this._hiddenIndices[t]=!this._hiddenIndices[t]}getDataVisibility(t){return!this._hiddenIndices[t]}_updateVisibility(t,e,n){const i=n?"show":"hide",r=this.getDatasetMeta(t),s=r.controller._resolveAnimations(void 0,i);Ort(e)?(r.data[e].hidden=!n,this.update()):(this.setDatasetVisibility(t,n),s.update(r,{visible:n}),this.update((e=>e.datasetIndex===t?i:void 0)))}hide(t,e){this._updateVisibility(t,e,!1)}show(t,e){this._updateVisibility(t,e,!0)}_destroyDatasetMeta(t){const e=this._metasets[t];e&&e.controller&&e.controller._destroy(),delete this._metasets[t]}_stop(){let t,e;for(this.stop(),sat.remove(this),t=0,e=this.data.datasets.length;t<e;++t)this._destroyDatasetMeta(t)}destroy(){this.notifyPlugins("beforeDestroy");const{canvas:t,ctx:e}=this;this._stop(),this.config.clearCache(),t&&(this.unbindEvents(),Vst(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),delete act[this.id],this.notifyPlugins("afterDestroy")}toBase64Image(...t){return this.canvas.toDataURL(...t)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const t=this._listeners,e=this.platform,n=(n,i)=>{e.addEventListener(this,n,i),t[n]=i},i=(t,e,n)=>{t.offsetX=e,t.offsetY=n,this._eventHandler(t)};Crt(this.options.events,(t=>n(t,i)))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const t=this._responsiveListeners,e=this.platform,n=(n,i)=>{e.addEventListener(this,n,i),t[n]=i},i=(n,i)=>{t[n]&&(e.removeEventListener(this,n,i),delete t[n])},r=(t,e)=>{this.canvas&&this.resize(t,e)};let s;const o=()=>{i("attach",o),this.attached=!0,this.resize(),n("resize",r),n("detach",s)};s=()=>{this.attached=!1,i("resize",r),this._stop(),this._resize(0,0),n("attach",o)},e.isAttached(this.canvas)?o():s()}unbindEvents(){Crt(this._listeners,((t,e)=>{this.platform.removeEventListener(this,e,t)})),this._listeners={},Crt(this._responsiveListeners,((t,e)=>{this.platform.removeEventListener(this,e,t)})),this._responsiveListeners=void 0}updateHoverStyle(t,e,n){const i=n?"set":"remove";let r,s,o,a;for("dataset"===e&&(r=this.getDatasetMeta(t[0].datasetIndex),r.controller["_"+i+"DatasetHoverStyle"]()),o=0,a=t.length;o<a;++o){s=t[o];const e=s&&this.getDatasetMeta(s.datasetIndex).controller;e&&e[i+"HoverStyle"](s.element,s.datasetIndex,s.index)}}getActiveElements(){return this._active||[]}setActiveElements(t){const e=this._active||[],n=t.map((({datasetIndex:t,index:e})=>{const n=this.getDatasetMeta(t);if(!n)throw new Error("No dataset found at index "+t);return{datasetIndex:t,element:n.data[e],index:e}}));!Trt(n,e)&&(this._active=n,this._lastEvent=null,this._updateHoverStyles(n,e))}notifyPlugins(t,e,n){return this._plugins.notify(this,t,e,n)}isPluginEnabled(t){return 1===this._plugins._cache.filter((e=>e.plugin.id===t)).length}_updateHoverStyles(t,e,n){const i=this.options.hover,r=(t,e)=>t.filter((t=>!e.some((e=>t.datasetIndex===e.datasetIndex&&t.index===e.index)))),s=r(e,t),o=n?t:r(t,e);s.length&&this.updateHoverStyle(s,i.mode,!1),o.length&&i.mode&&this.updateHoverStyle(o,i.mode,!0)}_eventHandler(t,e){const n={event:t,replay:e,cancelable:!0,inChartArea:this.isPointInArea(t)},i=e=>(e.options.events||this.options.events).includes(t.native.type);if(!1===this.notifyPlugins("beforeEvent",n,i))return;const r=this._handleEvent(t,e,n.inChartArea);return n.cancelable=!1,this.notifyPlugins("afterEvent",n,i),(r||n.changed)&&this.render(),this}_handleEvent(t,e,n){const{_active:i=[],options:r}=this,s=e,o=this._getActiveElements(t,i,n,s),a=function(t){return"mouseup"===t.type||"click"===t.type||"contextmenu"===t.type}(t),l=function(t,e,n,i){return n&&"mouseout"!==t.type?i?e:t:null}(t,this._lastEvent,n,a);n&&(this._lastEvent=null,krt(r.onHover,[t,o,this],this),a&&krt(r.onClick,[t,o,this],this));const c=!Trt(o,i);return(c||e)&&(this._active=o,this._updateHoverStyles(o,i,e)),this._lastEvent=l,c}_getActiveElements(t,e,n,i){if("mouseout"===t.type)return[];if(!n)return e;const r=this.options.hover;return this.getElementsAtEventForMode(t,r.mode,r,i)}}function dct(){return Crt(hct.instances,(t=>t._plugins.invalidate()))}function pct(t,e,n,i){const r=rot(t.options.borderRadius,["outerStart","outerEnd","innerStart","innerEnd"]);const s=(n-e)/2,o=Math.min(s,i*e/2),a=t=>{const e=(n-Math.min(s,t))*i/2;return ost(t,0,Math.min(s,e))};return{outerStart:a(r.outerStart),outerEnd:a(r.outerEnd),innerStart:ost(r.innerStart,0,o),innerEnd:ost(r.innerEnd,0,o)}}function fct(t,e,n,i){return{x:n+t*Math.cos(e),y:i+t*Math.sin(e)}}function mct(t,e,n,i,r,s){const{x:o,y:a,startAngle:l,pixelMargin:c,innerRadius:u}=e,h=Math.max(e.outerRadius+i+n-c,0),d=u>0?u+i+n+c:0;let p=0;const f=r-l;if(i){const t=((u>0?u-i:0)+(h>0?h-i:0))/2;p=(f-(0!==t?f*t/(t+i):f))/2}const m=(f-Math.max(.001,f*h-n/Frt)/h)/2,g=l+m+p,y=r-m-p,{outerStart:b,outerEnd:v,innerStart:x,innerEnd:w}=pct(e,d,h,y-g),S=h-b,k=h-v,C=g+b/S,T=y-v/k,_=d+x,E=d+w,M=g+x/_,$=y-w/E;if(t.beginPath(),s){const e=(C+T)/2;if(t.arc(o,a,h,C,e),t.arc(o,a,h,e,T),v>0){const e=fct(k,T,o,a);t.arc(e.x,e.y,v,T,y+Wrt)}const n=fct(E,y,o,a);if(t.lineTo(n.x,n.y),w>0){const e=fct(E,$,o,a);t.arc(e.x,e.y,w,y+Wrt,$+Math.PI)}const i=(y-w/d+(g+x/d))/2;if(t.arc(o,a,d,y-w/d,i,!0),t.arc(o,a,d,i,g+x/d,!0),x>0){const e=fct(_,M,o,a);t.arc(e.x,e.y,x,M+Math.PI,g-Wrt)}const r=fct(S,g,o,a);if(t.lineTo(r.x,r.y),b>0){const e=fct(S,C,o,a);t.arc(e.x,e.y,b,g-Wrt,C)}}else{t.moveTo(o,a);const e=Math.cos(C)*h+o,n=Math.sin(C)*h+a;t.lineTo(e,n);const i=Math.cos(T)*h+o,r=Math.sin(T)*h+a;t.lineTo(i,r)}t.closePath()}function gct(t,e,n,i,r){const{fullCircles:s,startAngle:o,circumference:a,options:l}=e,{borderWidth:c,borderJoinStyle:u,borderDash:h,borderDashOffset:d}=l,p="inner"===l.borderAlign;if(!c)return;t.setLineDash(h||[]),t.lineDashOffset=d,p?(t.lineWidth=2*c,t.lineJoin=u||"round"):(t.lineWidth=c,t.lineJoin=u||"bevel");let f=e.endAngle;if(s){mct(t,e,n,i,f,r);for(let e=0;e<s;++e)t.stroke();isNaN(a)||(f=o+(a%zrt||zrt))}p&&function(t,e,n){const{startAngle:i,pixelMargin:r,x:s,y:o,outerRadius:a,innerRadius:l}=e;let c=r/a;t.beginPath(),t.arc(s,o,a,i-c,n+c),l>r?(c=r/l,t.arc(s,o,l,n+c,i-c,!0)):t.arc(s,o,r,n+Wrt,i-Wrt),t.closePath(),t.clip()}(t,e,f),s||(mct(t,e,n,i,f,r),t.stroke())}class yct extends Clt{static id="arc";static defaults={borderAlign:"center",borderColor:"#fff",borderDash:[],borderDashOffset:0,borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0};static defaultRoutes={backgroundColor:"backgroundColor"};static descriptors={_scriptable:!0,_indexable:t=>"borderDash"!==t};circumference;endAngle;fullCircles;innerRadius;outerRadius;pixelMargin;startAngle;constructor(t){super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,t&&Object.assign(this,t)}inRange(t,e,n){const i=this.getProps(["x","y"],n),{angle:r,distance:s}=est(i,{x:t,y:e}),{startAngle:o,endAngle:a,innerRadius:l,outerRadius:c,circumference:u}=this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],n),h=(this.options.spacing+this.options.borderWidth)/2,d=wrt(u,a-o)>=zrt||sst(r,o,a),p=ast(s,l+h,c+h);return d&&p}getCenterPoint(t){const{x:e,y:n,startAngle:i,endAngle:r,innerRadius:s,outerRadius:o}=this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius"],t),{offset:a,spacing:l}=this.options,c=(i+r)/2,u=(s+o+l+a)/2;return{x:e+Math.cos(c)*u,y:n+Math.sin(c)*u}}tooltipPosition(t){return this.getCenterPoint(t)}draw(t){const{options:e,circumference:n}=this,i=(e.offset||0)/4,r=(e.spacing||0)/2,s=e.circular;if(this.pixelMargin="inner"===e.borderAlign?.33:0,this.fullCircles=n>zrt?Math.floor(n/zrt):0,0===n||this.innerRadius<0||this.outerRadius<0)return;t.save();const o=(this.startAngle+this.endAngle)/2;t.translate(Math.cos(o)*i,Math.sin(o)*i);const a=i*(1-Math.sin(Math.min(Frt,n||0)));t.fillStyle=e.backgroundColor,t.strokeStyle=e.borderColor,function(t,e,n,i,r){const{fullCircles:s,startAngle:o,circumference:a}=e;let l=e.endAngle;if(s){mct(t,e,n,i,l,r);for(let e=0;e<s;++e)t.fill();isNaN(a)||(l=o+(a%zrt||zrt))}mct(t,e,n,i,l,r),t.fill()}(t,this,a,r,s),gct(t,this,a,r,s),t.restore()}}function bct(t,e,n=e){t.lineCap=wrt(n.borderCapStyle,e.borderCapStyle),t.setLineDash(wrt(n.borderDash,e.borderDash)),t.lineDashOffset=wrt(n.borderDashOffset,e.borderDashOffset),t.lineJoin=wrt(n.borderJoinStyle,e.borderJoinStyle),t.lineWidth=wrt(n.borderWidth,e.borderWidth),t.strokeStyle=wrt(n.borderColor,e.borderColor)}function vct(t,e,n){t.lineTo(n.x,n.y)}function xct(t,e,n={}){const i=t.length,{start:r=0,end:s=i-1}=n,{start:o,end:a}=e,l=Math.max(r,o),c=Math.min(s,a),u=r<o&&s<o||r>a&&s>a;return{count:i,start:l,loop:e.loop,ilen:c<l&&!u?i+c-l:c-l}}function wct(t,e,n,i){const{points:r,options:s}=e,{count:o,start:a,loop:l,ilen:c}=xct(r,n,i),u=function(t){return t.stepped?Xst:t.tension||"monotone"===t.cubicInterpolationMode?Kst:vct}(s);let h,d,p,{move:f=!0,reverse:m}=i||{};for(h=0;h<=c;++h)d=r[(a+(m?c-h:h))%o],d.skip||(f?(t.moveTo(d.x,d.y),f=!1):u(t,p,d,m,s.stepped),p=d);return l&&(d=r[(a+(m?c:0))%o],u(t,p,d,m,s.stepped)),!!l}function Sct(t,e,n,i){const r=e.points,{count:s,start:o,ilen:a}=xct(r,n,i),{move:l=!0,reverse:c}=i||{};let u,h,d,p,f,m,g=0,y=0;const b=t=>(o+(c?a-t:t))%s,v=()=>{p!==f&&(t.lineTo(g,f),t.lineTo(g,p),t.lineTo(g,m))};for(l&&(h=r[b(0)],t.moveTo(h.x,h.y)),u=0;u<=a;++u){if(h=r[b(u)],h.skip)continue;const e=h.x,n=h.y,i=0|e;i===d?(n<p?p=n:n>f&&(f=n),g=(y*g+e)/++y):(v(),t.lineTo(e,n),d=i,y=0,p=f=n),m=n}v()}function kct(t){const e=t.options,n=e.borderDash&&e.borderDash.length;return!(t._decimated||t._loop||e.tension||"monotone"===e.cubicInterpolationMode||e.stepped||n)?Sct:wct}const Cct="function"==typeof Path2D;function Tct(t,e,n,i){Cct&&!e.options.segment?function(t,e,n,i){let r=e._path;r||(r=e._path=new Path2D,e.path(r,n,i)&&r.closePath()),bct(t,e.options),t.stroke(r)}(t,e,n,i):function(t,e,n,i){const{segments:r,options:s}=e,o=kct(e);for(const a of r)bct(t,s,a.style),t.beginPath(),o(t,e,a,{start:n,end:n+i-1})&&t.closePath(),t.stroke()}(t,e,n,i)}class _ct extends Clt{static id="line";static defaults={borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0};static defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};static descriptors={_scriptable:!0,_indexable:t=>"borderDash"!==t&&"fill"!==t};constructor(t){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,t&&Object.assign(this,t)}updateControlPoints(t,e){const n=this.options;if((n.tension||"monotone"===n.cubicInterpolationMode)&&!n.stepped&&!this._pointsUpdated){const i=n.spanGaps?this._loop:this._fullLoop;Aot(this._points,n,t,i,e),this._pointsUpdated=!0}}set points(t){this._points=t,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=function(t,e){const n=t.points,i=t.options.spanGaps,r=n.length;if(!r)return[];const s=!!t._loop,{start:o,end:a}=function(t,e,n,i){let r=0,s=e-1;if(n&&!i)for(;r<e&&!t[r].skip;)r++;for(;r<e&&t[r].skip;)r++;for(r%=e,n&&(s+=r);s>r&&t[s%e].skip;)s--;return s%=e,{start:r,end:s}}(n,r,s,i);return eat(t,!0===i?[{start:o,end:a,loop:s}]:function(t,e,n,i){const r=t.length,s=[];let o,a=e,l=t[e];for(o=e+1;o<=n;++o){const n=t[o%r];n.skip||n.stop?l.skip||(i=!1,s.push({start:e%r,end:(o-1)%r,loop:i}),e=a=n.stop?o:null):(a=o,l.skip&&(e=o)),l=n}return null!==a&&s.push({start:e%r,end:a%r,loop:i}),s}(n,o,a<o?a+r:a,!!t._fullLoop&&0===o&&a===r-1),n,e)}(this,this.options.segment))}first(){const t=this.segments,e=this.points;return t.length&&e[t[0].start]}last(){const t=this.segments,e=this.points,n=t.length;return n&&e[t[n-1].end]}interpolate(t,e){const n=this.options,i=t[e],r=this.points,s=tat(this,{property:e,start:i,end:i});if(!s.length)return;const o=[],a=function(t){return t.stepped?Got:t.tension||"monotone"===t.cubicInterpolationMode?qot:jot}(n);let l,c;for(l=0,c=s.length;l<c;++l){const{start:c,end:u}=s[l],h=r[c],d=r[u];if(h===d){o.push(h);continue}const p=a(h,d,Math.abs((i-h[e])/(d[e]-h[e])),n.stepped);p[e]=t[e],o.push(p)}return 1===o.length?o[0]:o}pathSegment(t,e,n){return kct(this)(t,this,e,n)}path(t,e,n){const i=this.segments,r=kct(this);let s=this._loop;e=e||0,n=n||this.points.length-e;for(const o of i)s&=r(t,this,o,{start:e,end:e+n-1});return!!s}draw(t,e,n,i){const r=this.options||{};(this.points||[]).length&&r.borderWidth&&(t.save(),Tct(t,this,n,i),t.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}function Ect(t,e,n,i){const r=t.options,{[n]:s}=t.getProps([n],i);return Math.abs(e-s)<r.radius+r.hitRadius}class Mct extends Clt{static id="point";parsed;skip;stop;static defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0};static defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};constructor(t){super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,t&&Object.assign(this,t)}inRange(t,e,n){const i=this.options,{x:r,y:s}=this.getProps(["x","y"],n);return Math.pow(t-r,2)+Math.pow(e-s,2)<Math.pow(i.hitRadius+i.radius,2)}inXRange(t,e){return Ect(this,t,"x",e)}inYRange(t,e){return Ect(this,t,"y",e)}getCenterPoint(t){const{x:e,y:n}=this.getProps(["x","y"],t);return{x:e,y:n}}size(t){let e=(t=t||this.options||{}).radius||0;e=Math.max(e,e&&t.hoverRadius||0);return 2*(e+(e&&t.borderWidth||0))}draw(t,e){const n=this.options;this.skip||n.radius<.1||!jst(this,e,this.size(n)/2)||(t.strokeStyle=n.borderColor,t.lineWidth=n.borderWidth,t.fillStyle=n.backgroundColor,Wst(t,n,this.x,this.y))}getRange(){const t=this.options||{};return t.radius+t.hitRadius}}function $ct(t,e){const{x:n,y:i,base:r,width:s,height:o}=t.getProps(["x","y","base","width","height"],e);let a,l,c,u,h;return t.horizontal?(h=o/2,a=Math.min(n,r),l=Math.max(n,r),c=i-h,u=i+h):(h=s/2,a=n-h,l=n+h,c=Math.min(i,r),u=Math.max(i,r)),{left:a,top:c,right:l,bottom:u}}function Ict(t,e,n,i){return t?0:ost(e,n,i)}function Act(t){const e=$ct(t),n=e.right-e.left,i=e.bottom-e.top,r=function(t,e,n){const i=t.options.borderWidth,r=t.borderSkipped,s=sot(i);return{t:Ict(r.top,s.top,0,n),r:Ict(r.right,s.right,0,e),b:Ict(r.bottom,s.bottom,0,n),l:Ict(r.left,s.left,0,e)}}(t,n/2,i/2),s=function(t,e,n){const{enableBorderRadius:i}=t.getProps(["enableBorderRadius"]),r=t.options.borderRadius,s=oot(r),o=Math.min(e,n),a=t.borderSkipped,l=i||brt(r);return{topLeft:Ict(!l||a.top||a.left,s.topLeft,0,o),topRight:Ict(!l||a.top||a.right,s.topRight,0,o),bottomLeft:Ict(!l||a.bottom||a.left,s.bottomLeft,0,o),bottomRight:Ict(!l||a.bottom||a.right,s.bottomRight,0,o)}}(t,n/2,i/2);return{outer:{x:e.left,y:e.top,w:n,h:i,radius:s},inner:{x:e.left+r.l,y:e.top+r.t,w:n-r.l-r.r,h:i-r.t-r.b,radius:{topLeft:Math.max(0,s.topLeft-Math.max(r.t,r.l)),topRight:Math.max(0,s.topRight-Math.max(r.t,r.r)),bottomLeft:Math.max(0,s.bottomLeft-Math.max(r.b,r.l)),bottomRight:Math.max(0,s.bottomRight-Math.max(r.b,r.r))}}}}function Nct(t,e,n,i){const r=null===e,s=null===n,o=t&&!(r&&s)&&$ct(t,i);return o&&(r||ast(e,o.left,o.right))&&(s||ast(n,o.top,o.bottom))}function Rct(t,e){t.rect(e.x,e.y,e.w,e.h)}function Pct(t,e,n={}){const i=t.x!==n.x?-e:0,r=t.y!==n.y?-e:0,s=(t.x+t.w!==n.x+n.w?e:0)-i,o=(t.y+t.h!==n.y+n.h?e:0)-r;return{x:t.x+i,y:t.y+r,w:t.w+s,h:t.h+o,radius:t.radius}}class Oct extends Clt{static id="bar";static defaults={borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0};static defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};constructor(t){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,t&&Object.assign(this,t)}draw(t){const{inflateAmount:e,options:{borderColor:n,backgroundColor:i}}=this,{inner:r,outer:s}=Act(this),o=(a=s.radius).topLeft||a.topRight||a.bottomLeft||a.bottomRight?Qst:Rct;var a;t.save(),s.w===r.w&&s.h===r.h||(t.beginPath(),o(t,Pct(s,e,r)),t.clip(),o(t,Pct(r,-e,s)),t.fillStyle=n,t.fill("evenodd")),t.beginPath(),o(t,Pct(r,e)),t.fillStyle=i,t.fill(),t.restore()}inRange(t,e,n){return Nct(this,t,e,n)}inXRange(t,e){return Nct(this,t,null,e)}inYRange(t,e){return Nct(this,null,t,e)}getCenterPoint(t){const{x:e,y:n,base:i,horizontal:r}=this.getProps(["x","y","base","horizontal"],t);return{x:r?(e+i)/2:e,y:r?n:(n+i)/2}}getRange(t){return"x"===t?this.width/2:this.height/2}}function Lct(t,e,n,i){if(i)return;let r=e[t],s=n[t];return"angle"===t&&(r=rst(r),s=rst(s)),{property:t,start:r,end:s}}function Dct(t,e,n){for(;e>t;e--){const t=n[e];if(!isNaN(t.x)&&!isNaN(t.y))break}return e}function Fct(t,e,n,i){return t&&e?i(t[n],e[n]):t?t[n]:e?e[n]:0}function zct(t,e){let n=[],i=!1;return yrt(t)?(i=!0,n=t):n=function(t,e){const{x:n=null,y:i=null}=t||{},r=e.points,s=[];return e.segments.forEach((({start:t,end:e})=>{e=Dct(t,e,r);const o=r[t],a=r[e];null!==i?(s.push({x:o.x,y:i}),s.push({x:a.x,y:i})):null!==n&&(s.push({x:n,y:o.y}),s.push({x:n,y:a.y}))})),s}(t,e),n.length?new _ct({points:n,options:{tension:0},_loop:i,_fullLoop:i}):null}function Bct(t){return t&&!1!==t.fill}function Uct(t,e,n){let i=t[e].fill;const r=[e];let s;if(!n)return i;for(;!1!==i&&-1===r.indexOf(i);){if(!vrt(i))return i;if(s=t[i],!s)return!1;if(s.visible)return i;r.push(i),i=s.fill}return!1}function Vct(t,e,n){const i=function(t){const e=t.options,n=e.fill;let i=wrt(n&&n.target,n);void 0===i&&(i=!!e.backgroundColor);if(!1===i||null===i)return!1;if(!0===i)return"origin";return i}(t);if(brt(i))return!isNaN(i.value)&&i;let r=parseFloat(i);return vrt(r)&&Math.floor(r)===r?function(t,e,n,i){"-"!==t&&"+"!==t||(n=e+n);if(n===e||n<0||n>=i)return!1;return n}(i[0],e,r,n):["origin","start","end","stack","shape"].indexOf(i)>=0&&i}function Wct(t,e,n){const i=[];for(let r=0;r<n.length;r++){const s=n[r],{first:o,last:a,point:l}=Hct(s,e,"x");if(!(!l||o&&a))if(o)i.unshift(l);else if(t.push(l),!a)break}t.push(...i)}function Hct(t,e,n){const i=t.interpolate(e,n);if(!i)return{};const r=i[n],s=t.segments,o=t.points;let a=!1,l=!1;for(let t=0;t<s.length;t++){const e=s[t],i=o[e.start][n],c=o[e.end][n];if(ast(r,i,c)){a=r===i,l=r===c;break}}return{first:a,last:l,point:i}}class jct{constructor(t){this.x=t.x,this.y=t.y,this.radius=t.radius}pathSegment(t,e,n){const{x:i,y:r,radius:s}=this;return e=e||{start:0,end:zrt},t.arc(i,r,s,e.end,e.start,!0),!n.bounds}interpolate(t){const{x:e,y:n,radius:i}=this,r=t.angle;return{x:e+Math.cos(r)*i,y:n+Math.sin(r)*i,angle:r}}}function Gct(t){const{chart:e,fill:n,line:i}=t;if(vrt(n))return function(t,e){const n=t.getDatasetMeta(e),i=n&&t.isDatasetVisible(e);return i?n.dataset:null}(e,n);if("stack"===n)return function(t){const{scale:e,index:n,line:i}=t,r=[],s=i.segments,o=i.points,a=function(t,e){const n=[],i=t.getMatchingVisibleMetas("line");for(let t=0;t<i.length;t++){const r=i[t];if(r.index===e)break;r.hidden||n.unshift(r.dataset)}return n}(e,n);a.push(zct({x:null,y:e.bottom},i));for(let t=0;t<s.length;t++){const e=s[t];for(let t=e.start;t<=e.end;t++)Wct(r,o[t],a)}return new _ct({points:r,options:{}})}(t);if("shape"===n)return!0;const r=function(t){const e=t.scale||{};if(e.getPointPositionForValue)return function(t){const{scale:e,fill:n}=t,i=e.options,r=e.getLabels().length,s=i.reverse?e.max:e.min,o=function(t,e,n){let i;return i="start"===t?n:"end"===t?e.options.reverse?e.min:e.max:brt(t)?t.value:e.getBaseValue(),i}(n,e,s),a=[];if(i.grid.circular){const t=e.getPointPositionForValue(0,s);return new jct({x:t.x,y:t.y,radius:e.getDistanceFromCenterForValue(o)})}for(let t=0;t<r;++t)a.push(e.getPointPositionForValue(t,o));return a}(t);return function(t){const{scale:e={},fill:n}=t,i=function(t,e){let n=null;return"start"===t?n=e.bottom:"end"===t?n=e.top:brt(t)?n=e.getPixelForValue(t.value):e.getBasePixel&&(n=e.getBasePixel()),n}(n,e);if(vrt(i)){const t=e.isHorizontal();return{x:t?i:null,y:t?null:i}}return null}(t)}(t);return r instanceof jct?r:zct(r,i)}function qct(t,e,n){const i=Gct(e),{line:r,scale:s,axis:o}=e,a=r.options,l=a.fill,c=a.backgroundColor,{above:u=c,below:h=c}=l||{};i&&r.points.length&&(Gst(t,n),function(t,e){const{line:n,target:i,above:r,below:s,area:o,scale:a}=e,l=n._loop?"angle":e.axis;t.save(),"x"===l&&s!==r&&(Xct(t,i,o.top),Kct(t,{line:n,target:i,color:r,scale:a,property:l}),t.restore(),t.save(),Xct(t,i,o.bottom));Kct(t,{line:n,target:i,color:s,scale:a,property:l}),t.restore()}(t,{line:r,target:i,above:u,below:h,area:n,scale:s,axis:o}),qst(t))}function Xct(t,e,n){const{segments:i,points:r}=e;let s=!0,o=!1;t.beginPath();for(const a of i){const{start:i,end:l}=a,c=r[i],u=r[Dct(i,l,r)];s?(t.moveTo(c.x,c.y),s=!1):(t.lineTo(c.x,n),t.lineTo(c.x,c.y)),o=!!e.pathSegment(t,a,{move:o}),o?t.closePath():t.lineTo(u.x,n)}t.lineTo(e.first().x,n),t.closePath(),t.clip()}function Kct(t,e){const{line:n,target:i,property:r,color:s,scale:o}=e,a=function(t,e,n){const i=t.segments,r=t.points,s=e.points,o=[];for(const t of i){let{start:i,end:a}=t;a=Dct(i,a,r);const l=Lct(n,r[i],r[a],t.loop);if(!e.segments){o.push({source:t,target:l,start:r[i],end:r[a]});continue}const c=tat(e,l);for(const e of c){const i=Lct(n,s[e.start],s[e.end],e.loop),a=Qot(t,r,i);for(const t of a)o.push({source:t,target:e,start:{[n]:Fct(l,i,"start",Math.max)},end:{[n]:Fct(l,i,"end",Math.min)}})}}return o}(n,i,r);for(const{source:e,target:l,start:c,end:u}of a){const{style:{backgroundColor:a=s}={}}=e,h=!0!==i;t.save(),t.fillStyle=a,Yct(t,o,h&&Lct(r,c,u)),t.beginPath();const d=!!n.pathSegment(t,e);let p;if(h){d?t.closePath():Zct(t,i,u,r);const e=!!i.pathSegment(t,l,{move:d,reverse:!0});p=d&&e,p||Zct(t,i,c,r)}t.closePath(),t.fill(p?"evenodd":"nonzero"),t.restore()}}function Yct(t,e,n){const{top:i,bottom:r}=e.chart.chartArea,{property:s,start:o,end:a}=n||{};"x"===s&&(t.beginPath(),t.rect(o,i,a-o,r-i),t.clip())}function Zct(t,e,n,i){const r=e.interpolate(n,i);r&&t.lineTo(r.x,r.y)}var Jct={id:"filler",afterDatasetsUpdate(t,e,n){const i=(t.data.datasets||[]).length,r=[];let s,o,a,l;for(o=0;o<i;++o)s=t.getDatasetMeta(o),a=s.dataset,l=null,a&&a.options&&a instanceof _ct&&(l={visible:t.isDatasetVisible(o),index:o,fill:Vct(a,o,i),chart:t,axis:s.controller.options.indexAxis,scale:s.vScale,line:a}),s.$filler=l,r.push(l);for(o=0;o<i;++o)l=r[o],l&&!1!==l.fill&&(l.fill=Uct(r,o,n.propagate))},beforeDraw(t,e,n){const i="beforeDraw"===n.drawTime,r=t.getSortedVisibleDatasetMetas(),s=t.chartArea;for(let e=r.length-1;e>=0;--e){const n=r[e].$filler;n&&(n.line.updateControlPoints(s,n.axis),i&&n.fill&&qct(t.ctx,n,s))}},beforeDatasetsDraw(t,e,n){if("beforeDatasetsDraw"!==n.drawTime)return;const i=t.getSortedVisibleDatasetMetas();for(let e=i.length-1;e>=0;--e){const n=i[e].$filler;Bct(n)&&qct(t.ctx,n,t.chartArea)}},beforeDatasetDraw(t,e,n){const i=e.meta.$filler;Bct(i)&&"beforeDatasetDraw"===n.drawTime&&qct(t.ctx,i,t.chartArea)},defaults:{propagate:!0,drawTime:"beforeDatasetDraw"}};const Qct=(t,e)=>{let{boxHeight:n=e,boxWidth:i=e}=t;return t.usePointStyle&&(n=Math.min(n,e),i=t.pointStyleWidth||Math.min(i,e)),{boxWidth:i,boxHeight:n,itemHeight:Math.max(e,n)}};class tut extends Clt{constructor(t){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e,n){this.maxWidth=t,this.maxHeight=e,this._margins=n,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const t=this.options.labels||{};let e=krt(t.generateLabels,[this.chart],this)||[];t.filter&&(e=e.filter((e=>t.filter(e,this.chart.data)))),t.sort&&(e=e.sort(((e,n)=>t.sort(e,n,this.chart.data)))),this.options.reverse&&e.reverse(),this.legendItems=e}fit(){const{options:t,ctx:e}=this;if(!t.display)return void(this.width=this.height=0);const n=t.labels,i=lot(n.font),r=i.size,s=this._computeTitleHeight(),{boxWidth:o,itemHeight:a}=Qct(n,r);let l,c;e.font=i.string,this.isHorizontal()?(l=this.maxWidth,c=this._fitRows(s,r,o,a)+10):(c=this.maxHeight,l=this._fitCols(s,i,o,a)+10),this.width=Math.min(l,t.maxWidth||this.maxWidth),this.height=Math.min(c,t.maxHeight||this.maxHeight)}_fitRows(t,e,n,i){const{ctx:r,maxWidth:s,options:{labels:{padding:o}}}=this,a=this.legendHitBoxes=[],l=this.lineWidths=[0],c=i+o;let u=t;r.textAlign="left",r.textBaseline="middle";let h=-1,d=-c;return this.legendItems.forEach(((t,p)=>{const f=n+e/2+r.measureText(t.text).width;(0===p||l[l.length-1]+f+2*o>s)&&(u+=c,l[l.length-(p>0?0:1)]=0,d+=c,h++),a[p]={left:0,top:d,row:h,width:f,height:i},l[l.length-1]+=f+o})),u}_fitCols(t,e,n,i){const{ctx:r,maxHeight:s,options:{labels:{padding:o}}}=this,a=this.legendHitBoxes=[],l=this.columnSizes=[],c=s-t;let u=o,h=0,d=0,p=0,f=0;return this.legendItems.forEach(((t,s)=>{const{itemWidth:m,itemHeight:g}=function(t,e,n,i,r){const s=function(t,e,n,i){let r=t.text;r&&"string"!=typeof r&&(r=r.reduce(((t,e)=>t.length>e.length?t:e)));return e+n.size/2+i.measureText(r).width}(i,t,e,n),o=function(t,e,n){let i=t;"string"!=typeof e.text&&(i=eut(e,n));return i}(r,i,e.lineHeight);return{itemWidth:s,itemHeight:o}}(n,e,r,t,i);s>0&&d+g+2*o>c&&(u+=h+o,l.push({width:h,height:d}),p+=h+o,f++,h=d=0),a[s]={left:p,top:d,col:f,width:m,height:g},h=Math.max(h,m),d+=g+o})),u+=h,l.push({width:h,height:d}),u}adjustHitBoxes(){if(!this.options.display)return;const t=this._computeTitleHeight(),{legendHitBoxes:e,options:{align:n,labels:{padding:i},rtl:r}}=this,s=Xot(r,this.left,this.width);if(this.isHorizontal()){let r=0,o=yst(n,this.left+i,this.right-this.lineWidths[r]);for(const a of e)r!==a.row&&(r=a.row,o=yst(n,this.left+i,this.right-this.lineWidths[r])),a.top+=this.top+t+i,a.left=s.leftForLtr(s.x(o),a.width),o+=a.width+i}else{let r=0,o=yst(n,this.top+t+i,this.bottom-this.columnSizes[r].height);for(const a of e)a.col!==r&&(r=a.col,o=yst(n,this.top+t+i,this.bottom-this.columnSizes[r].height)),a.top=o,a.left+=this.left+i,a.left=s.leftForLtr(s.x(a.left),a.width),o+=a.height+i}}isHorizontal(){return"top"===this.options.position||"bottom"===this.options.position}draw(){if(this.options.display){const t=this.ctx;Gst(t,this),this._draw(),qst(t)}}_draw(){const{options:t,columnSizes:e,lineWidths:n,ctx:i}=this,{align:r,labels:s}=t,o=Fst.color,a=Xot(t.rtl,this.left,this.width),l=lot(s.font),{padding:c}=s,u=l.size,h=u/2;let d;this.drawTitle(),i.textAlign=a.textAlign("left"),i.textBaseline="middle",i.lineWidth=.5,i.font=l.string;const{boxWidth:p,boxHeight:f,itemHeight:m}=Qct(s,u),g=this.isHorizontal(),y=this._computeTitleHeight();d=g?{x:yst(r,this.left+c,this.right-n[0]),y:this.top+c+y,line:0}:{x:this.left+c,y:yst(r,this.top+y+c,this.bottom-e[0].height),line:0},Kot(this.ctx,t.textDirection);const b=m+c;this.legendItems.forEach(((v,x)=>{i.strokeStyle=v.fontColor,i.fillStyle=v.fontColor;const w=i.measureText(v.text).width,S=a.textAlign(v.textAlign||(v.textAlign=s.textAlign)),k=p+h+w;let C=d.x,T=d.y;a.setWidth(this.width),g?x>0&&C+k+c>this.right&&(T=d.y+=b,d.line++,C=d.x=yst(r,this.left+c,this.right-n[d.line])):x>0&&T+b>this.bottom&&(C=d.x=C+e[d.line].width+c,d.line++,T=d.y=yst(r,this.top+y+c,this.bottom-e[d.line].height));if(function(t,e,n){if(isNaN(p)||p<=0||isNaN(f)||f<0)return;i.save();const r=wrt(n.lineWidth,1);if(i.fillStyle=wrt(n.fillStyle,o),i.lineCap=wrt(n.lineCap,"butt"),i.lineDashOffset=wrt(n.lineDashOffset,0),i.lineJoin=wrt(n.lineJoin,"miter"),i.lineWidth=r,i.strokeStyle=wrt(n.strokeStyle,o),i.setLineDash(wrt(n.lineDash,[])),s.usePointStyle){const o={radius:f*Math.SQRT2/2,pointStyle:n.pointStyle,rotation:n.rotation,borderWidth:r},l=a.xPlus(t,p/2);Hst(i,o,l,e+h,s.pointStyleWidth&&p)}else{const s=e+Math.max((u-f)/2,0),o=a.leftForLtr(t,p),l=oot(n.borderRadius);i.beginPath(),Object.values(l).some((t=>0!==t))?Qst(i,{x:o,y:s,w:p,h:f,radius:l}):i.rect(o,s,p,f),i.fill(),0!==r&&i.stroke()}i.restore()}(a.x(C),T,v),C=((t,e,n,i)=>t===(i?"left":"right")?n:"center"===t?(e+n)/2:e)(S,C+p+h,g?C+k:this.right,t.rtl),function(t,e,n){Jst(i,n.text,t,e+m/2,l,{strikethrough:n.hidden,textAlign:a.textAlign(n.textAlign)})}(a.x(C),T,v),g)d.x+=k+c;else if("string"!=typeof v.text){const t=l.lineHeight;d.y+=eut(v,t)+c}else d.y+=b})),Yot(this.ctx,t.textDirection)}drawTitle(){const t=this.options,e=t.title,n=lot(e.font),i=aot(e.padding);if(!e.display)return;const r=Xot(t.rtl,this.left,this.width),s=this.ctx,o=e.position,a=n.size/2,l=i.top+a;let c,u=this.left,h=this.width;if(this.isHorizontal())h=Math.max(...this.lineWidths),c=this.top+l,u=yst(t.align,u,this.right-h);else{const e=this.columnSizes.reduce(((t,e)=>Math.max(t,e.height)),0);c=l+yst(t.align,this.top,this.bottom-e-t.labels.padding-this._computeTitleHeight())}const d=yst(o,u,u+h);s.textAlign=r.textAlign(gst(o)),s.textBaseline="middle",s.strokeStyle=e.color,s.fillStyle=e.color,s.font=n.string,Jst(s,e.text,d,c,n)}_computeTitleHeight(){const t=this.options.title,e=lot(t.font),n=aot(t.padding);return t.display?e.lineHeight+n.height:0}_getLegendItemAt(t,e){let n,i,r;if(ast(t,this.left,this.right)&&ast(e,this.top,this.bottom))for(r=this.legendHitBoxes,n=0;n<r.length;++n)if(i=r[n],ast(t,i.left,i.left+i.width)&&ast(e,i.top,i.top+i.height))return this.legendItems[n];return null}handleEvent(t){const e=this.options;if(!function(t,e){if(("mousemove"===t||"mouseout"===t)&&(e.onHover||e.onLeave))return!0;if(e.onClick&&("click"===t||"mouseup"===t))return!0;return!1}(t.type,e))return;const n=this._getLegendItemAt(t.x,t.y);if("mousemove"===t.type||"mouseout"===t.type){const i=this._hoveredItem,r=((t,e)=>null!==t&&null!==e&&t.datasetIndex===e.datasetIndex&&t.index===e.index)(i,n);i&&!r&&krt(e.onLeave,[t,i,this],this),this._hoveredItem=n,n&&!r&&krt(e.onHover,[t,n,this],this)}else n&&krt(e.onClick,[t,n,this],this)}}function eut(t,e){return e*(t.text?t.text.length:0)}var nut={id:"legend",_element:tut,start(t,e,n){const i=t.legend=new tut({ctx:t.ctx,options:n,chart:t});olt.configure(t,i,n),olt.addBox(t,i)},stop(t){olt.removeBox(t,t.legend),delete t.legend},beforeUpdate(t,e,n){const i=t.legend;olt.configure(t,i,n),i.options=n},afterUpdate(t){const e=t.legend;e.buildLabels(),e.adjustHitBoxes()},afterEvent(t,e){e.replay||t.legend.handleEvent(e.event)},defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,onClick(t,e,n){const i=e.datasetIndex,r=n.chart;r.isDatasetVisible(i)?(r.hide(i),e.hidden=!0):(r.show(i),e.hidden=!1)},onHover:null,onLeave:null,labels:{color:t=>t.chart.options.color,boxWidth:40,padding:10,generateLabels(t){const e=t.data.datasets,{labels:{usePointStyle:n,pointStyle:i,textAlign:r,color:s,useBorderRadius:o,borderRadius:a}}=t.legend.options;return t._getSortedDatasetMetas().map((t=>{const l=t.controller.getStyle(n?0:void 0),c=aot(l.borderWidth);return{text:e[t.index].label,fillStyle:l.backgroundColor,fontColor:s,hidden:!t.visible,lineCap:l.borderCapStyle,lineDash:l.borderDash,lineDashOffset:l.borderDashOffset,lineJoin:l.borderJoinStyle,lineWidth:(c.width+c.height)/4,strokeStyle:l.borderColor,pointStyle:i||l.pointStyle,rotation:l.rotation,textAlign:r||l.textAlign,borderRadius:o&&(a||l.borderRadius),datasetIndex:t.index}}),this)}},title:{color:t=>t.chart.options.color,display:!1,position:"center",text:""}},descriptors:{_scriptable:t=>!t.startsWith("on"),labels:{_scriptable:t=>!["generateLabels","filter","sort"].includes(t)}}};class iut extends Clt{constructor(t){super(),this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e){const n=this.options;if(this.left=0,this.top=0,!n.display)return void(this.width=this.height=this.right=this.bottom=0);this.width=this.right=t,this.height=this.bottom=e;const i=yrt(n.text)?n.text.length:1;this._padding=aot(n.padding);const r=i*lot(n.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=r:this.width=r}isHorizontal(){const t=this.options.position;return"top"===t||"bottom"===t}_drawArgs(t){const{top:e,left:n,bottom:i,right:r,options:s}=this,o=s.align;let a,l,c,u=0;return this.isHorizontal()?(l=yst(o,n,r),c=e+t,a=r-n):("left"===s.position?(l=n+t,c=yst(o,i,e),u=-.5*Frt):(l=r-t,c=yst(o,e,i),u=.5*Frt),a=i-e),{titleX:l,titleY:c,maxWidth:a,rotation:u}}draw(){const t=this.ctx,e=this.options;if(!e.display)return;const n=lot(e.font),i=n.lineHeight/2+this._padding.top,{titleX:r,titleY:s,maxWidth:o,rotation:a}=this._drawArgs(i);Jst(t,e.text,0,0,n,{color:e.color,maxWidth:o,rotation:a,textAlign:gst(e.align),textBaseline:"middle",translation:[r,s]})}}var rut={id:"title",_element:iut,start(t,e,n){!function(t,e){const n=new iut({ctx:t.ctx,options:e,chart:t});olt.configure(t,n,e),olt.addBox(t,n),t.titleBlock=n}(t,n)},stop(t){const e=t.titleBlock;olt.removeBox(t,e),delete t.titleBlock},beforeUpdate(t,e,n){const i=t.titleBlock;olt.configure(t,i,n),i.options=n},defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const sut={average(t){if(!t.length)return!1;let e,n,i=0,r=0,s=0;for(e=0,n=t.length;e<n;++e){const n=t[e].element;if(n&&n.hasValue()){const t=n.tooltipPosition();i+=t.x,r+=t.y,++s}}return{x:i/s,y:r/s}},nearest(t,e){if(!t.length)return!1;let n,i,r,s=e.x,o=e.y,a=Number.POSITIVE_INFINITY;for(n=0,i=t.length;n<i;++n){const i=t[n].element;if(i&&i.hasValue()){const t=nst(e,i.getCenterPoint());t<a&&(a=t,r=i)}}if(r){const t=r.tooltipPosition();s=t.x,o=t.y}return{x:s,y:o}}};function out(t,e){return e&&(yrt(e)?Array.prototype.push.apply(t,e):t.push(e)),t}function aut(t){return("string"==typeof t||t instanceof String)&&t.indexOf("\n")>-1?t.split("\n"):t}function lut(t,e){const{element:n,datasetIndex:i,index:r}=e,s=t.getDatasetMeta(i).controller,{label:o,value:a}=s.getLabelAndValue(r);return{chart:t,label:o,parsed:s.getParsed(r),raw:t.data.datasets[i].data[r],formattedValue:a,dataset:s.getDataset(),dataIndex:r,datasetIndex:i,element:n}}function cut(t,e){const n=t.chart.ctx,{body:i,footer:r,title:s}=t,{boxWidth:o,boxHeight:a}=e,l=lot(e.bodyFont),c=lot(e.titleFont),u=lot(e.footerFont),h=s.length,d=r.length,p=i.length,f=aot(e.padding);let m=f.height,g=0,y=i.reduce(((t,e)=>t+e.before.length+e.lines.length+e.after.length),0);if(y+=t.beforeBody.length+t.afterBody.length,h&&(m+=h*c.lineHeight+(h-1)*e.titleSpacing+e.titleMarginBottom),y){m+=p*(e.displayColors?Math.max(a,l.lineHeight):l.lineHeight)+(y-p)*l.lineHeight+(y-1)*e.bodySpacing}d&&(m+=e.footerMarginTop+d*u.lineHeight+(d-1)*e.footerSpacing);let b=0;const v=function(t){g=Math.max(g,n.measureText(t).width+b)};return n.save(),n.font=c.string,Crt(t.title,v),n.font=l.string,Crt(t.beforeBody.concat(t.afterBody),v),b=e.displayColors?o+2+e.boxPadding:0,Crt(i,(t=>{Crt(t.before,v),Crt(t.lines,v),Crt(t.after,v)})),b=0,n.font=u.string,Crt(t.footer,v),n.restore(),g+=f.width,{width:g,height:m}}function uut(t,e,n,i){const{x:r,width:s}=n,{width:o,chartArea:{left:a,right:l}}=t;let c="center";return"center"===i?c=r<=(a+l)/2?"left":"right":r<=s/2?c="left":r>=o-s/2&&(c="right"),function(t,e,n,i){const{x:r,width:s}=i,o=n.caretSize+n.caretPadding;return"left"===t&&r+s+o>e.width||"right"===t&&r-s-o<0||void 0}(c,t,e,n)&&(c="center"),c}function hut(t,e,n){const i=n.yAlign||e.yAlign||function(t,e){const{y:n,height:i}=e;return n<i/2?"top":n>t.height-i/2?"bottom":"center"}(t,n);return{xAlign:n.xAlign||e.xAlign||uut(t,e,n,i),yAlign:i}}function dut(t,e,n,i){const{caretSize:r,caretPadding:s,cornerRadius:o}=t,{xAlign:a,yAlign:l}=n,c=r+s,{topLeft:u,topRight:h,bottomLeft:d,bottomRight:p}=oot(o);let f=function(t,e){let{x:n,width:i}=t;return"right"===e?n-=i:"center"===e&&(n-=i/2),n}(e,a);const m=function(t,e,n){let{y:i,height:r}=t;return"top"===e?i+=n:i-="bottom"===e?r+n:r/2,i}(e,l,c);return"center"===l?"left"===a?f+=c:"right"===a&&(f-=c):"left"===a?f-=Math.max(u,d)+r:"right"===a&&(f+=Math.max(h,p)+r),{x:ost(f,0,i.width-e.width),y:ost(m,0,i.height-e.height)}}function put(t,e,n){const i=aot(n.padding);return"center"===e?t.x+t.width/2:"right"===e?t.x+t.width-i.right:t.x+i.left}function fut(t){return out([],aut(t))}function mut(t,e){const n=e&&e.dataset&&e.dataset.tooltip&&e.dataset.tooltip.callbacks;return n?t.override(n):t}const gut={beforeTitle:frt,title(t){if(t.length>0){const e=t[0],n=e.chart.data.labels,i=n?n.length:0;if(this&&this.options&&"dataset"===this.options.mode)return e.dataset.label||"";if(e.label)return e.label;if(i>0&&e.dataIndex<i)return n[e.dataIndex]}return""},afterTitle:frt,beforeBody:frt,beforeLabel:frt,label(t){if(this&&this.options&&"dataset"===this.options.mode)return t.label+": "+t.formattedValue||t.formattedValue;let e=t.dataset.label||"";e&&(e+=": ");const n=t.formattedValue;return grt(n)||(e+=n),e},labelColor(t){const e=t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(t){const e=t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);return{pointStyle:e.pointStyle,rotation:e.rotation}},afterLabel:frt,afterBody:frt,beforeFooter:frt,footer:frt,afterFooter:frt};function yut(t,e,n,i){const r=t[e].call(n,i);return void 0===r?gut[e].call(n,i):r}let but=class extends Clt{static positioners=sut;constructor(t){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(t){this.options=t,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const t=this._cachedAnimations;if(t)return t;const e=this.chart,n=this.options.setContext(this.getContext()),i=n.enabled&&e.options.animation&&n.animations,r=new cat(this.chart,i);return i._cacheable&&(this._cachedAnimations=Object.freeze(r)),r}getContext(){return this.$context||(this.$context=(t=this.chart.getContext(),e=this,n=this._tooltipItems,uot(t,{tooltip:e,tooltipItems:n,type:"tooltip"})));var t,e,n}getTitle(t,e){const{callbacks:n}=e,i=yut(n,"beforeTitle",this,t),r=yut(n,"title",this,t),s=yut(n,"afterTitle",this,t);let o=[];return o=out(o,aut(i)),o=out(o,aut(r)),o=out(o,aut(s)),o}getBeforeBody(t,e){return fut(yut(e.callbacks,"beforeBody",this,t))}getBody(t,e){const{callbacks:n}=e,i=[];return Crt(t,(t=>{const e={before:[],lines:[],after:[]},r=mut(n,t);out(e.before,aut(yut(r,"beforeLabel",this,t))),out(e.lines,yut(r,"label",this,t)),out(e.after,aut(yut(r,"afterLabel",this,t))),i.push(e)})),i}getAfterBody(t,e){return fut(yut(e.callbacks,"afterBody",this,t))}getFooter(t,e){const{callbacks:n}=e,i=yut(n,"beforeFooter",this,t),r=yut(n,"footer",this,t),s=yut(n,"afterFooter",this,t);let o=[];return o=out(o,aut(i)),o=out(o,aut(r)),o=out(o,aut(s)),o}_createItems(t){const e=this._active,n=this.chart.data,i=[],r=[],s=[];let o,a,l=[];for(o=0,a=e.length;o<a;++o)l.push(lut(this.chart,e[o]));return t.filter&&(l=l.filter(((e,i,r)=>t.filter(e,i,r,n)))),t.itemSort&&(l=l.sort(((e,i)=>t.itemSort(e,i,n)))),Crt(l,(e=>{const n=mut(t.callbacks,e);i.push(yut(n,"labelColor",this,e)),r.push(yut(n,"labelPointStyle",this,e)),s.push(yut(n,"labelTextColor",this,e))})),this.labelColors=i,this.labelPointStyles=r,this.labelTextColors=s,this.dataPoints=l,l}update(t,e){const n=this.options.setContext(this.getContext()),i=this._active;let r,s=[];if(i.length){const t=sut[n.position].call(this,i,this._eventPosition);s=this._createItems(n),this.title=this.getTitle(s,n),this.beforeBody=this.getBeforeBody(s,n),this.body=this.getBody(s,n),this.afterBody=this.getAfterBody(s,n),this.footer=this.getFooter(s,n);const e=this._size=cut(this,n),o=Object.assign({},t,e),a=hut(this.chart,n,o),l=dut(n,o,a,this.chart);this.xAlign=a.xAlign,this.yAlign=a.yAlign,r={opacity:1,x:l.x,y:l.y,width:e.width,height:e.height,caretX:t.x,caretY:t.y}}else 0!==this.opacity&&(r={opacity:0});this._tooltipItems=s,this.$context=void 0,r&&this._resolveAnimations().update(this,r),t&&n.external&&n.external.call(this,{chart:this.chart,tooltip:this,replay:e})}drawCaret(t,e,n,i){const r=this.getCaretPosition(t,n,i);e.lineTo(r.x1,r.y1),e.lineTo(r.x2,r.y2),e.lineTo(r.x3,r.y3)}getCaretPosition(t,e,n){const{xAlign:i,yAlign:r}=this,{caretSize:s,cornerRadius:o}=n,{topLeft:a,topRight:l,bottomLeft:c,bottomRight:u}=oot(o),{x:h,y:d}=t,{width:p,height:f}=e;let m,g,y,b,v,x;return"center"===r?(v=d+f/2,"left"===i?(m=h,g=m-s,b=v+s,x=v-s):(m=h+p,g=m+s,b=v-s,x=v+s),y=m):(g="left"===i?h+Math.max(a,c)+s:"right"===i?h+p-Math.max(l,u)-s:this.caretX,"top"===r?(b=d,v=b-s,m=g-s,y=g+s):(b=d+f,v=b+s,m=g+s,y=g-s),x=b),{x1:m,x2:g,x3:y,y1:b,y2:v,y3:x}}drawTitle(t,e,n){const i=this.title,r=i.length;let s,o,a;if(r){const l=Xot(n.rtl,this.x,this.width);for(t.x=put(this,n.titleAlign,n),e.textAlign=l.textAlign(n.titleAlign),e.textBaseline="middle",s=lot(n.titleFont),o=n.titleSpacing,e.fillStyle=n.titleColor,e.font=s.string,a=0;a<r;++a)e.fillText(i[a],l.x(t.x),t.y+s.lineHeight/2),t.y+=s.lineHeight+o,a+1===r&&(t.y+=n.titleMarginBottom-o)}}_drawColorBox(t,e,n,i,r){const s=this.labelColors[n],o=this.labelPointStyles[n],{boxHeight:a,boxWidth:l}=r,c=lot(r.bodyFont),u=put(this,"left",r),h=i.x(u),d=a<c.lineHeight?(c.lineHeight-a)/2:0,p=e.y+d;if(r.usePointStyle){const e={radius:Math.min(l,a)/2,pointStyle:o.pointStyle,rotation:o.rotation,borderWidth:1},n=i.leftForLtr(h,l)+l/2,c=p+a/2;t.strokeStyle=r.multiKeyBackground,t.fillStyle=r.multiKeyBackground,Wst(t,e,n,c),t.strokeStyle=s.borderColor,t.fillStyle=s.backgroundColor,Wst(t,e,n,c)}else{t.lineWidth=brt(s.borderWidth)?Math.max(...Object.values(s.borderWidth)):s.borderWidth||1,t.strokeStyle=s.borderColor,t.setLineDash(s.borderDash||[]),t.lineDashOffset=s.borderDashOffset||0;const e=i.leftForLtr(h,l),n=i.leftForLtr(i.xPlus(h,1),l-2),o=oot(s.borderRadius);Object.values(o).some((t=>0!==t))?(t.beginPath(),t.fillStyle=r.multiKeyBackground,Qst(t,{x:e,y:p,w:l,h:a,radius:o}),t.fill(),t.stroke(),t.fillStyle=s.backgroundColor,t.beginPath(),Qst(t,{x:n,y:p+1,w:l-2,h:a-2,radius:o}),t.fill()):(t.fillStyle=r.multiKeyBackground,t.fillRect(e,p,l,a),t.strokeRect(e,p,l,a),t.fillStyle=s.backgroundColor,t.fillRect(n,p+1,l-2,a-2))}t.fillStyle=this.labelTextColors[n]}drawBody(t,e,n){const{body:i}=this,{bodySpacing:r,bodyAlign:s,displayColors:o,boxHeight:a,boxWidth:l,boxPadding:c}=n,u=lot(n.bodyFont);let h=u.lineHeight,d=0;const p=Xot(n.rtl,this.x,this.width),f=function(n){e.fillText(n,p.x(t.x+d),t.y+h/2),t.y+=h+r},m=p.textAlign(s);let g,y,b,v,x,w,S;for(e.textAlign=s,e.textBaseline="middle",e.font=u.string,t.x=put(this,m,n),e.fillStyle=n.bodyColor,Crt(this.beforeBody,f),d=o&&"right"!==m?"center"===s?l/2+c:l+2+c:0,v=0,w=i.length;v<w;++v){for(g=i[v],y=this.labelTextColors[v],e.fillStyle=y,Crt(g.before,f),b=g.lines,o&&b.length&&(this._drawColorBox(e,t,v,p,n),h=Math.max(u.lineHeight,a)),x=0,S=b.length;x<S;++x)f(b[x]),h=u.lineHeight;Crt(g.after,f)}d=0,h=u.lineHeight,Crt(this.afterBody,f),t.y-=r}drawFooter(t,e,n){const i=this.footer,r=i.length;let s,o;if(r){const a=Xot(n.rtl,this.x,this.width);for(t.x=put(this,n.footerAlign,n),t.y+=n.footerMarginTop,e.textAlign=a.textAlign(n.footerAlign),e.textBaseline="middle",s=lot(n.footerFont),e.fillStyle=n.footerColor,e.font=s.string,o=0;o<r;++o)e.fillText(i[o],a.x(t.x),t.y+s.lineHeight/2),t.y+=s.lineHeight+n.footerSpacing}}drawBackground(t,e,n,i){const{xAlign:r,yAlign:s}=this,{x:o,y:a}=t,{width:l,height:c}=n,{topLeft:u,topRight:h,bottomLeft:d,bottomRight:p}=oot(i.cornerRadius);e.fillStyle=i.backgroundColor,e.strokeStyle=i.borderColor,e.lineWidth=i.borderWidth,e.beginPath(),e.moveTo(o+u,a),"top"===s&&this.drawCaret(t,e,n,i),e.lineTo(o+l-h,a),e.quadraticCurveTo(o+l,a,o+l,a+h),"center"===s&&"right"===r&&this.drawCaret(t,e,n,i),e.lineTo(o+l,a+c-p),e.quadraticCurveTo(o+l,a+c,o+l-p,a+c),"bottom"===s&&this.drawCaret(t,e,n,i),e.lineTo(o+d,a+c),e.quadraticCurveTo(o,a+c,o,a+c-d),"center"===s&&"left"===r&&this.drawCaret(t,e,n,i),e.lineTo(o,a+u),e.quadraticCurveTo(o,a,o+u,a),e.closePath(),e.fill(),i.borderWidth>0&&e.stroke()}_updateAnimationTarget(t){const e=this.chart,n=this.$animations,i=n&&n.x,r=n&&n.y;if(i||r){const n=sut[t.position].call(this,this._active,this._eventPosition);if(!n)return;const s=this._size=cut(this,t),o=Object.assign({},n,this._size),a=hut(e,t,o),l=dut(t,o,a,e);i._to===l.x&&r._to===l.y||(this.xAlign=a.xAlign,this.yAlign=a.yAlign,this.width=s.width,this.height=s.height,this.caretX=n.x,this.caretY=n.y,this._resolveAnimations().update(this,l))}}_willRender(){return!!this.opacity}draw(t){const e=this.options.setContext(this.getContext());let n=this.opacity;if(!n)return;this._updateAnimationTarget(e);const i={width:this.width,height:this.height},r={x:this.x,y:this.y};n=Math.abs(n)<.001?0:n;const s=aot(e.padding),o=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;e.enabled&&o&&(t.save(),t.globalAlpha=n,this.drawBackground(r,t,i,e),Kot(t,e.textDirection),r.y+=s.top,this.drawTitle(r,t,e),this.drawBody(r,t,e),this.drawFooter(r,t,e),Yot(t,e.textDirection),t.restore())}getActiveElements(){return this._active||[]}setActiveElements(t,e){const n=this._active,i=t.map((({datasetIndex:t,index:e})=>{const n=this.chart.getDatasetMeta(t);if(!n)throw new Error("Cannot find a dataset at index "+t);return{datasetIndex:t,element:n.data[e],index:e}})),r=!Trt(n,i),s=this._positionChanged(i,e);(r||s)&&(this._active=i,this._eventPosition=e,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(t,e,n=!0){if(e&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const i=this.options,r=this._active||[],s=this._getActiveElements(t,r,e,n),o=this._positionChanged(s,t),a=e||!Trt(s,r)||o;return a&&(this._active=s,(i.enabled||i.external)&&(this._eventPosition={x:t.x,y:t.y},this.update(!0,e))),a}_getActiveElements(t,e,n,i){const r=this.options;if("mouseout"===t.type)return[];if(!i)return e;const s=this.chart.getElementsAtEventForMode(t,r.mode,r,n);return r.reverse&&s.reverse(),s}_positionChanged(t,e){const{caretX:n,caretY:i,options:r}=this,s=sut[r.position].call(this,t,e);return!1!==s&&(n!==s.x||i!==s.y)}};var vut={id:"tooltip",_element:but,positioners:sut,afterInit(t,e,n){n&&(t.tooltip=new but({chart:t,options:n}))},beforeUpdate(t,e,n){t.tooltip&&t.tooltip.initialize(n)},reset(t,e,n){t.tooltip&&t.tooltip.initialize(n)},afterDraw(t){const e=t.tooltip;if(e&&e._willRender()){const n={tooltip:e};if(!1===t.notifyPlugins("beforeTooltipDraw",{...n,cancelable:!0}))return;e.draw(t.ctx),t.notifyPlugins("afterTooltipDraw",n)}},afterEvent(t,e){if(t.tooltip){const n=e.replay;t.tooltip.handleEvent(e.event,n,e.inChartArea)&&(e.changed=!0)}},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(t,e)=>e.bodyFont.size,boxWidth:(t,e)=>e.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:gut},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:t=>"filter"!==t&&"itemSort"!==t&&"external"!==t,_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};function xut(t,e,n,i){const r=t.indexOf(e);if(-1===r)return((t,e,n,i)=>("string"==typeof e?(n=t.push(e)-1,i.unshift({index:n,label:e})):isNaN(e)&&(n=null),n))(t,e,n,i);return r!==t.lastIndexOf(e)?n:r}function wut(t){const e=this.getLabels();return t>=0&&t<e.length?e[t]:t}class Sut extends Plt{static id="category";static defaults={ticks:{callback:wut}};constructor(t){super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(t){const e=this._addedLabels;if(e.length){const t=this.getLabels();for(const{index:n,label:i}of e)t[n]===i&&t.splice(n,1);this._addedLabels=[]}super.init(t)}parse(t,e){if(grt(t))return null;const n=this.getLabels();return((t,e)=>null===t?null:ost(Math.round(t),0,e))(e=isFinite(e)&&n[e]===t?e:xut(n,t,wrt(e,t),this._addedLabels),n.length-1)}determineDataLimits(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let{min:n,max:i}=this.getMinMax(!0);"ticks"===this.options.bounds&&(t||(n=0),e||(i=this.getLabels().length-1)),this.min=n,this.max=i}buildTicks(){const t=this.min,e=this.max,n=this.options.offset,i=[];let r=this.getLabels();r=0===t&&e===r.length-1?r:r.slice(t,e+1),this._valueRange=Math.max(r.length-(n?0:1),1),this._startValue=this.min-(n?.5:0);for(let n=t;n<=e;n++)i.push({value:n});return i}getLabelForValue(t){return wut.call(this,t)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(t){return"number"!=typeof t&&(t=this.parse(t)),null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getValueForPixel(t){return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}getBasePixel(){return this.bottom}}function kut(t,e){const n=[],{bounds:i,step:r,min:s,max:o,precision:a,count:l,maxTicks:c,maxDigits:u,includeBounds:h}=t,d=r||1,p=c-1,{min:f,max:m}=e,g=!grt(s),y=!grt(o),b=!grt(l),v=(m-f)/(u+1);let x,w,S,k,C=Krt((m-f)/p/d)*d;if(C<1e-14&&!g&&!y)return[{value:f},{value:m}];k=Math.ceil(m/C)-Math.floor(f/C),k>p&&(C=Krt(k*C/p/d)*d),grt(a)||(x=Math.pow(10,a),C=Math.ceil(C*x)/x),"ticks"===i?(w=Math.floor(f/C)*C,S=Math.ceil(m/C)*C):(w=f,S=m),g&&y&&r&&function(t,e){const n=Math.round(t);return n-e<=t&&n+e>=t}((o-s)/r,C/1e3)?(k=Math.round(Math.min((o-s)/C,c)),C=(o-s)/k,w=s,S=o):b?(w=g?s:w,S=y?o:S,k=l-1,C=(S-w)/k):(k=(S-w)/C,k=Xrt(k,Math.round(k),C/1e3)?Math.round(k):Math.ceil(k));const T=Math.max(tst(C),tst(w));x=Math.pow(10,grt(a)?T:a),w=Math.round(w*x)/x,S=Math.round(S*x)/x;let _=0;for(g&&(h&&w!==s?(n.push({value:s}),w<s&&_++,Xrt(Math.round((w+_*C)*x)/x,s,Cut(s,v,t))&&_++):w<s&&_++);_<k;++_){const t=Math.round((w+_*C)*x)/x;if(y&&t>o)break;n.push({value:t})}return y&&h&&S!==o?n.length&&Xrt(n[n.length-1].value,o,Cut(o,v,t))?n[n.length-1].value=o:n.push({value:o}):y&&S!==o||n.push({value:S}),n}function Cut(t,e,{horizontal:n,minRotation:i}){const r=Jrt(i),s=(n?Math.sin(r):Math.cos(r))||.001,o=.75*e*(""+t).length;return Math.min(e/s,o)}class Tut extends Plt{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(t,e){return grt(t)||("number"==typeof t||t instanceof Number)&&!isFinite(+t)?null:+t}handleTickRangeOptions(){const{beginAtZero:t}=this.options,{minDefined:e,maxDefined:n}=this.getUserBounds();let{min:i,max:r}=this;const s=t=>i=e?i:t,o=t=>r=n?r:t;if(t){const t=qrt(i),e=qrt(r);t<0&&e<0?o(0):t>0&&e>0&&s(0)}if(i===r){let e=0===r?1:Math.abs(.05*r);o(r+e),t||s(i-e)}this.min=i,this.max=r}getTickLimit(){const t=this.options.ticks;let e,{maxTicksLimit:n,stepSize:i}=t;return i?(e=Math.ceil(this.max/i)-Math.floor(this.min/i)+1,e>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${e} ticks. Limiting to 1000.`),e=1e3)):(e=this.computeTickLimit(),n=n||11),n&&(e=Math.min(n,e)),e}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const t=this.options,e=t.ticks;let n=this.getTickLimit();n=Math.max(2,n);const i=kut({maxTicks:n,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:!1!==e.includeBounds},this._range||this);return"ticks"===t.bounds&&Zrt(i,this,"value"),t.reverse?(i.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),i}configure(){const t=this.ticks;let e=this.min,n=this.max;if(super.configure(),this.options.offset&&t.length){const i=(n-e)/Math.max(t.length-1,1)/2;e-=i,n+=i}this._startValue=e,this._endValue=n,this._valueRange=n-e}getLabelForValue(t){return Ist(t,this.chart.options.locale,this.options.ticks.format)}}class _ut extends Tut{static id="linear";static defaults={ticks:{callback:Nst.formatters.numeric}};determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=vrt(t)?t:0,this.max=vrt(e)?e:1,this.handleTickRangeOptions()}computeTickLimit(){const t=this.isHorizontal(),e=t?this.width:this.height,n=Jrt(this.options.ticks.minRotation),i=(t?Math.sin(n):Math.cos(n))||.001,r=this._resolveTickFontOptions(0);return Math.ceil(e/Math.min(40,r.lineHeight/i))}getPixelForValue(t){return null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getValueForPixel(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange}}const Eut=t=>Math.floor(Grt(t)),Mut=(t,e)=>Math.pow(10,Eut(t)+e);function $ut(t){return 1===t/Math.pow(10,Eut(t))}function Iut(t,e,n){const i=Math.pow(10,n),r=Math.floor(t/i);return Math.ceil(e/i)-r}function Aut(t,{min:e,max:n}){e=xrt(t.min,e);const i=[],r=Eut(e);let s=function(t,e){let n=Eut(e-t);for(;Iut(t,e,n)>10;)n++;for(;Iut(t,e,n)<10;)n--;return Math.min(n,Eut(t))}(e,n),o=s<0?Math.pow(10,Math.abs(s)):1;const a=Math.pow(10,s),l=r>s?Math.pow(10,r):0,c=Math.round((e-l)*o)/o,u=Math.floor((e-l)/a/10)*a*10;let h=Math.floor((c-u)/Math.pow(10,s)),d=xrt(t.min,Math.round((l+u+h*Math.pow(10,s))*o)/o);for(;d<n;)i.push({value:d,major:$ut(d),significand:h}),h>=10?h=h<15?15:20:h++,h>=20&&(s++,h=2,o=s>=0?1:o),d=Math.round((l+u+h*Math.pow(10,s))*o)/o;const p=xrt(t.max,d);return i.push({value:p,major:$ut(p),significand:h}),i}class Nut extends Plt{static id="logarithmic";static defaults={ticks:{callback:Nst.formatters.logarithmic,major:{enabled:!0}}};constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(t,e){const n=Tut.prototype.parse.apply(this,[t,e]);if(0!==n)return vrt(n)&&n>0?n:null;this._zero=!0}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=vrt(t)?Math.max(0,t):null,this.max=vrt(e)?Math.max(0,e):null,this.options.beginAtZero&&(this._zero=!0),this._zero&&this.min!==this._suggestedMin&&!vrt(this._userMin)&&(this.min=t===Mut(this.min,0)?Mut(this.min,-1):Mut(this.min,0)),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let n=this.min,i=this.max;const r=e=>n=t?n:e,s=t=>i=e?i:t;n===i&&(n<=0?(r(1),s(10)):(r(Mut(n,-1)),s(Mut(i,1)))),n<=0&&r(Mut(i,-1)),i<=0&&s(Mut(n,1)),this.min=n,this.max=i}buildTicks(){const t=this.options,e=Aut({min:this._userMin,max:this._userMax},this);return"ticks"===t.bounds&&Zrt(e,this,"value"),t.reverse?(e.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),e}getLabelForValue(t){return void 0===t?"0":Ist(t,this.chart.options.locale,this.options.ticks.format)}configure(){const t=this.min;super.configure(),this._startValue=Grt(t),this._valueRange=Grt(this.max)-Grt(t)}getPixelForValue(t){return void 0!==t&&0!==t||(t=this.min),null===t||isNaN(t)?NaN:this.getPixelForDecimal(t===this.min?0:(Grt(t)-this._startValue)/this._valueRange)}getValueForPixel(t){const e=this.getDecimalForPixel(t);return Math.pow(10,this._startValue+e*this._valueRange)}}function Rut(t){const e=t.ticks;if(e.display&&t.display){const t=aot(e.backdropPadding);return wrt(e.font&&e.font.size,Fst.font.size)+t.height}return 0}function Put(t,e,n){return n=yrt(n)?n:[n],{w:Bst(t,e.string,n),h:n.length*e.lineHeight}}function Out(t,e,n,i,r){return t===i||t===r?{start:e-n/2,end:e+n/2}:t<i||t>r?{start:e-n,end:e}:{start:e,end:e+n}}function Lut(t){const e={l:t.left+t._padding.left,r:t.right-t._padding.right,t:t.top+t._padding.top,b:t.bottom-t._padding.bottom},n=Object.assign({},e),i=[],r=[],s=t._pointLabels.length,o=t.options.pointLabels,a=o.centerPointLabels?Frt/s:0;for(let l=0;l<s;l++){const s=o.setContext(t.getPointLabelContext(l));r[l]=s.padding;const c=t.getPointPosition(l,t.drawingArea+r[l],a),u=lot(s.font),h=Put(t.ctx,u,t._pointLabels[l]);i[l]=h;const d=rst(t.getIndexAngle(l)+a),p=Math.round(Qrt(d));Dut(n,e,d,Out(p,c.x,h.w,0,180),Out(p,c.y,h.h,90,270))}t.setCenterPoint(e.l-n.l,n.r-e.r,e.t-n.t,n.b-e.b),t._pointLabelItems=function(t,e,n){const i=[],r=t._pointLabels.length,s=t.options,{centerPointLabels:o,display:a}=s.pointLabels,l={extra:Rut(s)/2,additionalAngle:o?Frt/r:0};let c;for(let s=0;s<r;s++){l.padding=n[s],l.size=e[s];const r=Fut(t,s,l);i.push(r),"auto"===a&&(r.visible=zut(r,c),r.visible&&(c=r))}return i}(t,i,r)}function Dut(t,e,n,i,r){const s=Math.abs(Math.sin(n)),o=Math.abs(Math.cos(n));let a=0,l=0;i.start<e.l?(a=(e.l-i.start)/s,t.l=Math.min(t.l,e.l-a)):i.end>e.r&&(a=(i.end-e.r)/s,t.r=Math.max(t.r,e.r+a)),r.start<e.t?(l=(e.t-r.start)/o,t.t=Math.min(t.t,e.t-l)):r.end>e.b&&(l=(r.end-e.b)/o,t.b=Math.max(t.b,e.b+l))}function Fut(t,e,n){const i=t.drawingArea,{extra:r,additionalAngle:s,padding:o,size:a}=n,l=t.getPointPosition(e,i+r+o,s),c=Math.round(Qrt(rst(l.angle+Wrt))),u=function(t,e,n){90===n||270===n?t-=e/2:(n>270||n<90)&&(t-=e);return t}(l.y,a.h,c),h=function(t){if(0===t||180===t)return"center";if(t<180)return"left";return"right"}(c),d=function(t,e,n){"right"===n?t-=e:"center"===n&&(t-=e/2);return t}(l.x,a.w,h);return{visible:!0,x:l.x,y:u,textAlign:h,left:d,top:u,right:d+a.w,bottom:u+a.h}}function zut(t,e){if(!e)return!0;const{left:n,top:i,right:r,bottom:s}=t;return!(jst({x:n,y:i},e)||jst({x:n,y:s},e)||jst({x:r,y:i},e)||jst({x:r,y:s},e))}function But(t,e,n){const{left:i,top:r,right:s,bottom:o}=n,{backdropColor:a}=e;if(!grt(a)){const n=oot(e.borderRadius),l=aot(e.backdropPadding);t.fillStyle=a;const c=i-l.left,u=r-l.top,h=s-i+l.width,d=o-r+l.height;Object.values(n).some((t=>0!==t))?(t.beginPath(),Qst(t,{x:c,y:u,w:h,h:d,radius:n}),t.fill()):t.fillRect(c,u,h,d)}}function Uut(t,e,n,i){const{ctx:r}=t;if(n)r.arc(t.xCenter,t.yCenter,e,0,zrt);else{let n=t.getPointPosition(0,e);r.moveTo(n.x,n.y);for(let s=1;s<i;s++)n=t.getPointPosition(s,e),r.lineTo(n.x,n.y)}}class Vut extends Tut{static id="radialLinear";static defaults={display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:Nst.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback:t=>t,padding:5,centerPointLabels:!1}};static defaultRoutes={"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"};static descriptors={angleLines:{_fallback:"grid"}};constructor(t){super(t),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const t=this._padding=aot(Rut(this.options)/2),e=this.width=this.maxWidth-t.width,n=this.height=this.maxHeight-t.height;this.xCenter=Math.floor(this.left+e/2+t.left),this.yCenter=Math.floor(this.top+n/2+t.top),this.drawingArea=Math.floor(Math.min(e,n)/2)}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!1);this.min=vrt(t)&&!isNaN(t)?t:0,this.max=vrt(e)&&!isNaN(e)?e:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/Rut(this.options))}generateTickLabels(t){Tut.prototype.generateTickLabels.call(this,t),this._pointLabels=this.getLabels().map(((t,e)=>{const n=krt(this.options.pointLabels.callback,[t,e],this);return n||0===n?n:""})).filter(((t,e)=>this.chart.getDataVisibility(e)))}fit(){const t=this.options;t.display&&t.pointLabels.display?Lut(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(t,e,n,i){this.xCenter+=Math.floor((t-e)/2),this.yCenter+=Math.floor((n-i)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,e,n,i))}getIndexAngle(t){return rst(t*(zrt/(this._pointLabels.length||1))+Jrt(this.options.startAngle||0))}getDistanceFromCenterForValue(t){if(grt(t))return NaN;const e=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-t)*e:(t-this.min)*e}getValueForDistanceFromCenter(t){if(grt(t))return NaN;const e=t/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-e:this.min+e}getPointLabelContext(t){const e=this._pointLabels||[];if(t>=0&&t<e.length){const n=e[t];return function(t,e,n){return uot(t,{label:n,index:e,type:"pointLabel"})}(this.getContext(),t,n)}}getPointPosition(t,e,n=0){const i=this.getIndexAngle(t)-Wrt+n;return{x:Math.cos(i)*e+this.xCenter,y:Math.sin(i)*e+this.yCenter,angle:i}}getPointPositionForValue(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))}getBasePosition(t){return this.getPointPositionForValue(t||0,this.getBaseValue())}getPointLabelPosition(t){const{left:e,top:n,right:i,bottom:r}=this._pointLabelItems[t];return{left:e,top:n,right:i,bottom:r}}drawBackground(){const{backgroundColor:t,grid:{circular:e}}=this.options;if(t){const n=this.ctx;n.save(),n.beginPath(),Uut(this,this.getDistanceFromCenterForValue(this._endValue),e,this._pointLabels.length),n.closePath(),n.fillStyle=t,n.fill(),n.restore()}}drawGrid(){const t=this.ctx,e=this.options,{angleLines:n,grid:i,border:r}=e,s=this._pointLabels.length;let o,a,l;if(e.pointLabels.display&&function(t,e){const{ctx:n,options:{pointLabels:i}}=t;for(let r=e-1;r>=0;r--){const e=t._pointLabelItems[r];if(!e.visible)continue;const s=i.setContext(t.getPointLabelContext(r));But(n,s,e);const o=lot(s.font),{x:a,y:l,textAlign:c}=e;Jst(n,t._pointLabels[r],a,l+o.lineHeight/2,o,{color:s.color,textAlign:c,textBaseline:"middle"})}}(this,s),i.display&&this.ticks.forEach(((t,e)=>{if(0!==e){a=this.getDistanceFromCenterForValue(t.value);const n=this.getContext(e),o=i.setContext(n),l=r.setContext(n);!function(t,e,n,i,r){const s=t.ctx,o=e.circular,{color:a,lineWidth:l}=e;!o&&!i||!a||!l||n<0||(s.save(),s.strokeStyle=a,s.lineWidth=l,s.setLineDash(r.dash),s.lineDashOffset=r.dashOffset,s.beginPath(),Uut(t,n,o,i),s.closePath(),s.stroke(),s.restore())}(this,o,a,s,l)}})),n.display){for(t.save(),o=s-1;o>=0;o--){const i=n.setContext(this.getPointLabelContext(o)),{color:r,lineWidth:s}=i;s&&r&&(t.lineWidth=s,t.strokeStyle=r,t.setLineDash(i.borderDash),t.lineDashOffset=i.borderDashOffset,a=this.getDistanceFromCenterForValue(e.ticks.reverse?this.min:this.max),l=this.getPointPosition(o,a),t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(l.x,l.y),t.stroke())}t.restore()}}drawBorder(){}drawLabels(){const t=this.ctx,e=this.options,n=e.ticks;if(!n.display)return;const i=this.getIndexAngle(0);let r,s;t.save(),t.translate(this.xCenter,this.yCenter),t.rotate(i),t.textAlign="center",t.textBaseline="middle",this.ticks.forEach(((i,o)=>{if(0===o&&!e.reverse)return;const a=n.setContext(this.getContext(o)),l=lot(a.font);if(r=this.getDistanceFromCenterForValue(this.ticks[o].value),a.showLabelBackdrop){t.font=l.string,s=t.measureText(i.label).width,t.fillStyle=a.backdropColor;const e=aot(a.backdropPadding);t.fillRect(-s/2-e.left,-r-l.size/2-e.top,s+e.width,l.size+e.height)}Jst(t,i.label,0,-r,l,{color:a.color,strokeColor:a.textStrokeColor,strokeWidth:a.textStrokeWidth})})),t.restore()}drawTitle(){}}const Wut={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},Hut=Object.keys(Wut);function jut(t,e){return t-e}function Gut(t,e){if(grt(e))return null;const n=t._adapter,{parser:i,round:r,isoWeekday:s}=t._parseOpts;let o=e;return"function"==typeof i&&(o=i(o)),vrt(o)||(o="string"==typeof i?n.parse(o,i):n.parse(o)),null===o?null:(r&&(o="week"!==r||!Yrt(s)&&!0!==s?n.startOf(o,r):n.startOf(o,"isoWeek",s)),+o)}function qut(t,e,n,i){const r=Hut.length;for(let s=Hut.indexOf(t);s<r-1;++s){const t=Wut[Hut[s]],r=t.steps?t.steps:Number.MAX_SAFE_INTEGER;if(t.common&&Math.ceil((n-e)/(r*t.size))<=i)return Hut[s]}return Hut[r-1]}function Xut(t,e,n){if(n){if(n.length){const{lo:i,hi:r}=lst(n,e);t[n[i]>=e?n[i]:n[r]]=!0}}else t[e]=!0}function Kut(t,e,n){const i=[],r={},s=e.length;let o,a;for(o=0;o<s;++o)a=e[o],r[a]=o,i.push({value:a,major:!1});return 0!==s&&n?function(t,e,n,i){const r=t._adapter,s=+r.startOf(e[0].value,i),o=e[e.length-1].value;let a,l;for(a=s;a<=o;a=+r.add(a,1,i))l=n[a],l>=0&&(e[l].major=!0);return e}(t,i,r,n):i}class Yut extends Plt{static id="time";static defaults={bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",callback:!1,major:{enabled:!1}}};constructor(t){super(t),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(t,e={}){const n=t.time||(t.time={}),i=this._adapter=new Bat._date(t.adapters.date);i.init(e),Irt(n.displayFormats,i.formats()),this._parseOpts={parser:n.parser,round:n.round,isoWeekday:n.isoWeekday},super.init(t),this._normalized=e.normalized}parse(t,e){return void 0===t?null:Gut(this,t)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const t=this.options,e=this._adapter,n=t.time.unit||"day";let{min:i,max:r,minDefined:s,maxDefined:o}=this.getUserBounds();function a(t){s||isNaN(t.min)||(i=Math.min(i,t.min)),o||isNaN(t.max)||(r=Math.max(r,t.max))}s&&o||(a(this._getLabelBounds()),"ticks"===t.bounds&&"labels"===t.ticks.source||a(this.getMinMax(!1))),i=vrt(i)&&!isNaN(i)?i:+e.startOf(Date.now(),n),r=vrt(r)&&!isNaN(r)?r:+e.endOf(Date.now(),n)+1,this.min=Math.min(i,r-1),this.max=Math.max(i+1,r)}_getLabelBounds(){const t=this.getLabelTimestamps();let e=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;return t.length&&(e=t[0],n=t[t.length-1]),{min:e,max:n}}buildTicks(){const t=this.options,e=t.time,n=t.ticks,i="labels"===n.source?this.getLabelTimestamps():this._generate();"ticks"===t.bounds&&i.length&&(this.min=this._userMin||i[0],this.max=this._userMax||i[i.length-1]);const r=this.min,s=function(t,e,n){let i=0,r=t.length;for(;i<r&&t[i]<e;)i++;for(;r>i&&t[r-1]>n;)r--;return i>0||r<t.length?t.slice(i,r):t}(i,r,this.max);return this._unit=e.unit||(n.autoSkip?qut(e.minUnit,this.min,this.max,this._getLabelCapacity(r)):function(t,e,n,i,r){for(let s=Hut.length-1;s>=Hut.indexOf(n);s--){const n=Hut[s];if(Wut[n].common&&t._adapter.diff(r,i,n)>=e-1)return n}return Hut[n?Hut.indexOf(n):0]}(this,s.length,e.minUnit,this.min,this.max)),this._majorUnit=n.major.enabled&&"year"!==this._unit?function(t){for(let e=Hut.indexOf(t)+1,n=Hut.length;e<n;++e)if(Wut[Hut[e]].common)return Hut[e]}(this._unit):void 0,this.initOffsets(i),t.reverse&&s.reverse(),Kut(this,s,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map((t=>+t.value)))}initOffsets(t=[]){let e,n,i=0,r=0;this.options.offset&&t.length&&(e=this.getDecimalForValue(t[0]),i=1===t.length?1-e:(this.getDecimalForValue(t[1])-e)/2,n=this.getDecimalForValue(t[t.length-1]),r=1===t.length?n:(n-this.getDecimalForValue(t[t.length-2]))/2);const s=t.length<3?.5:.25;i=ost(i,0,s),r=ost(r,0,s),this._offsets={start:i,end:r,factor:1/(i+1+r)}}_generate(){const t=this._adapter,e=this.min,n=this.max,i=this.options,r=i.time,s=r.unit||qut(r.minUnit,e,n,this._getLabelCapacity(e)),o=wrt(i.ticks.stepSize,1),a="week"===s&&r.isoWeekday,l=Yrt(a)||!0===a,c={};let u,h,d=e;if(l&&(d=+t.startOf(d,"isoWeek",a)),d=+t.startOf(d,l?"day":s),t.diff(n,e,s)>1e5*o)throw new Error(e+" and "+n+" are too far apart with stepSize of "+o+" "+s);const p="data"===i.ticks.source&&this.getDataTimestamps();for(u=d,h=0;u<n;u=+t.add(u,o,s),h++)Xut(c,u,p);return u!==n&&"ticks"!==i.bounds&&1!==h||Xut(c,u,p),Object.keys(c).sort(jut).map((t=>+t))}getLabelForValue(t){const e=this._adapter,n=this.options.time;return n.tooltipFormat?e.format(t,n.tooltipFormat):e.format(t,n.displayFormats.datetime)}format(t,e){const n=this.options.time.displayFormats,i=this._unit,r=e||n[i];return this._adapter.format(t,r)}_tickFormatFunction(t,e,n,i){const r=this.options,s=r.ticks.callback;if(s)return krt(s,[t,e,n],this);const o=r.time.displayFormats,a=this._unit,l=this._majorUnit,c=a&&o[a],u=l&&o[l],h=n[e],d=l&&u&&h&&h.major;return this._adapter.format(t,i||(d?u:c))}generateTickLabels(t){let e,n,i;for(e=0,n=t.length;e<n;++e)i=t[e],i.label=this._tickFormatFunction(i.value,e,t)}getDecimalForValue(t){return null===t?NaN:(t-this.min)/(this.max-this.min)}getPixelForValue(t){const e=this._offsets,n=this.getDecimalForValue(t);return this.getPixelForDecimal((e.start+n)*e.factor)}getValueForPixel(t){const e=this._offsets,n=this.getDecimalForPixel(t)/e.factor-e.end;return this.min+n*(this.max-this.min)}_getLabelSize(t){const e=this.options.ticks,n=this.ctx.measureText(t).width,i=Jrt(this.isHorizontal()?e.maxRotation:e.minRotation),r=Math.cos(i),s=Math.sin(i),o=this._resolveTickFontOptions(0).size;return{w:n*r+o*s,h:n*s+o*r}}_getLabelCapacity(t){const e=this.options.time,n=e.displayFormats,i=n[e.unit]||n.millisecond,r=this._tickFormatFunction(t,0,Kut(this,[t],this._majorUnit),i),s=this._getLabelSize(r),o=Math.floor(this.isHorizontal()?this.width/s.w:this.height/s.h)-1;return o>0?o:1}getDataTimestamps(){let t,e,n=this._cache.data||[];if(n.length)return n;const i=this.getMatchingVisibleMetas();if(this._normalized&&i.length)return this._cache.data=i[0].controller.getAllParsedValues(this);for(t=0,e=i.length;t<e;++t)n=n.concat(i[t].controller.getAllParsedValues(this));return this._cache.data=this.normalize(n)}getLabelTimestamps(){const t=this._cache.labels||[];let e,n;if(t.length)return t;const i=this.getLabels();for(e=0,n=i.length;e<n;++e)t.push(Gut(this,i[e]));return this._cache.labels=this._normalized?t:this.normalize(t)}normalize(t){return pst(t.sort(jut))}}function Zut(t,e,n){let i,r,s,o,a=0,l=t.length-1;n?(e>=t[a].pos&&e<=t[l].pos&&({lo:a,hi:l}=cst(t,"pos",e)),({pos:i,time:s}=t[a]),({pos:r,time:o}=t[l])):(e>=t[a].time&&e<=t[l].time&&({lo:a,hi:l}=cst(t,"time",e)),({time:i,pos:s}=t[a]),({time:r,pos:o}=t[l]));const c=r-i;return c?s+(o-s)*(e-i)/c:s}class Jut extends Yut{static id="timeseries";static defaults=Yut.defaults;constructor(t){super(t),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const t=this._getTimestampsForTable(),e=this._table=this.buildLookupTable(t);this._minPos=Zut(e,this.min),this._tableRange=Zut(e,this.max)-this._minPos,super.initOffsets(t)}buildLookupTable(t){const{min:e,max:n}=this,i=[],r=[];let s,o,a,l,c;for(s=0,o=t.length;s<o;++s)l=t[s],l>=e&&l<=n&&i.push(l);if(i.length<2)return[{time:e,pos:0},{time:n,pos:1}];for(s=0,o=i.length;s<o;++s)c=i[s+1],a=i[s-1],l=i[s],Math.round((c+a)/2)!==l&&r.push({time:l,pos:s/(o-1)});return r}_generate(){const t=this.min,e=this.max;let n=super.getDataTimestamps();return n.includes(t)&&n.length||n.splice(0,0,t),n.includes(e)&&1!==n.length||n.push(e),n.sort(((t,e)=>t-e))}_getTimestampsForTable(){let t=this._cache.all||[];if(t.length)return t;const e=this.getDataTimestamps(),n=this.getLabelTimestamps();return t=e.length&&n.length?this.normalize(e.concat(n)):e.length?e:n,t=this._cache.all=t,t}getDecimalForValue(t){return(Zut(this._table,t)-this._minPos)/this._tableRange}getValueForPixel(t){const e=this._offsets,n=this.getDecimalForPixel(t)/e.factor-e.end;return Zut(this._table,n*this._tableRange+this._minPos,!0)}}class Qut extends Error{}class tht extends Qut{constructor(t){super(`Invalid DateTime: ${t.toMessage()}`)}}class eht extends Qut{constructor(t){super(`Invalid Interval: ${t.toMessage()}`)}}class nht extends Qut{constructor(t){super(`Invalid Duration: ${t.toMessage()}`)}}class iht extends Qut{}class rht extends Qut{constructor(t){super(`Invalid unit ${t}`)}}class sht extends Qut{}class oht extends Qut{constructor(){super("Zone is an abstract class")}}const aht="numeric",lht="short",cht="long",uht={year:aht,month:aht,day:aht},hht={year:aht,month:lht,day:aht},dht={year:aht,month:lht,day:aht,weekday:lht},pht={year:aht,month:cht,day:aht},fht={year:aht,month:cht,day:aht,weekday:cht},mht={hour:aht,minute:aht},ght={hour:aht,minute:aht,second:aht},yht={hour:aht,minute:aht,second:aht,timeZoneName:lht},bht={hour:aht,minute:aht,second:aht,timeZoneName:cht},vht={hour:aht,minute:aht,hourCycle:"h23"},xht={hour:aht,minute:aht,second:aht,hourCycle:"h23"},wht={hour:aht,minute:aht,second:aht,hourCycle:"h23",timeZoneName:lht},Sht={hour:aht,minute:aht,second:aht,hourCycle:"h23",timeZoneName:cht},kht={year:aht,month:aht,day:aht,hour:aht,minute:aht},Cht={year:aht,month:aht,day:aht,hour:aht,minute:aht,second:aht},Tht={year:aht,month:lht,day:aht,hour:aht,minute:aht},_ht={year:aht,month:lht,day:aht,hour:aht,minute:aht,second:aht},Eht={year:aht,month:lht,day:aht,weekday:lht,hour:aht,minute:aht},Mht={year:aht,month:cht,day:aht,hour:aht,minute:aht,timeZoneName:lht},$ht={year:aht,month:cht,day:aht,hour:aht,minute:aht,second:aht,timeZoneName:lht},Iht={year:aht,month:cht,day:aht,weekday:cht,hour:aht,minute:aht,timeZoneName:cht},Aht={year:aht,month:cht,day:aht,weekday:cht,hour:aht,minute:aht,second:aht,timeZoneName:cht};class Nht{get type(){throw new oht}get name(){throw new oht}get ianaName(){return this.name}get isUniversal(){throw new oht}offsetName(t,e){throw new oht}formatOffset(t,e){throw new oht}offset(t){throw new oht}equals(t){throw new oht}get isValid(){throw new oht}}let Rht=null;class Pht extends Nht{static get instance(){return null===Rht&&(Rht=new Pht),Rht}get type(){return"system"}get name(){return(new Intl.DateTimeFormat).resolvedOptions().timeZone}get isUniversal(){return!1}offsetName(t,{format:e,locale:n}){return _dt(t,e,n)}formatOffset(t,e){return Idt(this.offset(t),e)}offset(t){return-new Date(t).getTimezoneOffset()}equals(t){return"system"===t.type}get isValid(){return!0}}let Oht={};const Lht={year:0,month:1,day:2,era:3,hour:4,minute:5,second:6};let Dht={};class Fht extends Nht{static create(t){return Dht[t]||(Dht[t]=new Fht(t)),Dht[t]}static resetCache(){Dht={},Oht={}}static isValidSpecifier(t){return this.isValidZone(t)}static isValidZone(t){if(!t)return!1;try{return new Intl.DateTimeFormat("en-US",{timeZone:t}).format(),!0}catch(t){return!1}}constructor(t){super(),this.zoneName=t,this.valid=Fht.isValidZone(t)}get type(){return"iana"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(t,{format:e,locale:n}){return _dt(t,e,n,this.name)}formatOffset(t,e){return Idt(this.offset(t),e)}offset(t){const e=new Date(t);if(isNaN(e))return NaN;const n=(i=this.name,Oht[i]||(Oht[i]=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:i,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",era:"short"})),Oht[i]);var i;let[r,s,o,a,l,c,u]=n.formatToParts?function(t,e){const n=t.formatToParts(e),i=[];for(let t=0;t<n.length;t++){const{type:e,value:r}=n[t],s=Lht[e];"era"===e?i[s]=r:ldt(s)||(i[s]=parseInt(r,10))}return i}(n,e):function(t,e){const n=t.format(e).replace(/\u200E/g,""),i=/(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n),[,r,s,o,a,l,c,u]=i;return[o,r,s,a,l,c,u]}(n,e);"BC"===a&&(r=1-Math.abs(r));let h=+e;const d=h%1e3;return h-=d>=0?d:1e3+d,(kdt({year:r,month:s,day:o,hour:24===l?0:l,minute:c,second:u,millisecond:0})-h)/6e4}equals(t){return"iana"===t.type&&t.name===this.name}get isValid(){return this.valid}}let zht={};let Bht={};function Uht(t,e={}){const n=JSON.stringify([t,e]);let i=Bht[n];return i||(i=new Intl.DateTimeFormat(t,e),Bht[n]=i),i}let Vht={};let Wht={};let Hht=null;function jht(t,e,n,i){const r=t.listingMode();return"error"===r?null:"en"===r?n(e):i(e)}class Ght{constructor(t,e,n){this.padTo=n.padTo||0,this.floor=n.floor||!1;const{padTo:i,floor:r,...s}=n;if(!e||Object.keys(s).length>0){const e={useGrouping:!1,...n};n.padTo>0&&(e.minimumIntegerDigits=n.padTo),this.inf=function(t,e={}){const n=JSON.stringify([t,e]);let i=Vht[n];return i||(i=new Intl.NumberFormat(t,e),Vht[n]=i),i}(t,e)}}format(t){if(this.inf){const e=this.floor?Math.floor(t):t;return this.inf.format(e)}return mdt(this.floor?Math.floor(t):vdt(t,3),this.padTo)}}class qht{constructor(t,e,n){let i;if(this.opts=n,this.originalZone=void 0,this.opts.timeZone)this.dt=t;else if("fixed"===t.zone.type){const e=t.offset/60*-1,n=e>=0?`Etc/GMT+${e}`:`Etc/GMT${e}`;0!==t.offset&&Fht.create(n).valid?(i=n,this.dt=t):(i="UTC",this.dt=0===t.offset?t:t.setZone("UTC").plus({minutes:t.offset}),this.originalZone=t.zone)}else"system"===t.zone.type?this.dt=t:"iana"===t.zone.type?(this.dt=t,i=t.zone.name):(i="UTC",this.dt=t.setZone("UTC").plus({minutes:t.offset}),this.originalZone=t.zone);const r={...this.opts};r.timeZone=r.timeZone||i,this.dtf=Uht(e,r)}format(){return this.originalZone?this.formatToParts().map((({value:t})=>t)).join(""):this.dtf.format(this.dt.toJSDate())}formatToParts(){const t=this.dtf.formatToParts(this.dt.toJSDate());return this.originalZone?t.map((t=>{if("timeZoneName"===t.type){const e=this.originalZone.offsetName(this.dt.ts,{locale:this.dt.locale,format:this.opts.timeZoneName});return{...t,value:e}}return t})):t}resolvedOptions(){return this.dtf.resolvedOptions()}}class Xht{constructor(t,e,n){this.opts={style:"long",...n},!e&&hdt()&&(this.rtf=function(t,e={}){const{base:n,...i}=e,r=JSON.stringify([t,i]);let s=Wht[r];return s||(s=new Intl.RelativeTimeFormat(t,e),Wht[r]=s),s}(t,n))}format(t,e){return this.rtf?this.rtf.format(t,e):function(t,e,n="always",i=!1){const r={years:["year","yr."],quarters:["quarter","qtr."],months:["month","mo."],weeks:["week","wk."],days:["day","day","days"],hours:["hour","hr."],minutes:["minute","min."],seconds:["second","sec."]},s=-1===["hours","minutes","seconds"].indexOf(t);if("auto"===n&&s){const n="days"===t;switch(e){case 1:return n?"tomorrow":`next ${r[t][0]}`;case-1:return n?"yesterday":`last ${r[t][0]}`;case 0:return n?"today":`this ${r[t][0]}`}}const o=Object.is(e,-0)||e<0,a=Math.abs(e),l=1===a,c=r[t],u=i?l?c[1]:c[2]||c[1]:l?r[t][0]:t;return o?`${a} ${u} ago`:`in ${a} ${u}`}(e,t,this.opts.numeric,"long"!==this.opts.style)}formatToParts(t,e){return this.rtf?this.rtf.formatToParts(t,e):[]}}class Kht{static fromOpts(t){return Kht.create(t.locale,t.numberingSystem,t.outputCalendar,t.defaultToEN)}static create(t,e,n,i=!1){const r=t||adt.defaultLocale,s=r||(i?"en-US":Hht||(Hht=(new Intl.DateTimeFormat).resolvedOptions().locale,Hht)),o=e||adt.defaultNumberingSystem,a=n||adt.defaultOutputCalendar;return new Kht(s,o,a,r)}static resetCache(){Hht=null,Bht={},Vht={},Wht={}}static fromObject({locale:t,numberingSystem:e,outputCalendar:n}={}){return Kht.create(t,e,n)}constructor(t,e,n,i){const[r,s,o]=function(t){const e=t.indexOf("-x-");-1!==e&&(t=t.substring(0,e));const n=t.indexOf("-u-");if(-1===n)return[t];{let e,i;try{e=Uht(t).resolvedOptions(),i=t}catch(r){const s=t.substring(0,n);e=Uht(s).resolvedOptions(),i=s}const{numberingSystem:r,calendar:s}=e;return[i,r,s]}}(t);this.locale=r,this.numberingSystem=e||s||null,this.outputCalendar=n||o||null,this.intl=function(t,e,n){return n||e?(t.includes("-u-")||(t+="-u"),n&&(t+=`-ca-${n}`),e&&(t+=`-nu-${e}`),t):t}(this.locale,this.numberingSystem,this.outputCalendar),this.weekdaysCache={format:{},standalone:{}},this.monthsCache={format:{},standalone:{}},this.meridiemCache=null,this.eraCache={},this.specifiedLocale=i,this.fastNumbersCached=null}get fastNumbers(){var t;return null==this.fastNumbersCached&&(this.fastNumbersCached=(!(t=this).numberingSystem||"latn"===t.numberingSystem)&&("latn"===t.numberingSystem||!t.locale||t.locale.startsWith("en")||"latn"===new Intl.DateTimeFormat(t.intl).resolvedOptions().numberingSystem)),this.fastNumbersCached}listingMode(){const t=this.isEnglish(),e=!(null!==this.numberingSystem&&"latn"!==this.numberingSystem||null!==this.outputCalendar&&"gregory"!==this.outputCalendar);return t&&e?"en":"intl"}clone(t){return t&&0!==Object.getOwnPropertyNames(t).length?Kht.create(t.locale||this.specifiedLocale,t.numberingSystem||this.numberingSystem,t.outputCalendar||this.outputCalendar,t.defaultToEN||!1):this}redefaultToEN(t={}){return this.clone({...t,defaultToEN:!0})}redefaultToSystem(t={}){return this.clone({...t,defaultToEN:!1})}months(t,e=!1){return jht(this,t,Odt,(()=>{const n=e?{month:t,day:"numeric"}:{month:t},i=e?"format":"standalone";return this.monthsCache[i][t]||(this.monthsCache[i][t]=function(t){const e=[];for(let n=1;n<=12;n++){const i=Jft.utc(2009,n,1);e.push(t(i))}return e}((t=>this.extract(t,n,"month")))),this.monthsCache[i][t]}))}weekdays(t,e=!1){return jht(this,t,zdt,(()=>{const n=e?{weekday:t,year:"numeric",month:"long",day:"numeric"}:{weekday:t},i=e?"format":"standalone";return this.weekdaysCache[i][t]||(this.weekdaysCache[i][t]=function(t){const e=[];for(let n=1;n<=7;n++){const i=Jft.utc(2016,11,13+n);e.push(t(i))}return e}((t=>this.extract(t,n,"weekday")))),this.weekdaysCache[i][t]}))}meridiems(){return jht(this,void 0,(()=>Bdt),(()=>{if(!this.meridiemCache){const t={hour:"numeric",hourCycle:"h12"};this.meridiemCache=[Jft.utc(2016,11,13,9),Jft.utc(2016,11,13,19)].map((e=>this.extract(e,t,"dayperiod")))}return this.meridiemCache}))}eras(t){return jht(this,t,Hdt,(()=>{const e={era:t};return this.eraCache[t]||(this.eraCache[t]=[Jft.utc(-40,1,1),Jft.utc(2017,1,1)].map((t=>this.extract(t,e,"era")))),this.eraCache[t]}))}extract(t,e,n){const i=this.dtFormatter(t,e).formatToParts().find((t=>t.type.toLowerCase()===n));return i?i.value:null}numberFormatter(t={}){return new Ght(this.intl,t.forceSimple||this.fastNumbers,t)}dtFormatter(t,e={}){return new qht(t,this.intl,e)}relFormatter(t={}){return new Xht(this.intl,this.isEnglish(),t)}listFormatter(t={}){return function(t,e={}){const n=JSON.stringify([t,e]);let i=zht[n];return i||(i=new Intl.ListFormat(t,e),zht[n]=i),i}(this.intl,t)}isEnglish(){return"en"===this.locale||"en-us"===this.locale.toLowerCase()||new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")}equals(t){return this.locale===t.locale&&this.numberingSystem===t.numberingSystem&&this.outputCalendar===t.outputCalendar}}let Yht=null;class Zht extends Nht{static get utcInstance(){return null===Yht&&(Yht=new Zht(0)),Yht}static instance(t){return 0===t?Zht.utcInstance:new Zht(t)}static parseSpecifier(t){if(t){const e=t.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);if(e)return new Zht(Edt(e[1],e[2]))}return null}constructor(t){super(),this.fixed=t}get type(){return"fixed"}get name(){return 0===this.fixed?"UTC":`UTC${Idt(this.fixed,"narrow")}`}get ianaName(){return 0===this.fixed?"Etc/UTC":`Etc/GMT${Idt(-this.fixed,"narrow")}`}offsetName(){return this.name}formatOffset(t,e){return Idt(this.fixed,e)}get isUniversal(){return!0}offset(){return this.fixed}equals(t){return"fixed"===t.type&&t.fixed===this.fixed}get isValid(){return!0}}class Jht extends Nht{constructor(t){super(),this.zoneName=t}get type(){return"invalid"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(){return null}formatOffset(){return""}offset(){return NaN}equals(){return!1}get isValid(){return!1}}function Qht(t,e){if(ldt(t)||null===t)return e;if(t instanceof Nht)return t;if(function(t){return"string"==typeof t}(t)){const n=t.toLowerCase();return"default"===n?e:"local"===n||"system"===n?Pht.instance:"utc"===n||"gmt"===n?Zht.utcInstance:Zht.parseSpecifier(n)||Fht.create(t)}return cdt(t)?Zht.instance(t):"object"==typeof t&&"offset"in t&&"function"==typeof t.offset?t:new Jht(t)}let tdt,edt=()=>Date.now(),ndt="system",idt=null,rdt=null,sdt=null,odt=60;class adt{static get now(){return edt}static set now(t){edt=t}static set defaultZone(t){ndt=t}static get defaultZone(){return Qht(ndt,Pht.instance)}static get defaultLocale(){return idt}static set defaultLocale(t){idt=t}static get defaultNumberingSystem(){return rdt}static set defaultNumberingSystem(t){rdt=t}static get defaultOutputCalendar(){return sdt}static set defaultOutputCalendar(t){sdt=t}static get twoDigitCutoffYear(){return odt}static set twoDigitCutoffYear(t){odt=t%100}static get throwOnInvalid(){return tdt}static set throwOnInvalid(t){tdt=t}static resetCaches(){Kht.resetCache(),Fht.resetCache()}}function ldt(t){return void 0===t}function cdt(t){return"number"==typeof t}function udt(t){return"number"==typeof t&&t%1==0}function hdt(){try{return"undefined"!=typeof Intl&&!!Intl.RelativeTimeFormat}catch(t){return!1}}function ddt(t,e,n){if(0!==t.length)return t.reduce(((t,i)=>{const r=[e(i),i];return t&&n(t[0],r[0])===t[0]?t:r}),null)[1]}function pdt(t,e){return Object.prototype.hasOwnProperty.call(t,e)}function fdt(t,e,n){return udt(t)&&t>=e&&t<=n}function mdt(t,e=2){let n;return n=t<0?"-"+(""+-t).padStart(e,"0"):(""+t).padStart(e,"0"),n}function gdt(t){return ldt(t)||null===t||""===t?void 0:parseInt(t,10)}function ydt(t){return ldt(t)||null===t||""===t?void 0:parseFloat(t)}function bdt(t){if(!ldt(t)&&null!==t&&""!==t){const e=1e3*parseFloat("0."+t);return Math.floor(e)}}function vdt(t,e,n=!1){const i=10**e;return(n?Math.trunc:Math.round)(t*i)/i}function xdt(t){return t%4==0&&(t%100!=0||t%400==0)}function wdt(t){return xdt(t)?366:365}function Sdt(t,e){const n=function(t,e){return t-e*Math.floor(t/e)}(e-1,12)+1;return 2===n?xdt(t+(e-n)/12)?29:28:[31,null,31,30,31,30,31,31,30,31,30,31][n-1]}function kdt(t){let e=Date.UTC(t.year,t.month-1,t.day,t.hour,t.minute,t.second,t.millisecond);return t.year<100&&t.year>=0&&(e=new Date(e),e.setUTCFullYear(t.year,t.month-1,t.day)),+e}function Cdt(t){const e=(t+Math.floor(t/4)-Math.floor(t/100)+Math.floor(t/400))%7,n=t-1,i=(n+Math.floor(n/4)-Math.floor(n/100)+Math.floor(n/400))%7;return 4===e||3===i?53:52}function Tdt(t){return t>99?t:t>adt.twoDigitCutoffYear?1900+t:2e3+t}function _dt(t,e,n,i=null){const r=new Date(t),s={hourCycle:"h23",year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit"};i&&(s.timeZone=i);const o={timeZoneName:e,...s},a=new Intl.DateTimeFormat(n,o).formatToParts(r).find((t=>"timezonename"===t.type.toLowerCase()));return a?a.value:null}function Edt(t,e){let n=parseInt(t,10);Number.isNaN(n)&&(n=0);const i=parseInt(e,10)||0;return 60*n+(n<0||Object.is(n,-0)?-i:i)}function Mdt(t){const e=Number(t);if("boolean"==typeof t||""===t||Number.isNaN(e))throw new sht(`Invalid unit value ${t}`);return e}function $dt(t,e){const n={};for(const i in t)if(pdt(t,i)){const r=t[i];if(null==r)continue;n[e(i)]=Mdt(r)}return n}function Idt(t,e){const n=Math.trunc(Math.abs(t/60)),i=Math.trunc(Math.abs(t%60)),r=t>=0?"+":"-";switch(e){case"short":return`${r}${mdt(n,2)}:${mdt(i,2)}`;case"narrow":return`${r}${n}${i>0?`:${i}`:""}`;case"techie":return`${r}${mdt(n,2)}${mdt(i,2)}`;default:throw new RangeError(`Value format ${e} is out of range for property format`)}}function Adt(t){return function(t,e){return e.reduce(((e,n)=>(e[n]=t[n],e)),{})}(t,["hour","minute","second","millisecond"])}const Ndt=["January","February","March","April","May","June","July","August","September","October","November","December"],Rdt=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],Pdt=["J","F","M","A","M","J","J","A","S","O","N","D"];function Odt(t){switch(t){case"narrow":return[...Pdt];case"short":return[...Rdt];case"long":return[...Ndt];case"numeric":return["1","2","3","4","5","6","7","8","9","10","11","12"];case"2-digit":return["01","02","03","04","05","06","07","08","09","10","11","12"];default:return null}}const Ldt=["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"],Ddt=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"],Fdt=["M","T","W","T","F","S","S"];function zdt(t){switch(t){case"narrow":return[...Fdt];case"short":return[...Ddt];case"long":return[...Ldt];case"numeric":return["1","2","3","4","5","6","7"];default:return null}}const Bdt=["AM","PM"],Udt=["Before Christ","Anno Domini"],Vdt=["BC","AD"],Wdt=["B","A"];function Hdt(t){switch(t){case"narrow":return[...Wdt];case"short":return[...Vdt];case"long":return[...Udt];default:return null}}function jdt(t,e){let n="";for(const i of t)i.literal?n+=i.val:n+=e(i.val);return n}const Gdt={D:uht,DD:hht,DDD:pht,DDDD:fht,t:mht,tt:ght,ttt:yht,tttt:bht,T:vht,TT:xht,TTT:wht,TTTT:Sht,f:kht,ff:Tht,fff:Mht,ffff:Iht,F:Cht,FF:_ht,FFF:$ht,FFFF:Aht};class qdt{static create(t,e={}){return new qdt(t,e)}static parseFormat(t){let e=null,n="",i=!1;const r=[];for(let s=0;s<t.length;s++){const o=t.charAt(s);"'"===o?(n.length>0&&r.push({literal:i||/^\s+$/.test(n),val:n}),e=null,n="",i=!i):i||o===e?n+=o:(n.length>0&&r.push({literal:/^\s+$/.test(n),val:n}),n=o,e=o)}return n.length>0&&r.push({literal:i||/^\s+$/.test(n),val:n}),r}static macroTokenToFormatOpts(t){return Gdt[t]}constructor(t,e){this.opts=e,this.loc=t,this.systemLoc=null}formatWithSystemDefault(t,e){null===this.systemLoc&&(this.systemLoc=this.loc.redefaultToSystem());return this.systemLoc.dtFormatter(t,{...this.opts,...e}).format()}dtFormatter(t,e={}){return this.loc.dtFormatter(t,{...this.opts,...e})}formatDateTime(t,e){return this.dtFormatter(t,e).format()}formatDateTimeParts(t,e){return this.dtFormatter(t,e).formatToParts()}formatInterval(t,e){return this.dtFormatter(t.start,e).dtf.formatRange(t.start.toJSDate(),t.end.toJSDate())}resolvedOptions(t,e){return this.dtFormatter(t,e).resolvedOptions()}num(t,e=0){if(this.opts.forceSimple)return mdt(t,e);const n={...this.opts};return e>0&&(n.padTo=e),this.loc.numberFormatter(n).format(t)}formatDateTimeFromString(t,e){const n="en"===this.loc.listingMode(),i=this.loc.outputCalendar&&"gregory"!==this.loc.outputCalendar,r=(e,n)=>this.loc.extract(t,e,n),s=e=>t.isOffsetFixed&&0===t.offset&&e.allowZ?"Z":t.isValid?t.zone.formatOffset(t.ts,e.format):"",o=()=>n?function(t){return Bdt[t.hour<12?0:1]}(t):r({hour:"numeric",hourCycle:"h12"},"dayperiod"),a=(e,i)=>n?function(t,e){return Odt(e)[t.month-1]}(t,e):r(i?{month:e}:{month:e,day:"numeric"},"month"),l=(e,i)=>n?function(t,e){return zdt(e)[t.weekday-1]}(t,e):r(i?{weekday:e}:{weekday:e,month:"long",day:"numeric"},"weekday"),c=e=>{const n=qdt.macroTokenToFormatOpts(e);return n?this.formatWithSystemDefault(t,n):e},u=e=>n?function(t,e){return Hdt(e)[t.year<0?0:1]}(t,e):r({era:e},"era");return jdt(qdt.parseFormat(e),(e=>{switch(e){case"S":return this.num(t.millisecond);case"u":case"SSS":return this.num(t.millisecond,3);case"s":return this.num(t.second);case"ss":return this.num(t.second,2);case"uu":return this.num(Math.floor(t.millisecond/10),2);case"uuu":return this.num(Math.floor(t.millisecond/100));case"m":return this.num(t.minute);case"mm":return this.num(t.minute,2);case"h":return this.num(t.hour%12==0?12:t.hour%12);case"hh":return this.num(t.hour%12==0?12:t.hour%12,2);case"H":return this.num(t.hour);case"HH":return this.num(t.hour,2);case"Z":return s({format:"narrow",allowZ:this.opts.allowZ});case"ZZ":return s({format:"short",allowZ:this.opts.allowZ});case"ZZZ":return s({format:"techie",allowZ:this.opts.allowZ});case"ZZZZ":return t.zone.offsetName(t.ts,{format:"short",locale:this.loc.locale});case"ZZZZZ":return t.zone.offsetName(t.ts,{format:"long",locale:this.loc.locale});case"z":return t.zoneName;case"a":return o();case"d":return i?r({day:"numeric"},"day"):this.num(t.day);case"dd":return i?r({day:"2-digit"},"day"):this.num(t.day,2);case"c":case"E":return this.num(t.weekday);case"ccc":return l("short",!0);case"cccc":return l("long",!0);case"ccccc":return l("narrow",!0);case"EEE":return l("short",!1);case"EEEE":return l("long",!1);case"EEEEE":return l("narrow",!1);case"L":return i?r({month:"numeric",day:"numeric"},"month"):this.num(t.month);case"LL":return i?r({month:"2-digit",day:"numeric"},"month"):this.num(t.month,2);case"LLL":return a("short",!0);case"LLLL":return a("long",!0);case"LLLLL":return a("narrow",!0);case"M":return i?r({month:"numeric"},"month"):this.num(t.month);case"MM":return i?r({month:"2-digit"},"month"):this.num(t.month,2);case"MMM":return a("short",!1);case"MMMM":return a("long",!1);case"MMMMM":return a("narrow",!1);case"y":return i?r({year:"numeric"},"year"):this.num(t.year);case"yy":return i?r({year:"2-digit"},"year"):this.num(t.year.toString().slice(-2),2);case"yyyy":return i?r({year:"numeric"},"year"):this.num(t.year,4);case"yyyyyy":return i?r({year:"numeric"},"year"):this.num(t.year,6);case"G":return u("short");case"GG":return u("long");case"GGGGG":return u("narrow");case"kk":return this.num(t.weekYear.toString().slice(-2),2);case"kkkk":return this.num(t.weekYear,4);case"W":return this.num(t.weekNumber);case"WW":return this.num(t.weekNumber,2);case"o":return this.num(t.ordinal);case"ooo":return this.num(t.ordinal,3);case"q":return this.num(t.quarter);case"qq":return this.num(t.quarter,2);case"X":return this.num(Math.floor(t.ts/1e3));case"x":return this.num(t.ts);default:return c(e)}}))}formatDurationFromString(t,e){const n=t=>{switch(t[0]){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":return"hour";case"d":return"day";case"w":return"week";case"M":return"month";case"y":return"year";default:return null}},i=qdt.parseFormat(e),r=i.reduce(((t,{literal:e,val:n})=>e?t:t.concat(n)),[]),s=t.shiftTo(...r.map(n).filter((t=>t)));return jdt(i,(t=>e=>{const i=n(e);return i?this.num(t.get(i),e.length):e})(s))}}class Xdt{constructor(t,e){this.reason=t,this.explanation=e}toMessage(){return this.explanation?`${this.reason}: ${this.explanation}`:this.reason}}const Kdt=/[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;function Ydt(...t){const e=t.reduce(((t,e)=>t+e.source),"");return RegExp(`^${e}$`)}function Zdt(...t){return e=>t.reduce((([t,n,i],r)=>{const[s,o,a]=r(e,i);return[{...t,...s},o||n,a]}),[{},null,1]).slice(0,2)}function Jdt(t,...e){if(null==t)return[null,null];for(const[n,i]of e){const e=n.exec(t);if(e)return i(e)}return[null,null]}function Qdt(...t){return(e,n)=>{const i={};let r;for(r=0;r<t.length;r++)i[t[r]]=gdt(e[n+r]);return[i,null,n+r]}}const tpt=/(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,ept=/(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/,npt=RegExp(`${ept.source}${`(?:${tpt.source}?(?:\\[(${Kdt.source})\\])?)?`}`),ipt=RegExp(`(?:T${npt.source})?`),rpt=Qdt("weekYear","weekNumber","weekDay"),spt=Qdt("year","ordinal"),opt=RegExp(`${ept.source} ?(?:${tpt.source}|(${Kdt.source}))?`),apt=RegExp(`(?: ${opt.source})?`);function lpt(t,e,n){const i=t[e];return ldt(i)?n:gdt(i)}function cpt(t,e){return[{hours:lpt(t,e,0),minutes:lpt(t,e+1,0),seconds:lpt(t,e+2,0),milliseconds:bdt(t[e+3])},null,e+4]}function upt(t,e){const n=!t[e]&&!t[e+1],i=Edt(t[e+1],t[e+2]);return[{},n?null:Zht.instance(i),e+3]}function hpt(t,e){return[{},t[e]?Fht.create(t[e]):null,e+1]}const dpt=RegExp(`^T?${ept.source}$`),ppt=/^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;function fpt(t){const[e,n,i,r,s,o,a,l,c]=t,u="-"===e[0],h=l&&"-"===l[0],d=(t,e=!1)=>void 0!==t&&(e||t&&u)?-t:t;return[{years:d(ydt(n)),months:d(ydt(i)),weeks:d(ydt(r)),days:d(ydt(s)),hours:d(ydt(o)),minutes:d(ydt(a)),seconds:d(ydt(l),"-0"===l),milliseconds:d(bdt(c),h)}]}const mpt={GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function gpt(t,e,n,i,r,s,o){const a={year:2===e.length?Tdt(gdt(e)):gdt(e),month:Rdt.indexOf(n)+1,day:gdt(i),hour:gdt(r),minute:gdt(s)};return o&&(a.second=gdt(o)),t&&(a.weekday=t.length>3?Ldt.indexOf(t)+1:Ddt.indexOf(t)+1),a}const ypt=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;function bpt(t){const[,e,n,i,r,s,o,a,l,c,u,h]=t,d=gpt(e,r,i,n,s,o,a);let p;return p=l?mpt[l]:c?0:Edt(u,h),[d,new Zht(p)]}const vpt=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,xpt=/^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,wpt=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;function Spt(t){const[,e,n,i,r,s,o,a]=t;return[gpt(e,r,i,n,s,o,a),Zht.utcInstance]}function kpt(t){const[,e,n,i,r,s,o,a]=t;return[gpt(e,a,n,i,r,s,o),Zht.utcInstance]}const Cpt=Ydt(/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/,ipt),Tpt=Ydt(/(\d{4})-?W(\d\d)(?:-?(\d))?/,ipt),_pt=Ydt(/(\d{4})-?(\d{3})/,ipt),Ept=Ydt(npt),Mpt=Zdt((function(t,e){return[{year:lpt(t,e),month:lpt(t,e+1,1),day:lpt(t,e+2,1)},null,e+3]}),cpt,upt,hpt),$pt=Zdt(rpt,cpt,upt,hpt),Ipt=Zdt(spt,cpt,upt,hpt),Apt=Zdt(cpt,upt,hpt);const Npt=Zdt(cpt);const Rpt=Ydt(/(\d{4})-(\d\d)-(\d\d)/,apt),Ppt=Ydt(opt),Opt=Zdt(cpt,upt,hpt);const Lpt="Invalid Duration",Dpt={weeks:{days:7,hours:168,minutes:10080,seconds:604800,milliseconds:6048e5},days:{hours:24,minutes:1440,seconds:86400,milliseconds:864e5},hours:{minutes:60,seconds:3600,milliseconds:36e5},minutes:{seconds:60,milliseconds:6e4},seconds:{milliseconds:1e3}},Fpt={years:{quarters:4,months:12,weeks:52,days:365,hours:8760,minutes:525600,seconds:31536e3,milliseconds:31536e6},quarters:{months:3,weeks:13,days:91,hours:2184,minutes:131040,seconds:7862400,milliseconds:78624e5},months:{weeks:4,days:30,hours:720,minutes:43200,seconds:2592e3,milliseconds:2592e6},...Dpt},zpt=365.2425,Bpt=30.436875,Upt={years:{quarters:4,months:12,weeks:52.1775,days:zpt,hours:8765.82,minutes:525949.2,seconds:525949.2*60,milliseconds:525949.2*60*1e3},quarters:{months:3,weeks:13.044375,days:91.310625,hours:2191.455,minutes:131487.3,seconds:525949.2*60/4,milliseconds:7889237999.999999},months:{weeks:4.3481250000000005,days:Bpt,hours:730.485,minutes:43829.1,seconds:2629746,milliseconds:2629746e3},...Dpt},Vpt=["years","quarters","months","weeks","days","hours","minutes","seconds","milliseconds"],Wpt=Vpt.slice(0).reverse();function Hpt(t,e,n=!1){const i={values:n?e.values:{...t.values,...e.values||{}},loc:t.loc.clone(e.loc),conversionAccuracy:e.conversionAccuracy||t.conversionAccuracy,matrix:e.matrix||t.matrix};return new qpt(i)}function jpt(t,e){let n=e.milliseconds??0;for(const i of Wpt.slice(1))e[i]&&(n+=e[i]*t[i].milliseconds);return n}function Gpt(t,e){const n=jpt(t,e)<0?-1:1;Vpt.reduceRight(((i,r)=>{if(ldt(e[r]))return i;if(i){const s=e[i]*n,o=t[r][i],a=Math.floor(s/o);e[r]+=a*n,e[i]-=a*o*n}return r}),null),Vpt.reduce(((n,i)=>{if(ldt(e[i]))return n;if(n){const r=e[n]%1;e[n]-=r,e[i]+=r*t[n][i]}return i}),null)}class qpt{constructor(t){const e="longterm"===t.conversionAccuracy||!1;let n=e?Upt:Fpt;t.matrix&&(n=t.matrix),this.values=t.values,this.loc=t.loc||Kht.create(),this.conversionAccuracy=e?"longterm":"casual",this.invalid=t.invalid||null,this.matrix=n,this.isLuxonDuration=!0}static fromMillis(t,e){return qpt.fromObject({milliseconds:t},e)}static fromObject(t,e={}){if(null==t||"object"!=typeof t)throw new sht("Duration.fromObject: argument expected to be an object, got "+(null===t?"null":typeof t));return new qpt({values:$dt(t,qpt.normalizeUnit),loc:Kht.fromObject(e),conversionAccuracy:e.conversionAccuracy,matrix:e.matrix})}static fromDurationLike(t){if(cdt(t))return qpt.fromMillis(t);if(qpt.isDuration(t))return t;if("object"==typeof t)return qpt.fromObject(t);throw new sht(`Unknown duration argument ${t} of type ${typeof t}`)}static fromISO(t,e){const[n]=function(t){return Jdt(t,[ppt,fpt])}(t);return n?qpt.fromObject(n,e):qpt.invalid("unparsable",`the input "${t}" can't be parsed as ISO 8601`)}static fromISOTime(t,e){const[n]=function(t){return Jdt(t,[dpt,Npt])}(t);return n?qpt.fromObject(n,e):qpt.invalid("unparsable",`the input "${t}" can't be parsed as ISO 8601`)}static invalid(t,e=null){if(!t)throw new sht("need to specify a reason the Duration is invalid");const n=t instanceof Xdt?t:new Xdt(t,e);if(adt.throwOnInvalid)throw new nht(n);return new qpt({invalid:n})}static normalizeUnit(t){const e={year:"years",years:"years",quarter:"quarters",quarters:"quarters",month:"months",months:"months",week:"weeks",weeks:"weeks",day:"days",days:"days",hour:"hours",hours:"hours",minute:"minutes",minutes:"minutes",second:"seconds",seconds:"seconds",millisecond:"milliseconds",milliseconds:"milliseconds"}[t?t.toLowerCase():t];if(!e)throw new rht(t);return e}static isDuration(t){return t&&t.isLuxonDuration||!1}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}toFormat(t,e={}){const n={...e,floor:!1!==e.round&&!1!==e.floor};return this.isValid?qdt.create(this.loc,n).formatDurationFromString(this,t):Lpt}toHuman(t={}){if(!this.isValid)return Lpt;const e=Vpt.map((e=>{const n=this.values[e];return ldt(n)?null:this.loc.numberFormatter({style:"unit",unitDisplay:"long",...t,unit:e.slice(0,-1)}).format(n)})).filter((t=>t));return this.loc.listFormatter({type:"conjunction",style:t.listStyle||"narrow",...t}).format(e)}toObject(){return this.isValid?{...this.values}:{}}toISO(){if(!this.isValid)return null;let t="P";return 0!==this.years&&(t+=this.years+"Y"),0===this.months&&0===this.quarters||(t+=this.months+3*this.quarters+"M"),0!==this.weeks&&(t+=this.weeks+"W"),0!==this.days&&(t+=this.days+"D"),0===this.hours&&0===this.minutes&&0===this.seconds&&0===this.milliseconds||(t+="T"),0!==this.hours&&(t+=this.hours+"H"),0!==this.minutes&&(t+=this.minutes+"M"),0===this.seconds&&0===this.milliseconds||(t+=vdt(this.seconds+this.milliseconds/1e3,3)+"S"),"P"===t&&(t+="T0S"),t}toISOTime(t={}){if(!this.isValid)return null;const e=this.toMillis();if(e<0||e>=864e5)return null;t={suppressMilliseconds:!1,suppressSeconds:!1,includePrefix:!1,format:"extended",...t,includeOffset:!1};return Jft.fromMillis(e,{zone:"UTC"}).toISOTime(t)}toJSON(){return this.toISO()}toString(){return this.toISO()}toMillis(){return this.isValid?jpt(this.matrix,this.values):NaN}valueOf(){return this.toMillis()}plus(t){if(!this.isValid)return this;const e=qpt.fromDurationLike(t),n={};for(const t of Vpt)(pdt(e.values,t)||pdt(this.values,t))&&(n[t]=e.get(t)+this.get(t));return Hpt(this,{values:n},!0)}minus(t){if(!this.isValid)return this;const e=qpt.fromDurationLike(t);return this.plus(e.negate())}mapUnits(t){if(!this.isValid)return this;const e={};for(const n of Object.keys(this.values))e[n]=Mdt(t(this.values[n],n));return Hpt(this,{values:e},!0)}get(t){return this[qpt.normalizeUnit(t)]}set(t){if(!this.isValid)return this;return Hpt(this,{values:{...this.values,...$dt(t,qpt.normalizeUnit)}})}reconfigure({locale:t,numberingSystem:e,conversionAccuracy:n,matrix:i}={}){return Hpt(this,{loc:this.loc.clone({locale:t,numberingSystem:e}),matrix:i,conversionAccuracy:n})}as(t){return this.isValid?this.shiftTo(t).get(t):NaN}normalize(){if(!this.isValid)return this;const t=this.toObject();return Gpt(this.matrix,t),Hpt(this,{values:t},!0)}rescale(){if(!this.isValid)return this;const t=function(t){const e={};for(const[n,i]of Object.entries(t))0!==i&&(e[n]=i);return e}(this.normalize().shiftToAll().toObject());return Hpt(this,{values:t},!0)}shiftTo(...t){if(!this.isValid)return this;if(0===t.length)return this;t=t.map((t=>qpt.normalizeUnit(t)));const e={},n={},i=this.toObject();let r;for(const s of Vpt)if(t.indexOf(s)>=0){r=s;let t=0;for(const e in n)t+=this.matrix[e][s]*n[e],n[e]=0;cdt(i[s])&&(t+=i[s]);const o=Math.trunc(t);e[s]=o,n[s]=(1e3*t-1e3*o)/1e3}else cdt(i[s])&&(n[s]=i[s]);for(const t in n)0!==n[t]&&(e[r]+=t===r?n[t]:n[t]/this.matrix[r][t]);return Gpt(this.matrix,e),Hpt(this,{values:e},!0)}shiftToAll(){return this.isValid?this.shiftTo("years","months","weeks","days","hours","minutes","seconds","milliseconds"):this}negate(){if(!this.isValid)return this;const t={};for(const e of Object.keys(this.values))t[e]=0===this.values[e]?0:-this.values[e];return Hpt(this,{values:t},!0)}get years(){return this.isValid?this.values.years||0:NaN}get quarters(){return this.isValid?this.values.quarters||0:NaN}get months(){return this.isValid?this.values.months||0:NaN}get weeks(){return this.isValid?this.values.weeks||0:NaN}get days(){return this.isValid?this.values.days||0:NaN}get hours(){return this.isValid?this.values.hours||0:NaN}get minutes(){return this.isValid?this.values.minutes||0:NaN}get seconds(){return this.isValid?this.values.seconds||0:NaN}get milliseconds(){return this.isValid?this.values.milliseconds||0:NaN}get isValid(){return null===this.invalid}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}equals(t){if(!this.isValid||!t.isValid)return!1;if(!this.loc.equals(t.loc))return!1;for(const i of Vpt)if(e=this.values[i],n=t.values[i],!(void 0===e||0===e?void 0===n||0===n:e===n))return!1;var e,n;return!0}}const Xpt="Invalid Interval";class Kpt{constructor(t){this.s=t.start,this.e=t.end,this.invalid=t.invalid||null,this.isLuxonInterval=!0}static invalid(t,e=null){if(!t)throw new sht("need to specify a reason the Interval is invalid");const n=t instanceof Xdt?t:new Xdt(t,e);if(adt.throwOnInvalid)throw new eht(n);return new Kpt({invalid:n})}static fromDateTimes(t,e){const n=Qft(t),i=Qft(e),r=function(t,e){return t&&t.isValid?e&&e.isValid?e<t?Kpt.invalid("end before start",`The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`):null:Kpt.invalid("missing or invalid end"):Kpt.invalid("missing or invalid start")}(n,i);return null==r?new Kpt({start:n,end:i}):r}static after(t,e){const n=qpt.fromDurationLike(e),i=Qft(t);return Kpt.fromDateTimes(i,i.plus(n))}static before(t,e){const n=qpt.fromDurationLike(e),i=Qft(t);return Kpt.fromDateTimes(i.minus(n),i)}static fromISO(t,e){const[n,i]=(t||"").split("/",2);if(n&&i){let t,r,s,o;try{t=Jft.fromISO(n,e),r=t.isValid}catch(i){r=!1}try{s=Jft.fromISO(i,e),o=s.isValid}catch(i){o=!1}if(r&&o)return Kpt.fromDateTimes(t,s);if(r){const n=qpt.fromISO(i,e);if(n.isValid)return Kpt.after(t,n)}else if(o){const t=qpt.fromISO(n,e);if(t.isValid)return Kpt.before(s,t)}}return Kpt.invalid("unparsable",`the input "${t}" can't be parsed as ISO 8601`)}static isInterval(t){return t&&t.isLuxonInterval||!1}get start(){return this.isValid?this.s:null}get end(){return this.isValid?this.e:null}get isValid(){return null===this.invalidReason}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}length(t="milliseconds"){return this.isValid?this.toDuration(t).get(t):NaN}count(t="milliseconds"){if(!this.isValid)return NaN;const e=this.start.startOf(t),n=this.end.startOf(t);return Math.floor(n.diff(e,t).get(t))+(n.valueOf()!==this.end.valueOf())}hasSame(t){return!!this.isValid&&(this.isEmpty()||this.e.minus(1).hasSame(this.s,t))}isEmpty(){return this.s.valueOf()===this.e.valueOf()}isAfter(t){return!!this.isValid&&this.s>t}isBefore(t){return!!this.isValid&&this.e<=t}contains(t){return!!this.isValid&&(this.s<=t&&this.e>t)}set({start:t,end:e}={}){return this.isValid?Kpt.fromDateTimes(t||this.s,e||this.e):this}splitAt(...t){if(!this.isValid)return[];const e=t.map(Qft).filter((t=>this.contains(t))).sort(),n=[];let{s:i}=this,r=0;for(;i<this.e;){const t=e[r]||this.e,s=+t>+this.e?this.e:t;n.push(Kpt.fromDateTimes(i,s)),i=s,r+=1}return n}splitBy(t){const e=qpt.fromDurationLike(t);if(!this.isValid||!e.isValid||0===e.as("milliseconds"))return[];let n,{s:i}=this,r=1;const s=[];for(;i<this.e;){const t=this.start.plus(e.mapUnits((t=>t*r)));n=+t>+this.e?this.e:t,s.push(Kpt.fromDateTimes(i,n)),i=n,r+=1}return s}divideEqually(t){return this.isValid?this.splitBy(this.length()/t).slice(0,t):[]}overlaps(t){return this.e>t.s&&this.s<t.e}abutsStart(t){return!!this.isValid&&+this.e==+t.s}abutsEnd(t){return!!this.isValid&&+t.e==+this.s}engulfs(t){return!!this.isValid&&(this.s<=t.s&&this.e>=t.e)}equals(t){return!(!this.isValid||!t.isValid)&&(this.s.equals(t.s)&&this.e.equals(t.e))}intersection(t){if(!this.isValid)return this;const e=this.s>t.s?this.s:t.s,n=this.e<t.e?this.e:t.e;return e>=n?null:Kpt.fromDateTimes(e,n)}union(t){if(!this.isValid)return this;const e=this.s<t.s?this.s:t.s,n=this.e>t.e?this.e:t.e;return Kpt.fromDateTimes(e,n)}static merge(t){const[e,n]=t.sort(((t,e)=>t.s-e.s)).reduce((([t,e],n)=>e?e.overlaps(n)||e.abutsStart(n)?[t,e.union(n)]:[t.concat([e]),n]:[t,n]),[[],null]);return n&&e.push(n),e}static xor(t){let e=null,n=0;const i=[],r=t.map((t=>[{time:t.s,type:"s"},{time:t.e,type:"e"}])),s=Array.prototype.concat(...r).sort(((t,e)=>t.time-e.time));for(const t of s)n+="s"===t.type?1:-1,1===n?e=t.time:(e&&+e!=+t.time&&i.push(Kpt.fromDateTimes(e,t.time)),e=null);return Kpt.merge(i)}difference(...t){return Kpt.xor([this].concat(t)).map((t=>this.intersection(t))).filter((t=>t&&!t.isEmpty()))}toString(){return this.isValid?`[${this.s.toISO()}  ${this.e.toISO()})`:Xpt}toLocaleString(t=uht,e={}){return this.isValid?qdt.create(this.s.loc.clone(e),t).formatInterval(this):Xpt}toISO(t){return this.isValid?`${this.s.toISO(t)}/${this.e.toISO(t)}`:Xpt}toISODate(){return this.isValid?`${this.s.toISODate()}/${this.e.toISODate()}`:Xpt}toISOTime(t){return this.isValid?`${this.s.toISOTime(t)}/${this.e.toISOTime(t)}`:Xpt}toFormat(t,{separator:e="  "}={}){return this.isValid?`${this.s.toFormat(t)}${e}${this.e.toFormat(t)}`:Xpt}toDuration(t,e){return this.isValid?this.e.diff(this.s,t,e):qpt.invalid(this.invalidReason)}mapEndpoints(t){return Kpt.fromDateTimes(t(this.s),t(this.e))}}class Ypt{static hasDST(t=adt.defaultZone){const e=Jft.now().setZone(t).set({month:12});return!t.isUniversal&&e.offset!==e.set({month:6}).offset}static isValidIANAZone(t){return Fht.isValidZone(t)}static normalizeZone(t){return Qht(t,adt.defaultZone)}static months(t="long",{locale:e=null,numberingSystem:n=null,locObj:i=null,outputCalendar:r="gregory"}={}){return(i||Kht.create(e,n,r)).months(t)}static monthsFormat(t="long",{locale:e=null,numberingSystem:n=null,locObj:i=null,outputCalendar:r="gregory"}={}){return(i||Kht.create(e,n,r)).months(t,!0)}static weekdays(t="long",{locale:e=null,numberingSystem:n=null,locObj:i=null}={}){return(i||Kht.create(e,n,null)).weekdays(t)}static weekdaysFormat(t="long",{locale:e=null,numberingSystem:n=null,locObj:i=null}={}){return(i||Kht.create(e,n,null)).weekdays(t,!0)}static meridiems({locale:t=null}={}){return Kht.create(t).meridiems()}static eras(t="short",{locale:e=null}={}){return Kht.create(e,null,"gregory").eras(t)}static features(){return{relative:hdt()}}}function Zpt(t,e){const n=t=>t.toUTC(0,{keepLocalTime:!0}).startOf("day").valueOf(),i=n(e)-n(t);return Math.floor(qpt.fromMillis(i).as("days"))}function Jpt(t,e,n,i){let[r,s,o,a]=function(t,e,n){const i=[["years",(t,e)=>e.year-t.year],["quarters",(t,e)=>e.quarter-t.quarter+4*(e.year-t.year)],["months",(t,e)=>e.month-t.month+12*(e.year-t.year)],["weeks",(t,e)=>{const n=Zpt(t,e);return(n-n%7)/7}],["days",Zpt]],r={},s=t;let o,a;for(const[l,c]of i)n.indexOf(l)>=0&&(o=l,r[l]=c(t,e),a=s.plus(r),a>e?(r[l]--,(t=s.plus(r))>e&&(a=t,r[l]--,t=s.plus(r))):t=a);return[t,r,a,o]}(t,e,n);const l=e-r,c=n.filter((t=>["hours","minutes","seconds","milliseconds"].indexOf(t)>=0));0===c.length&&(o<e&&(o=r.plus({[a]:1})),o!==r&&(s[a]=(s[a]||0)+l/(o-r)));const u=qpt.fromObject(s,i);return c.length>0?qpt.fromMillis(l,i).shiftTo(...c).plus(u):u}const Qpt={arab:"[-]",arabext:"[-]",bali:"[-]",beng:"[-]",deva:"[-]",fullwide:"[-]",gujr:"[-]",hanidec:"[|||||||||]",khmr:"[-]",knda:"[-]",laoo:"[-]",limb:"[-]",mlym:"[-]",mong:"[-]",mymr:"[-]",orya:"[-]",tamldec:"[-]",telu:"[-]",thai:"[-]",tibt:"[-]",latn:"\\d"},tft={arab:[1632,1641],arabext:[1776,1785],bali:[6992,7001],beng:[2534,2543],deva:[2406,2415],fullwide:[65296,65303],gujr:[2790,2799],khmr:[6112,6121],knda:[3302,3311],laoo:[3792,3801],limb:[6470,6479],mlym:[3430,3439],mong:[6160,6169],mymr:[4160,4169],orya:[2918,2927],tamldec:[3046,3055],telu:[3174,3183],thai:[3664,3673],tibt:[3872,3881]},eft=Qpt.hanidec.replace(/[\[|\]]/g,"").split("");function nft({numberingSystem:t},e=""){return new RegExp(`${Qpt[t||"latn"]}${e}`)}const ift="missing Intl.DateTimeFormat.formatToParts support";function rft(t,e=(t=>t)){return{regex:t,deser:([t])=>e(function(t){let e=parseInt(t,10);if(isNaN(e)){e="";for(let n=0;n<t.length;n++){const i=t.charCodeAt(n);if(-1!==t[n].search(Qpt.hanidec))e+=eft.indexOf(t[n]);else for(const t in tft){const[n,r]=tft[t];i>=n&&i<=r&&(e+=i-n)}}return parseInt(e,10)}return e}(t))}}const sft=`[ ${String.fromCharCode(160)}]`,oft=new RegExp(sft,"g");function aft(t){return t.replace(/\./g,"\\.?").replace(oft,sft)}function lft(t){return t.replace(/\./g,"").replace(oft," ").toLowerCase()}function cft(t,e){return null===t?null:{regex:RegExp(t.map(aft).join("|")),deser:([n])=>t.findIndex((t=>lft(n)===lft(t)))+e}}function uft(t,e){return{regex:t,deser:([,t,e])=>Edt(t,e),groups:e}}function hft(t){return{regex:t,deser:([t])=>t}}const dft={year:{"2-digit":"yy",numeric:"yyyyy"},month:{numeric:"M","2-digit":"MM",short:"MMM",long:"MMMM"},day:{numeric:"d","2-digit":"dd"},weekday:{short:"EEE",long:"EEEE"},dayperiod:"a",dayPeriod:"a",hour12:{numeric:"h","2-digit":"hh"},hour24:{numeric:"H","2-digit":"HH"},minute:{numeric:"m","2-digit":"mm"},second:{numeric:"s","2-digit":"ss"},timeZoneName:{long:"ZZZZZ",short:"ZZZ"}};let pft=null;function fft(t,e){return Array.prototype.concat(...t.map((t=>function(t,e){if(t.literal)return t;const n=gft(qdt.macroTokenToFormatOpts(t.val),e);return null==n||n.includes(void 0)?t:n}(t,e))))}function mft(t,e,n){const i=fft(qdt.parseFormat(n),t),r=i.map((e=>function(t,e){const n=nft(e),i=nft(e,"{2}"),r=nft(e,"{3}"),s=nft(e,"{4}"),o=nft(e,"{6}"),a=nft(e,"{1,2}"),l=nft(e,"{1,3}"),c=nft(e,"{1,6}"),u=nft(e,"{1,9}"),h=nft(e,"{2,4}"),d=nft(e,"{4,6}"),p=t=>{return{regex:RegExp((e=t.val,e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"))),deser:([t])=>t,literal:!0};var e},f=(f=>{if(t.literal)return p(f);switch(f.val){case"G":return cft(e.eras("short"),0);case"GG":return cft(e.eras("long"),0);case"y":return rft(c);case"yy":case"kk":return rft(h,Tdt);case"yyyy":case"kkkk":return rft(s);case"yyyyy":return rft(d);case"yyyyyy":return rft(o);case"M":case"L":case"d":case"H":case"h":case"m":case"q":case"s":case"W":return rft(a);case"MM":case"LL":case"dd":case"HH":case"hh":case"mm":case"qq":case"ss":case"WW":return rft(i);case"MMM":return cft(e.months("short",!0),1);case"MMMM":return cft(e.months("long",!0),1);case"LLL":return cft(e.months("short",!1),1);case"LLLL":return cft(e.months("long",!1),1);case"o":case"S":return rft(l);case"ooo":case"SSS":return rft(r);case"u":return hft(u);case"uu":return hft(a);case"uuu":case"E":case"c":return rft(n);case"a":return cft(e.meridiems(),0);case"EEE":return cft(e.weekdays("short",!1),1);case"EEEE":return cft(e.weekdays("long",!1),1);case"ccc":return cft(e.weekdays("short",!0),1);case"cccc":return cft(e.weekdays("long",!0),1);case"Z":case"ZZ":return uft(new RegExp(`([+-]${a.source})(?::(${i.source}))?`),2);case"ZZZ":return uft(new RegExp(`([+-]${a.source})(${i.source})?`),2);case"z":return hft(/[a-z_+-/]{1,256}?/i);case" ":return hft(/[^\S\n\r]/);default:return p(f)}})(t)||{invalidReason:ift};return f.token=t,f}(e,t))),s=r.find((t=>t.invalidReason));if(s)return{input:e,tokens:i,invalidReason:s.invalidReason};{const[t,n]=function(t){const e=t.map((t=>t.regex)).reduce(((t,e)=>`${t}(${e.source})`),"");return[`^${e}$`,t]}(r),s=RegExp(t,"i"),[o,a]=function(t,e,n){const i=t.match(e);if(i){const t={};let e=1;for(const r in n)if(pdt(n,r)){const s=n[r],o=s.groups?s.groups+1:1;!s.literal&&s.token&&(t[s.token.val[0]]=s.deser(i.slice(e,e+o))),e+=o}return[i,t]}return[i,{}]}(e,s,n),[l,c,u]=a?function(t){let e,n=null;ldt(t.z)||(n=Fht.create(t.z)),ldt(t.Z)||(n||(n=new Zht(t.Z)),e=t.Z),ldt(t.q)||(t.M=3*(t.q-1)+1),ldt(t.h)||(t.h<12&&1===t.a?t.h+=12:12===t.h&&0===t.a&&(t.h=0)),0===t.G&&t.y&&(t.y=-t.y),ldt(t.u)||(t.S=bdt(t.u));const i=Object.keys(t).reduce(((e,n)=>{const i=(t=>{switch(t){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":case"H":return"hour";case"d":return"day";case"o":return"ordinal";case"L":case"M":return"month";case"y":return"year";case"E":case"c":return"weekday";case"W":return"weekNumber";case"k":return"weekYear";case"q":return"quarter";default:return null}})(n);return i&&(e[i]=t[n]),e}),{});return[i,n,e]}(a):[null,null,void 0];if(pdt(a,"a")&&pdt(a,"H"))throw new iht("Can't include meridiem when specifying 24-hour format");return{input:e,tokens:i,regex:s,rawMatches:o,matches:a,result:l,zone:c,specificOffset:u}}}function gft(t,e){if(!t)return null;const n=qdt.create(e,t).dtFormatter((pft||(pft=Jft.fromMillis(1555555555555)),pft)),i=n.formatToParts(),r=n.resolvedOptions();return i.map((e=>function(t,e,n){const{type:i,value:r}=t;if("literal"===i){const t=/^\s+$/.test(r);return{literal:!t,val:t?" ":r}}const s=e[i];let o=i;"hour"===i&&(o=null!=e.hour12?e.hour12?"hour12":"hour24":null!=e.hourCycle?"h11"===e.hourCycle||"h12"===e.hourCycle?"hour12":"hour24":n.hour12?"hour12":"hour24");let a=dft[o];if("object"==typeof a&&(a=a[s]),a)return{literal:!1,val:a}}(e,t,r)))}const yft=[0,31,59,90,120,151,181,212,243,273,304,334],bft=[0,31,60,91,121,152,182,213,244,274,305,335];function vft(t,e){return new Xdt("unit out of range",`you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`)}function xft(t,e,n){const i=new Date(Date.UTC(t,e-1,n));t<100&&t>=0&&i.setUTCFullYear(i.getUTCFullYear()-1900);const r=i.getUTCDay();return 0===r?7:r}function wft(t,e,n){return n+(xdt(t)?bft:yft)[e-1]}function Sft(t,e){const n=xdt(t)?bft:yft,i=n.findIndex((t=>t<e));return{month:i+1,day:e-n[i]}}function kft(t){const{year:e,month:n,day:i}=t,r=wft(e,n,i),s=xft(e,n,i);let o,a=Math.floor((r-s+10)/7);return a<1?(o=e-1,a=Cdt(o)):a>Cdt(e)?(o=e+1,a=1):o=e,{weekYear:o,weekNumber:a,weekday:s,...Adt(t)}}function Cft(t){const{weekYear:e,weekNumber:n,weekday:i}=t,r=xft(e,1,4),s=wdt(e);let o,a=7*n+i-r-3;a<1?(o=e-1,a+=wdt(o)):a>s?(o=e+1,a-=wdt(e)):o=e;const{month:l,day:c}=Sft(o,a);return{year:o,month:l,day:c,...Adt(t)}}function Tft(t){const{year:e,month:n,day:i}=t;return{year:e,ordinal:wft(e,n,i),...Adt(t)}}function _ft(t){const{year:e,ordinal:n}=t,{month:i,day:r}=Sft(e,n);return{year:e,month:i,day:r,...Adt(t)}}function Eft(t){const e=udt(t.year),n=fdt(t.month,1,12),i=fdt(t.day,1,Sdt(t.year,t.month));return e?n?!i&&vft("day",t.day):vft("month",t.month):vft("year",t.year)}function Mft(t){const{hour:e,minute:n,second:i,millisecond:r}=t,s=fdt(e,0,23)||24===e&&0===n&&0===i&&0===r,o=fdt(n,0,59),a=fdt(i,0,59),l=fdt(r,0,999);return s?o?a?!l&&vft("millisecond",r):vft("second",i):vft("minute",n):vft("hour",e)}const $ft="Invalid DateTime",Ift=864e13;function Aft(t){return new Xdt("unsupported zone",`the zone "${t.name}" is not supported`)}function Nft(t){return null===t.weekData&&(t.weekData=kft(t.c)),t.weekData}function Rft(t,e){const n={ts:t.ts,zone:t.zone,c:t.c,o:t.o,loc:t.loc,invalid:t.invalid};return new Jft({...n,...e,old:n})}function Pft(t,e,n){let i=t-60*e*1e3;const r=n.offset(i);if(e===r)return[i,e];i-=60*(r-e)*1e3;const s=n.offset(i);return r===s?[i,r]:[t-60*Math.min(r,s)*1e3,Math.max(r,s)]}function Oft(t,e){const n=new Date(t+=60*e*1e3);return{year:n.getUTCFullYear(),month:n.getUTCMonth()+1,day:n.getUTCDate(),hour:n.getUTCHours(),minute:n.getUTCMinutes(),second:n.getUTCSeconds(),millisecond:n.getUTCMilliseconds()}}function Lft(t,e,n){return Pft(kdt(t),e,n)}function Dft(t,e){const n=t.o,i=t.c.year+Math.trunc(e.years),r=t.c.month+Math.trunc(e.months)+3*Math.trunc(e.quarters),s={...t.c,year:i,month:r,day:Math.min(t.c.day,Sdt(i,r))+Math.trunc(e.days)+7*Math.trunc(e.weeks)},o=qpt.fromObject({years:e.years-Math.trunc(e.years),quarters:e.quarters-Math.trunc(e.quarters),months:e.months-Math.trunc(e.months),weeks:e.weeks-Math.trunc(e.weeks),days:e.days-Math.trunc(e.days),hours:e.hours,minutes:e.minutes,seconds:e.seconds,milliseconds:e.milliseconds}).as("milliseconds"),a=kdt(s);let[l,c]=Pft(a,n,t.zone);return 0!==o&&(l+=o,c=t.zone.offset(l)),{ts:l,o:c}}function Fft(t,e,n,i,r,s){const{setZone:o,zone:a}=n;if(t&&0!==Object.keys(t).length||e){const i=e||a,r=Jft.fromObject(t,{...n,zone:i,specificOffset:s});return o?r:r.setZone(a)}return Jft.invalid(new Xdt("unparsable",`the input "${r}" can't be parsed as ${i}`))}function zft(t,e,n=!0){return t.isValid?qdt.create(Kht.create("en-US"),{allowZ:n,forceSimple:!0}).formatDateTimeFromString(t,e):null}function Bft(t,e){const n=t.c.year>9999||t.c.year<0;let i="";return n&&t.c.year>=0&&(i+="+"),i+=mdt(t.c.year,n?6:4),e?(i+="-",i+=mdt(t.c.month),i+="-",i+=mdt(t.c.day)):(i+=mdt(t.c.month),i+=mdt(t.c.day)),i}function Uft(t,e,n,i,r,s){let o=mdt(t.c.hour);return e?(o+=":",o+=mdt(t.c.minute),0===t.c.millisecond&&0===t.c.second&&n||(o+=":")):o+=mdt(t.c.minute),0===t.c.millisecond&&0===t.c.second&&n||(o+=mdt(t.c.second),0===t.c.millisecond&&i||(o+=".",o+=mdt(t.c.millisecond,3))),r&&(t.isOffsetFixed&&0===t.offset&&!s?o+="Z":t.o<0?(o+="-",o+=mdt(Math.trunc(-t.o/60)),o+=":",o+=mdt(Math.trunc(-t.o%60))):(o+="+",o+=mdt(Math.trunc(t.o/60)),o+=":",o+=mdt(Math.trunc(t.o%60)))),s&&(o+="["+t.zone.ianaName+"]"),o}const Vft={month:1,day:1,hour:0,minute:0,second:0,millisecond:0},Wft={weekNumber:1,weekday:1,hour:0,minute:0,second:0,millisecond:0},Hft={ordinal:1,hour:0,minute:0,second:0,millisecond:0},jft=["year","month","day","hour","minute","second","millisecond"],Gft=["weekYear","weekNumber","weekday","hour","minute","second","millisecond"],qft=["year","ordinal","hour","minute","second","millisecond"];function Xft(t){const e={year:"year",years:"year",month:"month",months:"month",day:"day",days:"day",hour:"hour",hours:"hour",minute:"minute",minutes:"minute",quarter:"quarter",quarters:"quarter",second:"second",seconds:"second",millisecond:"millisecond",milliseconds:"millisecond",weekday:"weekday",weekdays:"weekday",weeknumber:"weekNumber",weeksnumber:"weekNumber",weeknumbers:"weekNumber",weekyear:"weekYear",weekyears:"weekYear",ordinal:"ordinal"}[t.toLowerCase()];if(!e)throw new rht(t);return e}function Kft(t,e){const n=Qht(e.zone,adt.defaultZone),i=Kht.fromObject(e),r=adt.now();let s,o;if(ldt(t.year))s=r;else{for(const e of jft)ldt(t[e])&&(t[e]=Vft[e]);const e=Eft(t)||Mft(t);if(e)return Jft.invalid(e);const i=n.offset(r);[s,o]=Lft(t,i,n)}return new Jft({ts:s,zone:n,loc:i,o:o})}function Yft(t,e,n){const i=!!ldt(n.round)||n.round,r=(t,r)=>{t=vdt(t,i||n.calendary?0:2,!0);return e.loc.clone(n).relFormatter(n).format(t,r)},s=i=>n.calendary?e.hasSame(t,i)?0:e.startOf(i).diff(t.startOf(i),i).get(i):e.diff(t,i).get(i);if(n.unit)return r(s(n.unit),n.unit);for(const t of n.units){const e=s(t);if(Math.abs(e)>=1)return r(e,t)}return r(t>e?-0:0,n.units[n.units.length-1])}function Zft(t){let e,n={};return t.length>0&&"object"==typeof t[t.length-1]?(n=t[t.length-1],e=Array.from(t).slice(0,t.length-1)):e=Array.from(t),[n,e]}class Jft{constructor(t){const e=t.zone||adt.defaultZone;let n=t.invalid||(Number.isNaN(t.ts)?new Xdt("invalid input"):null)||(e.isValid?null:Aft(e));this.ts=ldt(t.ts)?adt.now():t.ts;let i=null,r=null;if(!n){if(t.old&&t.old.ts===this.ts&&t.old.zone.equals(e))[i,r]=[t.old.c,t.old.o];else{const t=e.offset(this.ts);i=Oft(this.ts,t),n=Number.isNaN(i.year)?new Xdt("invalid input"):null,i=n?null:i,r=n?null:t}}this._zone=e,this.loc=t.loc||Kht.create(),this.invalid=n,this.weekData=null,this.c=i,this.o=r,this.isLuxonDateTime=!0}static now(){return new Jft({})}static local(){const[t,e]=Zft(arguments),[n,i,r,s,o,a,l]=e;return Kft({year:n,month:i,day:r,hour:s,minute:o,second:a,millisecond:l},t)}static utc(){const[t,e]=Zft(arguments),[n,i,r,s,o,a,l]=e;return t.zone=Zht.utcInstance,Kft({year:n,month:i,day:r,hour:s,minute:o,second:a,millisecond:l},t)}static fromJSDate(t,e={}){const n=function(t){return"[object Date]"===Object.prototype.toString.call(t)}(t)?t.valueOf():NaN;if(Number.isNaN(n))return Jft.invalid("invalid input");const i=Qht(e.zone,adt.defaultZone);return i.isValid?new Jft({ts:n,zone:i,loc:Kht.fromObject(e)}):Jft.invalid(Aft(i))}static fromMillis(t,e={}){if(cdt(t))return t<-Ift||t>Ift?Jft.invalid("Timestamp out of range"):new Jft({ts:t,zone:Qht(e.zone,adt.defaultZone),loc:Kht.fromObject(e)});throw new sht(`fromMillis requires a numerical input, but received a ${typeof t} with value ${t}`)}static fromSeconds(t,e={}){if(cdt(t))return new Jft({ts:1e3*t,zone:Qht(e.zone,adt.defaultZone),loc:Kht.fromObject(e)});throw new sht("fromSeconds requires a numerical input")}static fromObject(t,e={}){t=t||{};const n=Qht(e.zone,adt.defaultZone);if(!n.isValid)return Jft.invalid(Aft(n));const i=adt.now(),r=ldt(e.specificOffset)?n.offset(i):e.specificOffset,s=$dt(t,Xft),o=!ldt(s.ordinal),a=!ldt(s.year),l=!ldt(s.month)||!ldt(s.day),c=a||l,u=s.weekYear||s.weekNumber,h=Kht.fromObject(e);if((c||o)&&u)throw new iht("Can't mix weekYear/weekNumber units with year/month/day or ordinals");if(l&&o)throw new iht("Can't mix ordinal dates with month/day");const d=u||s.weekday&&!c;let p,f,m=Oft(i,r);d?(p=Gft,f=Wft,m=kft(m)):o?(p=qft,f=Hft,m=Tft(m)):(p=jft,f=Vft);let g=!1;for(const t of p){ldt(s[t])?s[t]=g?f[t]:m[t]:g=!0}const y=d?function(t){const e=udt(t.weekYear),n=fdt(t.weekNumber,1,Cdt(t.weekYear)),i=fdt(t.weekday,1,7);return e?n?!i&&vft("weekday",t.weekday):vft("week",t.week):vft("weekYear",t.weekYear)}(s):o?function(t){const e=udt(t.year),n=fdt(t.ordinal,1,wdt(t.year));return e?!n&&vft("ordinal",t.ordinal):vft("year",t.year)}(s):Eft(s),b=y||Mft(s);if(b)return Jft.invalid(b);const v=d?Cft(s):o?_ft(s):s,[x,w]=Lft(v,r,n),S=new Jft({ts:x,zone:n,o:w,loc:h});return s.weekday&&c&&t.weekday!==S.weekday?Jft.invalid("mismatched weekday",`you can't specify both a weekday of ${s.weekday} and a date of ${S.toISO()}`):S}static fromISO(t,e={}){const[n,i]=function(t){return Jdt(t,[Cpt,Mpt],[Tpt,$pt],[_pt,Ipt],[Ept,Apt])}(t);return Fft(n,i,e,"ISO 8601",t)}static fromRFC2822(t,e={}){const[n,i]=function(t){return Jdt(function(t){return t.replace(/\([^()]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").trim()}(t),[ypt,bpt])}(t);return Fft(n,i,e,"RFC 2822",t)}static fromHTTP(t,e={}){const[n,i]=function(t){return Jdt(t,[vpt,Spt],[xpt,Spt],[wpt,kpt])}(t);return Fft(n,i,e,"HTTP",e)}static fromFormat(t,e,n={}){if(ldt(t)||ldt(e))throw new sht("fromFormat requires an input string and a format");const{locale:i=null,numberingSystem:r=null}=n,s=Kht.fromOpts({locale:i,numberingSystem:r,defaultToEN:!0}),[o,a,l,c]=function(t,e,n){const{result:i,zone:r,specificOffset:s,invalidReason:o}=mft(t,e,n);return[i,r,s,o]}(s,t,e);return c?Jft.invalid(c):Fft(o,a,n,`format ${e}`,t,l)}static fromString(t,e,n={}){return Jft.fromFormat(t,e,n)}static fromSQL(t,e={}){const[n,i]=function(t){return Jdt(t,[Rpt,Mpt],[Ppt,Opt])}(t);return Fft(n,i,e,"SQL",t)}static invalid(t,e=null){if(!t)throw new sht("need to specify a reason the DateTime is invalid");const n=t instanceof Xdt?t:new Xdt(t,e);if(adt.throwOnInvalid)throw new tht(n);return new Jft({invalid:n})}static isDateTime(t){return t&&t.isLuxonDateTime||!1}static parseFormatForOpts(t,e={}){const n=gft(t,Kht.fromObject(e));return n?n.map((t=>t?t.val:null)).join(""):null}static expandFormat(t,e={}){return fft(qdt.parseFormat(t),Kht.fromObject(e)).map((t=>t.val)).join("")}get(t){return this[t]}get isValid(){return null===this.invalid}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}get outputCalendar(){return this.isValid?this.loc.outputCalendar:null}get zone(){return this._zone}get zoneName(){return this.isValid?this.zone.name:null}get year(){return this.isValid?this.c.year:NaN}get quarter(){return this.isValid?Math.ceil(this.c.month/3):NaN}get month(){return this.isValid?this.c.month:NaN}get day(){return this.isValid?this.c.day:NaN}get hour(){return this.isValid?this.c.hour:NaN}get minute(){return this.isValid?this.c.minute:NaN}get second(){return this.isValid?this.c.second:NaN}get millisecond(){return this.isValid?this.c.millisecond:NaN}get weekYear(){return this.isValid?Nft(this).weekYear:NaN}get weekNumber(){return this.isValid?Nft(this).weekNumber:NaN}get weekday(){return this.isValid?Nft(this).weekday:NaN}get ordinal(){return this.isValid?Tft(this.c).ordinal:NaN}get monthShort(){return this.isValid?Ypt.months("short",{locObj:this.loc})[this.month-1]:null}get monthLong(){return this.isValid?Ypt.months("long",{locObj:this.loc})[this.month-1]:null}get weekdayShort(){return this.isValid?Ypt.weekdays("short",{locObj:this.loc})[this.weekday-1]:null}get weekdayLong(){return this.isValid?Ypt.weekdays("long",{locObj:this.loc})[this.weekday-1]:null}get offset(){return this.isValid?+this.o:NaN}get offsetNameShort(){return this.isValid?this.zone.offsetName(this.ts,{format:"short",locale:this.locale}):null}get offsetNameLong(){return this.isValid?this.zone.offsetName(this.ts,{format:"long",locale:this.locale}):null}get isOffsetFixed(){return this.isValid?this.zone.isUniversal:null}get isInDST(){return!this.isOffsetFixed&&(this.offset>this.set({month:1,day:1}).offset||this.offset>this.set({month:5}).offset)}getPossibleOffsets(){if(!this.isValid||this.isOffsetFixed)return[this];const t=864e5,e=6e4,n=kdt(this.c),i=this.zone.offset(n-t),r=this.zone.offset(n+t),s=this.zone.offset(n-i*e),o=this.zone.offset(n-r*e);if(s===o)return[this];const a=n-s*e,l=n-o*e,c=Oft(a,s),u=Oft(l,o);return c.hour===u.hour&&c.minute===u.minute&&c.second===u.second&&c.millisecond===u.millisecond?[Rft(this,{ts:a}),Rft(this,{ts:l})]:[this]}get isInLeapYear(){return xdt(this.year)}get daysInMonth(){return Sdt(this.year,this.month)}get daysInYear(){return this.isValid?wdt(this.year):NaN}get weeksInWeekYear(){return this.isValid?Cdt(this.weekYear):NaN}resolvedLocaleOptions(t={}){const{locale:e,numberingSystem:n,calendar:i}=qdt.create(this.loc.clone(t),t).resolvedOptions(this);return{locale:e,numberingSystem:n,outputCalendar:i}}toUTC(t=0,e={}){return this.setZone(Zht.instance(t),e)}toLocal(){return this.setZone(adt.defaultZone)}setZone(t,{keepLocalTime:e=!1,keepCalendarTime:n=!1}={}){if((t=Qht(t,adt.defaultZone)).equals(this.zone))return this;if(t.isValid){let i=this.ts;if(e||n){const e=t.offset(this.ts),n=this.toObject();[i]=Lft(n,e,t)}return Rft(this,{ts:i,zone:t})}return Jft.invalid(Aft(t))}reconfigure({locale:t,numberingSystem:e,outputCalendar:n}={}){return Rft(this,{loc:this.loc.clone({locale:t,numberingSystem:e,outputCalendar:n})})}setLocale(t){return this.reconfigure({locale:t})}set(t){if(!this.isValid)return this;const e=$dt(t,Xft),n=!ldt(e.weekYear)||!ldt(e.weekNumber)||!ldt(e.weekday),i=!ldt(e.ordinal),r=!ldt(e.year),s=!ldt(e.month)||!ldt(e.day),o=r||s,a=e.weekYear||e.weekNumber;if((o||i)&&a)throw new iht("Can't mix weekYear/weekNumber units with year/month/day or ordinals");if(s&&i)throw new iht("Can't mix ordinal dates with month/day");let l;n?l=Cft({...kft(this.c),...e}):ldt(e.ordinal)?(l={...this.toObject(),...e},ldt(e.day)&&(l.day=Math.min(Sdt(l.year,l.month),l.day))):l=_ft({...Tft(this.c),...e});const[c,u]=Lft(l,this.o,this.zone);return Rft(this,{ts:c,o:u})}plus(t){if(!this.isValid)return this;return Rft(this,Dft(this,qpt.fromDurationLike(t)))}minus(t){if(!this.isValid)return this;return Rft(this,Dft(this,qpt.fromDurationLike(t).negate()))}startOf(t){if(!this.isValid)return this;const e={},n=qpt.normalizeUnit(t);switch(n){case"years":e.month=1;case"quarters":case"months":e.day=1;case"weeks":case"days":e.hour=0;case"hours":e.minute=0;case"minutes":e.second=0;case"seconds":e.millisecond=0}if("weeks"===n&&(e.weekday=1),"quarters"===n){const t=Math.ceil(this.month/3);e.month=3*(t-1)+1}return this.set(e)}endOf(t){return this.isValid?this.plus({[t]:1}).startOf(t).minus(1):this}toFormat(t,e={}){return this.isValid?qdt.create(this.loc.redefaultToEN(e)).formatDateTimeFromString(this,t):$ft}toLocaleString(t=uht,e={}){return this.isValid?qdt.create(this.loc.clone(e),t).formatDateTime(this):$ft}toLocaleParts(t={}){return this.isValid?qdt.create(this.loc.clone(t),t).formatDateTimeParts(this):[]}toISO({format:t="extended",suppressSeconds:e=!1,suppressMilliseconds:n=!1,includeOffset:i=!0,extendedZone:r=!1}={}){if(!this.isValid)return null;const s="extended"===t;let o=Bft(this,s);return o+="T",o+=Uft(this,s,e,n,i,r),o}toISODate({format:t="extended"}={}){return this.isValid?Bft(this,"extended"===t):null}toISOWeekDate(){return zft(this,"kkkk-'W'WW-c")}toISOTime({suppressMilliseconds:t=!1,suppressSeconds:e=!1,includeOffset:n=!0,includePrefix:i=!1,extendedZone:r=!1,format:s="extended"}={}){if(!this.isValid)return null;return(i?"T":"")+Uft(this,"extended"===s,e,t,n,r)}toRFC2822(){return zft(this,"EEE, dd LLL yyyy HH:mm:ss ZZZ",!1)}toHTTP(){return zft(this.toUTC(),"EEE, dd LLL yyyy HH:mm:ss 'GMT'")}toSQLDate(){return this.isValid?Bft(this,!0):null}toSQLTime({includeOffset:t=!0,includeZone:e=!1,includeOffsetSpace:n=!0}={}){let i="HH:mm:ss.SSS";return(e||t)&&(n&&(i+=" "),e?i+="z":t&&(i+="ZZ")),zft(this,i,!0)}toSQL(t={}){return this.isValid?`${this.toSQLDate()} ${this.toSQLTime(t)}`:null}toString(){return this.isValid?this.toISO():$ft}valueOf(){return this.toMillis()}toMillis(){return this.isValid?this.ts:NaN}toSeconds(){return this.isValid?this.ts/1e3:NaN}toUnixInteger(){return this.isValid?Math.floor(this.ts/1e3):NaN}toJSON(){return this.toISO()}toBSON(){return this.toJSDate()}toObject(t={}){if(!this.isValid)return{};const e={...this.c};return t.includeConfig&&(e.outputCalendar=this.outputCalendar,e.numberingSystem=this.loc.numberingSystem,e.locale=this.loc.locale),e}toJSDate(){return new Date(this.isValid?this.ts:NaN)}diff(t,e="milliseconds",n={}){if(!this.isValid||!t.isValid)return qpt.invalid("created by diffing an invalid DateTime");const i={locale:this.locale,numberingSystem:this.numberingSystem,...n},r=(a=e,Array.isArray(a)?a:[a]).map(qpt.normalizeUnit),s=t.valueOf()>this.valueOf(),o=Jpt(s?this:t,s?t:this,r,i);var a;return s?o.negate():o}diffNow(t="milliseconds",e={}){return this.diff(Jft.now(),t,e)}until(t){return this.isValid?Kpt.fromDateTimes(this,t):this}hasSame(t,e){if(!this.isValid)return!1;const n=t.valueOf(),i=this.setZone(t.zone,{keepLocalTime:!0});return i.startOf(e)<=n&&n<=i.endOf(e)}equals(t){return this.isValid&&t.isValid&&this.valueOf()===t.valueOf()&&this.zone.equals(t.zone)&&this.loc.equals(t.loc)}toRelative(t={}){if(!this.isValid)return null;const e=t.base||Jft.fromObject({},{zone:this.zone}),n=t.padding?this<e?-t.padding:t.padding:0;let i=["years","months","days","hours","minutes","seconds"],r=t.unit;return Array.isArray(t.unit)&&(i=t.unit,r=void 0),Yft(e,this.plus(n),{...t,numeric:"always",units:i,unit:r})}toRelativeCalendar(t={}){return this.isValid?Yft(t.base||Jft.fromObject({},{zone:this.zone}),this,{...t,numeric:"auto",units:["years","months","days"],calendary:!0}):null}static min(...t){if(!t.every(Jft.isDateTime))throw new sht("min requires all arguments be DateTimes");return ddt(t,(t=>t.valueOf()),Math.min)}static max(...t){if(!t.every(Jft.isDateTime))throw new sht("max requires all arguments be DateTimes");return ddt(t,(t=>t.valueOf()),Math.max)}static fromFormatExplain(t,e,n={}){const{locale:i=null,numberingSystem:r=null}=n;return mft(Kht.fromOpts({locale:i,numberingSystem:r,defaultToEN:!0}),t,e)}static fromStringExplain(t,e,n={}){return Jft.fromFormatExplain(t,e,n)}static get DATE_SHORT(){return uht}static get DATE_MED(){return hht}static get DATE_MED_WITH_WEEKDAY(){return dht}static get DATE_FULL(){return pht}static get DATE_HUGE(){return fht}static get TIME_SIMPLE(){return mht}static get TIME_WITH_SECONDS(){return ght}static get TIME_WITH_SHORT_OFFSET(){return yht}static get TIME_WITH_LONG_OFFSET(){return bht}static get TIME_24_SIMPLE(){return vht}static get TIME_24_WITH_SECONDS(){return xht}static get TIME_24_WITH_SHORT_OFFSET(){return wht}static get TIME_24_WITH_LONG_OFFSET(){return Sht}static get DATETIME_SHORT(){return kht}static get DATETIME_SHORT_WITH_SECONDS(){return Cht}static get DATETIME_MED(){return Tht}static get DATETIME_MED_WITH_SECONDS(){return _ht}static get DATETIME_MED_WITH_WEEKDAY(){return Eht}static get DATETIME_FULL(){return Mht}static get DATETIME_FULL_WITH_SECONDS(){return $ht}static get DATETIME_HUGE(){return Iht}static get DATETIME_HUGE_WITH_SECONDS(){return Aht}}function Qft(t){if(Jft.isDateTime(t))return t;if(t&&t.valueOf&&cdt(t.valueOf()))return Jft.fromJSDate(t);if(t&&"object"==typeof t)return Jft.fromObject(t);throw new sht(`Unknown datetime argument: ${t}, of type ${typeof t}`)}
/*!
 * chartjs-adapter-luxon v1.3.1
 * https://www.chartjs.org
 * (c) 2023 chartjs-adapter-luxon Contributors
 * Released under the MIT license
 */const tmt={datetime:Jft.DATETIME_MED_WITH_SECONDS,millisecond:"h:mm:ss.SSS a",second:Jft.TIME_WITH_SECONDS,minute:Jft.TIME_SIMPLE,hour:{hour:"numeric"},day:{day:"numeric",month:"short"},week:"DD",month:{month:"short",year:"numeric"},quarter:"'Q'q - yyyy",year:{year:"numeric"}};function emt(t){let e,n;return{c(){e=MB("div"),n=MB("canvas"),OB(e,"class","w-full h-96")},m(i,r){TB(i,e,r),SB(e,n),t[6](n)},p:Jz,d(n){n&&_B(e),t[6](null)}}}function nmt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[emt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),32770&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function imt(t,e,n){let{title:i}=e,{preset:r}=e,{options:s}=e,{datasets:o}=e;hct.register(yct,Iat,Aat,Sut,Nat,Jct,nut,_ct,Rat,_ut,Nut,Oat,Mct,Pat,Lat,Vut,Oct,Dat,Yut,Jut,rut,vut);const a=["rgb(54, 162, 235)","rgb(255, 99, 132)","rgb(255, 206, 86)","rgb(75, 192, 192)","rgb(153, 102, 255)","rgb(255, 159, 64)"],l={data:{},options:{maintainAspectRatio:!1,animation:{duration:200},borderWidth:4}};function c(t){return{borderColor:a[t%6],backgroundColor:a[t%6],fill:!1,lineTension:.2}}function u(t,e,n){const i={labels:[]};let r=0;return i.datasets=t.map((({dataStream:s,label:o,options:l},u)=>{r=Math.max(r,s.get()?s.get().length:0),0===u&&(i.labels=l.labels||[],!l.labels&&s.get()&&s.get().length>0&&("number"==typeof s.get()[0]?i.labels=Array.from(Array(s.get().length),((t,e)=>e.toString())):i.labels=s.get().map((t=>t.x.toString()))));let h={...c(u),...e,...l,label:o,data:s.get()||[]};return(["bar","bar-fast"].includes(l.type)||["bar","bar-fast"].includes(n.type)&&!l.type)&&1===t.length&&(h.borderColor=a,h.backgroundColor=a),h})),i}let h,d,p=[];function f(){let t=yK(l,r.global);t=yK(t,{data:u(o,r.datasets,t),options:s}),s.xlabel&&(t=yK(t,{options:{scales:{x:{title:{display:!0,text:s.xlabel}}}}})),s.ylabel&&(t=yK(t,{options:{scales:{y:{title:{display:!0,text:s.ylabel}}}}}));const e=o.map((({dataStream:t})=>{var e;return(null===(e=t.get())||void 0===e?void 0:e.length)||0}));p=o.map((({dataStream:n,options:i},r)=>n.subscribe((n=>{if(n&&h){const s=e.reduce(((t,e)=>Math.max(t,e)));e[r]=n.length,!i.labels&&n.length>0&&e[r]>s&&("number"==typeof n[0]?t.data.labels=Array.from(Array(n.length),((t,e)=>e.toString())):t.data.labels=n.map((t=>t.x.toString()))),t.data.datasets[r].data=n;try{h.update()}catch(t){console.log(t)}}}))));const n=d.getContext("2d");h=new hct(n,t)}function m(){for(const t of p)t();null==h||h.destroy()}tU((async()=>{await pU(),await pU(),f()}));let g=o.length;return nU(m),t.$$set=t=>{"title"in t&&n(0,i=t.title),"preset"in t&&n(2,r=t.preset),"options"in t&&n(3,s=t.options),"datasets"in t&&n(4,o=t.datasets)},t.$$.update=()=>{48&t.$$.dirty&&o.length!==g&&(m(),f(),n(5,g=o.length))},[i,d,r,s,o,g,function(t){aU[t?"unshift":"push"]((()=>{d=t,n(1,d)}))}]}Bat._date.override({_id:"luxon",_create:function(t){return Jft.fromMillis(t,this.options)},init(t){this.options.locale||(this.options.locale=t.locale)},formats:function(){return tmt},parse:function(t,e){const n=this.options,i=typeof t;return null===t||"undefined"===i?null:("number"===i?t=this._create(t):"string"===i?t="string"==typeof e?Jft.fromFormat(t,e,n):Jft.fromISO(t,n):t instanceof Date?t=Jft.fromJSDate(t,n):"object"!==i||t instanceof Jft||(t=Jft.fromObject(t,n)),t.isValid?t.valueOf():null)},format:function(t,e){const n=this._create(t);return"string"==typeof e?n.toFormat(e):n.toLocaleString(e)},add:function(t,e,n){const i={};return i[n]=e,this._create(t).plus(i).valueOf()},diff:function(t,e,n){return this._create(t).diff(this._create(e)).as(n).valueOf()},startOf:function(t,e,n){if("isoWeek"===e){n=Math.trunc(Math.min(Math.max(0,n),6));const e=this._create(t);return e.minus({days:(e.weekday-n+7)%7}).startOf("day").valueOf()}return e?this._create(t).startOf(e).valueOf():t},endOf:function(t,e){return this._create(t).endOf(e).valueOf()}});class rmt extends UU{constructor(t){super(),BU(this,t,imt,nmt,rB,{title:0,preset:2,options:3,datasets:4})}}var smt,omt,amt;const lmt={line:{global:{type:"line",options:{animation:{duration:200},scales:{x:{ticks:{sampleSize:11}}}}},datasets:{fill:!1,lineTension:.2}},"line-fast":{global:{type:"line",options:{elements:{point:{radius:0}},animation:!1,tooltips:!1,spanGaps:!0,scales:{x:{ticks:{sampleSize:11}}}}},datasets:{fill:!1,lineTension:0}},bar:{global:{type:"bar",options:{animation:{duration:200},scales:{y:{beginAtZero:!0}}}}},"bar-fast":{global:{type:"bar",options:{animation:!1,scales:{y:{beginAtZero:!0}}}}},scatter:{global:{type:"scatter",options:{scales:{x:{type:"linear",position:"bottom"}}}}}};class cmt extends xK{constructor({preset:t="line",options:e={}}={}){super(),this.title="generic chart",smt.set(this,void 0),omt.set(this,void 0),amt.set(this,[]),Object.keys(lmt).includes(t)||cK(new Error(`Preset ${t} is not recognized`)),WX(this,smt,t,"f"),WX(this,omt,lmt[t],"f"),this.options=e,this.start()}addSeries(t,e,n={}){if(tK(t)){if("line-fast"===VX(this,smt,"f")){const i=t.debounce(10);i.value=t.get(),VX(this,amt,"f").push({dataStream:i,label:e,options:n})}else VX(this,amt,"f").push({dataStream:t,label:e,options:n});this.updateView()}else t.toArray().then((t=>{const i=new eK(t,!0);VX(this,amt,"f").push({dataStream:i,label:e,options:n}),this.updateView()}))}setColors(t){VX(this,amt,"f")[0].label="clusters",VX(this,amt,"f")[0].options.backgroundColor=t.get(),VX(this,amt,"f")[0].options.color=t.get()}removeSeries(t){const e=VX(this,amt,"f").map((t=>t.dataStream)).indexOf(t);e>-1&&VX(this,amt,"f").splice(e,1)}clear(){WX(this,amt,[],"f"),this.updateView()}updateView(){this.$$.app&&this.$$.app.$set({datasets:VX(this,amt,"f")})}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new rmt({target:e,props:{title:this.title,preset:VX(this,omt,"f"),options:this.options,datasets:VX(this,amt,"f")}}))}}function umt(...t){return new cmt(...t)}function hmt(t){let e,n;return{c(){e=new jB(!1),n=NB(),e.a=n},m(i,r){e.m(t[2],i,r),TB(i,n,r)},p(t,n){4&n&&e.p(t[2])},d(t){t&&_B(n),t&&e.d()}}}function dmt(t){let e,n=t[2]&&hmt(t);return{c(){e=MB("div"),n&&n.c(),OB(e,"class","grow")},m(t,i){TB(t,e,i),n&&n.m(e,null)},p(t,i){t[2]?n?n.p(t,i):(n=hmt(t),n.c(),n.m(e,null)):n&&(n.d(1),n=null)},d(t){t&&_B(e),n&&n.d()}}}function pmt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[dmt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),12&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function fmt(t,e,n){let i,r=Jz,s=()=>(r(),r=aB(a,(t=>n(2,i=t))),a);t.$$.on_destroy.push((()=>r()));let{title:o}=e,{text:a}=e;return s(),t.$$set=t=>{"title"in t&&n(0,o=t.title),"text"in t&&s(n(1,a=t.text))},[o,a,i]}smt=new WeakMap,omt=new WeakMap,amt=new WeakMap;class mmt extends UU{constructor(t){super(),BU(this,t,fmt,pmt,rB,{title:0,text:1})}get title(){return this.$$.ctx[0]}set title(t){this.$$set({title:t}),vU()}get text(){return this.$$.ctx[1]}set text(t){this.$$set({text:t}),vU()}}class gmt extends xK{constructor(t="click me"){super(),this.title="text",this.$value=new eK(t,!0),this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new mmt({target:e,props:{title:this.title,text:this.$value}}))}}function ymt(...t){return new gmt(...t)}var bmt,vmt;class xmt extends xK{constructor(t){super(),this.title="confidence plot",bmt.set(this,void 0),vmt.set(this,void 0),this.$confidenceStream=t.map((({confidences:t})=>Object.entries(t).map((([t,e])=>({x:t,y:e}))).sort(((t,e)=>t.x<e.x?-1:t.x>e.x?1:0)))),WX(this,bmt,umt({preset:"bar-fast",options:{xlabel:"Label",ylabel:"Confidence",scales:{y:{suggestedMax:1}}}}),"f"),VX(this,bmt,"f").addSeries(this.$confidenceStream,"Confidences"),VX(this,bmt,"f").title="",WX(this,vmt,ymt("Waiting for predictions..."),"f"),VX(this,vmt,"f").title=this.title,VX(this,vmt,"f").$value=new eK(t.map((({label:t})=>`<p>Predicted Label: <code style="font-size: 1.5rem;">${t}</code></p>`)).startWith("Waiting for predictions..."),!0),this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);if(!e)return;const n=document.createElement("div");n.id=`${e.id}-${VX(this,vmt,"f").id}`;const i=document.createElement("div");i.id=`${e.id}-${VX(this,bmt,"f").id}`,e.appendChild(n),e.appendChild(i),VX(this,vmt,"f").title=this.title,VX(this,vmt,"f").mount(n),VX(this,bmt,"f").mount(i),this.destroy=()=>{n.parentElement.removeChild(n),i.parentElement.removeChild(i),VX(this,vmt,"f").destroy(),VX(this,bmt,"f").destroy()}}destroy(){VX(this,vmt,"f").destroy(),VX(this,bmt,"f").destroy()}}function wmt(...t){return new xmt(...t)}bmt=new WeakMap,vmt=new WeakMap;var Smt=Object.prototype.hasOwnProperty;function kmt(t,e,n){for(n of t.keys())if(Cmt(n,e))return n}function Cmt(t,e){var n,i,r;if(t===e)return!0;if(t&&e&&(n=t.constructor)===e.constructor){if(n===Date)return t.getTime()===e.getTime();if(n===RegExp)return t.toString()===e.toString();if(n===Array){if((i=t.length)===e.length)for(;i--&&Cmt(t[i],e[i]););return-1===i}if(n===Set){if(t.size!==e.size)return!1;for(i of t){if((r=i)&&"object"==typeof r&&!(r=kmt(e,r)))return!1;if(!e.has(r))return!1}return!0}if(n===Map){if(t.size!==e.size)return!1;for(i of t){if((r=i[0])&&"object"==typeof r&&!(r=kmt(e,r)))return!1;if(!Cmt(i[1],e.get(r)))return!1}return!0}if(n===ArrayBuffer)t=new Uint8Array(t),e=new Uint8Array(e);else if(n===DataView){if((i=t.byteLength)===e.byteLength)for(;i--&&t.getInt8(i)===e.getInt8(i););return-1===i}if(ArrayBuffer.isView(t)){if((i=t.byteLength)===e.byteLength)for(;i--&&t[i]===e[i];);return-1===i}if(!n||"object"==typeof t){for(n in i=0,t){if(Smt.call(t,n)&&++i&&!Smt.call(e,n))return!1;if(!(n in e)||!Cmt(t[n],e[n]))return!1}return Object.keys(e).length===i}}return t!=t&&e!=e}
/*!
 * chartjs-chart-matrix v2.0.1
 * https://chartjs-chart-matrix.pages.dev/
 * (c) 2023 Jukka Kurkela
 * Released under the MIT license
 */var Tmt;class _mt extends wat{static id="matrix";static version="2.0.1";static defaults={dataElementType:"matrix",animations:{numbers:{type:"number",properties:["x","y","width","height"]}}};static overrides={interaction:{mode:"nearest",intersect:!0},scales:{x:{type:"linear",offset:!0},y:{type:"linear",reverse:!0}}};initialize(){this.enableOptionSharing=!0,super.initialize()}update(t){const e=this._cachedMeta;this.updateElements(e.data,0,e.data.length,t)}updateElements(t,e,n,i){const r=this,s="reset"===i,{xScale:o,yScale:a}=r._cachedMeta,l=r.resolveDataElementOptions(e,i),c=r.getSharedOptions(i,t[e],l);for(let l=e;l<e+n;l++){const e=!s&&r.getParsed(l),n=s?o.getBasePixel():o.getPixelForValue(e.x),c=s?a.getBasePixel():a.getPixelForValue(e.y),u=r.resolveDataElementOptions(l,i),{width:h,height:d,anchorX:p,anchorY:f}=u,m={x:Emt(p,n,h),y:Mmt(f,c,d),width:h,height:d,options:u};r.updateElement(t[l],l,m,i)}r.updateSharedOptions(c,i)}draw(){const t=this,e=t.getMeta().data||[];let n,i;for(n=0,i=e.length;n<i;++n)e[n].draw(t._ctx)}}function Emt(t,e,n){return"left"===t||"start"===t?e:"right"===t||"end"===t?e-n:e-n/2}function Mmt(t,e,n){return"top"===t||"start"===t?e:"bottom"===t||"end"===t?e-n:e-n/2}function $mt(t,e){const{x:n,y:i,width:r,height:s}=t.getProps(["x","y","width","height"],e);return{left:n,top:i,right:n+r,bottom:i+s}}function Imt(t,e,n){return Math.max(Math.min(t,n),e)}function Amt(t){const e=$mt(t),n=e.right-e.left,i=e.bottom-e.top,r=function(t,e,n){const i=t.options.borderWidth;let r,s,o,a;return brt(i)?(r=+i.top||0,s=+i.right||0,o=+i.bottom||0,a=+i.left||0):r=s=o=a=+i||0,{t:Imt(r,0,n),r:Imt(s,0,e),b:Imt(o,0,n),l:Imt(a,0,e)}}(t,n/2,i/2);return{outer:{x:e.left,y:e.top,w:n,h:i},inner:{x:e.left+r.l,y:e.top+r.t,w:n-r.l-r.r,h:i-r.t-r.b}}}function Nmt(t,e,n,i){const r=null===e,s=null===n,o=!(!t||r&&s)&&$mt(t,i);return o&&(r||e>=o.left&&e<=o.right)&&(s||n>=o.top&&n<=o.bottom)}class Rmt extends Clt{static id="matrix";static defaults={backgroundColor:void 0,borderColor:void 0,borderWidth:void 0,borderRadius:0,anchorX:"center",anchorY:"center",width:20,height:20};constructor(t){super(),this.options=void 0,this.width=void 0,this.height=void 0,t&&Object.assign(this,t)}draw(t){const e=this.options,{inner:n,outer:i}=Amt(this),r=oot(e.borderRadius);t.save(),i.w!==n.w||i.h!==n.h?(t.beginPath(),Qst(t,{x:i.x,y:i.y,w:i.w,h:i.h,radius:r}),Qst(t,{x:n.x,y:n.y,w:n.w,h:n.h,radius:r}),t.fillStyle=e.backgroundColor,t.fill(),t.fillStyle=e.borderColor,t.fill("evenodd")):(t.beginPath(),Qst(t,{x:n.x,y:n.y,w:n.w,h:n.h,radius:r}),t.fillStyle=e.backgroundColor,t.fill()),t.restore()}inRange(t,e,n){return Nmt(this,t,e,n)}inXRange(t,e){return Nmt(this,t,null,e)}inYRange(t,e){return Nmt(this,null,t,e)}getCenterPoint(t){const{x:e,y:n,width:i,height:r}=this.getProps(["x","y","width","height"],t);return{x:e+i/2,y:n+r/2}}tooltipPosition(){return this.getCenterPoint()}getRange(t){return"x"===t?this.width/2:this.height/2}}function Pmt(t){let e;return{c(){e=MB("p"),e.textContent="Waiting for predictions...",OB(e,"class","m-2")},m(t,n){TB(t,e,n)},p:Jz,d(t){t&&_B(e)}}}function Omt(t){let e,n,i,r,s,o,a,l,c=t[6].toFixed(2)+"";return{c(){e=MB("p"),n=IB("Global Accuracy: "),i=IB(c),r=AB(),s=MB("div"),o=MB("canvas"),OB(e,"class","m-2"),OB(s,"class","confusion-container svelte-1d2i0ke")},m(c,u){var h;TB(c,e,u),SB(e,n),SB(e,i),TB(c,r,u),TB(c,s,u),SB(s,o),a||(h=t[7].call(null,o),l=h&&iB(h.destroy)?h.destroy:Jz,a=!0)},p(t,e){64&e&&c!==(c=t[6].toFixed(2)+"")&&DB(i,c)},d(t){t&&_B(e),t&&_B(r),t&&_B(s),a=!1,l()}}}function Lmt(t){let e;function n(t,e){return void 0!==t[6]?Omt:Pmt}let i=n(t),r=i(t);return{c(){r.c(),e=NB()},m(t,n){r.m(t,n),TB(t,e,n)},p(t,s){i===(i=n(t))&&r?r.p(t,s):(r.d(1),r=i(t),r&&(r.c(),r.m(e.parentNode,e)))},d(t){r.d(t),t&&_B(e)}}}function Dmt(t){let e,n;return e=new DH({props:{title:t[0],loading:t[4],progress:t[5],$$slots:{default:[Lmt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),16&n&&(i.loading=t[4]),32&n&&(i.progress=t[5]),131136&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function Fmt(t,e,n){let i,r,s,o=Jz,a=()=>(o(),o=aB(p,(t=>n(4,i=t))),p),l=Jz,c=()=>(l(),l=aB(f,(t=>n(5,r=t))),f),u=Jz,h=()=>(u(),u=aB(m,(t=>n(6,s=t))),m);t.$$.on_destroy.push((()=>o())),t.$$.on_destroy.push((()=>l())),t.$$.on_destroy.push((()=>u()));let{title:d}=e,{loading:p}=e;a();let{progress:f}=e;c();let{accuracy:m}=e;h();let{confusion:g}=e,{labels:y}=e,{selected:b}=e;hct.register(Sut,rut,vut,Rmt,_mt);let v=1,x=1,w=-1;const S={type:"matrix",data:{datasets:[{label:"Confusion Matrix",data:[],backgroundColor(t){if(t.dataset.data.length>0){if(t.dataIndex===w){const{x:e,y:n}=t.dataset.data[t.dataIndex];return e===n?"green":"red"}return`rgba(54, 162, 235, ${t.dataset.data[t.dataIndex].v/v})`}return"rgba(54, 162, 235, 0)"},width(t){const e=t.chart.chartArea;return e?(e.right-e.left)/x-2:0},height(t){const e=t.chart.chartArea;return e?(e.bottom-e.top)/x-2:0}}]},options:{aspectRatio:1,legend:{display:!1},plugins:{tooltip:{callbacks:{title:([t])=>["count: "+t.dataset.data[t.dataIndex].v],label(t){const e=t.dataset.data[t.dataIndex];return["true label: "+e.y,"predicted label: "+e.x]}}}},scales:{x:{type:"category",labels:[],ticks:{display:!0,autoSkip:!1},gridLines:{display:!1},title:{display:!0,text:"Predicted Label"}},y:{type:"category",labels:[],offset:!0,reverse:!0,ticks:{display:!0,autoSkip:!1},gridLines:{display:!1},title:{display:!0,text:"True Label"}}},onClick(t){try{const e=t.chart.tooltip.dataPoints[0].dataIndex;w===e?(b.set(null),w=-1):(b.set(t.chart.tooltip.dataPoints[0].raw),w=e,t.chart.update())}catch(t){console.log("[confusion matrix] selection error:",t)}}}};let k,C=[];return nU((()=>{for(const t of C)t()})),t.$$set=t=>{"title"in t&&n(0,d=t.title),"loading"in t&&a(n(1,p=t.loading)),"progress"in t&&c(n(2,f=t.progress)),"accuracy"in t&&h(n(3,m=t.accuracy)),"confusion"in t&&n(8,g=t.confusion),"labels"in t&&n(9,y=t.labels),"selected"in t&&n(10,b=t.selected)},[d,p,f,m,i,r,s,function(t){const e=t.getContext("2d");k=new hct(e,S),C.push(y.subscribe((t=>{x=t.length,S.options.scales.x.labels=t.sort(),S.options.scales.y.labels=t.sort(),k.update()}))),C.push(g.subscribe((t=>{v=t.reduce(((t,{v:e})=>Math.max(t,e)),0),S.data.datasets[0].data=t,k.update()})))},g,y,b]}class zmt extends UU{constructor(t){super(),BU(this,t,Fmt,Dmt,rB,{title:0,loading:1,progress:2,accuracy:3,confusion:8,labels:9,selected:10})}}class Bmt extends xK{constructor(t){super(),this.title="confusion matrix",Tmt.set(this,void 0),this.$confusion=new eK([],!0),this.$accuracy=new eK(void 0,!0),this.$labels=new eK([],!0),this.$selected=new eK(null,!0),this.$progress=new eK(!1,!0),WX(this,Tmt,t,"f"),this.start(),this.setup()}setup(){let t=[];VX(this,Tmt,"f").$status.subscribe((async({status:e,count:n,total:i,data:r})=>{"start"===e?(t=[],this.$progress.set(null)):"running"===e?(t.push(r),this.$progress.set(n/i)):"loaded"===e?(t=await VX(this,Tmt,"f").predictionService.items().query({$select:["id","label","yTrue"]}).toArray(),this.$progress.set(!1)):"loading"===e?(t=[],this.$progress.set(null)):this.$progress.set(!1),this.updateConfusionMatrix(t),this.updateAccuracy(t)}))}updateConfusionMatrix(t){const e=t.map((t=>t.label)),n=t.map((t=>t.yTrue)),i=Array.from(new Set(e.concat(n)));Cmt(i,this.$labels.value)||this.$labels.set(i);const r=i.length,s=i.reduce(((t,e,n)=>({...t,[e]:n})),{}),o=Array.from(Array(r**2),(()=>0));for(let t=0;t<e.length;t+=1)o[s[e[t]]*r+s[n[t]]]+=1;const a=o.map(((t,e)=>({x:i[Math.floor(e/r)],y:i[e%r],v:t})));this.$confusion.set(a)}updateAccuracy(t){0===t.length?this.$accuracy.set(void 0):this.$accuracy.set(t.reduce(((t,{label:e,yTrue:n})=>t+(e===n?1:0)),0)/t.length)}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new zmt({target:e,props:{title:this.title,loading:VX(this,Tmt,"f").$status.map((({status:t})=>"loading"===t)),progress:this.$progress,confusion:this.$confusion,accuracy:this.$accuracy,labels:this.$labels,selected:this.$selected}}))}}function Umt(...t){return new Bmt(...t)}Tmt=new WeakMap;const{window:Vmt}=wB;function Wmt(t,e,n){const i=t.slice();return i[27]=e[n][0],i[28]=e[n][1].loaded,i[29]=e[n][1].total,i[30]=e[n][1].instances,i}function Hmt(t,e,n){const i=t.slice();return i[33]=e[n].id,i[34]=e[n].thumbnail,i}function jmt(t){let e,n,i,r,s;function o(t,e){return t[6]>0?qmt:Gmt}let a=o(t),l=a(t),c=Object.entries(t[5]),u=[];for(let e=0;e<c.length;e+=1)u[e]=Zmt(Wmt(t,c,e));const h=t=>MU(u[t],1,1,(()=>{u[t]=null}));return{c(){l.c(),e=AB(),n=MB("div");for(let t=0;t<u.length;t+=1)u[t].c();OB(n,"class","flex flex-wrap")},m(o,a){l.m(o,a),TB(o,e,a),TB(o,n,a);for(let t=0;t<u.length;t+=1)u[t]&&u[t].m(n,null);i=!0,r||(s=[RB(n,"click",t[18]),RB(n,"keypress",PB(t[19]))],r=!0)},p(t,i){if(a===(a=o(t))&&l?l.p(t,i):(l.d(1),l=a(t),l&&(l.c(),l.m(e.parentNode,e))),6560&i[0]){let e;for(c=Object.entries(t[5]),e=0;e<c.length;e+=1){const r=Wmt(t,c,e);u[e]?(u[e].p(r,i),EU(u[e],1)):(u[e]=Zmt(r),u[e].c(),EU(u[e],1),u[e].m(n,null))}for(TU(),e=c.length;e<u.length;e+=1)h(e);_U()}},i(t){if(!i){for(let t=0;t<c.length;t+=1)EU(u[t]);i=!0}},o(t){u=u.filter(Boolean);for(let t=0;t<u.length;t+=1)MU(u[t]);i=!1},d(t){l.d(t),t&&_B(e),t&&_B(n),EB(u,t),r=!1,nB(s)}}}function Gmt(t){let e;return{c(){e=MB("p"),e.textContent="This dataset is empty.",OB(e,"class","ml-3 mt-2")},m(t,n){TB(t,e,n)},p:Jz,d(t){t&&_B(e)}}}function qmt(t){let e,n,i,r,s,o,a=t[6]>1?"s":"";return{c(){e=MB("p"),n=IB("This dataset contains "),i=IB(t[6]),r=IB(" instance"),s=IB(a),o=IB("."),OB(e,"class","ml-3 mt-2")},m(t,a){TB(t,e,a),SB(e,n),SB(e,i),SB(e,r),SB(e,s),SB(e,o)},p(t,e){64&e[0]&&DB(i,t[6]),64&e[0]&&a!==(a=t[6]>1?"s":"")&&DB(s,a)},d(t){t&&_B(e)}}}function Xmt(t,e){let n,i,r,s,o,a,l;function c(){return e[16](e[33])}return{key:t,first:null,c(){n=MB("img"),oB(n.src,i=e[34])||OB(n,"src",i),OB(n,"alt","thumbnail"),OB(n,"class","m-1 svelte-14ms951"),WB(n,"selected",e[7].includes(e[33])),this.first=n},m(t,e){TB(t,n,e),o=!0,a||(l=RB(n,"click",function(t){return function(e){return e.stopPropagation(),t.call(this,e)}}(c)),a=!0)},p(t,r){e=t,(!o||32&r[0]&&!oB(n.src,i=e[34]))&&OB(n,"src",i),(!o||160&r[0])&&WB(n,"selected",e[7].includes(e[33]))},i(t){o||(fU((()=>{o&&(s&&s.end(1),r=function(t,e,n){const i={direction:"in"};let r,s,o=e(t,n,i),a=!1,l=0;function c(){r&&YB(t,r)}function u(){const{delay:e=0,duration:n=300,easing:i=Qz,tick:u=Jz,css:h}=o||$U;h&&(r=KB(t,0,1,n,e,i,h,l++)),u(0,1);const d=gB()+e,p=d+n;s&&s.abort(),a=!0,fU((()=>SU(t,!0,"start"))),s=xB((e=>{if(a){if(e>=p)return u(1,0),SU(t,!0,"end"),c(),a=!1;if(e>=d){const t=i((e-d)/n);u(t,1-t)}}return a}))}let h=!1;return{start(){h||(h=!0,YB(t),iB(o)?(o=o(i),wU().then(u)):u())},invalidate(){h=!1},end(){a&&(c(),a=!1)}}}(n,eV,{}),r.start())})),o=!0)},o(t){r&&r.invalidate(),s=function(t,e,n){const i={direction:"out"};let r,s=e(t,n,i),o=!0;const a=CU;function l(){const{delay:e=0,duration:n=300,easing:i=Qz,tick:l=Jz,css:c}=s||$U;c&&(r=KB(t,1,0,n,e,i,c));const u=gB()+e,h=u+n;fU((()=>SU(t,!1,"start"))),xB((e=>{if(o){if(e>=h)return l(0,1),SU(t,!1,"end"),--a.r||nB(a.c),!1;if(e>=u){const t=i((e-u)/n);l(1-t,t)}}return o}))}return a.r+=1,iB(s)?wU().then((()=>{s=s(i),l()})):l(),{end(e){e&&s.tick&&s.tick(1,0),o&&(r&&YB(t,r),o=!1)}}}(n,eV,{}),o=!1},d(t){t&&_B(n),t&&s&&s.end(),a=!1,l()}}}function Kmt(t){let e,n;return e=new HU({props:{size:"small",variant:"light",$$slots:{default:[Ymt]},$$scope:{ctx:t}}}),e.$on("click",(function(){return t[17](t[27])})),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(n,i){t=n;const r={};64&i[1]&&(r.$$scope={dirty:i,ctx:t}),e.$set(r)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function Ymt(t){let e;return{c(){e=IB("View More")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function Zmt(t){let e,n,i,r,s,o,a,l,c,u,h,d,p,f=t[27]+"",m=[],g=new Map;a=new TV({props:{actions:[{code:"edit",text:"Edit class label"},{code:"delete",text:"Delete class"}].concat(t[7].length>0?[{code:"deleteInstances",text:"Delete selected instance"+(t[7].length>1?"s":"")},{code:"relabelInstances",text:"Relabel selected instance"+(t[7].length>1?"s":"")}]:[])}}),a.$on("select",(function(...e){return t[15](t[27],...e)}));let y=t[30];const b=t=>t[33];for(let e=0;e<y.length;e+=1){let n=Hmt(t,y,e),i=b(n);g.set(i,m[e]=Xmt(i,n))}let v=t[28]<t[29]&&Kmt(t);return{c(){e=MB("div"),n=MB("div"),i=MB("div"),r=MB("span"),s=IB(f),o=AB(),DU(a.$$.fragment),l=AB(),c=MB("div");for(let t=0;t<m.length;t+=1)m[t].c();u=AB(),h=MB("div"),v&&v.c(),d=AB(),OB(r,"class","browser-class-title svelte-14ms951"),OB(i,"class","browser-class-header svelte-14ms951"),OB(c,"class","browser-class-body svelte-14ms951"),OB(n,"class","w-full"),OB(h,"class","pb-1"),OB(e,"class","browser-class svelte-14ms951")},m(t,f){TB(t,e,f),SB(e,n),SB(n,i),SB(i,r),SB(r,s),SB(i,o),FU(a,i,null),SB(n,l),SB(n,c);for(let t=0;t<m.length;t+=1)m[t]&&m[t].m(c,null);SB(e,u),SB(e,h),v&&v.m(h,null),SB(e,d),p=!0},p(e,n){t=e,(!p||32&n[0])&&f!==(f=t[27]+"")&&DB(s,f);const i={};128&n[0]&&(i.actions=[{code:"edit",text:"Edit class label"},{code:"delete",text:"Delete class"}].concat(t[7].length>0?[{code:"deleteInstances",text:"Delete selected instance"+(t[7].length>1?"s":"")},{code:"relabelInstances",text:"Relabel selected instance"+(t[7].length>1?"s":"")}]:[])),a.$set(i),2208&n[0]&&(y=t[30],TU(),m=OU(m,n,b,1,t,y,g,c,RU,Xmt,null,Hmt),_U()),t[28]<t[29]?v?(v.p(t,n),32&n[0]&&EU(v,1)):(v=Kmt(t),v.c(),EU(v,1),v.m(h,null)):v&&(TU(),MU(v,1,1,(()=>{v=null})),_U())},i(t){if(!p){EU(a.$$.fragment,t);for(let t=0;t<y.length;t+=1)EU(m[t]);EU(v),p=!0}},o(t){MU(a.$$.fragment,t);for(let t=0;t<m.length;t+=1)MU(m[t]);MU(v),p=!1},d(t){t&&_B(e),zU(a);for(let t=0;t<m.length;t+=1)m[t].d();v&&v.d()}}}function Jmt(t){let e;return{c(){e=MB("div"),e.innerHTML='<svg class="inline flex-shrink-0 mr-3 w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg> \n      <div><span class="font-medium">Data Store connection Error!</span> This data store probably requires\n        authentication</div>',OB(e,"class","flex p-4 mb-4 text-sm text-red-700 bg-red-100 rounded-lg dark:bg-red-200 dark:text-red-800"),OB(e,"role","alert")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function Qmt(t){let e,n,i,r=t[5]&&!t[4]&&jmt(t),s=t[4]&&Jmt();return{c(){r&&r.c(),e=AB(),s&&s.c(),n=NB()},m(t,o){r&&r.m(t,o),TB(t,e,o),s&&s.m(t,o),TB(t,n,o),i=!0},p(t,i){t[5]&&!t[4]?r?(r.p(t,i),48&i[0]&&EU(r,1)):(r=jmt(t),r.c(),EU(r,1),r.m(e.parentNode,e)):r&&(TU(),MU(r,1,1,(()=>{r=null})),_U()),t[4]?s||(s=Jmt(),s.c(),s.m(n.parentNode,n)):s&&(s.d(1),s=null)},i(t){i||(EU(r),i=!0)},o(t){MU(r),i=!1},d(t){r&&r.d(t),t&&_B(e),s&&s.d(t),t&&_B(n)}}}function tgt(t){let e,n,i,r;return e=new DH({props:{title:t[0],loading:t[3],$$slots:{default:[Qmt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(s,o){FU(e,s,o),n=!0,i||(r=[RB(Vmt,"keydown",t[9]),RB(Vmt,"keyup",t[10])],i=!0)},p(t,n){const i={};1&n[0]&&(i.title=t[0]),8&n[0]&&(i.loading=t[3]),240&n[0]|64&n[1]&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t),i=!1,nB(r)}}}function egt(t,e,n){let i,r,s=Jz,o=()=>(s(),s=aB(h,(t=>n(6,i=t))),h),a=Jz,l=()=>(a(),a=aB(p,(t=>n(7,r=t))),p);t.$$.on_destroy.push((()=>s())),t.$$.on_destroy.push((()=>a()));let{title:c}=e,{batchSize:u}=e,{count:h}=e;o();let{dataset:d}=e,{selected:p}=e;l();let f=!1,m=!1,g={};async function y(t){await d.ready;for await(const e of d.items().query({y:t,$sort:{updatedAt:-1}}).skip(g[t].loaded).take(u).select(["id","y","thumbnail"]))n(5,g[t].instances=[...g[t].instances,e],g),n(5,g[t].loaded+=1,g)}async function b(){if(f)return;n(3,f=!0);try{n(4,m=!1),await d.ready}catch(t){return n(3,f=!1),void n(4,m=!0)}const t=await d.distinct("y");n(5,g=t.reduce(((t,e)=>({...t,[e]:{total:0,loaded:0,instances:[]}})),{}));for(const e of t){const{total:t}=await d.find({query:{$limit:0,y:e}});if(n(5,g[e].total=t,g),u>0)await y(e);else for(;g[e].loaded<g[e].total;)await y(e)}n(3,f=!1)}function v(t){for(const[e,{instances:n}]of Object.entries(g))if(n.map((t=>t.id)).includes(t))return e;return null}async function x(){let t=Promise.resolve();for(const e of p.get())t=t.then((()=>d.remove(e)));await t,p.set([])}let w=!1,S=!1;let k=null;function C(t){if(w){if(!t)return;p.get().includes(t)?p.set(p.get().filter((e=>e!==t))):p.set(p.get().concat([t]))}else if(S){if(!k||!t)return;const e=v(k);if(e!==v(t))return;const n=g[e].instances.map((t=>t.id)),i=n.indexOf(k),r=n.indexOf(t);p.set(i<r?n.slice(i,r+1):n.slice(r,i+1))}else p.set(t?[t]:[]),k=t}function T(t,e){let n;switch(e){case"edit":n=window.prompt("Enter the new label",t),n&&d.patch(null,{y:n},{query:{y:t}});break;case"delete":d.remove(null,{query:{y:t}});break;case"deleteInstances":x();break;case"relabelInstances":n=window.prompt("Enter the new label",t),n&&async function(t){let e=Promise.resolve();for(const n of p.get())e=e.then((()=>d.patch(n,{y:t})));await e,p.set([])}(n);break;default:alert(`Class ${t}: ${e}`)}}tU((()=>{b(),d.$changes.subscribe((async t=>{for(const{level:e,type:i,data:r}of t)if("dataset"===e)"created"===i&&(C(),b());else if("instance"===e)if("created"===i)g[r.y]||n(5,g[r.y]={total:0,loaded:0,instances:[]},g),n(5,g[r.y].total+=1,g),n(5,g[r.y].loaded+=1,g),n(5,g[r.y].instances=[{id:r.id,y:r.y,thumbnail:r.thumbnail},...g[r.y].instances],g);else if("updated"===i){const t=v(r.id);n(5,g[t].total-=1,g),n(5,g[t].loaded-=1,g),n(5,g[t].instances=g[t].instances.filter((({id:t})=>t!==r.id)),g),0===g[t].total&&(delete g[t],n(5,g)),g[r.y]||n(5,g[r.y]={total:0,loaded:0,instances:[]},g),n(5,g[r.y].instances=[{id:r.id,y:r.y,thumbnail:r.thumbnail},...g[r.y].instances],g)}else"removed"===i&&(n(5,g[r.y].total-=1,g),n(5,g[r.y].loaded-=1,g),n(5,g[r.y].instances=g[r.y].instances.filter((({id:t})=>t!==r.id)),g),0===g[r.y].total&&(delete g[r.y],n(5,g)))}))}));return t.$$set=t=>{"title"in t&&n(0,c=t.title),"batchSize"in t&&n(13,u=t.batchSize),"count"in t&&o(n(1,h=t.count)),"dataset"in t&&n(14,d=t.dataset),"selected"in t&&l(n(2,p=t.selected))},[c,h,p,f,m,g,i,r,y,function(t){["Meta","Control"].includes(t.key)?w=!0:"Shift"===t.key?S=!0:("Delete"===t.key||"Backspace"===t.key&&w)&&x()},function(t){["Meta","Control"].includes(t.key)?w=!1:"Shift"===t.key&&(S=!1)},C,T,u,d,(t,e)=>T(t,e.detail),t=>C(t),t=>y(t),()=>C(),t=>"Escape"===t.key&&C()]}class ngt extends UU{constructor(t){super(),BU(this,t,egt,tgt,rB,{title:0,batchSize:13,count:1,dataset:14,selected:2},null,[-1,-1])}}var igt;class rgt extends xK{constructor(t,{batchSize:e=6}={}){super(),this.title="dataset browser",igt.set(this,void 0),this.$selected=new eK([],!0),WX(this,igt,t,"f"),this.batchSize=e,this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new ngt({target:e,props:{title:this.title,batchSize:this.batchSize,count:VX(this,igt,"f").$count,dataset:VX(this,igt,"f"),selected:this.$selected}}))}}function sgt(...t){return new rgt(...t)}igt=new WeakMap;var ogt={exports:{}};
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */!function(t){!function(e,n,i,r){var s,o=["","webkit","Moz","MS","ms","o"],a=n.createElement("div"),l="function",c=Math.round,u=Math.abs,h=Date.now;function d(t,e,n){return setTimeout(v(t,n),e)}function p(t,e,n){return!!Array.isArray(t)&&(f(t,n[e],n),!0)}function f(t,e,n){var i;if(t)if(t.forEach)t.forEach(e,n);else if(t.length!==r)for(i=0;i<t.length;)e.call(n,t[i],i,t),i++;else for(i in t)t.hasOwnProperty(i)&&e.call(n,t[i],i,t)}function m(t,n,i){var r="DEPRECATED METHOD: "+n+"\n"+i+" AT \n";return function(){var n=new Error("get-stack-trace"),i=n&&n.stack?n.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",s=e.console&&(e.console.warn||e.console.log);return s&&s.call(e.console,r,i),t.apply(this,arguments)}}s="function"!=typeof Object.assign?function(t){if(t===r||null===t)throw new TypeError("Cannot convert undefined or null to object");for(var e=Object(t),n=1;n<arguments.length;n++){var i=arguments[n];if(i!==r&&null!==i)for(var s in i)i.hasOwnProperty(s)&&(e[s]=i[s])}return e}:Object.assign;var g=m((function(t,e,n){for(var i=Object.keys(e),s=0;s<i.length;)(!n||n&&t[i[s]]===r)&&(t[i[s]]=e[i[s]]),s++;return t}),"extend","Use `assign`."),y=m((function(t,e){return g(t,e,!0)}),"merge","Use `assign`.");function b(t,e,n){var i,r=e.prototype;(i=t.prototype=Object.create(r)).constructor=t,i._super=r,n&&s(i,n)}function v(t,e){return function(){return t.apply(e,arguments)}}function x(t,e){return typeof t==l?t.apply(e&&e[0]||r,e):t}function w(t,e){return t===r?e:t}function S(t,e,n){f(_(e),(function(e){t.addEventListener(e,n,!1)}))}function k(t,e,n){f(_(e),(function(e){t.removeEventListener(e,n,!1)}))}function C(t,e){for(;t;){if(t==e)return!0;t=t.parentNode}return!1}function T(t,e){return t.indexOf(e)>-1}function _(t){return t.trim().split(/\s+/g)}function E(t,e,n){if(t.indexOf&&!n)return t.indexOf(e);for(var i=0;i<t.length;){if(n&&t[i][n]==e||!n&&t[i]===e)return i;i++}return-1}function M(t){return Array.prototype.slice.call(t,0)}function $(t,e,n){for(var i=[],r=[],s=0;s<t.length;){var o=e?t[s][e]:t[s];E(r,o)<0&&i.push(t[s]),r[s]=o,s++}return n&&(i=e?i.sort((function(t,n){return t[e]>n[e]})):i.sort()),i}function I(t,e){for(var n,i,s=e[0].toUpperCase()+e.slice(1),a=0;a<o.length;){if((i=(n=o[a])?n+s:e)in t)return i;a++}return r}var A=1;function N(t){var n=t.ownerDocument||t;return n.defaultView||n.parentWindow||e}var R="ontouchstart"in e,P=I(e,"PointerEvent")!==r,O=R&&/mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent),L="touch",D="mouse",F=25,z=1,B=4,U=8,V=1,W=2,H=4,j=8,G=16,q=W|H,X=j|G,K=q|X,Y=["x","y"],Z=["clientX","clientY"];function J(t,e){var n=this;this.manager=t,this.callback=e,this.element=t.element,this.target=t.options.inputTarget,this.domHandler=function(e){x(t.options.enable,[t])&&n.handler(e)},this.init()}function Q(t,e,n){var i=n.pointers.length,s=n.changedPointers.length,o=e&z&&i-s==0,a=e&(B|U)&&i-s==0;n.isFirst=!!o,n.isFinal=!!a,o&&(t.session={}),n.eventType=e,function(t,e){var n=t.session,i=e.pointers,s=i.length;n.firstInput||(n.firstInput=tt(e));s>1&&!n.firstMultiple?n.firstMultiple=tt(e):1===s&&(n.firstMultiple=!1);var o=n.firstInput,a=n.firstMultiple,l=a?a.center:o.center,c=e.center=et(i);e.timeStamp=h(),e.deltaTime=e.timeStamp-o.timeStamp,e.angle=st(l,c),e.distance=rt(l,c),function(t,e){var n=e.center,i=t.offsetDelta||{},r=t.prevDelta||{},s=t.prevInput||{};e.eventType!==z&&s.eventType!==B||(r=t.prevDelta={x:s.deltaX||0,y:s.deltaY||0},i=t.offsetDelta={x:n.x,y:n.y});e.deltaX=r.x+(n.x-i.x),e.deltaY=r.y+(n.y-i.y)}(n,e),e.offsetDirection=it(e.deltaX,e.deltaY);var d=nt(e.deltaTime,e.deltaX,e.deltaY);e.overallVelocityX=d.x,e.overallVelocityY=d.y,e.overallVelocity=u(d.x)>u(d.y)?d.x:d.y,e.scale=a?(p=a.pointers,f=i,rt(f[0],f[1],Z)/rt(p[0],p[1],Z)):1,e.rotation=a?function(t,e){return st(e[1],e[0],Z)+st(t[1],t[0],Z)}(a.pointers,i):0,e.maxPointers=n.prevInput?e.pointers.length>n.prevInput.maxPointers?e.pointers.length:n.prevInput.maxPointers:e.pointers.length,function(t,e){var n,i,s,o,a=t.lastInterval||e,l=e.timeStamp-a.timeStamp;if(e.eventType!=U&&(l>F||a.velocity===r)){var c=e.deltaX-a.deltaX,h=e.deltaY-a.deltaY,d=nt(l,c,h);i=d.x,s=d.y,n=u(d.x)>u(d.y)?d.x:d.y,o=it(c,h),t.lastInterval=e}else n=a.velocity,i=a.velocityX,s=a.velocityY,o=a.direction;e.velocity=n,e.velocityX=i,e.velocityY=s,e.direction=o}(n,e);var p,f;var m=t.element;C(e.srcEvent.target,m)&&(m=e.srcEvent.target);e.target=m}(t,n),t.emit("hammer.input",n),t.recognize(n),t.session.prevInput=n}function tt(t){for(var e=[],n=0;n<t.pointers.length;)e[n]={clientX:c(t.pointers[n].clientX),clientY:c(t.pointers[n].clientY)},n++;return{timeStamp:h(),pointers:e,center:et(e),deltaX:t.deltaX,deltaY:t.deltaY}}function et(t){var e=t.length;if(1===e)return{x:c(t[0].clientX),y:c(t[0].clientY)};for(var n=0,i=0,r=0;r<e;)n+=t[r].clientX,i+=t[r].clientY,r++;return{x:c(n/e),y:c(i/e)}}function nt(t,e,n){return{x:e/t||0,y:n/t||0}}function it(t,e){return t===e?V:u(t)>=u(e)?t<0?W:H:e<0?j:G}function rt(t,e,n){n||(n=Y);var i=e[n[0]]-t[n[0]],r=e[n[1]]-t[n[1]];return Math.sqrt(i*i+r*r)}function st(t,e,n){n||(n=Y);var i=e[n[0]]-t[n[0]],r=e[n[1]]-t[n[1]];return 180*Math.atan2(r,i)/Math.PI}J.prototype={handler:function(){},init:function(){this.evEl&&S(this.element,this.evEl,this.domHandler),this.evTarget&&S(this.target,this.evTarget,this.domHandler),this.evWin&&S(N(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&k(this.element,this.evEl,this.domHandler),this.evTarget&&k(this.target,this.evTarget,this.domHandler),this.evWin&&k(N(this.element),this.evWin,this.domHandler)}};var ot={mousedown:z,mousemove:2,mouseup:B},at="mousedown",lt="mousemove mouseup";function ct(){this.evEl=at,this.evWin=lt,this.pressed=!1,J.apply(this,arguments)}b(ct,J,{handler:function(t){var e=ot[t.type];e&z&&0===t.button&&(this.pressed=!0),2&e&&1!==t.which&&(e=B),this.pressed&&(e&B&&(this.pressed=!1),this.callback(this.manager,e,{pointers:[t],changedPointers:[t],pointerType:D,srcEvent:t}))}});var ut={pointerdown:z,pointermove:2,pointerup:B,pointercancel:U,pointerout:U},ht={2:L,3:"pen",4:D,5:"kinect"},dt="pointerdown",pt="pointermove pointerup pointercancel";function ft(){this.evEl=dt,this.evWin=pt,J.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}e.MSPointerEvent&&!e.PointerEvent&&(dt="MSPointerDown",pt="MSPointerMove MSPointerUp MSPointerCancel"),b(ft,J,{handler:function(t){var e=this.store,n=!1,i=t.type.toLowerCase().replace("ms",""),r=ut[i],s=ht[t.pointerType]||t.pointerType,o=s==L,a=E(e,t.pointerId,"pointerId");r&z&&(0===t.button||o)?a<0&&(e.push(t),a=e.length-1):r&(B|U)&&(n=!0),a<0||(e[a]=t,this.callback(this.manager,r,{pointers:e,changedPointers:[t],pointerType:s,srcEvent:t}),n&&e.splice(a,1))}});var mt={touchstart:z,touchmove:2,touchend:B,touchcancel:U};function gt(){this.evTarget="touchstart",this.evWin="touchstart touchmove touchend touchcancel",this.started=!1,J.apply(this,arguments)}function yt(t,e){var n=M(t.touches),i=M(t.changedTouches);return e&(B|U)&&(n=$(n.concat(i),"identifier",!0)),[n,i]}b(gt,J,{handler:function(t){var e=mt[t.type];if(e===z&&(this.started=!0),this.started){var n=yt.call(this,t,e);e&(B|U)&&n[0].length-n[1].length==0&&(this.started=!1),this.callback(this.manager,e,{pointers:n[0],changedPointers:n[1],pointerType:L,srcEvent:t})}}});var bt={touchstart:z,touchmove:2,touchend:B,touchcancel:U},vt="touchstart touchmove touchend touchcancel";function xt(){this.evTarget=vt,this.targetIds={},J.apply(this,arguments)}function wt(t,e){var n=M(t.touches),i=this.targetIds;if(e&(2|z)&&1===n.length)return i[n[0].identifier]=!0,[n,n];var r,s,o=M(t.changedTouches),a=[],l=this.target;if(s=n.filter((function(t){return C(t.target,l)})),e===z)for(r=0;r<s.length;)i[s[r].identifier]=!0,r++;for(r=0;r<o.length;)i[o[r].identifier]&&a.push(o[r]),e&(B|U)&&delete i[o[r].identifier],r++;return a.length?[$(s.concat(a),"identifier",!0),a]:void 0}b(xt,J,{handler:function(t){var e=bt[t.type],n=wt.call(this,t,e);n&&this.callback(this.manager,e,{pointers:n[0],changedPointers:n[1],pointerType:L,srcEvent:t})}});var St=2500;function kt(){J.apply(this,arguments);var t=v(this.handler,this);this.touch=new xt(this.manager,t),this.mouse=new ct(this.manager,t),this.primaryTouch=null,this.lastTouches=[]}function Ct(t,e){t&z?(this.primaryTouch=e.changedPointers[0].identifier,Tt.call(this,e)):t&(B|U)&&Tt.call(this,e)}function Tt(t){var e=t.changedPointers[0];if(e.identifier===this.primaryTouch){var n={x:e.clientX,y:e.clientY};this.lastTouches.push(n);var i=this.lastTouches;setTimeout((function(){var t=i.indexOf(n);t>-1&&i.splice(t,1)}),St)}}function _t(t){for(var e=t.srcEvent.clientX,n=t.srcEvent.clientY,i=0;i<this.lastTouches.length;i++){var r=this.lastTouches[i],s=Math.abs(e-r.x),o=Math.abs(n-r.y);if(s<=25&&o<=25)return!0}return!1}b(kt,J,{handler:function(t,e,n){var i=n.pointerType==L,r=n.pointerType==D;if(!(r&&n.sourceCapabilities&&n.sourceCapabilities.firesTouchEvents)){if(i)Ct.call(this,e,n);else if(r&&_t.call(this,n))return;this.callback(t,e,n)}},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var Et=I(a.style,"touchAction"),Mt=Et!==r,$t="compute",It="auto",At="manipulation",Nt="none",Rt="pan-x",Pt="pan-y",Ot=function(){if(!Mt)return!1;var t={},n=e.CSS&&e.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach((function(i){t[i]=!n||e.CSS.supports("touch-action",i)})),t}();function Lt(t,e){this.manager=t,this.set(e)}Lt.prototype={set:function(t){t==$t&&(t=this.compute()),Mt&&this.manager.element.style&&Ot[t]&&(this.manager.element.style[Et]=t),this.actions=t.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var t=[];return f(this.manager.recognizers,(function(e){x(e.options.enable,[e])&&(t=t.concat(e.getTouchAction()))})),function(t){if(T(t,Nt))return Nt;var e=T(t,Rt),n=T(t,Pt);if(e&&n)return Nt;if(e||n)return e?Rt:Pt;if(T(t,At))return At;return It}(t.join(" "))},preventDefaults:function(t){var e=t.srcEvent,n=t.offsetDirection;if(this.manager.session.prevented)e.preventDefault();else{var i=this.actions,r=T(i,Nt)&&!Ot[Nt],s=T(i,Pt)&&!Ot[Pt],o=T(i,Rt)&&!Ot[Rt];if(r){var a=1===t.pointers.length,l=t.distance<2,c=t.deltaTime<250;if(a&&l&&c)return}if(!o||!s)return r||s&&n&q||o&&n&X?this.preventSrc(e):void 0}},preventSrc:function(t){this.manager.session.prevented=!0,t.preventDefault()}};var Dt=1,Ft=32;function zt(t){this.options=s({},this.defaults,t||{}),this.id=A++,this.manager=null,this.options.enable=w(this.options.enable,!0),this.state=Dt,this.simultaneous={},this.requireFail=[]}function Bt(t){return 16&t?"cancel":8&t?"end":4&t?"move":2&t?"start":""}function Ut(t){return t==G?"down":t==j?"up":t==W?"left":t==H?"right":""}function Vt(t,e){var n=e.manager;return n?n.get(t):t}function Wt(){zt.apply(this,arguments)}function Ht(){Wt.apply(this,arguments),this.pX=null,this.pY=null}function jt(){Wt.apply(this,arguments)}function Gt(){zt.apply(this,arguments),this._timer=null,this._input=null}function qt(){Wt.apply(this,arguments)}function Xt(){Wt.apply(this,arguments)}function Kt(){zt.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function Yt(t,e){return(e=e||{}).recognizers=w(e.recognizers,Yt.defaults.preset),new Zt(t,e)}zt.prototype={defaults:{},set:function(t){return s(this.options,t),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(t){if(p(t,"recognizeWith",this))return this;var e=this.simultaneous;return e[(t=Vt(t,this)).id]||(e[t.id]=t,t.recognizeWith(this)),this},dropRecognizeWith:function(t){return p(t,"dropRecognizeWith",this)||(t=Vt(t,this),delete this.simultaneous[t.id]),this},requireFailure:function(t){if(p(t,"requireFailure",this))return this;var e=this.requireFail;return-1===E(e,t=Vt(t,this))&&(e.push(t),t.requireFailure(this)),this},dropRequireFailure:function(t){if(p(t,"dropRequireFailure",this))return this;t=Vt(t,this);var e=E(this.requireFail,t);return e>-1&&this.requireFail.splice(e,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(t){return!!this.simultaneous[t.id]},emit:function(t){var e=this,n=this.state;function i(n){e.manager.emit(n,t)}n<8&&i(e.options.event+Bt(n)),i(e.options.event),t.additionalEvent&&i(t.additionalEvent),n>=8&&i(e.options.event+Bt(n))},tryEmit:function(t){if(this.canEmit())return this.emit(t);this.state=Ft},canEmit:function(){for(var t=0;t<this.requireFail.length;){if(!(this.requireFail[t].state&(Ft|Dt)))return!1;t++}return!0},recognize:function(t){var e=s({},t);if(!x(this.options.enable,[this,e]))return this.reset(),void(this.state=Ft);56&this.state&&(this.state=Dt),this.state=this.process(e),30&this.state&&this.tryEmit(e)},process:function(t){},getTouchAction:function(){},reset:function(){}},b(Wt,zt,{defaults:{pointers:1},attrTest:function(t){var e=this.options.pointers;return 0===e||t.pointers.length===e},process:function(t){var e=this.state,n=t.eventType,i=6&e,r=this.attrTest(t);return i&&(n&U||!r)?16|e:i||r?n&B?8|e:2&e?4|e:2:Ft}}),b(Ht,Wt,{defaults:{event:"pan",threshold:10,pointers:1,direction:K},getTouchAction:function(){var t=this.options.direction,e=[];return t&q&&e.push(Pt),t&X&&e.push(Rt),e},directionTest:function(t){var e=this.options,n=!0,i=t.distance,r=t.direction,s=t.deltaX,o=t.deltaY;return r&e.direction||(e.direction&q?(r=0===s?V:s<0?W:H,n=s!=this.pX,i=Math.abs(t.deltaX)):(r=0===o?V:o<0?j:G,n=o!=this.pY,i=Math.abs(t.deltaY))),t.direction=r,n&&i>e.threshold&&r&e.direction},attrTest:function(t){return Wt.prototype.attrTest.call(this,t)&&(2&this.state||!(2&this.state)&&this.directionTest(t))},emit:function(t){this.pX=t.deltaX,this.pY=t.deltaY;var e=Ut(t.direction);e&&(t.additionalEvent=this.options.event+e),this._super.emit.call(this,t)}}),b(jt,Wt,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[Nt]},attrTest:function(t){return this._super.attrTest.call(this,t)&&(Math.abs(t.scale-1)>this.options.threshold||2&this.state)},emit:function(t){if(1!==t.scale){var e=t.scale<1?"in":"out";t.additionalEvent=this.options.event+e}this._super.emit.call(this,t)}}),b(Gt,zt,{defaults:{event:"press",pointers:1,time:251,threshold:9},getTouchAction:function(){return[It]},process:function(t){var e=this.options,n=t.pointers.length===e.pointers,i=t.distance<e.threshold,r=t.deltaTime>e.time;if(this._input=t,!i||!n||t.eventType&(B|U)&&!r)this.reset();else if(t.eventType&z)this.reset(),this._timer=d((function(){this.state=8,this.tryEmit()}),e.time,this);else if(t.eventType&B)return 8;return Ft},reset:function(){clearTimeout(this._timer)},emit:function(t){8===this.state&&(t&&t.eventType&B?this.manager.emit(this.options.event+"up",t):(this._input.timeStamp=h(),this.manager.emit(this.options.event,this._input)))}}),b(qt,Wt,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[Nt]},attrTest:function(t){return this._super.attrTest.call(this,t)&&(Math.abs(t.rotation)>this.options.threshold||2&this.state)}}),b(Xt,Wt,{defaults:{event:"swipe",threshold:10,velocity:.3,direction:q|X,pointers:1},getTouchAction:function(){return Ht.prototype.getTouchAction.call(this)},attrTest:function(t){var e,n=this.options.direction;return n&(q|X)?e=t.overallVelocity:n&q?e=t.overallVelocityX:n&X&&(e=t.overallVelocityY),this._super.attrTest.call(this,t)&&n&t.offsetDirection&&t.distance>this.options.threshold&&t.maxPointers==this.options.pointers&&u(e)>this.options.velocity&&t.eventType&B},emit:function(t){var e=Ut(t.offsetDirection);e&&this.manager.emit(this.options.event+e,t),this.manager.emit(this.options.event,t)}}),b(Kt,zt,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},getTouchAction:function(){return[At]},process:function(t){var e=this.options,n=t.pointers.length===e.pointers,i=t.distance<e.threshold,r=t.deltaTime<e.time;if(this.reset(),t.eventType&z&&0===this.count)return this.failTimeout();if(i&&r&&n){if(t.eventType!=B)return this.failTimeout();var s=!this.pTime||t.timeStamp-this.pTime<e.interval,o=!this.pCenter||rt(this.pCenter,t.center)<e.posThreshold;if(this.pTime=t.timeStamp,this.pCenter=t.center,o&&s?this.count+=1:this.count=1,this._input=t,0===this.count%e.taps)return this.hasRequireFailures()?(this._timer=d((function(){this.state=8,this.tryEmit()}),e.interval,this),2):8}return Ft},failTimeout:function(){return this._timer=d((function(){this.state=Ft}),this.options.interval,this),Ft},reset:function(){clearTimeout(this._timer)},emit:function(){8==this.state&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),Yt.VERSION="2.0.7",Yt.defaults={domEvents:!1,touchAction:$t,enable:!0,inputTarget:null,inputClass:null,preset:[[qt,{enable:!1}],[jt,{enable:!1},["rotate"]],[Xt,{direction:q}],[Ht,{direction:q},["swipe"]],[Kt],[Kt,{event:"doubletap",taps:2},["tap"]],[Gt]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};function Zt(t,e){this.options=s({},Yt.defaults,e||{}),this.options.inputTarget=this.options.inputTarget||t,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=t,this.input=function(t){var e=t.options.inputClass;return new(e||(P?ft:O?xt:R?kt:ct))(t,Q)}(this),this.touchAction=new Lt(this,this.options.touchAction),Jt(this,!0),f(this.options.recognizers,(function(t){var e=this.add(new t[0](t[1]));t[2]&&e.recognizeWith(t[2]),t[3]&&e.requireFailure(t[3])}),this)}function Jt(t,e){var n,i=t.element;i.style&&(f(t.options.cssProps,(function(r,s){n=I(i.style,s),e?(t.oldCssProps[n]=i.style[n],i.style[n]=r):i.style[n]=t.oldCssProps[n]||""})),e||(t.oldCssProps={}))}Zt.prototype={set:function(t){return s(this.options,t),t.touchAction&&this.touchAction.update(),t.inputTarget&&(this.input.destroy(),this.input.target=t.inputTarget,this.input.init()),this},stop:function(t){this.session.stopped=t?2:1},recognize:function(t){var e=this.session;if(!e.stopped){var n;this.touchAction.preventDefaults(t);var i=this.recognizers,r=e.curRecognizer;(!r||r&&8&r.state)&&(r=e.curRecognizer=null);for(var s=0;s<i.length;)n=i[s],2===e.stopped||r&&n!=r&&!n.canRecognizeWith(r)?n.reset():n.recognize(t),!r&&14&n.state&&(r=e.curRecognizer=n),s++}},get:function(t){if(t instanceof zt)return t;for(var e=this.recognizers,n=0;n<e.length;n++)if(e[n].options.event==t)return e[n];return null},add:function(t){if(p(t,"add",this))return this;var e=this.get(t.options.event);return e&&this.remove(e),this.recognizers.push(t),t.manager=this,this.touchAction.update(),t},remove:function(t){if(p(t,"remove",this))return this;if(t=this.get(t)){var e=this.recognizers,n=E(e,t);-1!==n&&(e.splice(n,1),this.touchAction.update())}return this},on:function(t,e){if(t!==r&&e!==r){var n=this.handlers;return f(_(t),(function(t){n[t]=n[t]||[],n[t].push(e)})),this}},off:function(t,e){if(t!==r){var n=this.handlers;return f(_(t),(function(t){e?n[t]&&n[t].splice(E(n[t],e),1):delete n[t]})),this}},emit:function(t,e){this.options.domEvents&&function(t,e){var i=n.createEvent("Event");i.initEvent(t,!0,!0),i.gesture=e,e.target.dispatchEvent(i)}(t,e);var i=this.handlers[t]&&this.handlers[t].slice();if(i&&i.length){e.type=t,e.preventDefault=function(){e.srcEvent.preventDefault()};for(var r=0;r<i.length;)i[r](e),r++}},destroy:function(){this.element&&Jt(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},s(Yt,{INPUT_START:z,INPUT_MOVE:2,INPUT_END:B,INPUT_CANCEL:U,STATE_POSSIBLE:Dt,STATE_BEGAN:2,STATE_CHANGED:4,STATE_ENDED:8,STATE_RECOGNIZED:8,STATE_CANCELLED:16,STATE_FAILED:Ft,DIRECTION_NONE:V,DIRECTION_LEFT:W,DIRECTION_RIGHT:H,DIRECTION_UP:j,DIRECTION_DOWN:G,DIRECTION_HORIZONTAL:q,DIRECTION_VERTICAL:X,DIRECTION_ALL:K,Manager:Zt,Input:J,TouchAction:Lt,TouchInput:xt,MouseInput:ct,PointerEventInput:ft,TouchMouseInput:kt,SingleTouchInput:gt,Recognizer:zt,AttrRecognizer:Wt,Tap:Kt,Pan:Ht,Swipe:Xt,Pinch:jt,Rotate:qt,Press:Gt,on:S,off:k,each:f,merge:y,extend:g,assign:s,inherit:b,bindFn:v,prefixed:I}),(void 0!==e?e:"undefined"!=typeof self?self:{}).Hammer=Yt,"function"==typeof r&&r.amd?r((function(){return Yt})):t.exports?t.exports=Yt:e.Hammer=Yt}(window,document)}(ogt);var agt=_i(ogt.exports);
/*!
* chartjs-plugin-zoom v2.0.1
* undefined
 * (c) 2016-2023 chartjs-plugin-zoom Contributors
 * Released under the MIT License
 */
const lgt=t=>t&&t.enabled&&t.modifierKey,cgt=(t,e)=>t&&e[t+"Key"],ugt=(t,e)=>t&&!e[t+"Key"];function hgt(t,e,n){return void 0===t||("string"==typeof t?-1!==t.indexOf(e):"function"==typeof t&&-1!==t({chart:n}).indexOf(e))}function dgt(t,e){return"function"==typeof t&&(t=t({chart:e})),"string"==typeof t?{x:-1!==t.indexOf("x"),y:-1!==t.indexOf("y")}:{x:!1,y:!1}}function pgt(t,e,n){const{mode:i="xy",scaleMode:r,overScaleMode:s}=t||{},o=function({x:t,y:e},n){const i=n.scales,r=Object.keys(i);for(let n=0;n<r.length;n++){const s=i[r[n]];if(e>=s.top&&e<=s.bottom&&t>=s.left&&t<=s.right)return s}return null}(e,n),a=dgt(i,n),l=dgt(r,n);if(s){const t=dgt(s,n);for(const e of["x","y"])t[e]&&(l[e]=a[e],a[e]=!1)}if(o&&l[o.axis])return[o];const c=[];return Crt(n.scales,(function(t){a[t.axis]&&c.push(t)})),c}const fgt=new WeakMap;function mgt(t){let e=fgt.get(t);return e||(e={originalScaleLimits:{},updatedScaleLimits:{},handlers:{},panDelta:{}},fgt.set(t,e)),e}function ggt(t,e,n){const i=t.max-t.min,r=i*(e-1),s=t.isHorizontal()?n.x:n.y,o=Math.max(0,Math.min(1,(t.getValueForPixel(s)-t.min)/i||0));return{min:r*o,max:r*(1-o)}}function ygt(t,e,n,i,r){let s=n[i];if("original"===s){const n=t.originalScaleLimits[e.id][i];s=wrt(n.options,n.scale)}return wrt(s,r)}function bgt(t,{min:e,max:n},i,r=!1){const s=mgt(t.chart),{id:o,axis:a,options:l}=t,c=i&&(i[o]||i[a])||{},{minRange:u=0}=c,h=ygt(s,t,c,"min",-1/0),d=ygt(s,t,c,"max",1/0),p=r?Math.max(n-e,u):t.max-t.min,f=(p-n+e)/2;return n+=f,(e-=f)<h?(e=h,n=Math.min(h+p,d)):n>d&&(n=d,e=Math.max(d-p,h)),l.min=e,l.max=n,s.updatedScaleLimits[t.id]={min:e,max:n},t.parse(e)!==t.min||t.parse(n)!==t.max}const vgt=t=>0===t||isNaN(t)?0:t<0?Math.min(Math.round(t),-1):Math.max(Math.round(t),1);const xgt={second:500,minute:3e4,hour:18e5,day:432e5,week:3024e5,month:1296e6,quarter:5184e6,year:157248e5};function wgt(t,e,n,i=!1){const{min:r,max:s,options:o}=t,a=o.time&&o.time.round,l=xgt[a]||0,c=t.getValueForPixel(t.getPixelForValue(r+l)-e),u=t.getValueForPixel(t.getPixelForValue(s+l)-e),{min:h=-1/0,max:d=1/0}=i&&n&&n[t.axis]||{};return!!(isNaN(c)||isNaN(u)||c<h||u>d)||bgt(t,{min:c,max:u},n,i)}function Sgt(t,e,n){return wgt(t,e,n,!0)}const kgt={category:function(t,e,n,i){const r=ggt(t,e,n);return t.min===t.max&&e<1&&function(t){const e=t.getLabels().length-1;t.min>0&&(t.min-=1),t.max<e&&(t.max+=1)}(t),bgt(t,{min:t.min+vgt(r.min),max:t.max-vgt(r.max)},i,!0)},default:function(t,e,n,i){const r=ggt(t,e,n);return bgt(t,{min:t.min+r.min,max:t.max-r.max},i,!0)}},Cgt={default:function(t,e,n,i){bgt(t,function(t,e,n){const i=t.getValueForPixel(e),r=t.getValueForPixel(n);return{min:Math.min(i,r),max:Math.max(i,r)}}(t,e,n),i,!0)}},Tgt={category:function(t,e,n){const i=t.getLabels().length-1;let{min:r,max:s}=t;const o=Math.max(s-r,1),a=Math.round(function(t){return t.isHorizontal()?t.width:t.height}(t)/Math.max(o,10)),l=Math.round(Math.abs(e/a));let c;return e<-a?(s=Math.min(s+l,i),r=1===o?s:s-o,c=s===i):e>a&&(r=Math.max(0,r-l),s=1===o?r:r+o,c=0===r),bgt(t,{min:r,max:s},n)||c},default:wgt,logarithmic:Sgt,timeseries:Sgt};function _gt(t,e){Crt(t,((n,i)=>{e[i]||delete t[i]}))}function Egt(t,e){const{scales:n}=t,{originalScaleLimits:i,updatedScaleLimits:r}=e;return Crt(n,(function(t){(function(t,e,n){const{id:i,options:{min:r,max:s}}=t;if(!e[i]||!n[i])return!0;const o=n[i];return o.min!==r||o.max!==s})(t,i,r)&&(i[t.id]={min:{scale:t.min,options:t.options.min},max:{scale:t.max,options:t.options.max}})})),_gt(i,n),_gt(r,n),i}function Mgt(t,e,n,i){krt(kgt[t.type]||kgt.default,[t,e,n,i])}function $gt(t,e,n,i,r){krt(Cgt[t.type]||Cgt.default,[t,e,n,i,r])}function Igt(t){const e=t.chartArea;return{x:(e.left+e.right)/2,y:(e.top+e.bottom)/2}}function Agt(t,e,n="none"){const{x:i=1,y:r=1,focalPoint:s=Igt(t)}="number"==typeof e?{x:e,y:e}:e,o=mgt(t),{options:{limits:a,zoom:l}}=o;Egt(t,o);const c=1!==i,u=1!==r;Crt(pgt(l,s,t)||t.scales,(function(t){t.isHorizontal()&&c?Mgt(t,i,s,a):!t.isHorizontal()&&u&&Mgt(t,r,s,a)})),t.update(n),krt(l.onZoom,[{chart:t}])}function Ngt(t,e,n,i="none"){const r=mgt(t),{options:{limits:s,zoom:o}}=r,{mode:a="xy"}=o;Egt(t,r);const l=hgt(a,"x",t),c=hgt(a,"y",t);Crt(t.scales,(function(t){t.isHorizontal()&&l?$gt(t,e.x,n.x,s):!t.isHorizontal()&&c&&$gt(t,e.y,n.y,s)})),t.update(i),krt(o.onZoom,[{chart:t}])}function Rgt(t){const e=mgt(t);let n=1,i=1;return Crt(t.scales,(function(t){const r=function(t,e){const n=t.originalScaleLimits[e];if(!n)return;const{min:i,max:r}=n;return wrt(r.options,r.scale)-wrt(i.options,i.scale)}(e,t.id);if(r){const e=Math.round(r/(t.max-t.min)*100)/100;n=Math.min(n,e),i=Math.max(i,e)}})),n<1?n:i}function Pgt(t,e,n,i){const{panDelta:r}=i,s=r[t.id]||0;qrt(s)===qrt(e)&&(e+=s);krt(Tgt[t.type]||Tgt.default,[t,e,n])?r[t.id]=0:r[t.id]=e}function Ogt(t,e,n,i="none"){const{x:r=0,y:s=0}="number"==typeof e?{x:e,y:e}:e,o=mgt(t),{options:{pan:a,limits:l}}=o,{onPan:c}=a||{};Egt(t,o);const u=0!==r,h=0!==s;Crt(n||t.scales,(function(t){t.isHorizontal()&&u?Pgt(t,r,l,o):!t.isHorizontal()&&h&&Pgt(t,s,l,o)})),t.update(i),krt(c,[{chart:t}])}function Lgt(t){const e=mgt(t);Egt(t,e);const n={};for(const i of Object.keys(t.scales)){const{min:t,max:r}=e.originalScaleLimits[i]||{min:{},max:{}};n[i]={min:t.scale,max:r.scale}}return n}function Dgt(t,e){const{handlers:n}=mgt(t),i=n[e];i&&i.target&&(i.target.removeEventListener(e,i),delete n[e])}function Fgt(t,e,n,i){const{handlers:r,options:s}=mgt(t),o=r[n];o&&o.target===e||(Dgt(t,n),r[n]=e=>i(t,e,s),r[n].target=e,e.addEventListener(n,r[n]))}function zgt(t,e){const n=mgt(t);n.dragStart&&(n.dragging=!0,n.dragEnd=e,t.update("none"))}function Bgt(t,e){const n=mgt(t);n.dragStart&&"Escape"===e.key&&(Dgt(t,"keydown"),n.dragging=!1,n.dragStart=n.dragEnd=null,t.update("none"))}function Ugt(t,e,n){const{onZoomStart:i,onZoomRejected:r}=n;if(i){if(!1===krt(i,[{chart:t,event:e,point:zot(e,t)}]))return krt(r,[{chart:t,event:e}]),!1}}function Vgt(t,e){const n=mgt(t),{pan:i,zoom:r={}}=n.options;if(0!==e.button||cgt(lgt(i),e)||ugt(lgt(r.drag),e))return krt(r.onZoomRejected,[{chart:t,event:e}]);!1!==Ugt(t,e,r)&&(n.dragStart=e,Fgt(t,t.canvas,"mousemove",zgt),Fgt(t,window.document,"keydown",Bgt))}function Wgt(t,e,n,i){const r=hgt(e,"x",t),s=hgt(e,"y",t);let{top:o,left:a,right:l,bottom:c,width:u,height:h}=t.chartArea;const d=zot(n,t),p=zot(i,t);r&&(a=Math.min(d.x,p.x),l=Math.max(d.x,p.x)),s&&(o=Math.min(d.y,p.y),c=Math.max(d.y,p.y));const f=l-a,m=c-o;return{left:a,top:o,right:l,bottom:c,width:f,height:m,zoomX:r&&f?1+(u-f)/u:1,zoomY:s&&m?1+(h-m)/h:1}}function Hgt(t,e){const n=mgt(t);if(!n.dragStart)return;Dgt(t,"mousemove");const{mode:i,onZoomComplete:r,drag:{threshold:s=0}}=n.options.zoom,o=Wgt(t,i,n.dragStart,e),a=hgt(i,"x",t)?o.width:0,l=hgt(i,"y",t)?o.height:0,c=Math.sqrt(a*a+l*l);if(n.dragStart=n.dragEnd=null,c<=s)return n.dragging=!1,void t.update("none");Ngt(t,{x:o.left,y:o.top},{x:o.right,y:o.bottom},"zoom"),setTimeout((()=>n.dragging=!1),500),krt(r,[{chart:t}])}function jgt(t,e){const{handlers:{onZoomComplete:n},options:{zoom:i}}=mgt(t);if(!function(t,e,n){if(ugt(lgt(n.wheel),e))krt(n.onZoomRejected,[{chart:t,event:e}]);else if(!1!==Ugt(t,e,n)&&(e.cancelable&&e.preventDefault(),void 0!==e.deltaY))return!0}(t,e,i))return;const r=e.target.getBoundingClientRect(),s=1+(e.deltaY>=0?-i.wheel.speed:i.wheel.speed);Agt(t,{x:s,y:s,focalPoint:{x:e.clientX-r.left,y:e.clientY-r.top}}),n&&n()}function Ggt(t,e,n,i){n&&(mgt(t).handlers[e]=function(t,e){let n;return function(){return clearTimeout(n),n=setTimeout(t,e),e}}((()=>krt(n,[{chart:t}])),i))}function qgt(t,e){return function(n,i){const{pan:r,zoom:s={}}=e.options;if(!r||!r.enabled)return!1;const o=i&&i.srcEvent;return!o||(!(!e.panning&&"mouse"===i.pointerType&&(ugt(lgt(r),o)||cgt(lgt(s.drag),o)))||(krt(r.onPanRejected,[{chart:t,event:i}]),!1))}}function Xgt(t,e,n){if(e.scale){const{center:i,pointers:r}=n,s=1/e.scale*n.scale,o=n.target.getBoundingClientRect(),a=function(t,e){const n=Math.abs(t.clientX-e.clientX),i=Math.abs(t.clientY-e.clientY),r=n/i;let s,o;return r>.3&&r<1.7?s=o=!0:n>i?s=!0:o=!0,{x:s,y:o}}(r[0],r[1]),l=e.options.zoom.mode;Agt(t,{x:a.x&&hgt(l,"x",t)?s:1,y:a.y&&hgt(l,"y",t)?s:1,focalPoint:{x:i.x-o.left,y:i.y-o.top}}),e.scale=n.scale}}function Kgt(t,e,n){const i=e.delta;i&&(e.panning=!0,Ogt(t,{x:n.deltaX-i.x,y:n.deltaY-i.y},e.panScales),e.delta={x:n.deltaX,y:n.deltaY})}const Ygt=new WeakMap;function Zgt(t,e){const n=mgt(t),i=t.canvas,{pan:r,zoom:s}=e,o=new agt.Manager(i);s&&s.pinch.enabled&&(o.add(new agt.Pinch),o.on("pinchstart",(()=>function(t,e){e.options.zoom.pinch.enabled&&(e.scale=1)}(0,n))),o.on("pinch",(e=>Xgt(t,n,e))),o.on("pinchend",(e=>function(t,e,n){e.scale&&(Xgt(t,e,n),e.scale=null,krt(e.options.zoom.onZoomComplete,[{chart:t}]))}(t,n,e)))),r&&r.enabled&&(o.add(new agt.Pan({threshold:r.threshold,enable:qgt(t,n)})),o.on("panstart",(e=>function(t,e,n){const{enabled:i,onPanStart:r,onPanRejected:s}=e.options.pan;if(!i)return;const o=n.target.getBoundingClientRect(),a={x:n.center.x-o.left,y:n.center.y-o.top};if(!1===krt(r,[{chart:t,event:n,point:a}]))return krt(s,[{chart:t,event:n}]);e.panScales=pgt(e.options.pan,a,t),e.delta={x:0,y:0},clearTimeout(e.panEndTimeout),Kgt(t,e,n)}(t,n,e))),o.on("panmove",(e=>Kgt(t,n,e))),o.on("panend",(()=>function(t,e){e.delta=null,e.panning&&(e.panEndTimeout=setTimeout((()=>e.panning=!1),500),krt(e.options.pan.onPanComplete,[{chart:t}]))}(t,n)))),Ygt.set(t,o)}function Jgt(t,e,n){const i=n.zoom.drag,{dragStart:r,dragEnd:s}=mgt(t);if(i.drawTime!==e||!s)return;const{left:o,top:a,width:l,height:c}=Wgt(t,n.zoom.mode,r,s),u=t.ctx;u.save(),u.beginPath(),u.fillStyle=i.backgroundColor||"rgba(225,225,225,0.3)",u.fillRect(o,a,l,c),i.borderWidth>0&&(u.lineWidth=i.borderWidth,u.strokeStyle=i.borderColor||"rgba(225,225,225)",u.strokeRect(o,a,l,c)),u.restore()}var Qgt={id:"zoom",version:"2.0.1",defaults:{pan:{enabled:!1,mode:"xy",threshold:10,modifierKey:null},zoom:{wheel:{enabled:!1,speed:.1,modifierKey:null},drag:{enabled:!1,drawTime:"beforeDatasetsDraw",modifierKey:null},pinch:{enabled:!1},mode:"xy"}},start:function(t,e,n){mgt(t).options=n,Object.prototype.hasOwnProperty.call(n.zoom,"enabled")&&console.warn("The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`."),(Object.prototype.hasOwnProperty.call(n.zoom,"overScaleMode")||Object.prototype.hasOwnProperty.call(n.pan,"overScaleMode"))&&console.warn("The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired)."),agt&&Zgt(t,n),t.pan=(e,n,i)=>Ogt(t,e,n,i),t.zoom=(e,n)=>Agt(t,e,n),t.zoomRect=(e,n,i)=>Ngt(t,e,n,i),t.zoomScale=(e,n,i)=>function(t,e,n,i="none"){Egt(t,mgt(t)),bgt(t.scales[e],n,void 0,!0),t.update(i)}(t,e,n,i),t.resetZoom=e=>function(t,e="default"){const n=mgt(t),i=Egt(t,n);Crt(t.scales,(function(t){const e=t.options;i[t.id]?(e.min=i[t.id].min.options,e.max=i[t.id].max.options):(delete e.min,delete e.max)})),t.update(e),krt(n.options.zoom.onZoomComplete,[{chart:t}])}(t,e),t.getZoomLevel=()=>Rgt(t),t.getInitialScaleBounds=()=>Lgt(t),t.isZoomedOrPanned=()=>function(t){const e=Lgt(t);for(const n of Object.keys(t.scales)){const{min:i,max:r}=e[n];if(void 0!==i&&t.scales[n].min!==i)return!0;if(void 0!==r&&t.scales[n].max!==r)return!0}return!1}(t)},beforeEvent(t){const e=mgt(t);if(e.panning||e.dragging)return!1},beforeUpdate:function(t,e,n){mgt(t).options=n,function(t,e){const n=t.canvas,{wheel:i,drag:r,onZoomComplete:s}=e.zoom;i.enabled?(Fgt(t,n,"wheel",jgt),Ggt(t,"onZoomComplete",s,250)):Dgt(t,"wheel"),r.enabled?(Fgt(t,n,"mousedown",Vgt),Fgt(t,n.ownerDocument,"mouseup",Hgt)):(Dgt(t,"mousedown"),Dgt(t,"mousemove"),Dgt(t,"mouseup"),Dgt(t,"keydown"))}(t,n)},beforeDatasetsDraw(t,e,n){Jgt(t,"beforeDatasetsDraw",n)},afterDatasetsDraw(t,e,n){Jgt(t,"afterDatasetsDraw",n)},beforeDraw(t,e,n){Jgt(t,"beforeDraw",n)},afterDraw(t,e,n){Jgt(t,"afterDraw",n)},stop:function(t){!function(t){Dgt(t,"mousedown"),Dgt(t,"mousemove"),Dgt(t,"mouseup"),Dgt(t,"wheel"),Dgt(t,"click"),Dgt(t,"keydown")}(t),agt&&function(t){const e=Ygt.get(t);e&&(e.remove("pinchstart"),e.remove("pinch"),e.remove("pinchend"),e.remove("panstart"),e.remove("pan"),e.remove("panend"),e.destroy(),Ygt.delete(t))}(t),function(t){fgt.delete(t)}(t)},panFunctions:Tgt,zoomFunctions:kgt,zoomRectFunctions:Cgt};function tyt(t){let e;return{c(){e=IB("Reset Zoom")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function eyt(t){let e,n,i,r,s,o;return s=new HU({props:{size:"small",$$slots:{default:[tyt]},$$scope:{ctx:t}}}),s.$on("click",t[8]),{c(){e=MB("div"),n=MB("canvas"),i=AB(),r=MB("div"),DU(s.$$.fragment),OB(e,"id","scatter-container"),OB(e,"class","svelte-ei9k3k"),OB(r,"class","flex justify-end")},m(a,l){TB(a,e,l),SB(e,n),t[7](n),TB(a,i,l),TB(a,r,l),FU(s,r,null),o=!0},p(t,e){const n={};8192&e&&(n.$$scope={dirty:e,ctx:t}),s.$set(n)},i(t){o||(EU(s.$$.fragment,t),o=!0)},o(t){MU(s.$$.fragment,t),o=!1},d(n){n&&_B(e),t[7](null),n&&_B(i),n&&_B(r),zU(s)}}}function nyt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[eyt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),8198&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function iyt(t,e,n){hct.register(Jct,nut,_ct,_ut,Mct,Dat,rut,vut),hct.register(Qgt);let{title:i}=e,{data:r}=e,{hovered:s}=e,{clicked:o}=e;function a(t){const{chart:e,tooltip:n}=t,i=(t=>{let e=t.canvas.parentNode.querySelector("div");if(!e){e=document.createElement("div"),e.style.background="transparent",e.style.borderRadius="3px",e.style.color="white",e.style.opacity=1,e.style.pointerEvents="none",e.style.position="absolute",e.style.transform="translate(-50%, 0)",e.style.transition="all .1s ease";const n=document.createElement("img");n.style.borderRadius="4px",n.style.margin="0px",n.width=100,n.height=100,e.appendChild(n),t.canvas.parentNode.appendChild(e)}return e})(e);if(0===n.opacity)return void(i.style.opacity=0);i.querySelector("img").src=n.dataPoints[0].raw.thumbnail;const{offsetLeft:r,offsetTop:s}=e.canvas;i.style.opacity=1,i.style.left=r+n.caretX+70+"px",i.style.top=s+n.caretY+20+"px",i.style.font=n.options.bodyFont.string,i.style.padding=n.options.padding+"px "+n.options.padding+"px"}const l={type:"scatter",data:{labels:[],datasets:[]},options:{responsive:!0,maintainAspectRatio:!1,animation:{duration:200},scales:{y:{position:"center",ticks:{display:!1}},x:{position:"center",ticks:{display:!1}}},elements:{point:{radius:8,hoverRadius:10,borderWidth:0,hoverBorderWidth:3}},plugins:{legend:{position:"top"},tooltip:{enabled:!1,position:"nearest",external:a},zoom:{zoom:{wheel:{enabled:!0},pinch:{enabled:!0},mode:"xy"},pan:{enabled:!0,mode:"xy"}}},onClick(t,e){o.set(e.map((({element:t})=>t)))},onHover(t,e){const n=e.map((({element:t})=>{var e,n;return null===(n=null===(e=null==t?void 0:t.$context)||void 0===e?void 0:e.raw)||void 0===n?void 0:n.id}));Cmt(n,s.get())||s.set(n)}}};let c,u,h=()=>{};tU((async()=>{await pU(),await pU(),async function(){h();const t={...l,data:r.get()};h=r.filter((t=>!!t)).subscribe((e=>{t.data=e,c.update(),c.resetZoom()}));const e=u.getContext("2d");n(1,c=new hct(e,t))}()})),nU((()=>{h(),null==c||c.destroy()}));return t.$$set=t=>{"title"in t&&n(0,i=t.title),"data"in t&&n(3,r=t.data),"hovered"in t&&n(4,s=t.hovered),"clicked"in t&&n(5,o=t.clicked)},[i,c,u,r,s,o,a,function(t){aU[t?"unshift":"push"]((()=>{u=t,n(2,u)}))},()=>c.resetZoom()]}class ryt extends UU{constructor(t){super(),BU(this,t,iyt,nyt,rB,{title:0,data:3,hovered:4,clicked:5,externalTooltipHandler:6})}get externalTooltipHandler(){return this.$$.ctx[6]}}const syt=["rgb(54, 162, 235)","rgb(255, 99, 132)","rgb(255, 206, 86)","rgb(75, 192, 192)","rgb(153, 102, 255)","rgb(255, 159, 64)"];class oyt extends xK{constructor(t){super(),this.dataset=t,this.title="Dataset ScatterPlot",this.transforms={xy:t=>[t.x[0],t.x[1]],label:t=>t.y},this.$data=new eK(void 0,!0),this.$hovered=new eK([],!0),this.$clicked=new eK([],!0),this.dataset.ready.then((()=>{this.updateData()}))}setTransforms(t){this.transforms={...this.transforms,...t},this.updateData()}async updateData(){await this.dataset.ready;const t=await Promise.all(await this.dataset.items().map((async t=>{const[e,n]=await this.transforms.xy(t);return{x:e,y:n,label:await this.transforms.label(t),id:t.id,thumbnail:t.thumbnail}})).toArray()),e=t.map((t=>t.label)),n=Array.from(new Set(e));n.sort();const i={labels:e,datasets:n.map(((e,n)=>{return{label:e,data:t.filter((t=>t.label===e)),borderColor:(i=syt[n],new prt(i)).darken(.5).rgbString(),backgroundColor:syt[n]};var i}))};this.$data.set(i)}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new ryt({target:e,props:{title:this.title,data:this.$data,hovered:this.$hovered,clicked:this.$clicked}}))}}function ayt(...t){return new oyt(...t)}function lyt(t){return{c:Jz,m:Jz,p:Jz,i:Jz,o:Jz,d:Jz}}function cyt(t){let e,n,i=t[5]&&uyt(t);return{c(){i&&i.c(),e=NB()},m(t,r){i&&i.m(t,r),TB(t,e,r),n=!0},p(t,n){t[5]?i?(i.p(t,n),32&n&&EU(i,1)):(i=uyt(t),i.c(),EU(i,1),i.m(e.parentNode,e)):i&&(TU(),MU(i,1,1,(()=>{i=null})),_U())},i(t){n||(EU(i),n=!0)},o(t){MU(i),n=!1},d(t){i&&i.d(t),t&&_B(e)}}}function uyt(t){let e,n;return e=new TH({props:{provider:t[5],columns:t[4],singleSelection:t[2],actions:[{name:"delete"}]}}),e.$on("selection",t[7]),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};32&n&&(i.provider=t[5]),16&n&&(i.columns=t[4]),4&n&&(i.singleSelection=t[2]),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function hyt(t){let e,n;return e=new LV({}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p:Jz,i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function dyt(t){let e,n,i,r={ctx:t,current:null,token:null,hasCatch:!1,pending:hyt,then:cyt,catch:lyt,blocks:[,,,]};return AU(n=t[1].ready,r),{c(){e=NB(),r.block.c()},m(t,n){TB(t,e,n),r.block.m(t,r.anchor=n),r.mount=()=>e.parentNode,r.anchor=e,i=!0},p(e,i){t=e,r.ctx=t,2&i&&n!==(n=t[1].ready)&&AU(n,r)||NU(r,t,i)},i(t){i||(EU(r.block),i=!0)},o(t){for(let t=0;t<3;t+=1){MU(r.blocks[t])}i=!1},d(t){t&&_B(e),r.block.d(t),r.token=null,r=null}}}function pyt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[dyt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),318&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function fyt(t){return"string"==typeof t&&t.includes("data:image/")?"image":"string"!=typeof t||isNaN(Date.parse(t))?Array.isArray(t)&&(t.length>1&&Array.isArray(t[0])||t.length>3)?"array":"generic":"date"}function myt(t){return"image"!==fyt(t)}function gyt(t,e,n){let i,{title:r}=e,{dataset:s}=e,{colNames:o}=e,{singleSelection:a=!1}=e,{selection:l}=e,c=[{name:"x"},{name:"y",sortable:!0},{name:"thumbnail",type:"image"},{name:"updatedAt",sortable:!0}];tU((async()=>{await pU(),await s.ready,n(5,i=new NH({service:s.instanceService,columns:c})),o.subscribe((async t=>{if(n(4,c=t.map((t=>({name:t})))),s.$count.get()>0){const[t]=await s.items().query(s.query).take(1).toArray();n(4,c=c.map((({name:e})=>({name:e,type:fyt(t[e]),sortable:myt(t[e])}))))}for(const[t,e]of Object.entries(s.query))n(5,i.query[t]=e,i);n(5,i.query.$select=c.map((t=>t.name)).concat(["id"]),i),i.update()}));const t=s.$count.subscribe((async e=>{if(e>0){const[e]=await s.items().query(s.query).take(1).toArray();n(4,c=c.map((({name:t})=>({name:t,type:fyt(e[t]),sortable:myt(e[t])})))),t()}}))}));return t.$$set=t=>{"title"in t&&n(0,r=t.title),"dataset"in t&&n(1,s=t.dataset),"colNames"in t&&n(6,o=t.colNames),"singleSelection"in t&&n(2,a=t.singleSelection),"selection"in t&&n(3,l=t.selection)},[r,s,a,l,c,i,o,({detail:t})=>{l.set(t)}]}class yyt extends UU{constructor(t){super(),BU(this,t,gyt,pyt,rB,{title:0,dataset:1,colNames:6,singleSelection:2,selection:3})}}var byt,vyt;class xyt extends xK{constructor(t,e,n=!1){super(),this.title="dataset table",byt.set(this,void 0),this.$selection=new eK([],!0),this.singleSelection=!1,WX(this,byt,t,"f"),this.singleSelection=n,this.$columns=new eK(e||["x","y","thumbnail","updatedAt"],!0),e||VX(this,byt,"f").ready.then((()=>VX(this,byt,"f").items().take(1).toArray())).then((t=>{if(t.length>0){const e=Object.keys(t[0]);this.$columns.set(e)}})).catch((t=>{console.log("An error occured while fetching the first instance.",t)})),this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new yyt({target:e,props:{title:this.title,dataset:VX(this,byt,"f"),colNames:this.$columns,singleSelection:this.singleSelection,selection:this.$selection}}))}}function wyt(t,e){return new xyt(t,e)}function Syt(t){let e;return{c(){e=MB("canvas"),OB(e,"id","can"),OB(e,"class","w-full max-w-full")},m(t,n){TB(t,e,n)},p:Jz,d(t){t&&_B(e)}}}function kyt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[Syt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),8&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function Cyt(t,e,n){let{title:i}=e,{imageStream:r}=e,{objectDetectionResults:s}=e;return tU((()=>{const t=document.getElementById("can"),e=t.getContext("2d");r.subscribe((n=>{t.height=n.height,t.width=n.width,e.putImageData(n,0,0)})),s.subscribe((({outputs:n})=>{for(let i=0;i<n.length;i++){e.font=`${Math.floor(t.width/60)}px sans-serif`;const r=`${n[i].confidence.toFixed(3)} ${n[i].class}`,s=e.measureText(r);e.beginPath(),e.rect(...n[i].bbox),e.lineWidth=t.width/300,e.strokeStyle="green",e.fillStyle="green",e.stroke(),e.fillRect(n[i].bbox[0]-e.lineWidth/2,n[i].bbox[1]>s.actualBoundingBoxAscent?n[i].bbox[1]-s.actualBoundingBoxAscent-1.5*e.lineWidth:0,s.width+e.lineWidth,s.actualBoundingBoxAscent+e.lineWidth),e.fillStyle="white",e.fillText(r,n[i].bbox[0],n[i].bbox[1]>s.actualBoundingBoxAscent?n[i].bbox[1]-e.lineWidth:s.actualBoundingBoxAscent)}}))})),t.$$set=t=>{"title"in t&&n(0,i=t.title),"imageStream"in t&&n(1,r=t.imageStream),"objectDetectionResults"in t&&n(2,s=t.objectDetectionResults)},[i,r,s]}byt=new WeakMap;class Tyt extends UU{constructor(t){super(),BU(this,t,Cyt,kyt,rB,{title:0,imageStream:1,objectDetectionResults:2})}}class _yt extends xK{constructor(t,e){super(),this.title="Visualize Object Detections",this.$imgStream=t,this.$objectDetectionResults=e,this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new Tyt({target:e,props:{title:this.title,imageStream:this.$imgStream,objectDetectionResults:this.$objectDetectionResults}}))}}function Eyt(...t){return new _yt(...t)}function Myt(t){let e;return{c(){e=MB("div"),e.innerHTML='<i><svg class="fill-current w-12 h-12 mb-3 text-blue-700" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19.479 10.092c-.212-3.951-3.473-7.092-7.479-7.092-4.005 0-7.267 3.141-7.479 7.092-2.57.463-4.521 2.706-4.521 5.408 0 3.037 2.463 5.5 5.5 5.5h13c3.037 0 5.5-2.463 5.5-5.5 0-2.702-1.951-4.945-4.521-5.408zm-7.479-1.092l4 4h-3v4h-2v-4h-3l4-4z"></path></svg></i> \n      <p class="text-lg text-blue-700">Drop files to upload</p>',OB(e,"class","overlay svelte-10fctvd")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function $yt(t){let e;return{c(){e=IB("Upload a file")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function Iyt(t){let e,n,i,r,s,o,a,l,c,u,h,d=t[2]&&Myt();return l=new HU({props:{$$slots:{default:[$yt]},$$scope:{ctx:t}}}),l.$on("click",t[7]),{c(){d&&d.c(),e=AB(),n=MB("div"),i=MB("div"),r=MB("p"),r.innerHTML="<span>Drop Files here or:</span>",s=AB(),o=MB("input"),a=AB(),DU(l.$$.fragment),OB(r,"class","mb-3 font-semibold text-gray-900 flex flex-wrap justify-center"),OB(o,"type","file"),o.multiple=!0,OB(o,"class","hidden"),OB(i,"class","border-dashed border-2 border-gray-300 py-8 flex flex-col justify-center items-center"),OB(n,"class","file-upload svelte-10fctvd")},m(p,f){d&&d.m(p,f),TB(p,e,f),TB(p,n,f),SB(n,i),SB(i,r),SB(i,s),SB(i,o),t[9](o),SB(i,a),FU(l,i,null),c=!0,u||(h=[RB(n,"dragenter",t[3]),RB(n,"dragleave",t[4]),RB(n,"dragover",t[5]),RB(n,"drop",t[6])],u=!0)},p(t,n){t[2]?d||(d=Myt(),d.c(),d.m(e.parentNode,e)):d&&(d.d(1),d=null);const i={};8192&n&&(i.$$scope={dirty:n,ctx:t}),l.$set(i)},i(t){c||(EU(l.$$.fragment,t),c=!0)},o(t){MU(l.$$.fragment,t),c=!1},d(i){d&&d.d(i),i&&_B(e),i&&_B(n),t[9](null),zU(l),u=!1,nB(h)}}}function Ayt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[Iyt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),8198&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function Nyt(t,e,n){let i,{title:r}=e,{fileStream:s}=e,o=0,a=!1;const l=({dataTransfer:{types:t=[]}})=>t.indexOf("Files")>-1;function c(t){const e=[];for(let n=0;n<t.length;n++)e.push(t[n]);s.set(e)}return tU((async()=>{await pU(),await pU(),i.addEventListener("change",(t=>{c(t.target.files)}))})),t.$$set=t=>{"title"in t&&n(0,r=t.title),"fileStream"in t&&n(8,s=t.fileStream)},[r,i,a,function(t){t.preventDefault(),l(t)&&(o+=1,n(2,a=!0))},function(){o-=1,o<1&&n(2,a=!1)},function(t){l(t)&&t.preventDefault()},function(t){t.preventDefault(),n(2,a=!1),c(t.dataTransfer.files)},function(){i&&i.click()},s,function(t){aU[t?"unshift":"push"]((()=>{i=t,n(1,i)}))}]}class Ryt extends UU{constructor(t){super(),BU(this,t,Nyt,Ayt,rB,{title:0,fileStream:8})}}class Pyt extends xK{constructor(){super(),this.title="file upload",this.$files=new eK(Yj()),this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new Ryt({target:e,props:{title:this.title,fileStream:this.$files}}))}}function Oyt(...t){return new Pyt(...t)}function Lyt(t){let e;return{c(){e=MB("canvas"),OB(e,"class","w-full max-w-full")},m(n,i){TB(n,e,i),t[3](e)},p:Jz,d(n){n&&_B(e),t[3](null)}}}function Dyt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[Lyt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),34&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function Fyt(t,e,n){let i,{title:r}=e,{imageStream:s}=e,o=ZX;return tU((async()=>{await pU(),await pU();const t=i.getContext("2d");o=s.subscribe((e=>{if(!Array.isArray(e)||0!==e.length)if(e instanceof ImageData)n(1,i.width=e.width,i),n(1,i.height=e.height,i),t.putImageData(e,0,0);else if(Array.isArray(e))throw new Error("This component does not yet support multiple images")}))})),nU((()=>{o()})),t.$$set=t=>{"title"in t&&n(0,r=t.title),"imageStream"in t&&n(2,s=t.imageStream)},[r,i,s,function(t){aU[t?"unshift":"push"]((()=>{i=t,n(1,i)}))}]}class zyt extends UU{constructor(t){super(),BU(this,t,Fyt,Dyt,rB,{title:0,imageStream:2})}get title(){return this.$$.ctx[0]}set title(t){this.$$set({title:t}),vU()}get imageStream(){return this.$$.ctx[2]}set imageStream(t){this.$$set({imageStream:t}),vU()}}class Byt extends xK{constructor(t){super(),this.title="image display",vyt.set(this,void 0),WX(this,vyt,t,"f")}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new zyt({target:e,props:{title:this.title,imageStream:VX(this,vyt,"f")}}))}}function Uyt(...t){return new Byt(...t)}vyt=new WeakMap;var Vyt={exports:{}};!function(t){!function(e){var n=e.URL||e.webkitURL;function i(t){return!!n&&n.createObjectURL(t)}function r(t){return!!n&&n.revokeObjectURL(t)}function s(t,e){!t||"blob:"!==t.slice(0,5)||e&&e.noRevoke||r(t)}function o(t,n,i,r){if(!e.FileReader)return!1;var s=new FileReader;s.onload=function(){n.call(s,this.result)},i&&(s.onabort=s.onerror=function(){i.call(s,this.error)});var o=s[r||"readAsDataURL"];return o?(o.call(s,t),s):void 0}function a(t,e){return Object.prototype.toString.call(e)==="[object "+t+"]"}function l(t,n,r){function c(n,c){var u,h=document.createElement("img");function d(t,e){n!==c?t instanceof Error?c(t):((e=e||{}).image=t,n(e)):n&&n(t,e)}function p(n,s){s&&e.console&&console.log(s),n&&a("Blob",n)?u=i(t=n):(u=t,r&&r.crossOrigin&&(h.crossOrigin=r.crossOrigin)),h.src=u}return h.onerror=function(t){s(u,r),c&&c.call(h,t)},h.onload=function(){s(u,r);var e={originalWidth:h.naturalWidth||h.width,originalHeight:h.naturalHeight||h.height};try{l.transform(h,r,d,t,e)}catch(t){c&&c(t)}},"string"==typeof t?(l.requiresMetaData(r)?l.fetchBlob(t,p,r):p(),h):a("Blob",t)||a("File",t)?(u=i(t))?(h.src=u,h):o(t,(function(t){h.src=t}),c):void 0}return e.Promise&&"function"!=typeof n?(r=n,new Promise(c)):c(n,n)}l.requiresMetaData=function(t){return t&&t.meta},l.fetchBlob=function(t,e){e()},l.transform=function(t,e,n,i,r){n(t,r)},l.global=e,l.readFile=o,l.isInstanceOf=a,l.createObjectURL=i,l.revokeObjectURL=r,t.exports?t.exports=l:e.loadImage=l}("undefined"!=typeof window&&window||Ti)}(Vyt);var Wyt,Hyt=Vyt.exports,jyt={exports:{}};Wyt=function(t){var e=t.transform;t.createCanvas=function(e,n,i){if(i&&t.global.OffscreenCanvas)return new OffscreenCanvas(e,n);var r=document.createElement("canvas");return r.width=e,r.height=n,r},t.transform=function(n,i,r,s,o){e.call(t,t.scale(n,i,o),i,r,s,o)},t.transformCoordinates=function(){},t.getTransformedOptions=function(t,e){var n,i,r,s,o=e.aspectRatio;if(!o)return e;for(i in n={},e)Object.prototype.hasOwnProperty.call(e,i)&&(n[i]=e[i]);return n.crop=!0,(r=t.naturalWidth||t.width)/(s=t.naturalHeight||t.height)>o?(n.maxWidth=s*o,n.maxHeight=s):(n.maxWidth=r,n.maxHeight=r/o),n},t.drawImage=function(t,e,n,i,r,s,o,a,l){var c=e.getContext("2d");return!1===l.imageSmoothingEnabled?(c.msImageSmoothingEnabled=!1,c.imageSmoothingEnabled=!1):l.imageSmoothingQuality&&(c.imageSmoothingQuality=l.imageSmoothingQuality),c.drawImage(t,n,i,r,s,0,0,o,a),c},t.requiresCanvas=function(t){return t.canvas||t.crop||!!t.aspectRatio},t.scale=function(e,n,i){n=n||{},i=i||{};var r,s,o,a,l,c,u,h,d,p,f,m,g=e.getContext||t.requiresCanvas(n)&&!!t.global.HTMLCanvasElement,y=e.naturalWidth||e.width,b=e.naturalHeight||e.height,v=y,x=b;function w(){var t=Math.max((o||v)/v,(a||x)/x);t>1&&(v*=t,x*=t)}function S(){var t=Math.min((r||v)/v,(s||x)/x);t<1&&(v*=t,x*=t)}if(g&&(u=(n=t.getTransformedOptions(e,n,i)).left||0,h=n.top||0,n.sourceWidth?(l=n.sourceWidth,void 0!==n.right&&void 0===n.left&&(u=y-l-n.right)):l=y-u-(n.right||0),n.sourceHeight?(c=n.sourceHeight,void 0!==n.bottom&&void 0===n.top&&(h=b-c-n.bottom)):c=b-h-(n.bottom||0),v=l,x=c),r=n.maxWidth,s=n.maxHeight,o=n.minWidth,a=n.minHeight,g&&r&&s&&n.crop?(v=r,x=s,(f=l/c-r/s)<0?(c=s*l/r,void 0===n.top&&void 0===n.bottom&&(h=(b-c)/2)):f>0&&(l=r*c/s,void 0===n.left&&void 0===n.right&&(u=(y-l)/2))):((n.contain||n.cover)&&(o=r=r||o,a=s=s||a),n.cover?(S(),w()):(w(),S())),g){if((d=n.pixelRatio)>1&&(!e.style.width||Math.floor(parseFloat(e.style.width,10))!==Math.floor(y/d))&&(v*=d,x*=d),t.orientationCropBug&&!e.getContext&&(u||h||l!==y||c!==b)&&(f=e,e=t.createCanvas(y,b,!0),t.drawImage(f,e,0,0,y,b,y,b,n)),(p=n.downsamplingRatio)>0&&p<1&&v<l&&x<c)for(;l*p>v;)m=t.createCanvas(l*p,c*p,!0),t.drawImage(e,m,u,h,l,c,m.width,m.height,n),u=0,h=0,l=m.width,c=m.height,e=m;return m=t.createCanvas(v,x),t.transformCoordinates(m,n,i),d>1&&(m.style.width=m.width/d+"px"),t.drawImage(e,m,u,h,l,c,v,x,n).setTransform(1,0,0,1,0,0),m}return e.width=v,e.height=x,e}},Wyt(jyt.exports?Hyt:window.loadImage);var Gyt={exports:{}};!function(t){!function(e){e(t.exports?Hyt:window.loadImage)}((function(t){var e=t.global,n=t.transform,i=e.Blob&&(Blob.prototype.slice||Blob.prototype.webkitSlice||Blob.prototype.mozSlice),r=e.ArrayBuffer&&ArrayBuffer.prototype.slice||function(t,e){e=e||this.byteLength-t;var n=new Uint8Array(this,t,e),i=new Uint8Array(e);return i.set(n),i.buffer},s={jpeg:{65505:[],65517:[]}};function o(n,o,a,l){var c=this;function u(o,u){if(!(e.DataView&&i&&n&&n.size>=12&&"image/jpeg"===n.type))return o(l);var h=a.maxMetaDataSize||262144;t.readFile(i.call(n,0,h),(function(t){var e=new DataView(t);if(65496!==e.getUint16(0))return u(new Error("Invalid JPEG file: Missing JPEG marker."));for(var n,i,h,d,p=2,f=e.byteLength-4,m=p;p<f&&((n=e.getUint16(p))>=65504&&n<=65519||65534===n);){if(p+(i=e.getUint16(p+2)+2)>e.byteLength){console.log("Invalid JPEG metadata: Invalid segment size.");break}if((h=s.jpeg[n])&&!a.disableMetaDataParsers)for(d=0;d<h.length;d+=1)h[d].call(c,e,p,i,l,a);m=p+=i}!a.disableImageHead&&m>6&&(l.imageHead=r.call(t,0,m)),o(l)}),u,"readAsArrayBuffer")||o(l)}return a=a||{},e.Promise&&"function"!=typeof o?(l=a=o||{},new Promise(u)):(l=l||{},u(o,o))}function a(t,e,n){return t&&e&&n?new Blob([n,i.call(t,e.byteLength)],{type:"image/jpeg"}):null}t.transform=function(i,r,s,a,l){t.requiresMetaData(r)?o(a,(function(o){o!==l&&(e.console&&console.log(o),o=l),n.call(t,i,r,s,a,o)}),r,l=l||{}):n.apply(t,arguments)},t.blobSlice=i,t.bufferSlice=r,t.replaceHead=function(t,n,i){var r={maxMetaDataSize:1024,disableMetaDataParsers:!0};if(!i&&e.Promise)return o(t,r).then((function(e){return a(t,e.imageHead,n)}));o(t,(function(e){i(a(t,e.imageHead,n))}),r)},t.parseMetaData=o,t.metaDataParsers=s}))}(Gyt);!function(t){!function(e){e(t.exports?Hyt:window.loadImage)}((function(t){var e=t.global;e.fetch&&e.Request&&e.Response&&e.Response.prototype.blob?t.fetchBlob=function(t,n,i){function r(t){return t.blob()}if(e.Promise&&"function"!=typeof n)return fetch(new Request(t,n)).then(r);fetch(new Request(t,i)).then(r).then(n).catch((function(t){n(null,t)}))}:e.XMLHttpRequest&&""===(new XMLHttpRequest).responseType&&(t.fetchBlob=function(t,n,i){function r(e,n){i=i||{};var r=new XMLHttpRequest;r.open(i.method||"GET",t),i.headers&&Object.keys(i.headers).forEach((function(t){r.setRequestHeader(t,i.headers[t])})),r.withCredentials="include"===i.credentials,r.responseType="blob",r.onload=function(){e(r.response)},r.onerror=r.onabort=r.ontimeout=function(t){e===n?n(null,t):n(t)},r.send(i.body)}return e.Promise&&"function"!=typeof n?(i=n,new Promise(r)):r(n,n)})}))}({exports:{}});var qyt={exports:{}};!function(t){!function(e){e(t.exports?Hyt:window.loadImage)}((function(t){function e(t){t&&(Object.defineProperty(this,"map",{value:this.ifds[t].map}),Object.defineProperty(this,"tags",{value:this.tags&&this.tags[t]||{}}))}e.prototype.map={Orientation:274,Thumbnail:"ifd1",Blob:513,Exif:34665,GPSInfo:34853,Interoperability:40965},e.prototype.ifds={ifd1:{name:"Thumbnail",map:e.prototype.map},34665:{name:"Exif",map:{}},34853:{name:"GPSInfo",map:{}},40965:{name:"Interoperability",map:{}}},e.prototype.get=function(t){return this[t]||this[this.map[t]]};var n={1:{getValue:function(t,e){return t.getUint8(e)},size:1},2:{getValue:function(t,e){return String.fromCharCode(t.getUint8(e))},size:1,ascii:!0},3:{getValue:function(t,e,n){return t.getUint16(e,n)},size:2},4:{getValue:function(t,e,n){return t.getUint32(e,n)},size:4},5:{getValue:function(t,e,n){return t.getUint32(e,n)/t.getUint32(e+4,n)},size:8},9:{getValue:function(t,e,n){return t.getInt32(e,n)},size:4},10:{getValue:function(t,e,n){return t.getInt32(e,n)/t.getInt32(e+4,n)},size:8}};function i(t,e,i,r,s,o){var a,l,c,u,h,d,p=n[r];if(p){if(!((l=(a=p.size*s)>4?e+t.getUint32(i+8,o):i+8)+a>t.byteLength)){if(1===s)return p.getValue(t,l,o);for(c=[],u=0;u<s;u+=1)c[u]=p.getValue(t,l+u*p.size,o);if(p.ascii){for(h="",u=0;u<c.length&&"\0"!==(d=c[u]);u+=1)h+=d;return h}return c}console.log("Invalid Exif data: Invalid data offset.")}else console.log("Invalid Exif data: Invalid tag type.")}function r(t,e,n){return(!t||t[n])&&(!e||!0!==e[n])}function s(t,e,n,s,o,a,l,c){var u,h,d,p,f,m;if(n+6>t.byteLength)console.log("Invalid Exif data: Invalid directory offset.");else{if(!((h=n+2+12*(u=t.getUint16(n,s)))+4>t.byteLength)){for(d=0;d<u;d+=1)p=n+2+12*d,r(l,c,f=t.getUint16(p,s))&&(m=i(t,e,p,t.getUint16(p+2,s),t.getUint32(p+4,s),s),o[f]=m,a&&(a[f]=p));return t.getUint32(h,s)}console.log("Invalid Exif data: Invalid directory size.")}}n[7]=n[1],t.parseExifData=function(n,i,o,a,l){if(!l.disableExif){var c,u,h,d=l.includeExifTags,p=l.excludeExifTags||{34665:{37500:!0}},f=i+10;if(1165519206===n.getUint32(i+4))if(f+8>n.byteLength)console.log("Invalid Exif data: Invalid segment size.");else if(0===n.getUint16(i+8)){switch(n.getUint16(f)){case 18761:c=!0;break;case 19789:c=!1;break;default:return void console.log("Invalid Exif data: Invalid byte alignment marker.")}42===n.getUint16(f+2,c)?(u=n.getUint32(f+4,c),a.exif=new e,l.disableExifOffsets||(a.exifOffsets=new e,a.exifTiffOffset=f,a.exifLittleEndian=c),(u=s(n,f,f+u,c,a.exif,a.exifOffsets,d,p))&&r(d,p,"ifd1")&&(a.exif.ifd1=u,a.exifOffsets&&(a.exifOffsets.ifd1=f+u)),Object.keys(a.exif.ifds).forEach((function(t){!function(t,n,i,r,o,a,l){var c=t.exif[n];c&&(t.exif[n]=new e(n),t.exifOffsets&&(t.exifOffsets[n]=new e(n)),s(i,r,r+c,o,t.exif[n],t.exifOffsets&&t.exifOffsets[n],a&&a[n],l&&l[n]))}(a,t,n,f,c,d,p)})),(h=a.exif.ifd1)&&h[513]&&(h[513]=function(e,n,i){if(i){if(!(n+i>e.byteLength))return new Blob([t.bufferSlice.call(e.buffer,n,n+i)],{type:"image/jpeg"});console.log("Invalid Exif data: Invalid thumbnail data.")}}(n,f+h[513],h[514]))):console.log("Invalid Exif data: Missing TIFF marker.")}else console.log("Invalid Exif data: Missing byte alignment offset.")}},t.metaDataParsers.jpeg[65505].push(t.parseExifData),t.exifWriters={274:function(t,e,n){var i=e.exifOffsets[274];return i?(new DataView(t,i+8,2).setUint16(0,n,e.exifLittleEndian),t):t}},t.writeExifData=function(e,n,i,r){return t.exifWriters[n.exif.map[i]](e,n,r)},t.ExifMap=e}))}(qyt);!function(t){!function(e){e(t.exports?Hyt:window.loadImage)}((function(t){var e=t.ExifMap.prototype;e.tags={256:"ImageWidth",257:"ImageHeight",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",274:"Orientation",277:"SamplesPerPixel",284:"PlanarConfiguration",530:"YCbCrSubSampling",531:"YCbCrPositioning",282:"XResolution",283:"YResolution",296:"ResolutionUnit",273:"StripOffsets",278:"RowsPerStrip",279:"StripByteCounts",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",301:"TransferFunction",318:"WhitePoint",319:"PrimaryChromaticities",529:"YCbCrCoefficients",532:"ReferenceBlackWhite",306:"DateTime",270:"ImageDescription",271:"Make",272:"Model",305:"Software",315:"Artist",33432:"Copyright",34665:{36864:"ExifVersion",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",42240:"Gamma",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37500:"MakerNote",37510:"UserComment",40964:"RelatedSoundFile",36867:"DateTimeOriginal",36868:"DateTimeDigitized",36880:"OffsetTime",36881:"OffsetTimeOriginal",36882:"OffsetTimeDigitized",37520:"SubSecTime",37521:"SubSecTimeOriginal",37522:"SubSecTimeDigitized",33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"PhotographicSensitivity",34856:"OECF",34864:"SensitivityType",34865:"StandardOutputSensitivity",34866:"RecommendedExposureIndex",34867:"ISOSpeed",34868:"ISOSpeedLatitudeyyy",34869:"ISOSpeedLatitudezzz",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBias",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37396:"SubjectArea",37386:"FocalLength",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRatio",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",42016:"ImageUniqueID",42032:"CameraOwnerName",42033:"BodySerialNumber",42034:"LensSpecification",42035:"LensMake",42036:"LensModel",42037:"LensSerialNumber"},34853:{0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential",31:"GPSHPositioningError"},40965:{1:"InteroperabilityIndex"}},e.tags.ifd1=e.tags,e.stringValues={ExposureProgram:{0:"Undefined",1:"Manual",2:"Normal program",3:"Aperture priority",4:"Shutter priority",5:"Creative program",6:"Action program",7:"Portrait mode",8:"Landscape mode"},MeteringMode:{0:"Unknown",1:"Average",2:"CenterWeightedAverage",3:"Spot",4:"MultiSpot",5:"Pattern",6:"Partial",255:"Other"},LightSource:{0:"Unknown",1:"Daylight",2:"Fluorescent",3:"Tungsten (incandescent light)",4:"Flash",9:"Fine weather",10:"Cloudy weather",11:"Shade",12:"Daylight fluorescent (D 5700 - 7100K)",13:"Day white fluorescent (N 4600 - 5400K)",14:"Cool white fluorescent (W 3900 - 4500K)",15:"White fluorescent (WW 3200 - 3700K)",17:"Standard light A",18:"Standard light B",19:"Standard light C",20:"D55",21:"D65",22:"D75",23:"D50",24:"ISO studio tungsten",255:"Other"},Flash:{0:"Flash did not fire",1:"Flash fired",5:"Strobe return light not detected",7:"Strobe return light detected",9:"Flash fired, compulsory flash mode",13:"Flash fired, compulsory flash mode, return light not detected",15:"Flash fired, compulsory flash mode, return light detected",16:"Flash did not fire, compulsory flash mode",24:"Flash did not fire, auto mode",25:"Flash fired, auto mode",29:"Flash fired, auto mode, return light not detected",31:"Flash fired, auto mode, return light detected",32:"No flash function",65:"Flash fired, red-eye reduction mode",69:"Flash fired, red-eye reduction mode, return light not detected",71:"Flash fired, red-eye reduction mode, return light detected",73:"Flash fired, compulsory flash mode, red-eye reduction mode",77:"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",79:"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",89:"Flash fired, auto mode, red-eye reduction mode",93:"Flash fired, auto mode, return light not detected, red-eye reduction mode",95:"Flash fired, auto mode, return light detected, red-eye reduction mode"},SensingMethod:{1:"Undefined",2:"One-chip color area sensor",3:"Two-chip color area sensor",4:"Three-chip color area sensor",5:"Color sequential area sensor",7:"Trilinear sensor",8:"Color sequential linear sensor"},SceneCaptureType:{0:"Standard",1:"Landscape",2:"Portrait",3:"Night scene"},SceneType:{1:"Directly photographed"},CustomRendered:{0:"Normal process",1:"Custom process"},WhiteBalance:{0:"Auto white balance",1:"Manual white balance"},GainControl:{0:"None",1:"Low gain up",2:"High gain up",3:"Low gain down",4:"High gain down"},Contrast:{0:"Normal",1:"Soft",2:"Hard"},Saturation:{0:"Normal",1:"Low saturation",2:"High saturation"},Sharpness:{0:"Normal",1:"Soft",2:"Hard"},SubjectDistanceRange:{0:"Unknown",1:"Macro",2:"Close view",3:"Distant view"},FileSource:{3:"DSC"},ComponentsConfiguration:{0:"",1:"Y",2:"Cb",3:"Cr",4:"R",5:"G",6:"B"},Orientation:{1:"Original",2:"Horizontal flip",3:"Rotate 180 CCW",4:"Vertical flip",5:"Vertical flip + Rotate 90 CW",6:"Rotate 90 CW",7:"Horizontal flip + Rotate 90 CW",8:"Rotate 90 CCW"}},e.getText=function(t){var e=this.get(t);switch(t){case"LightSource":case"Flash":case"MeteringMode":case"ExposureProgram":case"SensingMethod":case"SceneCaptureType":case"SceneType":case"CustomRendered":case"WhiteBalance":case"GainControl":case"Contrast":case"Saturation":case"Sharpness":case"SubjectDistanceRange":case"FileSource":case"Orientation":return this.stringValues[t][e];case"ExifVersion":case"FlashpixVersion":if(!e)return;return String.fromCharCode(e[0],e[1],e[2],e[3]);case"ComponentsConfiguration":if(!e)return;return this.stringValues[t][e[0]]+this.stringValues[t][e[1]]+this.stringValues[t][e[2]]+this.stringValues[t][e[3]];case"GPSVersionID":if(!e)return;return e[0]+"."+e[1]+"."+e[2]+"."+e[3]}return String(e)},e.getAll=function(){var t,e,n,i={};for(t in this)Object.prototype.hasOwnProperty.call(this,t)&&((e=this[t])&&e.getAll?i[this.ifds[t].name]=e.getAll():(n=this.tags[t])&&(i[n]=this.getText(n)));return i},e.getName=function(t){var e=this.tags[t];return"object"==typeof e?this.ifds[t].name:e},function(){var t,n,i,r=e.tags;for(t in r)if(Object.prototype.hasOwnProperty.call(r,t))if(n=e.ifds[t])for(t in i=r[t])Object.prototype.hasOwnProperty.call(i,t)&&(n.map[i[t]]=Number(t));else e.map[r[t]]=Number(t)}()}))}({exports:{}});var Xyt={exports:{}};!function(t){!function(e){e(t.exports?Hyt:window.loadImage)}((function(t){function e(){}function n(t,e,n,i,r){return"binary"===e.types[t]?new Blob([n.buffer.slice(i,i+r)]):"Uint16"===e.types[t]?n.getUint16(i):function(t,e,n){for(var i="",r=e+n,s=e;s<r;s+=1)i+=String.fromCharCode(t.getUint8(s));return i}(n,i,r)}function i(t,e){return void 0===t?e:t instanceof Array?(t.push(e),t):[t,e]}function r(t,e,r,s,o,a){for(var l,c,u,h=e+r,d=e;d<h;)28===t.getUint8(d)&&2===t.getUint8(d+1)&&(u=t.getUint8(d+2),o&&!o[u]||a&&a[u]||(c=t.getInt16(d+3),l=n(u,s.iptc,t,d+5,c),s.iptc[u]=i(s.iptc[u],l),s.iptcOffsets&&(s.iptcOffsets[u]=d))),d+=1}function s(t,e){return 943868237===t.getUint32(e)&&1028===t.getUint16(e+4)}function o(t,e){var n=t.getUint8(e+7);return n%2!=0&&(n+=1),0===n&&(n=4),n}e.prototype.map={ObjectName:5},e.prototype.types={0:"Uint16",200:"Uint16",201:"Uint16",202:"binary"},e.prototype.get=function(t){return this[t]||this[this.map[t]]},t.parseIptcData=function(t,n,i,a,l){if(!l.disableIptc)for(var c=n+i;n+8<c;){if(s(t,n)){var u=o(t,n),h=n+8+u;if(h>c){console.log("Invalid IPTC data: Invalid segment offset.");break}var d=t.getUint16(n+6+u);if(n+d>c){console.log("Invalid IPTC data: Invalid segment size.");break}return a.iptc=new e,l.disableIptcOffsets||(a.iptcOffsets=new e),void r(t,h,d,a,l.includeIptcTags,l.excludeIptcTags||{202:!0})}n+=1}},t.metaDataParsers.jpeg[65517].push(t.parseIptcData),t.IptcMap=e}))}(Xyt);!function(t){!function(e){e(t.exports?Hyt:window.loadImage)}((function(t){var e=t.IptcMap.prototype;e.tags={0:"ApplicationRecordVersion",3:"ObjectTypeReference",4:"ObjectAttributeReference",5:"ObjectName",7:"EditStatus",8:"EditorialUpdate",10:"Urgency",12:"SubjectReference",15:"Category",20:"SupplementalCategories",22:"FixtureIdentifier",25:"Keywords",26:"ContentLocationCode",27:"ContentLocationName",30:"ReleaseDate",35:"ReleaseTime",37:"ExpirationDate",38:"ExpirationTime",40:"SpecialInstructions",42:"ActionAdvised",45:"ReferenceService",47:"ReferenceDate",50:"ReferenceNumber",55:"DateCreated",60:"TimeCreated",62:"DigitalCreationDate",63:"DigitalCreationTime",65:"OriginatingProgram",70:"ProgramVersion",75:"ObjectCycle",80:"Byline",85:"BylineTitle",90:"City",92:"Sublocation",95:"State",100:"CountryCode",101:"Country",103:"OriginalTransmissionReference",105:"Headline",110:"Credit",115:"Source",116:"CopyrightNotice",118:"Contact",120:"Caption",121:"LocalCaption",122:"Writer",125:"RasterizedCaption",130:"ImageType",131:"ImageOrientation",135:"LanguageIdentifier",150:"AudioType",151:"AudioSamplingRate",152:"AudioSamplingResolution",153:"AudioDuration",154:"AudioOutcue",184:"JobID",185:"MasterDocumentID",186:"ShortDocumentID",187:"UniqueDocumentID",188:"OwnerID",200:"ObjectPreviewFileFormat",201:"ObjectPreviewFileVersion",202:"ObjectPreviewData",221:"Prefs",225:"ClassifyState",228:"SimilarityIndex",230:"DocumentNotes",231:"DocumentHistory",232:"ExifCameraInfo",255:"CatalogSets"},e.stringValues={10:{0:"0 (reserved)",1:"1 (most urgent)",2:"2",3:"3",4:"4",5:"5 (normal urgency)",6:"6",7:"7",8:"8 (least urgent)",9:"9 (user-defined priority)"},75:{a:"Morning",b:"Both Morning and Evening",p:"Evening"},131:{L:"Landscape",P:"Portrait",S:"Square"}},e.getText=function(t){var e=this.get(t),n=this.map[t],i=this.stringValues[n];return i?i[e]:String(e)},e.getAll=function(){var t,e,n={};for(t in this)Object.prototype.hasOwnProperty.call(this,t)&&(e=this.tags[t])&&(n[e]=this.getText(e));return n},e.getName=function(t){return this.tags[t]},function(){var t,n=e.tags,i=e.map||{};for(t in n)Object.prototype.hasOwnProperty.call(n,t)&&(i[n[t]]=Number(t))}()}))}({exports:{}});!function(t){!function(e){e(t.exports?Hyt:window.loadImage)}((function(t){var e=t.transform,n=t.requiresCanvas,i=t.requiresMetaData,r=t.transformCoordinates,s=t.getTransformedOptions;function o(e,n){var i=e&&e.orientation;return!0===i&&!t.orientation||1===i&&t.orientation||(!n||t.orientation)&&i>1&&i<9}function a(t,e){return t!==e&&(1===t&&e>1&&e<9||t>1&&t<9)}function l(t,e){if(e>1&&e<9)switch(t){case 2:case 4:return e>4;case 5:case 7:return e%2==0;case 6:case 8:return 2===e||4===e||5===e||7===e}return!1}!function(t){if(t.global.document){var e=document.createElement("img");e.onload=function(){if(t.orientation=2===e.width&&3===e.height,t.orientation){var n=t.createCanvas(1,1,!0).getContext("2d");n.drawImage(e,1,1,1,1,0,0,1,1),t.orientationCropBug="255,255,255,255"!==n.getImageData(0,0,1,1).data.toString()}},e.src="data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAIAAwMBEQACEQEDEQH/xABRAAEAAAAAAAAAAAAAAAAAAAAKEAEBAQADAQEAAAAAAAAAAAAGBQQDCAkCBwEBAAAAAAAAAAAAAAAAAAAAABEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AG8T9NfSMEVMhQvoP3fFiRZ+MTHDifa/95OFSZU5OzRzxkyejv8ciEfhSceSXGjS8eSdLnZc2HDm4M3BxcXwH/9k="}}(t),t.requiresCanvas=function(e){return o(e)||n.call(t,e)},t.requiresMetaData=function(e){return o(e,!0)||i.call(t,e)},t.transform=function(n,i,r,s,o){e.call(t,n,i,(function(e,n){if(n){var i=t.orientation&&n.exif&&n.exif.get("Orientation");if(i>4&&i<9){var s=n.originalWidth,o=n.originalHeight;n.originalWidth=o,n.originalHeight=s}}r(e,n)}),s,o)},t.getTransformedOptions=function(e,n,i){var r=s.call(t,e,n),o=i.exif&&i.exif.get("Orientation"),c=r.orientation,u=t.orientation&&o;if(!0===c&&(c=o),!a(c,u))return r;var h=r.top,d=r.right,p=r.bottom,f=r.left,m={};for(var g in r)Object.prototype.hasOwnProperty.call(r,g)&&(m[g]=r[g]);if(m.orientation=c,(c>4&&!(u>4)||c<5&&u>4)&&(m.maxWidth=r.maxHeight,m.maxHeight=r.maxWidth,m.minWidth=r.minHeight,m.minHeight=r.minWidth,m.sourceWidth=r.sourceHeight,m.sourceHeight=r.sourceWidth),u>1){switch(u){case 2:d=r.left,f=r.right;break;case 3:h=r.bottom,d=r.left,p=r.top,f=r.right;break;case 4:h=r.bottom,p=r.top;break;case 5:h=r.left,d=r.bottom,p=r.right,f=r.top;break;case 6:h=r.left,d=r.top,p=r.right,f=r.bottom;break;case 7:h=r.right,d=r.top,p=r.left,f=r.bottom;break;case 8:h=r.right,d=r.bottom,p=r.left,f=r.top}if(l(c,u)){var y=h,b=d;h=p,d=f,p=y,f=b}}switch(m.top=h,m.right=d,m.bottom=p,m.left=f,c){case 2:m.right=f,m.left=d;break;case 3:m.top=p,m.right=f,m.bottom=h,m.left=d;break;case 4:m.top=p,m.bottom=h;break;case 5:m.top=f,m.right=p,m.bottom=d,m.left=h;break;case 6:m.top=d,m.right=p,m.bottom=f,m.left=h;break;case 7:m.top=d,m.right=h,m.bottom=f,m.left=p;break;case 8:m.top=f,m.right=h,m.bottom=d,m.left=p}return m},t.transformCoordinates=function(e,n,i){r.call(t,e,n,i);var s=n.orientation,o=t.orientation&&i.exif&&i.exif.get("Orientation");if(a(s,o)){var c=e.getContext("2d"),u=e.width,h=e.height,d=u,p=h;switch((s>4&&!(o>4)||s<5&&o>4)&&(e.width=h,e.height=u),s>4&&(d=h,p=u),o){case 2:c.translate(d,0),c.scale(-1,1);break;case 3:c.translate(d,p),c.rotate(Math.PI);break;case 4:c.translate(0,p),c.scale(1,-1);break;case 5:c.rotate(-.5*Math.PI),c.scale(-1,1);break;case 6:c.rotate(-.5*Math.PI),c.translate(-d,0);break;case 7:c.rotate(-.5*Math.PI),c.translate(-d,p),c.scale(1,-1);break;case 8:c.rotate(.5*Math.PI),c.translate(0,-p)}switch(l(s,o)&&(c.translate(d,p),c.rotate(Math.PI)),s){case 2:c.translate(u,0),c.scale(-1,1);break;case 3:c.translate(u,h),c.rotate(Math.PI);break;case 4:c.translate(0,h),c.scale(1,-1);break;case 5:c.rotate(.5*Math.PI),c.scale(1,-1);break;case 6:c.rotate(.5*Math.PI),c.translate(0,-h);break;case 7:c.rotate(.5*Math.PI),c.translate(u,-h),c.scale(-1,1);break;case 8:c.rotate(-.5*Math.PI),c.translate(-u,0)}}}}))}({exports:{}});var Kyt,Yyt,Zyt=_i(Hyt);function Jyt(t,e,n){const i=t.slice();return i[18]=e[n],i}function Qyt(t){let e;return{c(){e=MB("div"),e.innerHTML='<i><svg class="fill-current w-12 h-12 mb-3 text-blue-700" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19.479 10.092c-.212-3.951-3.473-7.092-7.479-7.092-4.005 0-7.267 3.141-7.479 7.092-2.57.463-4.521 2.706-4.521 5.408 0 3.037 2.463 5.5 5.5 5.5h13c3.037 0 5.5-2.463 5.5-5.5 0-2.702-1.951-4.945-4.521-5.408zm-7.479-1.092l4 4h-3v4h-2v-4h-3l4-4z"></path></svg></i> \n      <p class="text-lg text-blue-700">Drop files to upload</p>',OB(e,"class","overlay svelte-u8vb5e")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function tbt(t){let e;return{c(){e=IB("Upload a file")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function ebt(t){let e,n;return{c(){e=MB("img"),OB(e,"class","mx-auto my-2 w-32"),oB(e.src,n=t[18]||"https://user-images.githubusercontent.com/507615/54591670-ac0a0180-4a65-11e9-846c-e55ffce0fe7b.png")||OB(e,"src",n),OB(e,"alt","no data")},m(t,n){TB(t,e,n)},p(t,i){8&i&&!oB(e.src,n=t[18]||"https://user-images.githubusercontent.com/507615/54591670-ac0a0180-4a65-11e9-846c-e55ffce0fe7b.png")&&OB(e,"src",n)},d(t){t&&_B(e)}}}function nbt(t){let e,n,i,r,s,o,a,l,c,u,h,d,p,f=t[2]&&Qyt();l=new HU({props:{$$slots:{default:[tbt]},$$scope:{ctx:t}}}),l.$on("click",t[8]);let m=t[3],g=[];for(let e=0;e<m.length;e+=1)g[e]=ebt(Jyt(t,m,e));return{c(){f&&f.c(),e=AB(),n=MB("div"),i=MB("div"),r=MB("p"),r.innerHTML="<span>Drag and drop an image or</span>",s=AB(),o=MB("input"),a=AB(),DU(l.$$.fragment),c=AB(),u=MB("div");for(let t=0;t<g.length;t+=1)g[t].c();OB(r,"class","mb-3 font-semibold text-gray-900 flex flex-wrap justify-center"),OB(o,"type","file"),o.multiple=!0,OB(o,"class","hidden"),OB(i,"class","border-dashed border-2 border-gray-300 py-8 flex flex-col justify-center items-center"),OB(u,"class","flex flex-wrap"),OB(n,"class","image-upload svelte-u8vb5e")},m(m,y){f&&f.m(m,y),TB(m,e,y),TB(m,n,y),SB(n,i),SB(i,r),SB(i,s),SB(i,o),t[13](o),SB(i,a),FU(l,i,null),SB(n,c),SB(n,u);for(let t=0;t<g.length;t+=1)g[t]&&g[t].m(u,null);h=!0,d||(p=[RB(n,"dragenter",t[4]),RB(n,"dragleave",t[5]),RB(n,"dragover",t[6]),RB(n,"drop",t[7])],d=!0)},p(t,n){t[2]?f||(f=Qyt(),f.c(),f.m(e.parentNode,e)):f&&(f.d(1),f=null);const i={};if(2097152&n&&(i.$$scope={dirty:n,ctx:t}),l.$set(i),8&n){let e;for(m=t[3],e=0;e<m.length;e+=1){const i=Jyt(t,m,e);g[e]?g[e].p(i,n):(g[e]=ebt(i),g[e].c(),g[e].m(u,null))}for(;e<g.length;e+=1)g[e].d(1);g.length=m.length}},i(t){h||(EU(l.$$.fragment,t),h=!0)},o(t){MU(l.$$.fragment,t),h=!1},d(i){f&&f.d(i),i&&_B(e),i&&_B(n),t[13](null),zU(l),EB(g,i),d=!1,nB(p)}}}function ibt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[nbt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),2097166&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function rbt(t,e,n){let i,{title:r}=e,{images:s}=e,{thumbnails:o}=e,{width:a}=e,{height:l}=e,c=0,u=!1,h=[];const d=({dataTransfer:{types:t=[]}})=>t.indexOf("Files")>-1;async function p(t){const{image:e}=await Zyt(t,{...a>0&&{maxWidth:a},...l>0&&{maxHeight:l},cover:!0,crop:!0,canvas:!0,crossOrigin:"Anonymous"}),{image:n}=await Zyt(t,{maxWidth:60,maxHeight:60,cover:!0,crop:!0,canvas:!0,crossOrigin:"Anonymous"}),i=e,r=i.getContext("2d").getImageData(0,0,a||i.width,l||i.height),c=n.toDataURL("image/jpeg");o.set(c),s.set(r)}async function f(t){n(3,h=[]);let e=Promise.resolve();for(let i=0;i<t.length;i++){const r=t[i];r.type.match("image.*")&&(e=e.then((()=>p(r)))),n(2,u=!1),c=0}await e}return tU((async()=>{await pU(),await pU(),i.addEventListener("change",(t=>{f(t.target.files)}))})),t.$$set=t=>{"title"in t&&n(0,r=t.title),"images"in t&&n(9,s=t.images),"thumbnails"in t&&n(10,o=t.thumbnails),"width"in t&&n(11,a=t.width),"height"in t&&n(12,l=t.height)},[r,i,u,h,function(t){t.preventDefault(),d(t)&&(c+=1,n(2,u=!0))},function(){c-=1,c<1&&n(2,u=!1)},function(t){d(t)&&t.preventDefault()},function(t){t.preventDefault(),f(t.dataTransfer.files)},function(){i&&i.click()},s,o,a,l,function(t){aU[t?"unshift":"push"]((()=>{i=t,n(1,i)}))}]}class sbt extends UU{constructor(t){super(),BU(this,t,rbt,ibt,rB,{title:0,images:9,thumbnails:10,width:11,height:12})}}class obt extends xK{constructor({width:t=0,height:e=0}={}){super(),this.title="image upload",this.$images=new eK(Yj()),this.$thumbnails=new eK(Yj()),Kyt.set(this,void 0),Yyt.set(this,void 0),WX(this,Kyt,t,"f"),WX(this,Yyt,e,"f"),this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new sbt({target:e,props:{title:this.title,images:this.$images,thumbnails:this.$thumbnails,width:VX(this,Kyt,"f"),height:VX(this,Yyt,"f")}}))}}function abt(...t){return new obt(...t)}function lbt(t,e){let n=0;for(let i=0;i<t.length;i++)n+=(t[i]-e[i])*(t[i]-e[i]);return n}Kyt=new WeakMap,Yyt=new WeakMap;const cbt={distanceFunction:lbt};function ubt(t,e,n=cbt){const i=n.distanceFunction||cbt.distanceFunction,r=n.similarityFunction||cbt.similarityFunction;let s=-1;if("function"==typeof r){let n=Number.MIN_VALUE;for(let i=0;i<t.length;i++){const o=r(e,t[i]);o>n&&(n=o,s=i)}}else{if("function"!=typeof i)throw new Error("A similarity or distance function it's required");{let n=Number.MAX_VALUE;for(let r=0;r<t.length;r++){const o=i(e,t[r]);o<n&&(n=o,s=r)}}}return s}function hbt(t,e,n,i){for(var r=0;r<t.length;r++)n[r]=ubt(e,t[r],{distanceFunction:i});return n}function dbt(t,e){const n=65535&(t>>>=0);return((t-n)*(e>>>=0)>>>0)+n*e>>>0}class pbt{constructor(t=Date.now()){this.state=new Uint32Array(4),this.init(t),this.random=this.getFloat.bind(this)}getUint32(){return this.nextState(),this.state[3]+this.state[2]>>>0}getFloat(){return 5.960464477539063e-8*(this.getUint32()>>>8)}init(t){if(!Number.isInteger(t))throw new TypeError("seed must be an integer");this.state[0]=t,this.state[1]=0,this.state[2]=0,this.state[3]=0;for(let t=1;t<8;t++)this.state[3&t]^=t+dbt(1812433253,this.state[t-1&3]^this.state[t-1&3]>>>30>>>0)>>>0;this.periodCertification();for(let t=0;t<8;t++)this.nextState()}periodCertification(){0===this.state[0]&&0===this.state[1]&&0===this.state[2]&&0===this.state[3]&&(this.state[0]=88,this.state[1]=83,this.state[2]=65,this.state[3]=68)}nextState(){let t=this.state[0];t^=t<<15,t^=t>>>18,t^=this.state[3]<<11,this.state[0]=this.state[1],this.state[1]=this.state[2],this.state[2]=this.state[3],this.state[3]=t}}function fbt(t,e={},n=Math.random){const{size:i=1,replace:r=!1,probabilities:s}=e;let o,a;if(o="number"==typeof t?function(t){const e=[];for(let n=0;n<t;n++)e.push(n);return e}(t):t.slice(),s){if(!r)throw new Error("choice with probabilities and no replacement is not implemented");if(s.length!==o.length)throw new Error("the length of probabilities option should be equal to the number of choices");a=[s[0]];for(let t=1;t<s.length;t++)a[t]=a[t-1]+s[t];if(Math.abs(1-a[a.length-1])>1e-8)throw new Error(`probabilities should sum to 1, but instead sums to ${a[a.length-1]}`)}if(!1===r&&i>o.length)throw new Error("size option is too large");const l=[];for(let t=0;t<i;t++){const t=mbt(o.length,n,a);l.push(o[t]),r||o.splice(t,1)}return l}function mbt(t,e,n){const i=e();if(n){let t=0;for(;i>n[t];)t++;return t}return Math.floor(i*t)}class gbt{constructor(t=Math.random){if("number"==typeof t){const e=new pbt(t);this.randomGenerator=e.random}else this.randomGenerator=t}choice(t,e){return fbt(t,e,this.randomGenerator)}random(){return this.randomGenerator()}randInt(t,e){return void 0===e&&(e=t,t=0),t+Math.floor(this.randomGenerator()*(e-t))}randomSample(t){const e=[];for(let n=0;n<t;n++)e.push(this.random());return e}}const ybt=Object.prototype.toString;function bbt(t){return ybt.call(t).endsWith("Array]")}function vbt(t){var e,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!bbt(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");if(void 0!==n.output){if(!bbt(n.output))throw new TypeError("output option must be an array if specified");e=n.output}else e=new Array(t.length);var i=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!bbt(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var n=e.fromIndex,i=void 0===n?0:n,r=e.toIndex,s=void 0===r?t.length:r;if(i<0||i>=t.length||!Number.isInteger(i))throw new Error("fromIndex must be a positive integer smaller than length");if(s<=i||s>t.length||!Number.isInteger(s))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var o=t[i],a=i+1;a<s;a++)t[a]<o&&(o=t[a]);return o}(t),r=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!bbt(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var n=e.fromIndex,i=void 0===n?0:n,r=e.toIndex,s=void 0===r?t.length:r;if(i<0||i>=t.length||!Number.isInteger(i))throw new Error("fromIndex must be a positive integer smaller than length");if(s<=i||s>t.length||!Number.isInteger(s))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var o=t[i],a=i+1;a<s;a++)t[a]>o&&(o=t[a]);return o}(t);if(i===r)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var s=n.min,o=void 0===s?n.autoMinMax?i:0:s,a=n.max,l=void 0===a?n.autoMinMax?r:1:a;if(o>=l)throw new RangeError("min option must be smaller than max option");for(var c=(l-o)/(r-i),u=0;u<t.length;u++)e[u]=(t[u]-i)*c+o;return e}const xbt=" ".repeat(2),wbt=" ".repeat(4);function Sbt(t,e={}){const{maxRows:n=15,maxColumns:i=10,maxNumSize:r=8}=e;return`${t.constructor.name} {\n${xbt}[\n${wbt}${function(t,e,n,i){const{rows:r,columns:s}=t,o=Math.min(r,e),a=Math.min(s,n),l=[];for(let e=0;e<o;e++){let n=[];for(let r=0;r<a;r++)n.push(kbt(t.get(e,r),i));l.push(`${n.join(" ")}`)}a!==s&&(l[l.length-1]+=` ... ${s-n} more columns`);o!==r&&l.push(`... ${r-e} more rows`);return l.join(`\n${wbt}`)}(t,n,i,r)}\n${xbt}]\n${xbt}rows: ${t.rows}\n${xbt}columns: ${t.columns}\n}`}function kbt(t,e){const n=String(t);if(n.length<=e)return n.padEnd(e," ");const i=t.toPrecision(e-2);if(i.length<=e)return i;const r=t.toExponential(e-2),s=r.indexOf("e"),o=r.slice(s);return r.slice(0,e-o.length)+o}function Cbt(t,e,n){let i=n?t.rows:t.rows-1;if(e<0||e>i)throw new RangeError("Row index out of range")}function Tbt(t,e,n){let i=n?t.columns:t.columns-1;if(e<0||e>i)throw new RangeError("Column index out of range")}function _bt(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function Ebt(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function Mbt(t,e,n,i,r){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(Ibt("startRow",e),Ibt("endRow",n),Ibt("startColumn",i),Ibt("endColumn",r),e>n||i>r||e<0||e>=t.rows||n<0||n>=t.rows||i<0||i>=t.columns||r<0||r>=t.columns)throw new RangeError("Submatrix indices are out of range")}function $bt(t,e=0){let n=[];for(let i=0;i<t;i++)n.push(e);return n}function Ibt(t,e){if("number"!=typeof e)throw new TypeError(`${t} must be a number`)}function Abt(t){if(t.isEmpty())throw new Error("Empty matrix has no elements to index")}let Nbt=class t{static from1DArray(t,e,n){if(t*e!==n.length)throw new RangeError("data length does not match given dimensions");let i=new Pbt(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++)i.set(r,t,n[r*e+t]);return i}static rowVector(t){let e=new Pbt(1,t.length);for(let n=0;n<t.length;n++)e.set(0,n,t[n]);return e}static columnVector(t){let e=new Pbt(t.length,1);for(let n=0;n<t.length;n++)e.set(n,0,t[n]);return e}static zeros(t,e){return new Pbt(t,e)}static ones(t,e){return new Pbt(t,e).fill(1)}static rand(t,e,n={}){if("object"!=typeof n)throw new TypeError("options must be an object");const{random:i=Math.random}=n;let r=new Pbt(t,e);for(let n=0;n<t;n++)for(let t=0;t<e;t++)r.set(n,t,i());return r}static randInt(t,e,n={}){if("object"!=typeof n)throw new TypeError("options must be an object");const{min:i=0,max:r=1e3,random:s=Math.random}=n;if(!Number.isInteger(i))throw new TypeError("min must be an integer");if(!Number.isInteger(r))throw new TypeError("max must be an integer");if(i>=r)throw new RangeError("min must be smaller than max");let o=r-i,a=new Pbt(t,e);for(let n=0;n<t;n++)for(let t=0;t<e;t++){let e=i+Math.round(s()*o);a.set(n,t,e)}return a}static eye(t,e,n){void 0===e&&(e=t),void 0===n&&(n=1);let i=Math.min(t,e),r=this.zeros(t,e);for(let t=0;t<i;t++)r.set(t,t,n);return r}static diag(t,e,n){let i=t.length;void 0===e&&(e=i),void 0===n&&(n=e);let r=Math.min(i,e,n),s=this.zeros(e,n);for(let e=0;e<r;e++)s.set(e,e,t[e]);return s}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let n=t.rows,i=t.columns,r=new Pbt(n,i);for(let s=0;s<n;s++)for(let n=0;n<i;n++)r.set(s,n,Math.min(t.get(s,n),e.get(s,n)));return r}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let n=t.rows,i=t.columns,r=new this(n,i);for(let s=0;s<n;s++)for(let n=0;n<i;n++)r.set(s,n,Math.max(t.get(s,n),e.get(s,n)));return r}static checkMatrix(e){return t.isMatrix(e)?e:new Pbt(e)}static isMatrix(t){return null!=t&&"Matrix"===t.klass}get size(){return this.rows*this.columns}apply(t){if("function"!=typeof t)throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t.call(this,e,n);return this}to1DArray(){let t=[];for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t.push(this.get(e,n));return t}to2DArray(){let t=[];for(let e=0;e<this.rows;e++){t.push([]);for(let n=0;n<this.columns;n++)t[e].push(this.get(e,n))}return t}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isEmpty(){return 0===this.rows||0===this.columns}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isEchelonForm(){let t=0,e=0,n=-1,i=!0,r=!1;for(;t<this.rows&&i;){for(e=0,r=!1;e<this.columns&&!1===r;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>n?(r=!0,n=e):(i=!1,r=!0);t++}return i}isReducedEchelonForm(){let t=0,e=0,n=-1,i=!0,r=!1;for(;t<this.rows&&i;){for(e=0,r=!1;e<this.columns&&!1===r;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>n?(r=!0,n=e):(i=!1,r=!0);for(let n=e+1;n<this.rows;n++)0!==this.get(t,n)&&(i=!1);t++}return i}echelonForm(){let t=this.clone(),e=0,n=0;for(;e<t.rows&&n<t.columns;){let i=e;for(let r=e;r<t.rows;r++)t.get(r,n)>t.get(i,n)&&(i=r);if(0===t.get(i,n))n++;else{t.swapRows(e,i);let r=t.get(e,n);for(let i=n;i<t.columns;i++)t.set(e,i,t.get(e,i)/r);for(let i=e+1;i<t.rows;i++){let r=t.get(i,n)/t.get(e,n);t.set(i,n,0);for(let s=n+1;s<t.columns;s++)t.set(i,s,t.get(i,s)-t.get(e,s)*r)}e++,n++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,n=t.rows,i=n-1;for(;i>=0;)if(0===t.maxRow(i))i--;else{let r=0,s=!1;for(;r<n&&!1===s;)1===t.get(i,r)?s=!0:r++;for(let n=0;n<i;n++){let s=t.get(n,r);for(let o=r;o<e;o++){let e=t.get(n,o)-s*t.get(i,o);t.set(n,o,e)}}i--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{rows:e=1,columns:n=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(n)||n<=0)throw new TypeError("columns must be a positive integer");let i=new Pbt(this.rows*e,this.columns*n);for(let t=0;t<e;t++)for(let e=0;e<n;e++)i.setSubMatrix(this,this.rows*t,this.columns*e);return i}fill(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,t);return this}neg(){return this.mulS(-1)}getRow(t){Cbt(this,t);let e=[];for(let n=0;n<this.columns;n++)e.push(this.get(t,n));return e}getRowVector(t){return Pbt.rowVector(this.getRow(t))}setRow(t,e){Cbt(this,t),e=_bt(this,e);for(let n=0;n<this.columns;n++)this.set(t,n,e[n]);return this}swapRows(t,e){Cbt(this,t),Cbt(this,e);for(let n=0;n<this.columns;n++){let i=this.get(t,n);this.set(t,n,this.get(e,n)),this.set(e,n,i)}return this}getColumn(t){Tbt(this,t);let e=[];for(let n=0;n<this.rows;n++)e.push(this.get(n,t));return e}getColumnVector(t){return Pbt.columnVector(this.getColumn(t))}setColumn(t,e){Tbt(this,t),e=Ebt(this,e);for(let n=0;n<this.rows;n++)this.set(n,t,e[n]);return this}swapColumns(t,e){Tbt(this,t),Tbt(this,e);for(let n=0;n<this.rows;n++){let i=this.get(n,t);this.set(n,t,this.get(n,e)),this.set(n,e,i)}return this}addRowVector(t){t=_bt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)+t[n]);return this}subRowVector(t){t=_bt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)-t[n]);return this}mulRowVector(t){t=_bt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)*t[n]);return this}divRowVector(t){t=_bt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)/t[n]);return this}addColumnVector(t){t=Ebt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)+t[e]);return this}subColumnVector(t){t=Ebt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)-t[e]);return this}mulColumnVector(t){t=Ebt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)*t[e]);return this}divColumnVector(t){t=Ebt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)/t[e]);return this}mulRow(t,e){Cbt(this,t);for(let n=0;n<this.columns;n++)this.set(t,n,this.get(t,n)*e);return this}mulColumn(t,e){Tbt(this,t);for(let n=0;n<this.rows;n++)this.set(n,t,this.get(n,t)*e);return this}max(t){if(this.isEmpty())return NaN;switch(t){case"row":{const t=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.get(e,n)>t[e]&&(t[e]=this.get(e,n));return t}case"column":{const t=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.get(e,n)>t[n]&&(t[n]=this.get(e,n));return t}case void 0:{let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.get(e,n)>t&&(t=this.get(e,n));return t}default:throw new Error(`invalid option: ${t}`)}}maxIndex(){Abt(this);let t=this.get(0,0),e=[0,0];for(let n=0;n<this.rows;n++)for(let i=0;i<this.columns;i++)this.get(n,i)>t&&(t=this.get(n,i),e[0]=n,e[1]=i);return e}min(t){if(this.isEmpty())return NaN;switch(t){case"row":{const t=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.get(e,n)<t[e]&&(t[e]=this.get(e,n));return t}case"column":{const t=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.get(e,n)<t[n]&&(t[n]=this.get(e,n));return t}case void 0:{let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.get(e,n)<t&&(t=this.get(e,n));return t}default:throw new Error(`invalid option: ${t}`)}}minIndex(){Abt(this);let t=this.get(0,0),e=[0,0];for(let n=0;n<this.rows;n++)for(let i=0;i<this.columns;i++)this.get(n,i)<t&&(t=this.get(n,i),e[0]=n,e[1]=i);return e}maxRow(t){if(Cbt(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let n=1;n<this.columns;n++)this.get(t,n)>e&&(e=this.get(t,n));return e}maxRowIndex(t){Cbt(this,t),Abt(this);let e=this.get(t,0),n=[t,0];for(let i=1;i<this.columns;i++)this.get(t,i)>e&&(e=this.get(t,i),n[1]=i);return n}minRow(t){if(Cbt(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let n=1;n<this.columns;n++)this.get(t,n)<e&&(e=this.get(t,n));return e}minRowIndex(t){Cbt(this,t),Abt(this);let e=this.get(t,0),n=[t,0];for(let i=1;i<this.columns;i++)this.get(t,i)<e&&(e=this.get(t,i),n[1]=i);return n}maxColumn(t){if(Tbt(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let n=1;n<this.rows;n++)this.get(n,t)>e&&(e=this.get(n,t));return e}maxColumnIndex(t){Tbt(this,t),Abt(this);let e=this.get(0,t),n=[0,t];for(let i=1;i<this.rows;i++)this.get(i,t)>e&&(e=this.get(i,t),n[0]=i);return n}minColumn(t){if(Tbt(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let n=1;n<this.rows;n++)this.get(n,t)<e&&(e=this.get(n,t));return e}minColumnIndex(t){Tbt(this,t),Abt(this);let e=this.get(0,t),n=[0,t];for(let i=1;i<this.rows;i++)this.get(i,t)<e&&(e=this.get(i,t),n[0]=i);return n}diag(){let t=Math.min(this.rows,this.columns),e=[];for(let n=0;n<t;n++)e.push(this.get(n,n));return e}norm(t="frobenius"){let e=0;if("max"===t)return this.max();if("frobenius"===t){for(let t=0;t<this.rows;t++)for(let n=0;n<this.columns;n++)e+=this.get(t,n)*this.get(t,n);return Math.sqrt(e)}throw new RangeError(`unknown norm type: ${t}`)}cumulativeSum(){let t=0;for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t+=this.get(e,n),this.set(e,n,t);return this}dot(e){t.isMatrix(e)&&(e=e.to1DArray());let n=this.to1DArray();if(n.length!==e.length)throw new RangeError("vectors do not have the same size");let i=0;for(let t=0;t<n.length;t++)i+=n[t]*e[t];return i}mmul(t){t=Pbt.checkMatrix(t);let e=this.rows,n=this.columns,i=t.columns,r=new Pbt(e,i),s=new Float64Array(n);for(let o=0;o<i;o++){for(let e=0;e<n;e++)s[e]=t.get(e,o);for(let t=0;t<e;t++){let e=0;for(let i=0;i<n;i++)e+=this.get(t,i)*s[i];r.set(t,o,e)}}return r}strassen2x2(t){t=Pbt.checkMatrix(t);let e=new Pbt(2,2);const n=this.get(0,0),i=t.get(0,0),r=this.get(0,1),s=t.get(0,1),o=this.get(1,0),a=t.get(1,0),l=this.get(1,1),c=t.get(1,1),u=(n+l)*(i+c),h=(o+l)*i,d=n*(s-c),p=l*(a-i),f=(n+r)*c,m=u+p-f+(r-l)*(a+c),g=d+f,y=h+p,b=u-h+d+(o-n)*(i+s);return e.set(0,0,m),e.set(0,1,g),e.set(1,0,y),e.set(1,1,b),e}strassen3x3(t){t=Pbt.checkMatrix(t);let e=new Pbt(3,3);const n=this.get(0,0),i=this.get(0,1),r=this.get(0,2),s=this.get(1,0),o=this.get(1,1),a=this.get(1,2),l=this.get(2,0),c=this.get(2,1),u=this.get(2,2),h=t.get(0,0),d=t.get(0,1),p=t.get(0,2),f=t.get(1,0),m=t.get(1,1),g=t.get(1,2),y=t.get(2,0),b=t.get(2,1),v=t.get(2,2),x=(n-s)*(-d+m),w=(-n+s+o)*(h-d+m),S=(s+o)*(-h+d),k=n*h,C=(-n+l+c)*(h-p+g),T=(-n+l)*(p-g),_=(l+c)*(-h+p),E=(-r+c+u)*(m+y-b),M=(r-u)*(m-b),$=r*y,I=(c+u)*(-y+b),A=(-r+o+a)*(g+y-v),N=(r-a)*(g-v),R=(o+a)*(-y+v),P=k+$+i*f,O=(n+i+r-s-o-c-u)*m+w+S+k+E+$+I,L=k+C+_+(n+i+r-o-a-l-c)*g+$+A+R,D=x+o*(-h+d+f-m-g-y+v)+w+k+$+A+N,F=x+w+S+k+a*b,z=$+A+N+R+s*p,B=k+C+T+c*(-h+p+f-m-g-y+b)+E+M+$,U=E+M+$+I+l*d,V=k+C+T+_+u*v;return e.set(0,0,P),e.set(0,1,O),e.set(0,2,L),e.set(1,0,D),e.set(1,1,F),e.set(1,2,z),e.set(2,0,B),e.set(2,1,U),e.set(2,2,V),e}mmulStrassen(e){e=Pbt.checkMatrix(e);let n=this.clone(),i=n.rows,r=n.columns,s=e.rows,o=e.columns;function a(e,n,i){let r=e.rows,s=e.columns;if(r===n&&s===i)return e;{let r=t.zeros(n,i);return r=r.setSubMatrix(e,0,0),r}}r!==s&&console.warn(`Multiplying ${i} x ${r} and ${s} x ${o} matrix: dimensions do not match.`);let l=Math.max(i,s),c=Math.max(r,o);return n=a(n,l,c),function e(n,i,r,s){if(r<=512||s<=512)return n.mmul(i);r%2==1&&s%2==1?(n=a(n,r+1,s+1),i=a(i,r+1,s+1)):r%2==1?(n=a(n,r+1,s),i=a(i,r+1,s)):s%2==1&&(n=a(n,r,s+1),i=a(i,r,s+1));let o=parseInt(n.rows/2,10),l=parseInt(n.columns/2,10),c=n.subMatrix(0,o-1,0,l-1),u=i.subMatrix(0,o-1,0,l-1),h=n.subMatrix(0,o-1,l,n.columns-1),d=i.subMatrix(0,o-1,l,i.columns-1),p=n.subMatrix(o,n.rows-1,0,l-1),f=i.subMatrix(o,i.rows-1,0,l-1),m=n.subMatrix(o,n.rows-1,l,n.columns-1),g=i.subMatrix(o,i.rows-1,l,i.columns-1),y=e(t.add(c,m),t.add(u,g),o,l),b=e(t.add(p,m),u,o,l),v=e(c,t.sub(d,g),o,l),x=e(m,t.sub(f,u),o,l),w=e(t.add(c,h),g,o,l),S=e(t.sub(p,c),t.add(u,d),o,l),k=e(t.sub(h,m),t.add(f,g),o,l),C=t.add(y,x);C.sub(w),C.add(k);let T=t.add(v,w),_=t.add(b,x),E=t.sub(y,b);E.add(v),E.add(S);let M=t.zeros(2*C.rows,2*C.columns);return M=M.setSubMatrix(C,0,0),M=M.setSubMatrix(T,C.rows,0),M=M.setSubMatrix(_,0,C.columns),M=M.setSubMatrix(E,C.rows,C.columns),M.subMatrix(0,r-1,0,s-1)}(n,e=a(e,l,c),l,c)}scaleRows(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:n=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(n))throw new TypeError("max must be a number");if(e>=n)throw new RangeError("min must be smaller than max");let i=new Pbt(this.rows,this.columns);for(let t=0;t<this.rows;t++){const r=this.getRow(t);r.length>0&&vbt(r,{min:e,max:n,output:r}),i.setRow(t,r)}return i}scaleColumns(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:n=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(n))throw new TypeError("max must be a number");if(e>=n)throw new RangeError("min must be smaller than max");let i=new Pbt(this.rows,this.columns);for(let t=0;t<this.columns;t++){const r=this.getColumn(t);r.length&&vbt(r,{min:e,max:n,output:r}),i.setColumn(t,r)}return i}flipRows(){const t=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let n=0;n<t;n++){let t=this.get(e,n),i=this.get(e,this.columns-1-n);this.set(e,n,i),this.set(e,this.columns-1-n,t)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let n=0;n<t;n++){let t=this.get(n,e),i=this.get(this.rows-1-n,e);this.set(n,e,i),this.set(this.rows-1-n,e,t)}return this}kroneckerProduct(t){t=Pbt.checkMatrix(t);let e=this.rows,n=this.columns,i=t.rows,r=t.columns,s=new Pbt(e*i,n*r);for(let o=0;o<e;o++)for(let e=0;e<n;e++)for(let n=0;n<i;n++)for(let a=0;a<r;a++)s.set(i*o+n,r*e+a,this.get(o,e)*t.get(n,a));return s}kroneckerSum(t){if(t=Pbt.checkMatrix(t),!this.isSquare()||!t.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let e=this.rows,n=t.rows,i=this.kroneckerProduct(Pbt.eye(n,n)),r=Pbt.eye(e,e).kroneckerProduct(t);return i.add(r)}transpose(){let t=new Pbt(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t.set(n,e,this.get(e,n));return t}sortRows(t=Rbt){for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(t=Rbt){for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,n,i){Mbt(this,t,e,n,i);let r=new Pbt(e-t+1,i-n+1);for(let s=t;s<=e;s++)for(let e=n;e<=i;e++)r.set(s-t,e-n,this.get(s,e));return r}subMatrixRow(t,e,n){if(void 0===e&&(e=0),void 0===n&&(n=this.columns-1),e>n||e<0||e>=this.columns||n<0||n>=this.columns)throw new RangeError("Argument out of range");let i=new Pbt(t.length,n-e+1);for(let r=0;r<t.length;r++)for(let s=e;s<=n;s++){if(t[r]<0||t[r]>=this.rows)throw new RangeError(`Row index out of range: ${t[r]}`);i.set(r,s-e,this.get(t[r],s))}return i}subMatrixColumn(t,e,n){if(void 0===e&&(e=0),void 0===n&&(n=this.rows-1),e>n||e<0||e>=this.rows||n<0||n>=this.rows)throw new RangeError("Argument out of range");let i=new Pbt(n-e+1,t.length);for(let r=0;r<t.length;r++)for(let s=e;s<=n;s++){if(t[r]<0||t[r]>=this.columns)throw new RangeError(`Column index out of range: ${t[r]}`);i.set(s-e,r,this.get(s,t[r]))}return i}setSubMatrix(t,e,n){if((t=Pbt.checkMatrix(t)).isEmpty())return this;Mbt(this,e,e+t.rows-1,n,n+t.columns-1);for(let i=0;i<t.rows;i++)for(let r=0;r<t.columns;r++)this.set(e+i,n+r,t.get(i,r));return this}selection(t,e){!function(t,e){if(!bbt(e))throw new TypeError("row indices must be an array");for(let n=0;n<e.length;n++)if(e[n]<0||e[n]>=t.rows)throw new RangeError("row indices are out of range")}(this,t),function(t,e){if(!bbt(e))throw new TypeError("column indices must be an array");for(let n=0;n<e.length;n++)if(e[n]<0||e[n]>=t.columns)throw new RangeError("column indices are out of range")}(this,e);let n=new Pbt(t.length,e.length);for(let i=0;i<t.length;i++){let r=t[i];for(let t=0;t<e.length;t++){let s=e[t];n.set(i,t,this.get(r,s))}}return n}trace(){let t=Math.min(this.rows,this.columns),e=0;for(let n=0;n<t;n++)e+=this.get(n,n);return e}clone(){let t=new Pbt(this.rows,this.columns);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t.set(e,n,this.get(e,n));return t}sum(t){switch(t){case"row":return function(t){let e=$bt(t.rows);for(let n=0;n<t.rows;++n)for(let i=0;i<t.columns;++i)e[n]+=t.get(n,i);return e}(this);case"column":return function(t){let e=$bt(t.columns);for(let n=0;n<t.rows;++n)for(let i=0;i<t.columns;++i)e[i]+=t.get(n,i);return e}(this);case void 0:return function(t){let e=0;for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)e+=t.get(n,i);return e}(this);default:throw new Error(`invalid option: ${t}`)}}product(t){switch(t){case"row":return function(t){let e=$bt(t.rows,1);for(let n=0;n<t.rows;++n)for(let i=0;i<t.columns;++i)e[n]*=t.get(n,i);return e}(this);case"column":return function(t){let e=$bt(t.columns,1);for(let n=0;n<t.rows;++n)for(let i=0;i<t.columns;++i)e[i]*=t.get(n,i);return e}(this);case void 0:return function(t){let e=1;for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)e*=t.get(n,i);return e}(this);default:throw new Error(`invalid option: ${t}`)}}mean(t){const e=this.sum(t);switch(t){case"row":for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e;case"column":for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e;case void 0:return e/this.size;default:throw new Error(`invalid option: ${t}`)}}variance(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{unbiased:n=!0,mean:i=this.mean(t)}=e;if("boolean"!=typeof n)throw new TypeError("unbiased must be a boolean");switch(t){case"row":if(!bbt(i))throw new TypeError("mean must be an array");return function(t,e,n){const i=t.rows,r=t.columns,s=[];for(let o=0;o<i;o++){let i=0,a=0,l=0;for(let e=0;e<r;e++)l=t.get(o,e)-n[o],i+=l,a+=l*l;e?s.push((a-i*i/r)/(r-1)):s.push((a-i*i/r)/r)}return s}(this,n,i);case"column":if(!bbt(i))throw new TypeError("mean must be an array");return function(t,e,n){const i=t.rows,r=t.columns,s=[];for(let o=0;o<r;o++){let r=0,a=0,l=0;for(let e=0;e<i;e++)l=t.get(e,o)-n[o],r+=l,a+=l*l;e?s.push((a-r*r/i)/(i-1)):s.push((a-r*r/i)/i)}return s}(this,n,i);case void 0:if("number"!=typeof i)throw new TypeError("mean must be a number");return function(t,e,n){const i=t.rows,r=t.columns,s=i*r;let o=0,a=0,l=0;for(let e=0;e<i;e++)for(let i=0;i<r;i++)l=t.get(e,i)-n,o+=l,a+=l*l;return e?(a-o*o/s)/(s-1):(a-o*o/s)/s}(this,n,i);default:throw new Error(`invalid option: ${t}`)}}standardDeviation(t,e){"object"==typeof t&&(e=t,t=void 0);const n=this.variance(t,e);if(void 0===t)return Math.sqrt(n);for(let t=0;t<n.length;t++)n[t]=Math.sqrt(n[t]);return n}center(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{center:n=this.mean(t)}=e;switch(t){case"row":if(!bbt(n))throw new TypeError("center must be an array");return function(t,e){for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)t.set(n,i,t.get(n,i)-e[n])}(this,n),this;case"column":if(!bbt(n))throw new TypeError("center must be an array");return function(t,e){for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)t.set(n,i,t.get(n,i)-e[i])}(this,n),this;case void 0:if("number"!=typeof n)throw new TypeError("center must be a number");return function(t,e){for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)t.set(n,i,t.get(n,i)-e)}(this,n),this;default:throw new Error(`invalid option: ${t}`)}}scale(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");let n=e.scale;switch(t){case"row":if(void 0===n)n=function(t){const e=[];for(let n=0;n<t.rows;n++){let i=0;for(let e=0;e<t.columns;e++)i+=Math.pow(t.get(n,e),2)/(t.columns-1);e.push(Math.sqrt(i))}return e}(this);else if(!bbt(n))throw new TypeError("scale must be an array");return function(t,e){for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)t.set(n,i,t.get(n,i)/e[n])}(this,n),this;case"column":if(void 0===n)n=function(t){const e=[];for(let n=0;n<t.columns;n++){let i=0;for(let e=0;e<t.rows;e++)i+=Math.pow(t.get(e,n),2)/(t.rows-1);e.push(Math.sqrt(i))}return e}(this);else if(!bbt(n))throw new TypeError("scale must be an array");return function(t,e){for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)t.set(n,i,t.get(n,i)/e[i])}(this,n),this;case void 0:if(void 0===n)n=function(t){const e=t.size-1;let n=0;for(let i=0;i<t.columns;i++)for(let r=0;r<t.rows;r++)n+=Math.pow(t.get(r,i),2)/e;return Math.sqrt(n)}(this);else if("number"!=typeof n)throw new TypeError("scale must be a number");return function(t,e){for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)t.set(n,i,t.get(n,i)/e)}(this,n),this;default:throw new Error(`invalid option: ${t}`)}}toString(t){return Sbt(this,t)}};function Rbt(t,e){return t-e}Nbt.prototype.klass="Matrix","undefined"!=typeof Symbol&&(Nbt.prototype[Symbol.for("nodejs.util.inspect.custom")]=function(){return Sbt(this)}),Nbt.random=Nbt.rand,Nbt.randomInt=Nbt.randInt,Nbt.diagonal=Nbt.diag,Nbt.prototype.diagonal=Nbt.prototype.diag,Nbt.identity=Nbt.eye,Nbt.prototype.negate=Nbt.prototype.neg,Nbt.prototype.tensorProduct=Nbt.prototype.kroneckerProduct;let Pbt=class t extends Nbt{constructor(e,n){if(super(),t.isMatrix(e))return e.clone();if(Number.isInteger(e)&&e>=0){if(this.data=[],!(Number.isInteger(n)&&n>=0))throw new TypeError("nColumns must be a positive integer");for(let t=0;t<e;t++)this.data.push(new Float64Array(n))}else{if(!bbt(e))throw new TypeError("First argument must be a positive number or an array");{const t=e;if("number"!=typeof(n=(e=t.length)?t[0].length:0))throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let i=0;i<e;i++){if(t[i].length!==n)throw new RangeError("Inconsistent array dimensions");if(!t[i].every((t=>"number"==typeof t)))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(t[i]))}}}this.rows=e,this.columns=n}set(t,e,n){return this.data[t][e]=n,this}get(t,e){return this.data[t][e]}removeRow(t){return Cbt(this,t),this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return void 0===e&&(e=t,t=this.rows),Cbt(this,t,!0),e=Float64Array.from(_bt(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){Tbt(this,t);for(let e=0;e<this.rows;e++){const n=new Float64Array(this.columns-1);for(let i=0;i<t;i++)n[i]=this.data[e][i];for(let i=t+1;i<this.columns;i++)n[i-1]=this.data[e][i];this.data[e]=n}return this.columns-=1,this}addColumn(t,e){void 0===e&&(e=t,t=this.columns),Tbt(this,t,!0),e=Ebt(this,e);for(let n=0;n<this.rows;n++){const i=new Float64Array(this.columns+1);let r=0;for(;r<t;r++)i[r]=this.data[n][r];for(i[r++]=e[n];r<this.columns+1;r++)i[r]=this.data[n][r-1];this.data[n]=i}return this.columns+=1,this}};!function(t,e){t.prototype.add=function(t){return"number"==typeof t?this.addS(t):this.addM(t)},t.prototype.addS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)+t);return this},t.prototype.addM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)+t.get(e,n));return this},t.add=function(t,n){return new e(t).add(n)},t.prototype.sub=function(t){return"number"==typeof t?this.subS(t):this.subM(t)},t.prototype.subS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)-t);return this},t.prototype.subM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)-t.get(e,n));return this},t.sub=function(t,n){return new e(t).sub(n)},t.prototype.subtract=t.prototype.sub,t.prototype.subtractS=t.prototype.subS,t.prototype.subtractM=t.prototype.subM,t.subtract=t.sub,t.prototype.mul=function(t){return"number"==typeof t?this.mulS(t):this.mulM(t)},t.prototype.mulS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)*t);return this},t.prototype.mulM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)*t.get(e,n));return this},t.mul=function(t,n){return new e(t).mul(n)},t.prototype.multiply=t.prototype.mul,t.prototype.multiplyS=t.prototype.mulS,t.prototype.multiplyM=t.prototype.mulM,t.multiply=t.mul,t.prototype.div=function(t){return"number"==typeof t?this.divS(t):this.divM(t)},t.prototype.divS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)/t);return this},t.prototype.divM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)/t.get(e,n));return this},t.div=function(t,n){return new e(t).div(n)},t.prototype.divide=t.prototype.div,t.prototype.divideS=t.prototype.divS,t.prototype.divideM=t.prototype.divM,t.divide=t.div,t.prototype.mod=function(t){return"number"==typeof t?this.modS(t):this.modM(t)},t.prototype.modS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)%t);return this},t.prototype.modM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)%t.get(e,n));return this},t.mod=function(t,n){return new e(t).mod(n)},t.prototype.modulus=t.prototype.mod,t.prototype.modulusS=t.prototype.modS,t.prototype.modulusM=t.prototype.modM,t.modulus=t.mod,t.prototype.and=function(t){return"number"==typeof t?this.andS(t):this.andM(t)},t.prototype.andS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)&t);return this},t.prototype.andM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)&t.get(e,n));return this},t.and=function(t,n){return new e(t).and(n)},t.prototype.or=function(t){return"number"==typeof t?this.orS(t):this.orM(t)},t.prototype.orS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)|t);return this},t.prototype.orM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)|t.get(e,n));return this},t.or=function(t,n){return new e(t).or(n)},t.prototype.xor=function(t){return"number"==typeof t?this.xorS(t):this.xorM(t)},t.prototype.xorS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)^t);return this},t.prototype.xorM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)^t.get(e,n));return this},t.xor=function(t,n){return new e(t).xor(n)},t.prototype.leftShift=function(t){return"number"==typeof t?this.leftShiftS(t):this.leftShiftM(t)},t.prototype.leftShiftS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)<<t);return this},t.prototype.leftShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)<<t.get(e,n));return this},t.leftShift=function(t,n){return new e(t).leftShift(n)},t.prototype.signPropagatingRightShift=function(t){return"number"==typeof t?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},t.prototype.signPropagatingRightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)>>t);return this},t.prototype.signPropagatingRightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)>>t.get(e,n));return this},t.signPropagatingRightShift=function(t,n){return new e(t).signPropagatingRightShift(n)},t.prototype.rightShift=function(t){return"number"==typeof t?this.rightShiftS(t):this.rightShiftM(t)},t.prototype.rightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)>>>t);return this},t.prototype.rightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)>>>t.get(e,n));return this},t.rightShift=function(t,n){return new e(t).rightShift(n)},t.prototype.zeroFillRightShift=t.prototype.rightShift,t.prototype.zeroFillRightShiftS=t.prototype.rightShiftS,t.prototype.zeroFillRightShiftM=t.prototype.rightShiftM,t.zeroFillRightShift=t.rightShift,t.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,~this.get(t,e));return this},t.not=function(t){return new e(t).not()},t.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.abs(this.get(t,e)));return this},t.abs=function(t){return new e(t).abs()},t.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acos(this.get(t,e)));return this},t.acos=function(t){return new e(t).acos()},t.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acosh(this.get(t,e)));return this},t.acosh=function(t){return new e(t).acosh()},t.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asin(this.get(t,e)));return this},t.asin=function(t){return new e(t).asin()},t.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asinh(this.get(t,e)));return this},t.asinh=function(t){return new e(t).asinh()},t.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atan(this.get(t,e)));return this},t.atan=function(t){return new e(t).atan()},t.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atanh(this.get(t,e)));return this},t.atanh=function(t){return new e(t).atanh()},t.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cbrt(this.get(t,e)));return this},t.cbrt=function(t){return new e(t).cbrt()},t.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.ceil(this.get(t,e)));return this},t.ceil=function(t){return new e(t).ceil()},t.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.clz32(this.get(t,e)));return this},t.clz32=function(t){return new e(t).clz32()},t.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cos(this.get(t,e)));return this},t.cos=function(t){return new e(t).cos()},t.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cosh(this.get(t,e)));return this},t.cosh=function(t){return new e(t).cosh()},t.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.exp(this.get(t,e)));return this},t.exp=function(t){return new e(t).exp()},t.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.expm1(this.get(t,e)));return this},t.expm1=function(t){return new e(t).expm1()},t.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.floor(this.get(t,e)));return this},t.floor=function(t){return new e(t).floor()},t.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.fround(this.get(t,e)));return this},t.fround=function(t){return new e(t).fround()},t.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log(this.get(t,e)));return this},t.log=function(t){return new e(t).log()},t.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log1p(this.get(t,e)));return this},t.log1p=function(t){return new e(t).log1p()},t.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log10(this.get(t,e)));return this},t.log10=function(t){return new e(t).log10()},t.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log2(this.get(t,e)));return this},t.log2=function(t){return new e(t).log2()},t.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.round(this.get(t,e)));return this},t.round=function(t){return new e(t).round()},t.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sign(this.get(t,e)));return this},t.sign=function(t){return new e(t).sign()},t.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sin(this.get(t,e)));return this},t.sin=function(t){return new e(t).sin()},t.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sinh(this.get(t,e)));return this},t.sinh=function(t){return new e(t).sinh()},t.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sqrt(this.get(t,e)));return this},t.sqrt=function(t){return new e(t).sqrt()},t.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tan(this.get(t,e)));return this},t.tan=function(t){return new e(t).tan()},t.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tanh(this.get(t,e)));return this},t.tanh=function(t){return new e(t).tanh()},t.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.trunc(this.get(t,e)));return this},t.trunc=function(t){return new e(t).trunc()},t.pow=function(t,n){return new e(t).pow(n)},t.prototype.pow=function(t){return"number"==typeof t?this.powS(t):this.powM(t)},t.prototype.powS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,Math.pow(this.get(e,n),t));return this},t.prototype.powM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,Math.pow(this.get(e,n),t.get(e,n)));return this}}(Nbt,Pbt);let Obt=class extends Nbt{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,e,n){return this.data[t][e]=n,this}get(t,e){return this.data[t][e]}};class Lbt{constructor(t){let e,n,i,r,s,o,a,l,c,u=(t=Obt.checkMatrix(t)).clone(),h=u.rows,d=u.columns,p=new Float64Array(h),f=1;for(e=0;e<h;e++)p[e]=e;for(l=new Float64Array(h),n=0;n<d;n++){for(e=0;e<h;e++)l[e]=u.get(e,n);for(e=0;e<h;e++){for(c=Math.min(e,n),s=0,i=0;i<c;i++)s+=u.get(e,i)*l[i];l[e]-=s,u.set(e,n,l[e])}for(r=n,e=n+1;e<h;e++)Math.abs(l[e])>Math.abs(l[r])&&(r=e);if(r!==n){for(i=0;i<d;i++)o=u.get(r,i),u.set(r,i,u.get(n,i)),u.set(n,i,o);a=p[r],p[r]=p[n],p[n]=a,f=-f}if(n<h&&0!==u.get(n,n))for(e=n+1;e<h;e++)u.set(e,n,u.get(e,n)/u.get(n,n))}this.LU=u,this.pivotVector=p,this.pivotSign=f}isSingular(){let t=this.LU,e=t.columns;for(let n=0;n<e;n++)if(0===t.get(n,n))return!0;return!1}solve(t){t=Pbt.checkMatrix(t);let e=this.LU;if(e.rows!==t.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let n,i,r,s=t.columns,o=t.subMatrixRow(this.pivotVector,0,s-1),a=e.columns;for(r=0;r<a;r++)for(n=r+1;n<a;n++)for(i=0;i<s;i++)o.set(n,i,o.get(n,i)-o.get(r,i)*e.get(n,r));for(r=a-1;r>=0;r--){for(i=0;i<s;i++)o.set(r,i,o.get(r,i)/e.get(r,r));for(n=0;n<r;n++)for(i=0;i<s;i++)o.set(n,i,o.get(n,i)-o.get(r,i)*e.get(n,r))}return o}get determinant(){let t=this.LU;if(!t.isSquare())throw new Error("Matrix must be square");let e=this.pivotSign,n=t.columns;for(let i=0;i<n;i++)e*=t.get(i,i);return e}get lowerTriangularMatrix(){let t=this.LU,e=t.rows,n=t.columns,i=new Pbt(e,n);for(let r=0;r<e;r++)for(let e=0;e<n;e++)r>e?i.set(r,e,t.get(r,e)):r===e?i.set(r,e,1):i.set(r,e,0);return i}get upperTriangularMatrix(){let t=this.LU,e=t.rows,n=t.columns,i=new Pbt(e,n);for(let r=0;r<e;r++)for(let e=0;e<n;e++)r<=e?i.set(r,e,t.get(r,e)):i.set(r,e,0);return i}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function Dbt(t,e){let n=0;return Math.abs(t)>Math.abs(e)?(n=e/t,Math.abs(t)*Math.sqrt(1+n*n)):0!==e?(n=t/e,Math.abs(e)*Math.sqrt(1+n*n)):0}class Fbt{constructor(t){let e,n,i,r,s=(t=Obt.checkMatrix(t)).clone(),o=t.rows,a=t.columns,l=new Float64Array(a);for(i=0;i<a;i++){let t=0;for(e=i;e<o;e++)t=Dbt(t,s.get(e,i));if(0!==t){for(s.get(i,i)<0&&(t=-t),e=i;e<o;e++)s.set(e,i,s.get(e,i)/t);for(s.set(i,i,s.get(i,i)+1),n=i+1;n<a;n++){for(r=0,e=i;e<o;e++)r+=s.get(e,i)*s.get(e,n);for(r=-r/s.get(i,i),e=i;e<o;e++)s.set(e,n,s.get(e,n)+r*s.get(e,i))}}l[i]=-t}this.QR=s,this.Rdiag=l}solve(t){t=Pbt.checkMatrix(t);let e=this.QR,n=e.rows;if(t.rows!==n)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let i,r,s,o,a=t.columns,l=t.clone(),c=e.columns;for(s=0;s<c;s++)for(r=0;r<a;r++){for(o=0,i=s;i<n;i++)o+=e.get(i,s)*l.get(i,r);for(o=-o/e.get(s,s),i=s;i<n;i++)l.set(i,r,l.get(i,r)+o*e.get(i,s))}for(s=c-1;s>=0;s--){for(r=0;r<a;r++)l.set(s,r,l.get(s,r)/this.Rdiag[s]);for(i=0;i<s;i++)for(r=0;r<a;r++)l.set(i,r,l.get(i,r)-l.get(s,r)*e.get(i,s))}return l.subMatrix(0,c-1,0,a-1)}isFullRank(){let t=this.QR.columns;for(let e=0;e<t;e++)if(0===this.Rdiag[e])return!1;return!0}get upperTriangularMatrix(){let t,e,n=this.QR,i=n.columns,r=new Pbt(i,i);for(t=0;t<i;t++)for(e=0;e<i;e++)t<e?r.set(t,e,n.get(t,e)):t===e?r.set(t,e,this.Rdiag[t]):r.set(t,e,0);return r}get orthogonalMatrix(){let t,e,n,i,r=this.QR,s=r.rows,o=r.columns,a=new Pbt(s,o);for(n=o-1;n>=0;n--){for(t=0;t<s;t++)a.set(t,n,0);for(a.set(n,n,1),e=n;e<o;e++)if(0!==r.get(n,n)){for(i=0,t=n;t<s;t++)i+=r.get(t,n)*a.get(t,e);for(i=-i/r.get(n,n),t=n;t<s;t++)a.set(t,e,a.get(t,e)+i*r.get(t,n))}}return a}}let zbt=class{constructor(t,e={}){if((t=Obt.checkMatrix(t)).isEmpty())throw new Error("Matrix must be non-empty");let n=t.rows,i=t.columns;const{computeLeftSingularVectors:r=!0,computeRightSingularVectors:s=!0,autoTranspose:o=!1}=e;let a,l=Boolean(r),c=Boolean(s),u=!1;if(n<i)if(o){a=t.transpose(),n=a.rows,i=a.columns,u=!0;let e=l;l=c,c=e}else a=t.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else a=t.clone();let h=Math.min(n,i),d=Math.min(n+1,i),p=new Float64Array(d),f=new Pbt(n,h),m=new Pbt(i,i),g=new Float64Array(i),y=new Float64Array(n),b=new Float64Array(d);for(let t=0;t<d;t++)b[t]=t;let v=Math.min(n-1,i),x=Math.max(0,Math.min(i-2,n)),w=Math.max(v,x);for(let t=0;t<w;t++){if(t<v){p[t]=0;for(let e=t;e<n;e++)p[t]=Dbt(p[t],a.get(e,t));if(0!==p[t]){a.get(t,t)<0&&(p[t]=-p[t]);for(let e=t;e<n;e++)a.set(e,t,a.get(e,t)/p[t]);a.set(t,t,a.get(t,t)+1)}p[t]=-p[t]}for(let e=t+1;e<i;e++){if(t<v&&0!==p[t]){let i=0;for(let r=t;r<n;r++)i+=a.get(r,t)*a.get(r,e);i=-i/a.get(t,t);for(let r=t;r<n;r++)a.set(r,e,a.get(r,e)+i*a.get(r,t))}g[e]=a.get(t,e)}if(l&&t<v)for(let e=t;e<n;e++)f.set(e,t,a.get(e,t));if(t<x){g[t]=0;for(let e=t+1;e<i;e++)g[t]=Dbt(g[t],g[e]);if(0!==g[t]){g[t+1]<0&&(g[t]=0-g[t]);for(let e=t+1;e<i;e++)g[e]/=g[t];g[t+1]+=1}if(g[t]=-g[t],t+1<n&&0!==g[t]){for(let e=t+1;e<n;e++)y[e]=0;for(let e=t+1;e<n;e++)for(let n=t+1;n<i;n++)y[e]+=g[n]*a.get(e,n);for(let e=t+1;e<i;e++){let i=-g[e]/g[t+1];for(let r=t+1;r<n;r++)a.set(r,e,a.get(r,e)+i*y[r])}}if(c)for(let e=t+1;e<i;e++)m.set(e,t,g[e])}}let S=Math.min(i,n+1);if(v<i&&(p[v]=a.get(v,v)),n<S&&(p[S-1]=0),x+1<S&&(g[x]=a.get(x,S-1)),g[S-1]=0,l){for(let t=v;t<h;t++){for(let e=0;e<n;e++)f.set(e,t,0);f.set(t,t,1)}for(let t=v-1;t>=0;t--)if(0!==p[t]){for(let e=t+1;e<h;e++){let i=0;for(let r=t;r<n;r++)i+=f.get(r,t)*f.get(r,e);i=-i/f.get(t,t);for(let r=t;r<n;r++)f.set(r,e,f.get(r,e)+i*f.get(r,t))}for(let e=t;e<n;e++)f.set(e,t,-f.get(e,t));f.set(t,t,1+f.get(t,t));for(let e=0;e<t-1;e++)f.set(e,t,0)}else{for(let e=0;e<n;e++)f.set(e,t,0);f.set(t,t,1)}}if(c)for(let t=i-1;t>=0;t--){if(t<x&&0!==g[t])for(let e=t+1;e<i;e++){let n=0;for(let r=t+1;r<i;r++)n+=m.get(r,t)*m.get(r,e);n=-n/m.get(t+1,t);for(let r=t+1;r<i;r++)m.set(r,e,m.get(r,e)+n*m.get(r,t))}for(let e=0;e<i;e++)m.set(e,t,0);m.set(t,t,1)}let k=S-1,C=Number.EPSILON;for(;S>0;){let t,e;for(t=S-2;t>=-1&&-1!==t;t--){const e=Number.MIN_VALUE+C*Math.abs(p[t]+Math.abs(p[t+1]));if(Math.abs(g[t])<=e||Number.isNaN(g[t])){g[t]=0;break}}if(t===S-2)e=4;else{let n;for(n=S-1;n>=t&&n!==t;n--){let e=(n!==S?Math.abs(g[n]):0)+(n!==t+1?Math.abs(g[n-1]):0);if(Math.abs(p[n])<=C*e){p[n]=0;break}}n===t?e=3:n===S-1?e=1:(e=2,t=n)}switch(t++,e){case 1:{let e=g[S-2];g[S-2]=0;for(let n=S-2;n>=t;n--){let r=Dbt(p[n],e),s=p[n]/r,o=e/r;if(p[n]=r,n!==t&&(e=-o*g[n-1],g[n-1]=s*g[n-1]),c)for(let t=0;t<i;t++)r=s*m.get(t,n)+o*m.get(t,S-1),m.set(t,S-1,-o*m.get(t,n)+s*m.get(t,S-1)),m.set(t,n,r)}break}case 2:{let e=g[t-1];g[t-1]=0;for(let i=t;i<S;i++){let r=Dbt(p[i],e),s=p[i]/r,o=e/r;if(p[i]=r,e=-o*g[i],g[i]=s*g[i],l)for(let e=0;e<n;e++)r=s*f.get(e,i)+o*f.get(e,t-1),f.set(e,t-1,-o*f.get(e,i)+s*f.get(e,t-1)),f.set(e,i,r)}break}case 3:{const e=Math.max(Math.abs(p[S-1]),Math.abs(p[S-2]),Math.abs(g[S-2]),Math.abs(p[t]),Math.abs(g[t])),r=p[S-1]/e,s=p[S-2]/e,o=g[S-2]/e,a=p[t]/e,u=g[t]/e,h=((s+r)*(s-r)+o*o)/2,d=r*o*(r*o);let y=0;0===h&&0===d||(y=h<0?0-Math.sqrt(h*h+d):Math.sqrt(h*h+d),y=d/(h+y));let b=(a+r)*(a-r)+y,v=a*u;for(let e=t;e<S-1;e++){let r=Dbt(b,v);0===r&&(r=Number.MIN_VALUE);let s=b/r,o=v/r;if(e!==t&&(g[e-1]=r),b=s*p[e]+o*g[e],g[e]=s*g[e]-o*p[e],v=o*p[e+1],p[e+1]=s*p[e+1],c)for(let t=0;t<i;t++)r=s*m.get(t,e)+o*m.get(t,e+1),m.set(t,e+1,-o*m.get(t,e)+s*m.get(t,e+1)),m.set(t,e,r);if(r=Dbt(b,v),0===r&&(r=Number.MIN_VALUE),s=b/r,o=v/r,p[e]=r,b=s*g[e]+o*p[e+1],p[e+1]=-o*g[e]+s*p[e+1],v=o*g[e+1],g[e+1]=s*g[e+1],l&&e<n-1)for(let t=0;t<n;t++)r=s*f.get(t,e)+o*f.get(t,e+1),f.set(t,e+1,-o*f.get(t,e)+s*f.get(t,e+1)),f.set(t,e,r)}g[S-2]=b;break}case 4:if(p[t]<=0&&(p[t]=p[t]<0?-p[t]:0,c))for(let e=0;e<=k;e++)m.set(e,t,-m.get(e,t));for(;t<k&&!(p[t]>=p[t+1]);){let e=p[t];if(p[t]=p[t+1],p[t+1]=e,c&&t<i-1)for(let n=0;n<i;n++)e=m.get(n,t+1),m.set(n,t+1,m.get(n,t)),m.set(n,t,e);if(l&&t<n-1)for(let i=0;i<n;i++)e=f.get(i,t+1),f.set(i,t+1,f.get(i,t)),f.set(i,t,e);t++}S--}}if(u){let t=m;m=f,f=t}this.m=n,this.n=i,this.s=p,this.U=f,this.V=m}solve(t){let e=t,n=this.threshold,i=this.s.length,r=Pbt.zeros(i,i);for(let t=0;t<i;t++)Math.abs(this.s[t])<=n?r.set(t,t,0):r.set(t,t,1/this.s[t]);let s=this.U,o=this.rightSingularVectors,a=o.mmul(r),l=o.rows,c=s.rows,u=Pbt.zeros(l,c);for(let t=0;t<l;t++)for(let e=0;e<c;e++){let n=0;for(let r=0;r<i;r++)n+=a.get(t,r)*s.get(e,r);u.set(t,e,n)}return u.mmul(e)}solveForDiagonal(t){return this.solve(Pbt.diag(t))}inverse(){let t=this.V,e=this.threshold,n=t.rows,i=t.columns,r=new Pbt(n,this.s.length);for(let s=0;s<n;s++)for(let n=0;n<i;n++)Math.abs(this.s[n])>e&&r.set(s,n,t.get(s,n)/this.s[n]);let s=this.U,o=s.rows,a=s.columns,l=new Pbt(n,o);for(let t=0;t<n;t++)for(let e=0;e<o;e++){let n=0;for(let i=0;i<a;i++)n+=r.get(t,i)*s.get(e,i);l.set(t,e,n)}return l}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,n=this.s;for(let i=0,r=n.length;i<r;i++)n[i]>t&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Pbt.diag(this.s)}};function Bbt(t,e=!1){return t=Obt.checkMatrix(t),e?new zbt(t).inverse():function(t,e,n=!1){return t=Obt.checkMatrix(t),e=Obt.checkMatrix(e),n?new zbt(t).solve(e):t.isSquare()?new Lbt(t).solve(e):new Fbt(t).solve(e)}(t,Pbt.eye(t.rows))}function Ubt(t,e){const n=new Pbt(t.rows,e.rows);for(let i=0;i<t.rows;i++)for(let r=0;r<e.rows;r++)n.set(i,r,lbt(t.getRow(i),e.getRow(r)));return n}function Vbt(t){let e=[];for(let n=0;n<t;n++)e.push(n);return e}function Wbt(t){let e=[t[0]];for(let n=1;n<t.length;n++)e[n]=e[n-1]+t[n];return e}const Hbt=Symbol("distance");class jbt{constructor(t,e,n,i,r){this.clusters=t,this.centroids=e,this.converged=n,this.iterations=i,this[Hbt]=r}nearest(t){const e=new Array(t.length);return hbt(t,this.centroids.map((function(t){return t.centroid})),e,this[Hbt])}computeInformation(t){for(var e=this.centroids.map((function(t){return{centroid:t,error:0,size:0}})),n=0;n<t.length;n++)e[this.clusters[n]].error+=this[Hbt](t[n],this.centroids[this.clusters[n]]),e[this.clusters[n]].size++;for(var i=0;i<this.centroids.length;i++)e[i].size?e[i].error/=e[i].size:e[i].error=null;return new jbt(this.clusters,e,this.converged,this.iterations,this[Hbt])}}const Gbt={maxIterations:100,tolerance:1e-6,withIterations:!1,initialization:"kmeans++",distanceFunction:lbt};function qbt(t,e,n,i,r,s){var o=function(t,e,n,i){const r=e[0].length;for(var s=new Array(i),o=new Array(i),a=0;a<i;a++){s[a]=new Array(r),o[a]=0;for(var l=0;l<r;l++)s[a][l]=0}for(var c=0;c<e.length;c++){o[n[c]]++;for(var u=0;u<r;u++)s[n[c]][u]+=e[c][u]}for(var h=0;h<i;h++)for(var d=0;d<r;d++)o[h]?s[h][d]/=o[h]:s[h][d]=t[h][d];return s}(t,e,n=hbt(e,t,n,r.distanceFunction),i),a=function(t,e,n,i){for(var r=0;r<t.length;r++)if(n(t[r],e[r])>i)return!1;return!0}(o,t,r.distanceFunction,r.tolerance);return new jbt(n,o,a,s,r.distanceFunction)}function Xbt(t,e,n){if(n=Object.assign({},Gbt,n),e<=0||e>t.length||!Number.isInteger(e))throw new Error("K should be a positive integer smaller than the number of points");var i;if(Array.isArray(n.initialization)){if(n.initialization.length!==e)throw new Error("The initial centers should have the same length as K");i=n.initialization}else switch(n.initialization){case"kmeans++":i=function(t,e,n={}){const i=(t=new Pbt(t)).rows,r=new gbt(n.seed),s=[],o=n.localTrials||2+Math.floor(Math.log(e)),a=r.randInt(i);s.push(t.getRow(a));let l=new Pbt(1,t.rows);for(let e=0;e<t.rows;e++)l.set(0,e,lbt(t.getRow(e),s[0]));let c=[Wbt(l.getRow(0))];const u=1/c[0][i-1];let h=Pbt.mul(l,u);for(let n=1;n<e;n++){const e=r.choice(i,{replace:!0,size:o,probabilities:h[0]}),a=Ubt(t.selection(e,Vbt(t.columns)),t);let u,d,p;for(let t=0;t<o;t++){const n=Pbt.min(l,[a.getRow(t)]),i=n.sum();(void 0===u||i<d)&&(u=e[t],d=i,p=n)}s[n]=t.getRow(u),l=p,c=[Wbt(l.getRow(0))],h=Pbt.mul(l,1/c[0][i-1])}return s}(t,e,n);break;case"random":i=function(t,e,n){return new gbt(n).choice(t,{size:e})}(t,e,n.seed);break;case"mostDistant":i=function(t,e,n,i){const r=new gbt(i);var s=new Array(e);if(s[0]=Math.floor(r.random()*t.length),e>1){for(var o={dist:-1,index:-1},a=0;a<t.length;++a)n[s[0]][a]>o.dist&&(o.dist=n[s[0]][a],o.index=a);if(s[1]=o.index,e>2)for(var l=2;l<e;++l){for(var c={dist:-1,index:-1},u=0;u<t.length;++u){for(var h={dist:Number.MAX_VALUE,index:-1},d=0;d<l;++d)n[d][u]<h.dist&&-1===s.indexOf(u)&&(h={dist:n[d][u],index:u});h.dist!==Number.MAX_VALUE&&h.dist>c.dist&&(c=Object.assign({},h))}s[l]=c.index}}return s.map((e=>t[e]))}(t,e,function(t,e){for(var n=new Array(t.length),i=0;i<t.length;++i)for(var r=i;r<t.length;++r){n[i]||(n[i]=new Array(t.length)),n[r]||(n[r]=new Array(t.length));const s=e(t[i],t[r]);n[i][r]=s,n[r][i]=s}return n}(t,n.distanceFunction),n.seed);break;default:throw new Error(`Unknown initialization method: "${n.initialization}"`)}0===n.maxIterations&&(n.maxIterations=Number.MAX_VALUE);var r=new Array(t.length);if(n.withIterations)return function*(t,e,n,i,r){for(var s,o=!1,a=0;!o&&a<r.maxIterations;)s=qbt(t,e,n,i,r,++a),yield s.computeInformation(e),o=s.converged,t=s.centroids}(i,t,r,e,n);for(var s,o=!1,a=0;!o&&a<n.maxIterations;)o=(s=qbt(i,t,r,e,n,++a)).converged,i=s.centroids;return s.computeInformation(t)}function Kbt(t,e){return t.map(((t,n)=>Math.abs(t-e[n])**2)).reduce(((t,e)=>t+e))**.5}class Ybt extends i3{constructor({k:t=3}={}){super(),this.title="k-means clustering",this.serviceName="kmeans-models",this.parameters={k:new eK(t,!0)},this.$centers=new eK([],!1),this.$clusters=new eK([],!1),this.dataset=[],this.start()}async train(t){this.$training.set({status:"start",epochs:1});const e=n3(t)?t.items():t;for await(const{x:t}of e)this.dataset.push(t);const n=Xbt(this.dataset,this.parameters.k.get());this.$centers.set(n.centroids.map((t=>t.centroid))),this.$clusters.set(n.clusters),this.$training.set({status:"success"})}async predict(t){let e=0,n=1e3;const i={};let r=0;for(let s=0;s<this.$centers.get().length;s++){const o=Kbt(this.$centers.get()[s],t);o<n&&(n=o,e=s),i[`${s}`]=Math.exp(o),r+=Math.exp(o)}if(Object.entries(i).forEach((([t])=>{i[t]/=r})),0===this.$centers.get().length){const t=new Error("KMeans is not trained");t.name="[KMeans] Prediction Error",cK(t)}return{cluster:e,confidences:i}}async batchPredict(t){const e=[],n=n3(t)?t.items():t;for await(const{x:t}of n)e.push(t);const i=[];for(let t=0;t<e.length;t++)this.predict(e[t]).then((t=>i.push(t)));if(0===this.$centers.get().length){const t=new Error("KMeans is not trained");t.name="[KMeans] Prediction Error",cK(t)}return i}async save(t,e,n,i=null){const r=await this.write(n);return r.name=e,this.saveToDatastore(t,r,i)}async load(t,e){const n=await this.loadFromDatastore(t,e);return await this.read(n),n}async download(t){const e=await this.write(t);s2(JSON.stringify(e),`${e.name}.json`,"text/plain")}async upload(...t){const e=t.filter((t=>t.name.includes(".json"))),n=await new Promise(((t,n)=>{const i=new FileReader;i.onload=()=>{const e=JSON.parse(i.result);t(e)},i.onerror=n,i.readAsText(e[0])}));return await this.read(n),n}async write(t={}){return{name:a2(this.title),files:[],format:"ml-kmeans",metadata:{clusters:this.$clusters.get(),centers:this.$centers.get(),...t}}}async read(t){const e=t.metadata.data;e&&(Object.entries(e).forEach((([t,e])=>{})),this.$clusters.set(t.metadata.labels),this.$training.set({status:"loaded"}))}}function Zbt(...t){return new Ybt(...t)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Jbt(t,e,n,i){return new(n||(n=Promise))((function(r,s){function o(t){try{l(i.next(t))}catch(t){s(t)}}function a(t){try{l(i.throw(t))}catch(t){s(t)}}function l(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(o,a)}l((i=i.apply(t,e||[])).next())}))}function Qbt(t,e){var n,i,r,s,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function a(s){return function(a){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,i&&(r=2&s[0]?i.return:s[0]?i.throw||((r=i.return)&&r.call(i),0):i.next)&&!(r=r.call(i,s[1])).done)return r;switch(i=0,r&&(s=[2&s[0],r.value]),s[0]){case 0:case 1:r=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,i=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(r=o.trys,(r=r.length>0&&r[r.length-1])||6!==s[0]&&2!==s[0])){o=0;continue}if(3===s[0]&&(!r||s[1]>r[0]&&s[1]<r[3])){o.label=s[1];break}if(6===s[0]&&o.label<r[1]){o.label=r[1],r=s;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(s);break}r[2]&&o.ops.pop(),o.trys.pop();continue}s=e.call(t,o)}catch(t){s=[6,t],i=0}finally{n=r=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,a])}}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tvt(t,e){for(var n=[],i=0;i<t.length;i++)n.push({value:t[i],index:i});n.sort((function(t,e){return e.value-t.value}));var r=new Float32Array(e),s=new Int32Array(e);for(i=0;i<e;i++)r[i]=n[i].value,s[i]=n[i].index;return{values:r,indices:s}}UX([aK],Ybt.prototype,"train",null),UX([aK],Ybt.prototype,"predict",null),UX([aK],Ybt.prototype,"batchPredict",null),Lr().prototype.flatten=function(){return this.throwIfDisposed(),ca(this,[this.size])},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Lr().prototype.norm=function(t,e,n){return this.throwIfDisposed(),Tl(this,t,e,n)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Lr().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),pa(this,t,e,n)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Lr().prototype.as1D=function(){return this.throwIfDisposed(),ca(this,[this.size])},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Lr().prototype.as2D=function(t,e){return this.throwIfDisposed(),ca(this,[t,e])},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Lr().prototype.asType=function(t){return this.throwIfDisposed(),vo(this,t)};var evt=function(){function t(){this.classDatasetMatrices={},this.classExampleCount={},this.labelToClassId={},this.nextClassId=0}return t.prototype.addExample=function(t,e){var n=this;if(null==this.exampleShape&&(this.exampleShape=t.shape),!m(this.exampleShape,t.shape))throw new Error("Example shape provided, ".concat(t.shape," does not match ")+"previously provided example shapes ".concat(this.exampleShape,"."));this.clearTrainDatasetMatrix(),e in this.labelToClassId||(this.labelToClassId[e]=this.nextClassId++),Co((function(){var i=n.normalizeVectorToUnitLength(ca(t,[t.size])),r=i.shape[0];if(null==n.classDatasetMatrices[e])n.classDatasetMatrices[e]=ca(i,[1,r]);else{var s=da([ca(n.classDatasetMatrices[e],[n.classExampleCount[e],r]),ca(i,[1,r])],0);n.classDatasetMatrices[e].dispose(),n.classDatasetMatrices[e]=s}_o(n.classDatasetMatrices[e]),null==n.classExampleCount[e]&&(n.classExampleCount[e]=0),n.classExampleCount[e]++}))},t.prototype.similarities=function(t){var e=this;return Co((function(){var n,i,r=e.normalizeVectorToUnitLength(ca(t,[t.size])),s=r.shape[0];if(null==e.trainDatasetMatrix){var o=null;for(var a in e.classDatasetMatrices)n=o,i=e.classDatasetMatrices[a],o=null==n&&null==i?null:null==n?i.clone():null===i?n.clone():da([n,i],0);e.trainDatasetMatrix=o}if(null==e.trainDatasetMatrix)return console.warn("Cannot predict without providing training examples."),null;_o(e.trainDatasetMatrix);var l=e.getNumExamples();return ca(pa(ca(e.trainDatasetMatrix,[l,s]),ca(r,[s,1])),[l])}))},t.prototype.predictClass=function(t,e){return void 0===e&&(e=3),Jbt(this,void 0,void 0,(function(){var n,i,r,s,o=this;return Qbt(this,(function(a){switch(a.label){case 0:if(e<1)throw new Error("Please provide a positive integer k value to predictClass.");if(0===this.getNumExamples())throw new Error("You have not added any examples to the KNN classifier. Please add examples before calling predictClass.");return n=Co((function(){return vo(o.similarities(t),"float32")})),i=Math.min(e,this.getNumExamples()),s=tvt,[4,n.data()];case 1:return r=s.apply(void 0,[a.sent(),i]).indices,n.dispose(),[2,this.calculateTopClass(r,i)]}}))}))},t.prototype.clearClass=function(t){if(null==this.classDatasetMatrices[t])throw new Error("Cannot clear invalid class ".concat(t));this.classDatasetMatrices[t].dispose(),delete this.classDatasetMatrices[t],delete this.classExampleCount[t],this.clearTrainDatasetMatrix()},t.prototype.clearAllClasses=function(){for(var t in this.classDatasetMatrices)this.clearClass(t)},t.prototype.getClassExampleCount=function(){return this.classExampleCount},t.prototype.getClassifierDataset=function(){return this.classDatasetMatrices},t.prototype.getNumClasses=function(){return Object.keys(this.classExampleCount).length},t.prototype.setClassifierDataset=function(t){for(var e in this.clearTrainDatasetMatrix(),this.classDatasetMatrices=t,t)this.classExampleCount[e]=t[e].shape[0]},t.prototype.calculateTopClass=function(t,e){var n,i={};if(null==t)return{classIndex:this.labelToClassId[n],label:n,confidences:i};var r={},s=0;for(var o in this.classDatasetMatrices)s+=this.classExampleCount[o],r[o]=s;var a={};for(var o in this.classDatasetMatrices)a[o]=0;for(var l=0;l<t.length;l++){var c=t[l];for(var o in this.classDatasetMatrices)if(c<r[o]){a[o]++;break}}var u=0;for(var o in this.classDatasetMatrices){var h=a[o]/e;h>u&&(u=h,n=o),i[o]=h}return{classIndex:this.labelToClassId[n],label:n,confidences:i}},t.prototype.clearTrainDatasetMatrix=function(){null!=this.trainDatasetMatrix&&(this.trainDatasetMatrix.dispose(),this.trainDatasetMatrix=null)},t.prototype.normalizeVectorToUnitLength=function(t){return Co((function(){var e=Tl(t);return Ro(t,e)}))},t.prototype.getNumExamples=function(){var t=0;for(var e in this.classDatasetMatrices)t+=this.classExampleCount[e];return t},t.prototype.dispose=function(){for(var t in this.clearTrainDatasetMatrix(),this.classDatasetMatrices)this.classDatasetMatrices[t].dispose()},t}();class nvt extends i3{constructor({k:t=3}={}){super(),this.title="KNN classifier",this.serviceName="knn-classifier-models",this.classifier=new evt,this.parameters={k:new eK(t,!0)}}async train(t){this.labels=n3(t)?await t.distinct("y"):this.labels=Array.from(new Set(await t.map((({y:t})=>t)).toArray()));const e=n3(t)?t.items():t;if(this.labels.length<1)throw this.$training.set({status:"error"}),new Error("Cannot train a kNN with no classes");this.$training.set({status:"start",epochs:1}),this.classifier.clearAllClasses();for await(const{x:t,y:n}of e)this.classifier.addExample(xs(t),n);this.$training.set({status:"success"})}async predict(t){if(!this.classifier||!this.labels||this.labels.length<1)return{label:void 0,confidences:{}};const{label:e,confidences:n}=await this.classifier.predictClass(xs(t),this.parameters.k.get());return{label:e,confidences:n}}clear(){delete this.classifier}async save(t,e,n,i=null){const r=await this.write(n);return r.name=e,this.saveToDatastore(t,r,i)}async load(t,e){const n=await this.loadFromDatastore(t,e);return await this.read(n),n}async download(t){const e=await this.write(t);s2(JSON.stringify(e),`${e.name}.json`,"text/plain")}async upload(...t){const e=t.filter((t=>t.name.includes(".json"))),n=await new Promise(((t,n)=>{const i=new FileReader;i.onload=()=>{const e=JSON.parse(i.result);t(e)},i.onerror=n,i.readAsText(e[0])}));return await this.read(n),n}async write(t={}){if(!this.classifier)return null;const e=this.classifier.getClassifierDataset(),n={};for(const t of Object.keys(e)){const i=e[t].arraySync();n[t]=i}return{name:a2(this.title),files:[],format:"knn-classifier",metadata:{labels:this.labels,data:n,...t}}}async read(t){const e=t.metadata.data;if(!e)return;const n={};for(const[t,i]of Object.entries(e))n[t]=rh(i);this.labels=t.metadata.labels,this.classifier.setClassifierDataset(n),this.$training.set({status:"loaded"})}}function ivt(...t){return new nvt(...t)}UX([aK],nvt.prototype,"train",null),UX([aK],nvt.prototype,"predict",null);const rvt=document.createElement("video"),svt=document.createElement("canvas"),ovt=100;async function avt(t){let e=await new Promise(((e,n)=>{rvt.addEventListener("loadedmetadata",(()=>{e(rvt.duration)})),rvt.src=window.URL.createObjectURL(t),rvt.onerror=t=>n(t.target.error)}));e===1/0&&(rvt.currentTime=Number.MAX_SAFE_INTEGER,e=await new Promise(((t,e)=>{rvt.ontimeupdate=()=>{rvt.ontimeupdate=null,rvt.currentTime=0,t(rvt.duration)},rvt.onerror=t=>e(t.target.error)})));const n=await new Promise(((t,n)=>{const i=()=>{try{svt.width=ovt,svt.height=ovt*rvt.videoHeight/rvt.videoWidth;const e=svt.height*rvt.videoWidth/rvt.videoHeight;svt.getContext("2d").drawImage(rvt,svt.width/2-e/2,0,e,svt.height);const n=svt.toDataURL("image/jpeg");rvt.pause(),rvt.removeEventListener("timeupdate",i),t(n)}catch(t){n(t)}};rvt.addEventListener("timeupdate",i),rvt.currentTime=e/2}));return[e,n]}var lvt={exports:{}};!function(t){var e;e=function(){var t={172351395:{name:"EBML",type:"Container"},646:{name:"EBMLVersion",type:"Uint"},759:{name:"EBMLReadVersion",type:"Uint"},754:{name:"EBMLMaxIDLength",type:"Uint"},755:{name:"EBMLMaxSizeLength",type:"Uint"},642:{name:"DocType",type:"String"},647:{name:"DocTypeVersion",type:"Uint"},645:{name:"DocTypeReadVersion",type:"Uint"},108:{name:"Void",type:"Binary"},63:{name:"CRC-32",type:"Binary"},190023271:{name:"SignatureSlot",type:"Container"},16010:{name:"SignatureAlgo",type:"Uint"},16026:{name:"SignatureHash",type:"Uint"},16037:{name:"SignaturePublicKey",type:"Binary"},16053:{name:"Signature",type:"Binary"},15963:{name:"SignatureElements",type:"Container"},15995:{name:"SignatureElementList",type:"Container"},9522:{name:"SignedElement",type:"Binary"},139690087:{name:"Segment",type:"Container"},21863284:{name:"SeekHead",type:"Container"},3515:{name:"Seek",type:"Container"},5035:{name:"SeekID",type:"Binary"},5036:{name:"SeekPosition",type:"Uint"},88713574:{name:"Info",type:"Container"},13220:{name:"SegmentUID",type:"Binary"},13188:{name:"SegmentFilename",type:"String"},1882403:{name:"PrevUID",type:"Binary"},1868715:{name:"PrevFilename",type:"String"},2013475:{name:"NextUID",type:"Binary"},1999803:{name:"NextFilename",type:"String"},1092:{name:"SegmentFamily",type:"Binary"},10532:{name:"ChapterTranslate",type:"Container"},10748:{name:"ChapterTranslateEditionUID",type:"Uint"},10687:{name:"ChapterTranslateCodec",type:"Uint"},10661:{name:"ChapterTranslateID",type:"Binary"},710577:{name:"TimecodeScale",type:"Uint"},1161:{name:"Duration",type:"Float"},1121:{name:"DateUTC",type:"Date"},15273:{name:"Title",type:"String"},3456:{name:"MuxingApp",type:"String"},5953:{name:"WritingApp",type:"String"},103:{name:"Timecode",type:"Uint"},6228:{name:"SilentTracks",type:"Container"},6359:{name:"SilentTrackNumber",type:"Uint"},39:{name:"Position",type:"Uint"},43:{name:"PrevSize",type:"Uint"},35:{name:"SimpleBlock",type:"Binary"},32:{name:"BlockGroup",type:"Container"},33:{name:"Block",type:"Binary"},34:{name:"BlockVirtual",type:"Binary"},13729:{name:"BlockAdditions",type:"Container"},38:{name:"BlockMore",type:"Container"},110:{name:"BlockAddID",type:"Uint"},37:{name:"BlockAdditional",type:"Binary"},27:{name:"BlockDuration",type:"Uint"},122:{name:"ReferencePriority",type:"Uint"},123:{name:"ReferenceBlock",type:"Int"},125:{name:"ReferenceVirtual",type:"Int"},36:{name:"CodecState",type:"Binary"},13730:{name:"DiscardPadding",type:"Int"},14:{name:"Slices",type:"Container"},104:{name:"TimeSlice",type:"Container"},76:{name:"LaceNumber",type:"Uint"},77:{name:"FrameNumber",type:"Uint"},75:{name:"BlockAdditionID",type:"Uint"},78:{name:"Delay",type:"Uint"},79:{name:"SliceDuration",type:"Uint"},72:{name:"ReferenceFrame",type:"Container"},73:{name:"ReferenceOffset",type:"Uint"},74:{name:"ReferenceTimeCode",type:"Uint"},47:{name:"EncryptedBlock",type:"Binary"},106212971:{name:"Tracks",type:"Container"},46:{name:"TrackEntry",type:"Container"},87:{name:"TrackNumber",type:"Uint"},13253:{name:"TrackUID",type:"Uint"},3:{name:"TrackType",type:"Uint"},57:{name:"FlagEnabled",type:"Uint"},8:{name:"FlagDefault",type:"Uint"},5546:{name:"FlagForced",type:"Uint"},28:{name:"FlagLacing",type:"Uint"},11751:{name:"MinCache",type:"Uint"},11768:{name:"MaxCache",type:"Uint"},254851:{name:"DefaultDuration",type:"Uint"},216698:{name:"DefaultDecodedFieldDuration",type:"Uint"},209231:{name:"TrackTimecodeScale",type:"Float"},4991:{name:"TrackOffset",type:"Int"},5614:{name:"MaxBlockAdditionID",type:"Uint"},4974:{name:"Name",type:"String"},177564:{name:"Language",type:"String"},6:{name:"CodecID",type:"String"},9122:{name:"CodecPrivate",type:"Binary"},362120:{name:"CodecName",type:"String"},13382:{name:"AttachmentLink",type:"Uint"},1742487:{name:"CodecSettings",type:"String"},1785920:{name:"CodecInfoURL",type:"String"},438848:{name:"CodecDownloadURL",type:"String"},42:{name:"CodecDecodeAll",type:"Uint"},12203:{name:"TrackOverlay",type:"Uint"},5802:{name:"CodecDelay",type:"Uint"},5819:{name:"SeekPreRoll",type:"Uint"},9764:{name:"TrackTranslate",type:"Container"},9980:{name:"TrackTranslateEditionUID",type:"Uint"},9919:{name:"TrackTranslateCodec",type:"Uint"},9893:{name:"TrackTranslateTrackID",type:"Binary"},96:{name:"Video",type:"Container"},26:{name:"FlagInterlaced",type:"Uint"},5048:{name:"StereoMode",type:"Uint"},5056:{name:"AlphaMode",type:"Uint"},5049:{name:"OldStereoMode",type:"Uint"},48:{name:"PixelWidth",type:"Uint"},58:{name:"PixelHeight",type:"Uint"},5290:{name:"PixelCropBottom",type:"Uint"},5307:{name:"PixelCropTop",type:"Uint"},5324:{name:"PixelCropLeft",type:"Uint"},5341:{name:"PixelCropRight",type:"Uint"},5296:{name:"DisplayWidth",type:"Uint"},5306:{name:"DisplayHeight",type:"Uint"},5298:{name:"DisplayUnit",type:"Uint"},5299:{name:"AspectRatioType",type:"Uint"},963876:{name:"ColourSpace",type:"Binary"},1029411:{name:"GammaValue",type:"Float"},230371:{name:"FrameRate",type:"Float"},97:{name:"Audio",type:"Container"},53:{name:"SamplingFrequency",type:"Float"},14517:{name:"OutputSamplingFrequency",type:"Float"},31:{name:"Channels",type:"Uint"},15739:{name:"ChannelPositions",type:"Binary"},8804:{name:"BitDepth",type:"Uint"},98:{name:"TrackOperation",type:"Container"},99:{name:"TrackCombinePlanes",type:"Container"},100:{name:"TrackPlane",type:"Container"},101:{name:"TrackPlaneUID",type:"Uint"},102:{name:"TrackPlaneType",type:"Uint"},105:{name:"TrackJoinBlocks",type:"Container"},109:{name:"TrackJoinUID",type:"Uint"},64:{name:"TrickTrackUID",type:"Uint"},65:{name:"TrickTrackSegmentUID",type:"Binary"},70:{name:"TrickTrackFlag",type:"Uint"},71:{name:"TrickMasterTrackUID",type:"Uint"},68:{name:"TrickMasterTrackSegmentUID",type:"Binary"},11648:{name:"ContentEncodings",type:"Container"},8768:{name:"ContentEncoding",type:"Container"},4145:{name:"ContentEncodingOrder",type:"Uint"},4146:{name:"ContentEncodingScope",type:"Uint"},4147:{name:"ContentEncodingType",type:"Uint"},4148:{name:"ContentCompression",type:"Container"},596:{name:"ContentCompAlgo",type:"Uint"},597:{name:"ContentCompSettings",type:"Binary"},4149:{name:"ContentEncryption",type:"Container"},2017:{name:"ContentEncAlgo",type:"Uint"},2018:{name:"ContentEncKeyID",type:"Binary"},2019:{name:"ContentSignature",type:"Binary"},2020:{name:"ContentSigKeyID",type:"Binary"},2021:{name:"ContentSigAlgo",type:"Uint"},2022:{name:"ContentSigHashAlgo",type:"Uint"},206814059:{name:"Cues",type:"Container"},59:{name:"CuePoint",type:"Container"},51:{name:"CueTime",type:"Uint"},55:{name:"CueTrackPositions",type:"Container"},119:{name:"CueTrack",type:"Uint"},113:{name:"CueClusterPosition",type:"Uint"},112:{name:"CueRelativePosition",type:"Uint"},50:{name:"CueDuration",type:"Uint"},4984:{name:"CueBlockNumber",type:"Uint"},106:{name:"CueCodecState",type:"Uint"},91:{name:"CueReference",type:"Container"},22:{name:"CueRefTime",type:"Uint"},23:{name:"CueRefCluster",type:"Uint"},4959:{name:"CueRefNumber",type:"Uint"},107:{name:"CueRefCodecState",type:"Uint"},155296873:{name:"Attachments",type:"Container"},8615:{name:"AttachedFile",type:"Container"},1662:{name:"FileDescription",type:"String"},1646:{name:"FileName",type:"String"},1632:{name:"FileMimeType",type:"String"},1628:{name:"FileData",type:"Binary"},1710:{name:"FileUID",type:"Uint"},1653:{name:"FileReferral",type:"Binary"},1633:{name:"FileUsedStartTime",type:"Uint"},1634:{name:"FileUsedEndTime",type:"Uint"},4433776:{name:"Chapters",type:"Container"},1465:{name:"EditionEntry",type:"Container"},1468:{name:"EditionUID",type:"Uint"},1469:{name:"EditionFlagHidden",type:"Uint"},1499:{name:"EditionFlagDefault",type:"Uint"},1501:{name:"EditionFlagOrdered",type:"Uint"},54:{name:"ChapterAtom",type:"Container"},13252:{name:"ChapterUID",type:"Uint"},5716:{name:"ChapterStringUID",type:"String"},17:{name:"ChapterTimeStart",type:"Uint"},18:{name:"ChapterTimeEnd",type:"Uint"},24:{name:"ChapterFlagHidden",type:"Uint"},1432:{name:"ChapterFlagEnabled",type:"Uint"},11879:{name:"ChapterSegmentUID",type:"Binary"},11964:{name:"ChapterSegmentEditionUID",type:"Uint"},9155:{name:"ChapterPhysicalEquiv",type:"Uint"},15:{name:"ChapterTrack",type:"Container"},9:{name:"ChapterTrackNumber",type:"Uint"},0:{name:"ChapterDisplay",type:"Container"},5:{name:"ChapString",type:"String"},892:{name:"ChapLanguage",type:"String"},894:{name:"ChapCountry",type:"String"},10564:{name:"ChapProcess",type:"Container"},10581:{name:"ChapProcessCodecID",type:"Uint"},1293:{name:"ChapProcessPrivate",type:"Binary"},10513:{name:"ChapProcessCommand",type:"Container"},10530:{name:"ChapProcessTime",type:"Uint"},10547:{name:"ChapProcessData",type:"Binary"},39109479:{name:"Tags",type:"Container"},13171:{name:"Tag",type:"Container"},9152:{name:"Targets",type:"Container"},10442:{name:"TargetTypeValue",type:"Uint"},9162:{name:"TargetType",type:"String"},9157:{name:"TagTrackUID",type:"Uint"},9161:{name:"TagEditionUID",type:"Uint"},9156:{name:"TagChapterUID",type:"Uint"},9158:{name:"TagAttachmentUID",type:"Uint"},10184:{name:"SimpleTag",type:"Container"},1443:{name:"TagName",type:"String"},1146:{name:"TagLanguage",type:"String"},1156:{name:"TagDefault",type:"Uint"},1159:{name:"TagString",type:"String"},1157:{name:"TagBinary",type:"Binary"}};function e(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t}function n(t,e){this.name=t||"Unknown",this.type=e||"Unknown"}function i(t,e){n.call(this,t,e||"Uint")}function r(t){return t.length%2==1?"0"+t:t}function s(t,e){n.call(this,t,e||"Float")}function o(t,e){n.call(this,t,e||"Container")}function a(t){o.call(this,"File","File"),this.setSource(t)}function l(t,e,n,i){if("object"==typeof n&&(i=n,n=void 0),!n)return new Promise((function(n){l(t,e,n,i)}));try{var r=new FileReader;r.onloadend=function(){try{var s=new a(new Uint8Array(r.result));s.fixDuration(e,i)&&(t=s.toBlob(t.type))}catch(t){}n(t)},r.readAsArrayBuffer(t)}catch(e){n(t)}}return n.prototype.updateBySource=function(){},n.prototype.setSource=function(t){this.source=t,this.updateBySource()},n.prototype.updateByData=function(){},n.prototype.setData=function(t){this.data=t,this.updateByData()},e(i,n),i.prototype.updateBySource=function(){this.data="";for(var t=0;t<this.source.length;t++){var e=this.source[t].toString(16);this.data+=r(e)}},i.prototype.updateByData=function(){var t=this.data.length/2;this.source=new Uint8Array(t);for(var e=0;e<t;e++){var n=this.data.substr(2*e,2);this.source[e]=parseInt(n,16)}},i.prototype.getValue=function(){return parseInt(this.data,16)},i.prototype.setValue=function(t){this.setData(r(t.toString(16)))},e(s,n),s.prototype.getFloatArrayType=function(){return this.source&&4===this.source.length?Float32Array:Float64Array},s.prototype.updateBySource=function(){var t=this.source.reverse(),e=new(this.getFloatArrayType())(t.buffer);this.data=e[0]},s.prototype.updateByData=function(){var t=new(this.getFloatArrayType())([this.data]),e=new Uint8Array(t.buffer);this.source=e.reverse()},s.prototype.getValue=function(){return this.data},s.prototype.setValue=function(t){this.setData(t)},e(o,n),o.prototype.readByte=function(){return this.source[this.offset++]},o.prototype.readUint=function(){for(var t=this.readByte(),e=8-t.toString(2).length,n=t-(1<<7-e),i=0;i<e;i++)n*=256,n+=this.readByte();return n},o.prototype.updateBySource=function(){for(this.data=[],this.offset=0;this.offset<this.source.length;this.offset=a){var e=this.readUint(),r=this.readUint(),a=Math.min(this.offset+r,this.source.length),l=this.source.slice(this.offset,a),c=t[e]||{name:"Unknown",type:"Unknown"},u=n;switch(c.type){case"Container":u=o;break;case"Uint":u=i;break;case"Float":u=s}var h=new u(c.name,c.type);h.setSource(l),this.data.push({id:e,idHex:e.toString(16),data:h})}},o.prototype.writeUint=function(t,e){for(var n=1,i=128;t>=i&&n<8;n++,i*=128);if(!e)for(var r=i+t,s=n-1;s>=0;s--){var o=r%256;this.source[this.offset+s]=o,r=(r-o)/256}this.offset+=n},o.prototype.writeSections=function(t){this.offset=0;for(var e=0;e<this.data.length;e++){var n=this.data[e],i=n.data.source,r=i.length;this.writeUint(n.id,t),this.writeUint(r,t),t||this.source.set(i,this.offset),this.offset+=r}return this.offset},o.prototype.updateByData=function(){var t=this.writeSections("draft");this.source=new Uint8Array(t),this.writeSections()},o.prototype.getSectionById=function(t){for(var e=0;e<this.data.length;e++){var n=this.data[e];if(n.id===t)return n.data}return null},e(a,o),a.prototype.fixDuration=function(t,e){var n=e&&e.logger;void 0===n?n=function(t){console.log(t)}:n||(n=function(){});var i=this.getSectionById(139690087);if(!i)return n("[fix-webm-duration] Segment section is missing"),!1;var r=i.getSectionById(88713574);if(!r)return n("[fix-webm-duration] Info section is missing"),!1;var o=r.getSectionById(710577);if(!o)return n("[fix-webm-duration] TimecodeScale section is missing"),!1;var a=r.getSectionById(1161);if(a){if(!(a.getValue()<=0))return n("[fix-webm-duration] Duration section is present"),!1;n("[fix-webm-duration] Duration section is present, but the value is empty"),a.setValue(t)}else n("[fix-webm-duration] Duration section is missing"),(a=new s("Duration","Float")).setValue(t),r.data.push({id:1161,data:a});return o.setValue(1e6),r.updateByData(),i.updateByData(),this.updateByData(),!0},a.prototype.toBlob=function(t){return new Blob([this.source.buffer],{type:t||"video/webm"})},l.default=l,l},t.exports?t.exports=e():window.ysFixWebmDuration=e()}(lvt);var cvt=_i(lvt.exports);function uvt(t){let e,n,i,r,s,o,a,l,c,u;return{c(){e=MB("div"),n=MB("div"),i=MB("input"),r=AB(),s=MB("label"),o=AB(),a=MB("div"),l=IB(t[2]),OB(i,"type","checkbox"),OB(i,"id","btn"),OB(i,"class","svelte-r0mvso"),OB(s,"for","btn"),OB(s,"class","svelte-r0mvso"),OB(n,"class","recorder-container svelte-r0mvso"),OB(a,"class","text-gray-600"),OB(e,"class","flex flex-col items-center")},m(h,d){TB(h,e,d),SB(e,n),SB(n,i),i.checked=t[3],SB(n,r),SB(n,s),SB(e,o),SB(e,a),SB(a,l),c||(u=RB(i,"change",t[6]),c=!0)},p(t,e){8&e&&(i.checked=t[3]),4&e&&DB(l,t[2])},d(t){t&&_B(e),c=!1,u()}}}function hvt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[uvt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),2060&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function dvt(t,e,n){let i,r=Jz,s=()=>(r(),r=aB(l,(t=>n(3,i=t))),l);t.$$.on_destroy.push((()=>r()));let{title:o}=e,{mediaStream:a}=e,{active:l}=e;s();let c,{recordings:u}=e,h="",d="";return tU((()=>{a.filter((t=>!!t)).subscribe((t=>{c&&"recording"===c.state&&c.stop(),c=new MediaRecorder(t)})),l.subscribe((t=>{if(t)try{!function(){if(!c){const t=new Error("Cannot find an input MediaStream");t.name="Check if your input device is active",cK(t)}}(),function(){const t=[];c.ondataavailable=e=>t.push(e.data),c.start();const e=Date.now();n(2,h="00:00:00");const i=setInterval((()=>{const t=new Date(Date.now()-e),i=t.getUTCHours().toString().padStart(2,"0"),r=t.getUTCMinutes().toString().padStart(2,"0"),s=t.getSeconds().toString().padStart(2,"0");n(2,h=`${i}:${r}:${s}`)}),1e3);let r=new Promise(((t,e)=>{c.onstop=t,c.onerror=t=>e(t.name)}));r.then((()=>{clearInterval(i);const e=new Blob(t,{type:t[0].type.split(";")[0]});return Promise.all([e,avt(e)])})).then((([t,[e,n]])=>Promise.all([cvt(t,e,{logger:!1}),e,n]))).then((([e,n,i])=>(d=i,u.set({blob:e,type:e.type,duration:n,thumbnail:d}),t)))}()}catch(t){l.set(!1)}else null==c||c.stop()}))})),t.$$set=t=>{"title"in t&&n(0,o=t.title),"mediaStream"in t&&n(4,a=t.mediaStream),"active"in t&&s(n(1,l=t.active)),"recordings"in t&&n(5,u=t.recordings)},[o,l,h,i,a,u,function(){i=this.checked,l.set(i)}]}class pvt extends UU{constructor(t){super(),BU(this,t,dvt,hvt,rB,{title:0,mediaStream:4,active:1,recordings:5})}}let fvt=class extends xK{constructor(t){super(),this.title="Media Recorder",this.$active=new eK(!1,!0),this.$recordings=new eK(void 0).skip(1),this.$mediaStream=new eK(t,!0),this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new pvt({target:e,props:{title:this.title,mediaStream:this.$mediaStream,active:this.$active,recordings:this.$recordings}}))}};function mvt(...t){return new fvt(...t)}function gvt(t){let e,n,i,r,s,o,a,l;function c(e){t[5](e)}let u={text:"activate microphone"};return void 0!==t[3]&&(u.checked=t[3]),i=new zV({props:u}),aU.push((()=>LU(i,"checked",c))),{c(){e=MB("div"),n=MB("div"),DU(i.$$.fragment),s=AB(),o=MB("div"),a=MB("canvas"),OB(a,"class","w-full")},m(r,c){TB(r,e,c),SB(e,n),FU(i,n,null),SB(e,s),SB(e,o),SB(o,a),t[6](a),l=!0},p(t,e){const n={};!r&&8&e&&(r=!0,n.checked=t[3],mU((()=>r=!1))),i.$set(n)},i(t){l||(EU(i.$$.fragment,t),l=!0)},o(t){MU(i.$$.fragment,t),l=!1},d(n){n&&_B(e),zU(i),t[6](null)}}}function yvt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[gvt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),65548&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function bvt(t,e,n){let i,r=Jz,s=()=>(r(),r=aB(a,(t=>n(3,i=t))),a);t.$$.on_destroy.push((()=>r()));let{title:o}=e,{active:a}=e;s();let l,c,u,{mediaStream:h}=e,d=0;const p=new window.AudioContext,f=p.createAnalyser();f.fftSize=4096,console.log("analyser.fftSize",f.fftSize);const m=new Uint8Array(f.fftSize);function g(){const t=()=>{u.clearRect(0,0,u.canvas.width,u.canvas.height),function(t=0,e=0,n=u.canvas.width-t,i=u.canvas.height-e){f.getByteTimeDomainData(m);const r=n/m.length;u.beginPath();for(let n=0;n<m.length;n+=2){const s=t+n*r,o=e+i*(m[n]/256);u.lineTo(s,o)}u.stroke()}(),d=window.requestAnimationFrame(t)};t()}return tU((()=>{let t;u=l.getContext("2d"),c=h.subscribe((e=>{e&&(t&&(t.disconnect(),d&&(window.cancelAnimationFrame(d),d=0,u.clearRect(0,0,u.canvas.width,u.canvas.height))),t=p.createMediaStreamSource(e),t.connect(f),g())}))})),nU(c),t.$$set=t=>{"title"in t&&n(0,o=t.title),"active"in t&&s(n(1,a=t.active)),"mediaStream"in t&&n(4,h=t.mediaStream)},[o,a,l,i,h,function(t){i=t,a.set(i)},function(t){aU[t?"unshift":"push"]((()=>{l=t,n(2,l)}))}]}class vvt extends UU{constructor(t){super(),BU(this,t,bvt,yvt,rB,{title:0,active:1,mediaStream:4})}}class xvt extends xK{constructor(){super(),this.$active=new eK(!1,!0),this.$ready=new eK(!1,!0),this.$mediastream=new eK(void 0,!0),this.title="Microphone",this.$active.subscribe((t=>{if(t)this.loadMicrophone();else if(this.$mediastream.get()){const t=this.$mediastream.get().getTracks();for(const e of t)e.stop();this.$ready.set(!1)}})),this.start()}async loadMicrophone(){try{const t=await navigator.mediaDevices.getUserMedia({video:!1,audio:!0});this.$mediastream.set(t),this.$ready.set(!0)}catch(t){cK(new Error("Webcam not supported"))}}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new vvt({target:e,props:{title:this.title,active:this.$active,mediaStream:this.$mediastream}}))}}function wvt(...t){return new xvt(...t)}class Svt extends jnt{constructor({layers:t=[64,32],...e}={}){super(e),this.title="MLPClassifier",this.parameters={layers:new eK(t,!0),...this.parameters}}buildModel(t,e){this.model=W7();for(const[e,n]of this.parameters.layers.get().entries()){const i={units:n,activation:"relu"};0===e&&(i.inputDim=t[0]),this.model.add(ont(i))}this.model.add(ont({units:e[0],activation:"softmax"}));const n=ef.adam();this.model.compile({optimizer:n,loss:"categoricalCrossentropy",metrics:["accuracy"]})}}function kvt(...t){return new Svt(...t)}class Cvt extends Hnt{constructor({units:t=[64,32],...e}={}){super(e),this.title="MLPRegressor",this.parameters={units:new eK(t,!0),...this.parameters}}async train(t,e){this.transformDataset=t=>t.map((t=>({xs:xs(t.x),ys:xs(t.y)}))),super.train(t,e)}buildModel(t,e){const n=this.parameters.units.get();this.model=W7(),this.model.add(
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function(t){return new C5(t)}({inputShape:t}));for(const t of n)this.model.add(ont({units:t,activation:"relu"}));this.model.add(ont({units:e.length>0?e[0]:1}));const i=ef.adam();this.model.compile({optimizer:i,loss:"meanSquaredError",metrics:[ant]})}async predict(t){return this.model?Co((()=>{const e=this._predict(t).arraySync();return 1===e.length?e[0]:e})):null}}function Tvt(...t){return new Cvt(...t)}
/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */function _vt(t,e,n,i){return new(n||(n=Promise))((function(r,s){function o(t){try{l(i.next(t))}catch(t){s(t)}}function a(t){try{l(i.throw(t))}catch(t){s(t)}}function l(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(o,a)}l((i=i.apply(t,e||[])).next())}))}function Evt(t,e){var n,i,r,s,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function a(s){return function(a){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,i&&(r=2&s[0]?i.return:s[0]?i.throw||((r=i.return)&&r.call(i),0):i.next)&&!(r=r.call(i,s[1])).done)return r;switch(i=0,r&&(s=[2&s[0],r.value]),s[0]){case 0:case 1:r=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,i=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(r=(r=o.trys).length>0&&r[r.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!r||s[1]>r[0]&&s[1]<r[3])){o.label=s[1];break}if(6===s[0]&&o.label<r[1]){o.label=r[1],r=s;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(s);break}r[2]&&o.ops.pop(),o.trys.pop();continue}s=e.call(t,o)}catch(t){s=[6,t],i=0}finally{n=r=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,a])}}}var Mvt={0:"tench, Tinca tinca",1:"goldfish, Carassius auratus",2:"great white shark, white shark, man-eater, man-eating shark, Carcharodon carcharias",3:"tiger shark, Galeocerdo cuvieri",4:"hammerhead, hammerhead shark",5:"electric ray, crampfish, numbfish, torpedo",6:"stingray",7:"cock",8:"hen",9:"ostrich, Struthio camelus",10:"brambling, Fringilla montifringilla",11:"goldfinch, Carduelis carduelis",12:"house finch, linnet, Carpodacus mexicanus",13:"junco, snowbird",14:"indigo bunting, indigo finch, indigo bird, Passerina cyanea",15:"robin, American robin, Turdus migratorius",16:"bulbul",17:"jay",18:"magpie",19:"chickadee",20:"water ouzel, dipper",21:"kite",22:"bald eagle, American eagle, Haliaeetus leucocephalus",23:"vulture",24:"great grey owl, great gray owl, Strix nebulosa",25:"European fire salamander, Salamandra salamandra",26:"common newt, Triturus vulgaris",27:"eft",28:"spotted salamander, Ambystoma maculatum",29:"axolotl, mud puppy, Ambystoma mexicanum",30:"bullfrog, Rana catesbeiana",31:"tree frog, tree-frog",32:"tailed frog, bell toad, ribbed toad, tailed toad, Ascaphus trui",33:"loggerhead, loggerhead turtle, Caretta caretta",34:"leatherback turtle, leatherback, leathery turtle, Dermochelys coriacea",35:"mud turtle",36:"terrapin",37:"box turtle, box tortoise",38:"banded gecko",39:"common iguana, iguana, Iguana iguana",40:"American chameleon, anole, Anolis carolinensis",41:"whiptail, whiptail lizard",42:"agama",43:"frilled lizard, Chlamydosaurus kingi",44:"alligator lizard",45:"Gila monster, Heloderma suspectum",46:"green lizard, Lacerta viridis",47:"African chameleon, Chamaeleo chamaeleon",48:"Komodo dragon, Komodo lizard, dragon lizard, giant lizard, Varanus komodoensis",49:"African crocodile, Nile crocodile, Crocodylus niloticus",50:"American alligator, Alligator mississipiensis",51:"triceratops",52:"thunder snake, worm snake, Carphophis amoenus",53:"ringneck snake, ring-necked snake, ring snake",54:"hognose snake, puff adder, sand viper",55:"green snake, grass snake",56:"king snake, kingsnake",57:"garter snake, grass snake",58:"water snake",59:"vine snake",60:"night snake, Hypsiglena torquata",61:"boa constrictor, Constrictor constrictor",62:"rock python, rock snake, Python sebae",63:"Indian cobra, Naja naja",64:"green mamba",65:"sea snake",66:"horned viper, cerastes, sand viper, horned asp, Cerastes cornutus",67:"diamondback, diamondback rattlesnake, Crotalus adamanteus",68:"sidewinder, horned rattlesnake, Crotalus cerastes",69:"trilobite",70:"harvestman, daddy longlegs, Phalangium opilio",71:"scorpion",72:"black and gold garden spider, Argiope aurantia",73:"barn spider, Araneus cavaticus",74:"garden spider, Aranea diademata",75:"black widow, Latrodectus mactans",76:"tarantula",77:"wolf spider, hunting spider",78:"tick",79:"centipede",80:"black grouse",81:"ptarmigan",82:"ruffed grouse, partridge, Bonasa umbellus",83:"prairie chicken, prairie grouse, prairie fowl",84:"peacock",85:"quail",86:"partridge",87:"African grey, African gray, Psittacus erithacus",88:"macaw",89:"sulphur-crested cockatoo, Kakatoe galerita, Cacatua galerita",90:"lorikeet",91:"coucal",92:"bee eater",93:"hornbill",94:"hummingbird",95:"jacamar",96:"toucan",97:"drake",98:"red-breasted merganser, Mergus serrator",99:"goose",100:"black swan, Cygnus atratus",101:"tusker",102:"echidna, spiny anteater, anteater",103:"platypus, duckbill, duckbilled platypus, duck-billed platypus, Ornithorhynchus anatinus",104:"wallaby, brush kangaroo",105:"koala, koala bear, kangaroo bear, native bear, Phascolarctos cinereus",106:"wombat",107:"jelly fish",108:"sea anemone, anemone",109:"brain coral",110:"flatworm, platyhelminth",111:"nematode, nematode worm, roundworm",112:"conch",113:"snail",114:"slug",115:"sea slug, nudibranch",116:"chiton, coat-of-mail shell, sea cradle, polyplacophore",117:"chambered nautilus, pearly nautilus, nautilus",118:"Dungeness crab, Cancer magister",119:"rock crab, Cancer irroratus",120:"fiddler crab",121:"king crab, Alaska crab, Alaskan king crab, Alaska king crab, Paralithodes camtschatica",122:"American lobster, Northern lobster, Maine lobster, Homarus americanus",123:"spiny lobster, langouste, rock lobster, crawfish, crayfish, sea crawfish",124:"crayfish, crawfish, crawdad, crawdaddy",125:"hermit crab",126:"isopod",127:"white stork, Ciconia ciconia",128:"black stork, Ciconia nigra",129:"spoonbill",130:"flamingo",131:"little blue heron, Egretta caerulea",132:"American egret, great white heron, Egretta albus",133:"bittern",134:"crane",135:"limpkin, Aramus pictus",136:"European gallinule, Porphyrio porphyrio",137:"American coot, marsh hen, mud hen, water hen, Fulica americana",138:"bustard",139:"ruddy turnstone, Arenaria interpres",140:"red-backed sandpiper, dunlin, Erolia alpina",141:"redshank, Tringa totanus",142:"dowitcher",143:"oystercatcher, oyster catcher",144:"pelican",145:"king penguin, Aptenodytes patagonica",146:"albatross, mollymawk",147:"grey whale, gray whale, devilfish, Eschrichtius gibbosus, Eschrichtius robustus",148:"killer whale, killer, orca, grampus, sea wolf, Orcinus orca",149:"dugong, Dugong dugon",150:"sea lion",151:"Chihuahua",152:"Japanese spaniel",153:"Maltese dog, Maltese terrier, Maltese",154:"Pekinese, Pekingese, Peke",155:"Shih-Tzu",156:"Blenheim spaniel",157:"papillon",158:"toy terrier",159:"Rhodesian ridgeback",160:"Afghan hound, Afghan",161:"basset, basset hound",162:"beagle",163:"bloodhound, sleuthhound",164:"bluetick",165:"black-and-tan coonhound",166:"Walker hound, Walker foxhound",167:"English foxhound",168:"redbone",169:"borzoi, Russian wolfhound",170:"Irish wolfhound",171:"Italian greyhound",172:"whippet",173:"Ibizan hound, Ibizan Podenco",174:"Norwegian elkhound, elkhound",175:"otterhound, otter hound",176:"Saluki, gazelle hound",177:"Scottish deerhound, deerhound",178:"Weimaraner",179:"Staffordshire bullterrier, Staffordshire bull terrier",180:"American Staffordshire terrier, Staffordshire terrier, American pit bull terrier, pit bull terrier",181:"Bedlington terrier",182:"Border terrier",183:"Kerry blue terrier",184:"Irish terrier",185:"Norfolk terrier",186:"Norwich terrier",187:"Yorkshire terrier",188:"wire-haired fox terrier",189:"Lakeland terrier",190:"Sealyham terrier, Sealyham",191:"Airedale, Airedale terrier",192:"cairn, cairn terrier",193:"Australian terrier",194:"Dandie Dinmont, Dandie Dinmont terrier",195:"Boston bull, Boston terrier",196:"miniature schnauzer",197:"giant schnauzer",198:"standard schnauzer",199:"Scotch terrier, Scottish terrier, Scottie",200:"Tibetan terrier, chrysanthemum dog",201:"silky terrier, Sydney silky",202:"soft-coated wheaten terrier",203:"West Highland white terrier",204:"Lhasa, Lhasa apso",205:"flat-coated retriever",206:"curly-coated retriever",207:"golden retriever",208:"Labrador retriever",209:"Chesapeake Bay retriever",210:"German short-haired pointer",211:"vizsla, Hungarian pointer",212:"English setter",213:"Irish setter, red setter",214:"Gordon setter",215:"Brittany spaniel",216:"clumber, clumber spaniel",217:"English springer, English springer spaniel",218:"Welsh springer spaniel",219:"cocker spaniel, English cocker spaniel, cocker",220:"Sussex spaniel",221:"Irish water spaniel",222:"kuvasz",223:"schipperke",224:"groenendael",225:"malinois",226:"briard",227:"kelpie",228:"komondor",229:"Old English sheepdog, bobtail",230:"Shetland sheepdog, Shetland sheep dog, Shetland",231:"collie",232:"Border collie",233:"Bouvier des Flandres, Bouviers des Flandres",234:"Rottweiler",235:"German shepherd, German shepherd dog, German police dog, alsatian",236:"Doberman, Doberman pinscher",237:"miniature pinscher",238:"Greater Swiss Mountain dog",239:"Bernese mountain dog",240:"Appenzeller",241:"EntleBucher",242:"boxer",243:"bull mastiff",244:"Tibetan mastiff",245:"French bulldog",246:"Great Dane",247:"Saint Bernard, St Bernard",248:"Eskimo dog, husky",249:"malamute, malemute, Alaskan malamute",250:"Siberian husky",251:"dalmatian, coach dog, carriage dog",252:"affenpinscher, monkey pinscher, monkey dog",253:"basenji",254:"pug, pug-dog",255:"Leonberg",256:"Newfoundland, Newfoundland dog",257:"Great Pyrenees",258:"Samoyed, Samoyede",259:"Pomeranian",260:"chow, chow chow",261:"keeshond",262:"Brabancon griffon",263:"Pembroke, Pembroke Welsh corgi",264:"Cardigan, Cardigan Welsh corgi",265:"toy poodle",266:"miniature poodle",267:"standard poodle",268:"Mexican hairless",269:"timber wolf, grey wolf, gray wolf, Canis lupus",270:"white wolf, Arctic wolf, Canis lupus tundrarum",271:"red wolf, maned wolf, Canis rufus, Canis niger",272:"coyote, prairie wolf, brush wolf, Canis latrans",273:"dingo, warrigal, warragal, Canis dingo",274:"dhole, Cuon alpinus",275:"African hunting dog, hyena dog, Cape hunting dog, Lycaon pictus",276:"hyena, hyaena",277:"red fox, Vulpes vulpes",278:"kit fox, Vulpes macrotis",279:"Arctic fox, white fox, Alopex lagopus",280:"grey fox, gray fox, Urocyon cinereoargenteus",281:"tabby, tabby cat",282:"tiger cat",283:"Persian cat",284:"Siamese cat, Siamese",285:"Egyptian cat",286:"cougar, puma, catamount, mountain lion, painter, panther, Felis concolor",287:"lynx, catamount",288:"leopard, Panthera pardus",289:"snow leopard, ounce, Panthera uncia",290:"jaguar, panther, Panthera onca, Felis onca",291:"lion, king of beasts, Panthera leo",292:"tiger, Panthera tigris",293:"cheetah, chetah, Acinonyx jubatus",294:"brown bear, bruin, Ursus arctos",295:"American black bear, black bear, Ursus americanus, Euarctos americanus",296:"ice bear, polar bear, Ursus Maritimus, Thalarctos maritimus",297:"sloth bear, Melursus ursinus, Ursus ursinus",298:"mongoose",299:"meerkat, mierkat",300:"tiger beetle",301:"ladybug, ladybeetle, lady beetle, ladybird, ladybird beetle",302:"ground beetle, carabid beetle",303:"long-horned beetle, longicorn, longicorn beetle",304:"leaf beetle, chrysomelid",305:"dung beetle",306:"rhinoceros beetle",307:"weevil",308:"fly",309:"bee",310:"ant, emmet, pismire",311:"grasshopper, hopper",312:"cricket",313:"walking stick, walkingstick, stick insect",314:"cockroach, roach",315:"mantis, mantid",316:"cicada, cicala",317:"leafhopper",318:"lacewing, lacewing fly",319:"dragonfly, darning needle, devil's darning needle, sewing needle, snake feeder, snake doctor, mosquito hawk, skeeter hawk",320:"damselfly",321:"admiral",322:"ringlet, ringlet butterfly",323:"monarch, monarch butterfly, milkweed butterfly, Danaus plexippus",324:"cabbage butterfly",325:"sulphur butterfly, sulfur butterfly",326:"lycaenid, lycaenid butterfly",327:"starfish, sea star",328:"sea urchin",329:"sea cucumber, holothurian",330:"wood rabbit, cottontail, cottontail rabbit",331:"hare",332:"Angora, Angora rabbit",333:"hamster",334:"porcupine, hedgehog",335:"fox squirrel, eastern fox squirrel, Sciurus niger",336:"marmot",337:"beaver",338:"guinea pig, Cavia cobaya",339:"sorrel",340:"zebra",341:"hog, pig, grunter, squealer, Sus scrofa",342:"wild boar, boar, Sus scrofa",343:"warthog",344:"hippopotamus, hippo, river horse, Hippopotamus amphibius",345:"ox",346:"water buffalo, water ox, Asiatic buffalo, Bubalus bubalis",347:"bison",348:"ram, tup",349:"bighorn, bighorn sheep, cimarron, Rocky Mountain bighorn, Rocky Mountain sheep, Ovis canadensis",350:"ibex, Capra ibex",351:"hartebeest",352:"impala, Aepyceros melampus",353:"gazelle",354:"Arabian camel, dromedary, Camelus dromedarius",355:"llama",356:"weasel",357:"mink",358:"polecat, fitch, foulmart, foumart, Mustela putorius",359:"black-footed ferret, ferret, Mustela nigripes",360:"otter",361:"skunk, polecat, wood pussy",362:"badger",363:"armadillo",364:"three-toed sloth, ai, Bradypus tridactylus",365:"orangutan, orang, orangutang, Pongo pygmaeus",366:"gorilla, Gorilla gorilla",367:"chimpanzee, chimp, Pan troglodytes",368:"gibbon, Hylobates lar",369:"siamang, Hylobates syndactylus, Symphalangus syndactylus",370:"guenon, guenon monkey",371:"patas, hussar monkey, Erythrocebus patas",372:"baboon",373:"macaque",374:"langur",375:"colobus, colobus monkey",376:"proboscis monkey, Nasalis larvatus",377:"marmoset",378:"capuchin, ringtail, Cebus capucinus",379:"howler monkey, howler",380:"titi, titi monkey",381:"spider monkey, Ateles geoffroyi",382:"squirrel monkey, Saimiri sciureus",383:"Madagascar cat, ring-tailed lemur, Lemur catta",384:"indri, indris, Indri indri, Indri brevicaudatus",385:"Indian elephant, Elephas maximus",386:"African elephant, Loxodonta africana",387:"lesser panda, red panda, panda, bear cat, cat bear, Ailurus fulgens",388:"giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca",389:"barracouta, snoek",390:"eel",391:"coho, cohoe, coho salmon, blue jack, silver salmon, Oncorhynchus kisutch",392:"rock beauty, Holocanthus tricolor",393:"anemone fish",394:"sturgeon",395:"gar, garfish, garpike, billfish, Lepisosteus osseus",396:"lionfish",397:"puffer, pufferfish, blowfish, globefish",398:"abacus",399:"abaya",400:"academic gown, academic robe, judge's robe",401:"accordion, piano accordion, squeeze box",402:"acoustic guitar",403:"aircraft carrier, carrier, flattop, attack aircraft carrier",404:"airliner",405:"airship, dirigible",406:"altar",407:"ambulance",408:"amphibian, amphibious vehicle",409:"analog clock",410:"apiary, bee house",411:"apron",412:"ashcan, trash can, garbage can, wastebin, ash bin, ash-bin, ashbin, dustbin, trash barrel, trash bin",413:"assault rifle, assault gun",414:"backpack, back pack, knapsack, packsack, rucksack, haversack",415:"bakery, bakeshop, bakehouse",416:"balance beam, beam",417:"balloon",418:"ballpoint, ballpoint pen, ballpen, Biro",419:"Band Aid",420:"banjo",421:"bannister, banister, balustrade, balusters, handrail",422:"barbell",423:"barber chair",424:"barbershop",425:"barn",426:"barometer",427:"barrel, cask",428:"barrow, garden cart, lawn cart, wheelbarrow",429:"baseball",430:"basketball",431:"bassinet",432:"bassoon",433:"bathing cap, swimming cap",434:"bath towel",435:"bathtub, bathing tub, bath, tub",436:"beach wagon, station wagon, wagon, estate car, beach waggon, station waggon, waggon",437:"beacon, lighthouse, beacon light, pharos",438:"beaker",439:"bearskin, busby, shako",440:"beer bottle",441:"beer glass",442:"bell cote, bell cot",443:"bib",444:"bicycle-built-for-two, tandem bicycle, tandem",445:"bikini, two-piece",446:"binder, ring-binder",447:"binoculars, field glasses, opera glasses",448:"birdhouse",449:"boathouse",450:"bobsled, bobsleigh, bob",451:"bolo tie, bolo, bola tie, bola",452:"bonnet, poke bonnet",453:"bookcase",454:"bookshop, bookstore, bookstall",455:"bottlecap",456:"bow",457:"bow tie, bow-tie, bowtie",458:"brass, memorial tablet, plaque",459:"brassiere, bra, bandeau",460:"breakwater, groin, groyne, mole, bulwark, seawall, jetty",461:"breastplate, aegis, egis",462:"broom",463:"bucket, pail",464:"buckle",465:"bulletproof vest",466:"bullet train, bullet",467:"butcher shop, meat market",468:"cab, hack, taxi, taxicab",469:"caldron, cauldron",470:"candle, taper, wax light",471:"cannon",472:"canoe",473:"can opener, tin opener",474:"cardigan",475:"car mirror",476:"carousel, carrousel, merry-go-round, roundabout, whirligig",477:"carpenter's kit, tool kit",478:"carton",479:"car wheel",480:"cash machine, cash dispenser, automated teller machine, automatic teller machine, automated teller, automatic teller, ATM",481:"cassette",482:"cassette player",483:"castle",484:"catamaran",485:"CD player",486:"cello, violoncello",487:"cellular telephone, cellular phone, cellphone, cell, mobile phone",488:"chain",489:"chainlink fence",490:"chain mail, ring mail, mail, chain armor, chain armour, ring armor, ring armour",491:"chain saw, chainsaw",492:"chest",493:"chiffonier, commode",494:"chime, bell, gong",495:"china cabinet, china closet",496:"Christmas stocking",497:"church, church building",498:"cinema, movie theater, movie theatre, movie house, picture palace",499:"cleaver, meat cleaver, chopper",500:"cliff dwelling",501:"cloak",502:"clog, geta, patten, sabot",503:"cocktail shaker",504:"coffee mug",505:"coffeepot",506:"coil, spiral, volute, whorl, helix",507:"combination lock",508:"computer keyboard, keypad",509:"confectionery, confectionary, candy store",510:"container ship, containership, container vessel",511:"convertible",512:"corkscrew, bottle screw",513:"cornet, horn, trumpet, trump",514:"cowboy boot",515:"cowboy hat, ten-gallon hat",516:"cradle",517:"crane",518:"crash helmet",519:"crate",520:"crib, cot",521:"Crock Pot",522:"croquet ball",523:"crutch",524:"cuirass",525:"dam, dike, dyke",526:"desk",527:"desktop computer",528:"dial telephone, dial phone",529:"diaper, nappy, napkin",530:"digital clock",531:"digital watch",532:"dining table, board",533:"dishrag, dishcloth",534:"dishwasher, dish washer, dishwashing machine",535:"disk brake, disc brake",536:"dock, dockage, docking facility",537:"dogsled, dog sled, dog sleigh",538:"dome",539:"doormat, welcome mat",540:"drilling platform, offshore rig",541:"drum, membranophone, tympan",542:"drumstick",543:"dumbbell",544:"Dutch oven",545:"electric fan, blower",546:"electric guitar",547:"electric locomotive",548:"entertainment center",549:"envelope",550:"espresso maker",551:"face powder",552:"feather boa, boa",553:"file, file cabinet, filing cabinet",554:"fireboat",555:"fire engine, fire truck",556:"fire screen, fireguard",557:"flagpole, flagstaff",558:"flute, transverse flute",559:"folding chair",560:"football helmet",561:"forklift",562:"fountain",563:"fountain pen",564:"four-poster",565:"freight car",566:"French horn, horn",567:"frying pan, frypan, skillet",568:"fur coat",569:"garbage truck, dustcart",570:"gasmask, respirator, gas helmet",571:"gas pump, gasoline pump, petrol pump, island dispenser",572:"goblet",573:"go-kart",574:"golf ball",575:"golfcart, golf cart",576:"gondola",577:"gong, tam-tam",578:"gown",579:"grand piano, grand",580:"greenhouse, nursery, glasshouse",581:"grille, radiator grille",582:"grocery store, grocery, food market, market",583:"guillotine",584:"hair slide",585:"hair spray",586:"half track",587:"hammer",588:"hamper",589:"hand blower, blow dryer, blow drier, hair dryer, hair drier",590:"hand-held computer, hand-held microcomputer",591:"handkerchief, hankie, hanky, hankey",592:"hard disc, hard disk, fixed disk",593:"harmonica, mouth organ, harp, mouth harp",594:"harp",595:"harvester, reaper",596:"hatchet",597:"holster",598:"home theater, home theatre",599:"honeycomb",600:"hook, claw",601:"hoopskirt, crinoline",602:"horizontal bar, high bar",603:"horse cart, horse-cart",604:"hourglass",605:"iPod",606:"iron, smoothing iron",607:"jack-o'-lantern",608:"jean, blue jean, denim",609:"jeep, landrover",610:"jersey, T-shirt, tee shirt",611:"jigsaw puzzle",612:"jinrikisha, ricksha, rickshaw",613:"joystick",614:"kimono",615:"knee pad",616:"knot",617:"lab coat, laboratory coat",618:"ladle",619:"lampshade, lamp shade",620:"laptop, laptop computer",621:"lawn mower, mower",622:"lens cap, lens cover",623:"letter opener, paper knife, paperknife",624:"library",625:"lifeboat",626:"lighter, light, igniter, ignitor",627:"limousine, limo",628:"liner, ocean liner",629:"lipstick, lip rouge",630:"Loafer",631:"lotion",632:"loudspeaker, speaker, speaker unit, loudspeaker system, speaker system",633:"loupe, jeweler's loupe",634:"lumbermill, sawmill",635:"magnetic compass",636:"mailbag, postbag",637:"mailbox, letter box",638:"maillot",639:"maillot, tank suit",640:"manhole cover",641:"maraca",642:"marimba, xylophone",643:"mask",644:"matchstick",645:"maypole",646:"maze, labyrinth",647:"measuring cup",648:"medicine chest, medicine cabinet",649:"megalith, megalithic structure",650:"microphone, mike",651:"microwave, microwave oven",652:"military uniform",653:"milk can",654:"minibus",655:"miniskirt, mini",656:"minivan",657:"missile",658:"mitten",659:"mixing bowl",660:"mobile home, manufactured home",661:"Model T",662:"modem",663:"monastery",664:"monitor",665:"moped",666:"mortar",667:"mortarboard",668:"mosque",669:"mosquito net",670:"motor scooter, scooter",671:"mountain bike, all-terrain bike, off-roader",672:"mountain tent",673:"mouse, computer mouse",674:"mousetrap",675:"moving van",676:"muzzle",677:"nail",678:"neck brace",679:"necklace",680:"nipple",681:"notebook, notebook computer",682:"obelisk",683:"oboe, hautboy, hautbois",684:"ocarina, sweet potato",685:"odometer, hodometer, mileometer, milometer",686:"oil filter",687:"organ, pipe organ",688:"oscilloscope, scope, cathode-ray oscilloscope, CRO",689:"overskirt",690:"oxcart",691:"oxygen mask",692:"packet",693:"paddle, boat paddle",694:"paddlewheel, paddle wheel",695:"padlock",696:"paintbrush",697:"pajama, pyjama, pj's, jammies",698:"palace",699:"panpipe, pandean pipe, syrinx",700:"paper towel",701:"parachute, chute",702:"parallel bars, bars",703:"park bench",704:"parking meter",705:"passenger car, coach, carriage",706:"patio, terrace",707:"pay-phone, pay-station",708:"pedestal, plinth, footstall",709:"pencil box, pencil case",710:"pencil sharpener",711:"perfume, essence",712:"Petri dish",713:"photocopier",714:"pick, plectrum, plectron",715:"pickelhaube",716:"picket fence, paling",717:"pickup, pickup truck",718:"pier",719:"piggy bank, penny bank",720:"pill bottle",721:"pillow",722:"ping-pong ball",723:"pinwheel",724:"pirate, pirate ship",725:"pitcher, ewer",726:"plane, carpenter's plane, woodworking plane",727:"planetarium",728:"plastic bag",729:"plate rack",730:"plow, plough",731:"plunger, plumber's helper",732:"Polaroid camera, Polaroid Land camera",733:"pole",734:"police van, police wagon, paddy wagon, patrol wagon, wagon, black Maria",735:"poncho",736:"pool table, billiard table, snooker table",737:"pop bottle, soda bottle",738:"pot, flowerpot",739:"potter's wheel",740:"power drill",741:"prayer rug, prayer mat",742:"printer",743:"prison, prison house",744:"projectile, missile",745:"projector",746:"puck, hockey puck",747:"punching bag, punch bag, punching ball, punchball",748:"purse",749:"quill, quill pen",750:"quilt, comforter, comfort, puff",751:"racer, race car, racing car",752:"racket, racquet",753:"radiator",754:"radio, wireless",755:"radio telescope, radio reflector",756:"rain barrel",757:"recreational vehicle, RV, R.V.",758:"reel",759:"reflex camera",760:"refrigerator, icebox",761:"remote control, remote",762:"restaurant, eating house, eating place, eatery",763:"revolver, six-gun, six-shooter",764:"rifle",765:"rocking chair, rocker",766:"rotisserie",767:"rubber eraser, rubber, pencil eraser",768:"rugby ball",769:"rule, ruler",770:"running shoe",771:"safe",772:"safety pin",773:"saltshaker, salt shaker",774:"sandal",775:"sarong",776:"sax, saxophone",777:"scabbard",778:"scale, weighing machine",779:"school bus",780:"schooner",781:"scoreboard",782:"screen, CRT screen",783:"screw",784:"screwdriver",785:"seat belt, seatbelt",786:"sewing machine",787:"shield, buckler",788:"shoe shop, shoe-shop, shoe store",789:"shoji",790:"shopping basket",791:"shopping cart",792:"shovel",793:"shower cap",794:"shower curtain",795:"ski",796:"ski mask",797:"sleeping bag",798:"slide rule, slipstick",799:"sliding door",800:"slot, one-armed bandit",801:"snorkel",802:"snowmobile",803:"snowplow, snowplough",804:"soap dispenser",805:"soccer ball",806:"sock",807:"solar dish, solar collector, solar furnace",808:"sombrero",809:"soup bowl",810:"space bar",811:"space heater",812:"space shuttle",813:"spatula",814:"speedboat",815:"spider web, spider's web",816:"spindle",817:"sports car, sport car",818:"spotlight, spot",819:"stage",820:"steam locomotive",821:"steel arch bridge",822:"steel drum",823:"stethoscope",824:"stole",825:"stone wall",826:"stopwatch, stop watch",827:"stove",828:"strainer",829:"streetcar, tram, tramcar, trolley, trolley car",830:"stretcher",831:"studio couch, day bed",832:"stupa, tope",833:"submarine, pigboat, sub, U-boat",834:"suit, suit of clothes",835:"sundial",836:"sunglass",837:"sunglasses, dark glasses, shades",838:"sunscreen, sunblock, sun blocker",839:"suspension bridge",840:"swab, swob, mop",841:"sweatshirt",842:"swimming trunks, bathing trunks",843:"swing",844:"switch, electric switch, electrical switch",845:"syringe",846:"table lamp",847:"tank, army tank, armored combat vehicle, armoured combat vehicle",848:"tape player",849:"teapot",850:"teddy, teddy bear",851:"television, television system",852:"tennis ball",853:"thatch, thatched roof",854:"theater curtain, theatre curtain",855:"thimble",856:"thresher, thrasher, threshing machine",857:"throne",858:"tile roof",859:"toaster",860:"tobacco shop, tobacconist shop, tobacconist",861:"toilet seat",862:"torch",863:"totem pole",864:"tow truck, tow car, wrecker",865:"toyshop",866:"tractor",867:"trailer truck, tractor trailer, trucking rig, rig, articulated lorry, semi",868:"tray",869:"trench coat",870:"tricycle, trike, velocipede",871:"trimaran",872:"tripod",873:"triumphal arch",874:"trolleybus, trolley coach, trackless trolley",875:"trombone",876:"tub, vat",877:"turnstile",878:"typewriter keyboard",879:"umbrella",880:"unicycle, monocycle",881:"upright, upright piano",882:"vacuum, vacuum cleaner",883:"vase",884:"vault",885:"velvet",886:"vending machine",887:"vestment",888:"viaduct",889:"violin, fiddle",890:"volleyball",891:"waffle iron",892:"wall clock",893:"wallet, billfold, notecase, pocketbook",894:"wardrobe, closet, press",895:"warplane, military plane",896:"washbasin, handbasin, washbowl, lavabo, wash-hand basin",897:"washer, automatic washer, washing machine",898:"water bottle",899:"water jug",900:"water tower",901:"whiskey jug",902:"whistle",903:"wig",904:"window screen",905:"window shade",906:"Windsor tie",907:"wine bottle",908:"wing",909:"wok",910:"wooden spoon",911:"wool, woolen, woollen",912:"worm fence, snake fence, snake-rail fence, Virginia fence",913:"wreck",914:"yawl",915:"yurt",916:"web site, website, internet site, site",917:"comic book",918:"crossword puzzle, crossword",919:"street sign",920:"traffic light, traffic signal, stoplight",921:"book jacket, dust cover, dust jacket, dust wrapper",922:"menu",923:"plate",924:"guacamole",925:"consomme",926:"hot pot, hotpot",927:"trifle",928:"ice cream, icecream",929:"ice lolly, lolly, lollipop, popsicle",930:"French loaf",931:"bagel, beigel",932:"pretzel",933:"cheeseburger",934:"hotdog, hot dog, red hot",935:"mashed potato",936:"head cabbage",937:"broccoli",938:"cauliflower",939:"zucchini, courgette",940:"spaghetti squash",941:"acorn squash",942:"butternut squash",943:"cucumber, cuke",944:"artichoke, globe artichoke",945:"bell pepper",946:"cardoon",947:"mushroom",948:"Granny Smith",949:"strawberry",950:"orange",951:"lemon",952:"fig",953:"pineapple, ananas",954:"banana",955:"jackfruit, jak, jack",956:"custard apple",957:"pomegranate",958:"hay",959:"carbonara",960:"chocolate sauce, chocolate syrup",961:"dough",962:"meat loaf, meatloaf",963:"pizza, pizza pie",964:"potpie",965:"burrito",966:"red wine",967:"espresso",968:"cup",969:"eggnog",970:"alp",971:"bubble",972:"cliff, drop, drop-off",973:"coral reef",974:"geyser",975:"lakeside, lakeshore",976:"promontory, headland, head, foreland",977:"sandbar, sand bar",978:"seashore, coast, seacoast, sea-coast",979:"valley, vale",980:"volcano",981:"ballplayer, baseball player",982:"groom, bridegroom",983:"scuba diver",984:"rapeseed",985:"daisy",986:"yellow lady's slipper, yellow lady-slipper, Cypripedium calceolus, Cypripedium parviflorum",987:"corn",988:"acorn",989:"hip, rose hip, rosehip",990:"buckeye, horse chestnut, conker",991:"coral fungus",992:"agaric",993:"gyromitra",994:"stinkhorn, carrion fungus",995:"earthstar",996:"hen-of-the-woods, hen of the woods, Polyporus frondosus, Grifola frondosa",997:"bolete",998:"ear, spike, capitulum",999:"toilet tissue, toilet paper, bathroom tissue"},$vt=224,Ivt={"1.00":"module_apply_default/MobilenetV1/Logits/global_pool","2.00":"module_apply_default/MobilenetV2/Logits/AvgPool"},Avt={"1.00":{.25:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_025_224/classification/1",inputRange:[0,1]},"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_050_224/classification/1",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_075_224/classification/1",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_100_224/classification/1",inputRange:[0,1]}},"2.00":{"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_050_224/classification/2",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_075_224/classification/2",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/classification/2",inputRange:[0,1]}}};function Nvt(t){return void 0===t&&(t={version:1,alpha:1}),_vt(this,void 0,void 0,(function(){var e,n,i,r,s,o,a;return Evt(this,(function(l){switch(l.label){case 0:if(null==pm)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");if(e=t.version.toFixed(2),n=t.alpha?t.alpha.toFixed(2):"",i=-1,r=1,null==t.modelUrl){if(!(e in Avt))throw new Error("Invalid version of MobileNet. Valid versions are: "+Object.keys(Avt));if(!(n in Avt[e]))throw new Error("MobileNet constructed with invalid alpha "+t.alpha+". Valid multipliers for this version are: "+Object.keys(Avt[e])+".");o=Avt[e][n].inputRange,i=o[0],r=o[1]}return null!=t.inputRange&&(a=t.inputRange,i=a[0],r=a[1]),[4,(s=new Ovt(e,n,t.modelUrl,i,r)).load()];case 1:return l.sent(),[2,s]}}))}))}var Rvt,Pvt,Ovt=function(){function t(t,e,n,i,r){void 0===i&&(i=-1),void 0===r&&(r=1),this.version=t,this.alpha=e,this.modelUrl=n,this.inputMin=i,this.inputMax=r,this.normalizationConstant=(r-i)/255}return t.prototype.load=function(){return _vt(this,void 0,void 0,(function(){var t,e,n,i,r=this;return Evt(this,(function(s){switch(s.label){case 0:return this.modelUrl?(t=this,[4,C4(this.modelUrl)]):[3,2];case 1:return t.model=s.sent(),[3,4];case 2:return e=Avt[this.version][this.alpha].url,n=this,[4,C4(e,{fromTFHub:!0})];case 3:n.model=s.sent(),s.label=4;case 4:return[4,(i=Co((function(){return r.model.predict(fc([1,$vt,$vt,3]))}))).data()];case 5:return s.sent(),i.dispose(),[2]}}))}))},t.prototype.infer=function(t,e){var n=this;return void 0===e&&(e=!1),Co((function(){t instanceof Or||(t=Np(t));var i=Ao(Po(vo(t,"float32"),n.normalizationConstant),n.inputMin),r=i;t.shape[0]===$vt&&t.shape[1]===$vt||(r=Bd.resizeBilinear(i,[$vt,$vt],!0));var s,o=ca(r,[-1,$vt,$vt,3]);if(e){var a=Ivt[n.version],l=n.model.execute(o,a);s=Ju(l,[1,2])}else{var c=n.model.predict(o);s=ma(c,[0,1],[-1,1e3])}return s}))},t.prototype.classify=function(t,e){return void 0===e&&(e=3),_vt(this,void 0,void 0,(function(){var n,i;return Evt(this,(function(r){switch(r.label){case 0:return[4,Lvt(n=this.infer(t),e)];case 1:return i=r.sent(),n.dispose(),[2,i]}}))}))},t}();function Lvt(t,e){return _vt(this,void 0,void 0,(function(){var n,i,r,s,o,a,l;return Evt(this,(function(c){switch(c.label){case 0:return[4,(n=ju(t)).data()];case 1:for(i=c.sent(),n.dispose(),r=[],l=0;l<i.length;l++)r.push({value:i[l],index:l});for(r.sort((function(t,e){return e.value-t.value})),s=new Float32Array(e),o=new Int32Array(e),l=0;l<e;l++)s[l]=r[l].value,o[l]=r[l].index;for(a=[],l=0;l<o.length;l++)a.push({className:Mvt[o[l]],probability:s[l]});return[2,a]}}))}))}function Dvt(t){let e,n,i,r,s;return{c(){e=IB("Using Mobilenet v"),n=IB(t[2]),i=IB(" with alpha = "),r=IB(t[3]),s=IB(".")},m(t,o){TB(t,e,o),TB(t,n,o),TB(t,i,o),TB(t,r,o),TB(t,s,o)},p(t,e){4&e&&DB(n,t[2]),8&e&&DB(r,t[3])},d(t){t&&_B(e),t&&_B(n),t&&_B(i),t&&_B(r),t&&_B(s)}}}function Fvt(t){let e;return{c(){e=IB("")},m(t,n){TB(t,e,n)},p:Jz,d(t){t&&_B(e)}}}function zvt(t){let e;function n(t,e){return t[4]?Fvt:Dvt}let i=n(t),r=i(t);return{c(){e=MB("p"),r.c(),OB(e,"class","p-2 text-sm text-gray-600")},m(t,n){TB(t,e,n),r.m(e,null)},p(t,s){i===(i=n(t))&&r?r.p(t,s):(r.d(1),r=i(t),r&&(r.c(),r.m(e,null)))},d(t){t&&_B(e),r.d()}}}function Bvt(t){let e,n;return e=new DH({props:{title:t[0],loading:t[4],$$slots:{default:[zvt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),16&n&&(i.loading=t[4]),60&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function Uvt(t,e,n){let i,r=Jz,s=()=>(r(),r=aB(a,(t=>n(4,i=t))),a);t.$$.on_destroy.push((()=>r()));let{title:o}=e,{loading:a}=e;s();let{version:l}=e,{alpha:c}=e;return t.$$set=t=>{"title"in t&&n(0,o=t.title),"loading"in t&&s(n(1,a=t.loading)),"version"in t&&n(2,l=t.version),"alpha"in t&&n(3,c=t.alpha)},[o,a,l,c,i]}class Vvt extends UU{constructor(t){super(),BU(this,t,Uvt,Bvt,rB,{title:0,loading:1,version:2,alpha:3})}}class Wvt extends i3{constructor({version:t=1,alpha:e=1}={}){if(super(),this.title="mobileNet",this.parameters={},this.serviceName="undefined",Rvt.set(this,void 0),this.$loading=new eK(!0,!0),![1,2].includes(t))throw new Error("Mobilenet version must be 1 or 2");if(![.25,.5,.75,1].includes(e))throw new Error("Mobilenet alpha must be 0.25 | 0.50 | 0.75 | 1.0");this.version=t,this.alpha=e,this.setup()}async setup(){await Eo();const t=await ho(),e=Object.keys(t).filter((t=>t.includes("mobileNet")));try{WX(this,Rvt,await Nvt({modelUrl:`indexeddb://mobilenet-v${this.version}-${this.alpha}`,version:this.version,alpha:this.alpha}),"f")}catch(t){e.length>0&&await po(e[0]),WX(this,Rvt,await Nvt({version:this.version,alpha:this.alpha}),"f"),await VX(this,Rvt,"f").model.save(`indexeddb://mobilenet-v${this.version}-${this.alpha}`)}return sK.info(`MobileNet v${this.version} loaded with alpha = ${this.alpha}`),this.$loading.set(!1),this.start(),this}async process(t){return VX(this,Rvt,"f")?Co((()=>VX(this,Rvt,"f").infer(t,!0).arraySync()[0])):[]}async predict(t){if(!VX(this,Rvt,"f"))throw new Error("Mobilenet is not loaded");const e=await VX(this,Rvt,"f").classify(t,5);return{label:e[0].className,confidences:e.reduce(((t,e)=>({...t,[e.className]:e.probability})),{})}}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new Vvt({target:e,props:{title:this.title,loading:this.$loading,version:this.version,alpha:this.alpha}}))}train(){throw new lK("Model `MobileNet` cannot be trained")}save(){throw new Error("MobileNet does not support saving")}load(){throw new Error("MobileNet does not support loading")}download(){throw new Error("MobileNet does not support downloading")}upload(){throw new Error("MobileNet does not support uploading")}}function Hvt(...t){return new Wvt(...t)}function jvt(t){let e,n,i;function r(e){t[7](e)}let s={type:"text"};return void 0!==t[2]&&(s.value=t[2]),e=new qU({props:s}),aU.push((()=>LU(e,"value",r))),{c(){DU(e.$$.fragment)},m(t,n){FU(e,t,n),i=!0},p(t,i){const r={};!n&&4&i&&(n=!0,r.value=t[2],mU((()=>n=!1))),e.$set(r)},i(t){i||(EU(e.$$.fragment,t),i=!0)},o(t){MU(e.$$.fragment,t),i=!1},d(t){zU(e,t)}}}function Gvt(t){let e,n,i;function r(e){t[6](e)}let s={};return void 0!==t[2]&&(s.value=t[2]),e=new bV({props:s}),aU.push((()=>LU(e,"value",r))),{c(){DU(e.$$.fragment)},m(t,n){FU(e,t,n),i=!0},p(t,i){const r={};!n&&4&i&&(n=!0,r.value=t[2],mU((()=>n=!1))),e.$set(r)},i(t){i||(EU(e.$$.fragment,t),i=!0)},o(t){MU(e.$$.fragment,t),i=!1},d(t){zU(e,t)}}}function qvt(t){let e,n,i;function r(e){t[5](e)}let s={};return void 0!==t[2]&&(s.value=t[2]),e=new dV({props:s}),aU.push((()=>LU(e,"value",r))),{c(){DU(e.$$.fragment)},m(t,n){FU(e,t,n),i=!0},p(t,i){const r={};!n&&4&i&&(n=!0,r.value=t[2],mU((()=>n=!1))),e.$set(r)},i(t){i||(EU(e.$$.fragment,t),i=!0)},o(t){MU(e.$$.fragment,t),i=!1},d(t){zU(e,t)}}}function Xvt(t){let e,n,i;function r(e){t[4](e)}let s={};return void 0!==t[2]&&(s.checked=t[2]),e=new zV({props:s}),aU.push((()=>LU(e,"checked",r))),{c(){DU(e.$$.fragment)},m(t,n){FU(e,t,n),i=!0},p(t,i){const r={};!n&&4&i&&(n=!0,r.checked=t[2],mU((()=>n=!1))),e.$set(r)},i(t){i||(EU(e.$$.fragment,t),i=!0)},o(t){MU(e.$$.fragment,t),i=!1},d(t){zU(e,t)}}}function Kvt(t){let e,n,i;function r(e){t[3](e)}let s={options:t[1].options};return void 0!==t[2]&&(s.value=t[2]),e=new PV({props:s}),aU.push((()=>LU(e,"value",r))),{c(){DU(e.$$.fragment)},m(t,n){FU(e,t,n),i=!0},p(t,i){const r={};2&i&&(r.options=t[1].options),!n&&4&i&&(n=!0,r.value=t[2],mU((()=>n=!1))),e.$set(r)},i(t){i||(EU(e.$$.fragment,t),i=!0)},o(t){MU(e.$$.fragment,t),i=!1},d(t){zU(e,t)}}}function Yvt(t){let e,n,i,r,s,o,a,l;const c=[Kvt,Xvt,qvt,Gvt,jvt],u=[];function h(t,e){return 2&e&&(n=null),3&e&&(i=null),3&e&&(r=null),3&e&&(s=null),null==n&&(n=!!("menu"===t[1].type&&Array.isArray(t[1].options)&&t[1].options.length>0)),n?0:(null==i&&(i=!("boolean"!==t[1].type&&("auto"!==t[1].type||"boolean"!=typeof t[0].get()))),i?1:(null==r&&(r=!("number"!==t[1].type&&("auto"!==t[1].type||"number"!=typeof t[0].get()))),r?2:(null==s&&(s=!!("number array"===t[1].type||"auto"===t[1].type&&Array.isArray(t[0].get())&&t[0].get().length&&"number"==typeof t[0].get()[0])),s?3:4)))}return o=h(t,-1),a=u[o]=c[o](t),{c(){e=MB("div"),a.c(),zB(e,"flex-grow","1")},m(t,n){TB(t,e,n),u[o].m(e,null),l=!0},p(t,[n]){let i=o;o=h(t,n),o===i?u[o].p(t,n):(TU(),MU(u[i],1,1,(()=>{u[i]=null})),_U(),a=u[o],a?a.p(t,n):(a=u[o]=c[o](t),a.c()),EU(a,1),a.m(e,null))},i(t){l||(EU(a),l=!0)},o(t){MU(a),l=!1},d(t){t&&_B(e),u[o].d()}}}function Zvt(t,e,n){let i,r=Jz,s=()=>(r(),r=aB(o,(t=>n(2,i=t))),o);t.$$.on_destroy.push((()=>r()));let{stream:o}=e;s();let{spec:a}=e;return t.$$set=t=>{"stream"in t&&s(n(0,o=t.stream)),"spec"in t&&n(1,a=t.spec)},[o,a,i,function(t){i=t,o.set(i)},function(t){i=t,o.set(i)},function(t){i=t,o.set(i)},function(t){i=t,o.set(i)},function(t){i=t,o.set(i)}]}Rvt=new WeakMap,UX([aK],Wvt.prototype,"train",null),UX([aK],Wvt.prototype,"save",null),UX([aK],Wvt.prototype,"load",null),UX([aK],Wvt.prototype,"download",null),UX([aK],Wvt.prototype,"upload",null);class Jvt extends UU{constructor(t){super(),BU(this,t,Zvt,Yvt,rB,{stream:0,spec:1})}}function Qvt(t,e,n){const i=t.slice();return i[4]=e[n][0],i[5]=e[n][1],i}function txt(t){let e,n;return e=new Jvt({props:{stream:t[5],spec:{type:"auto"}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};2&n&&(i.stream=t[5]),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function ext(t){let e,n;return e=new Jvt({props:{stream:t[5],spec:t[2][t[4]]}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};2&n&&(i.stream=t[5]),6&n&&(i.spec=t[2][t[4]]),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function nxt(t){let e,n,i,r,s,o,a,l,c=t[4]+"";const u=[ext,txt],h=[];function d(t,e){return t[4]in t[2]?0:1}return s=d(t),o=h[s]=u[s](t),{c(){e=MB("div"),n=MB("p"),i=IB(c),r=AB(),o.c(),a=AB(),OB(n,"class","w-32 my-2"),OB(e,"class","flex my-1 items-center")},m(t,o){TB(t,e,o),SB(e,n),SB(n,i),SB(e,r),h[s].m(e,null),SB(e,a),l=!0},p(t,n){(!l||2&n)&&c!==(c=t[4]+"")&&DB(i,c);let r=s;s=d(t),s===r?h[s].p(t,n):(TU(),MU(h[r],1,1,(()=>{h[r]=null})),_U(),o=h[s],o?o.p(t,n):(o=h[s]=u[s](t),o.c()),EU(o,1),o.m(e,a))},i(t){l||(EU(o),l=!0)},o(t){MU(o),l=!1},d(t){t&&_B(e),h[s].d()}}}function ixt(t){let e,n,i=Object.entries(t[1]),r=[];for(let e=0;e<i.length;e+=1)r[e]=nxt(Qvt(t,i,e));const s=t=>MU(r[t],1,1,(()=>{r[t]=null}));return{c(){e=MB("div");for(let t=0;t<r.length;t+=1)r[t].c();OB(e,"class","m-2")},m(t,i){TB(t,e,i);for(let t=0;t<r.length;t+=1)r[t]&&r[t].m(e,null);n=!0},p(t,n){if(6&n){let o;for(i=Object.entries(t[1]),o=0;o<i.length;o+=1){const s=Qvt(t,i,o);r[o]?(r[o].p(s,n),EU(r[o],1)):(r[o]=nxt(s),r[o].c(),EU(r[o],1),r[o].m(e,null))}for(TU(),o=i.length;o<r.length;o+=1)s(o);_U()}},i(t){if(!n){for(let t=0;t<i.length;t+=1)EU(r[t]);n=!0}},o(t){r=r.filter(Boolean);for(let t=0;t<r.length;t+=1)MU(r[t]);n=!1},d(t){t&&_B(e),EB(r,t)}}}function rxt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[ixt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),262&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function sxt(t,e,n){let{title:i}=e,{parameters:r}=e,{config:s={}}=e,o=[];return t.$$set=t=>{"title"in t&&n(0,i=t.title),"parameters"in t&&n(1,r=t.parameters),"config"in t&&n(2,s=t.config)},t.$$.update=()=>{if(10&t.$$.dirty){for(const t of o)t();n(3,o=Object.values(r).map((t=>t.subscribe())))}},[i,r,s,o]}class oxt extends UU{constructor(t){super(),BU(this,t,sxt,rxt,rB,{title:0,parameters:1,config:2})}}class axt extends xK{constructor(t,e={}){super(),this.title="modelParameters",Pvt.set(this,void 0),WX(this,Pvt,t,"f"),this.config=e}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new oxt({target:e,props:{title:this.title,parameters:VX(this,Pvt,"f").parameters,config:this.config}}))}}function lxt(t,e={}){if(!t.parameters)throw new Error("The argument is not a valid component with parameters");return new axt(t,e)}function cxt(t){let e,n,i,r,s;function o(e){t[5](e)}let a={disabled:t[4]};return void 0!==t[3]&&(a.value=t[3]),i=new dV({props:a}),aU.push((()=>LU(i,"value",o))),{c(){e=MB("div"),n=MB("div"),DU(i.$$.fragment),OB(n,"class","md:flex md:items-center mb-2"),OB(e,"class","w-full max-w-sm")},m(t,r){TB(t,e,r),SB(e,n),FU(i,n,null),s=!0},p(t,e){const n={};16&e&&(n.disabled=t[4]),!r&&8&e&&(r=!0,n.value=t[3],mU((()=>r=!1))),i.$set(n)},i(t){s||(EU(i.$$.fragment,t),s=!0)},o(t){MU(i.$$.fragment,t),s=!1},d(t){t&&_B(e),zU(i)}}}function uxt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[cxt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),88&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function hxt(t,e,n){let i,r,s=Jz,o=()=>(s(),s=aB(u,(t=>n(3,i=t))),u),a=Jz,l=()=>(a(),a=aB(h,(t=>n(4,r=t))),h);t.$$.on_destroy.push((()=>s())),t.$$.on_destroy.push((()=>a()));let{title:c}=e,{value:u}=e;o();let{disabled:h}=e;return l(),t.$$set=t=>{"title"in t&&n(0,c=t.title),"value"in t&&o(n(1,u=t.value)),"disabled"in t&&l(n(2,h=t.disabled))},[c,u,h,i,r,function(t){i=t,u.set(i)}]}Pvt=new WeakMap;class dxt extends UU{constructor(t){super(),BU(this,t,hxt,uxt,rB,{title:0,value:1,disabled:2})}}let pxt=class extends xK{constructor(t){super(),this.title="number",this.$value=new eK(0,!0),this.$disabled=new eK(!1,!0),void 0!==t&&this.$value.set(t),this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new dxt({target:e,props:{title:this.title,value:this.$value,disabled:this.$disabled}}))}};function fxt(...t){return new pxt(...t)}function mxt(t){let e,n,i,r,s;function o(e){t[5](e)}let a={disabled:t[4]};return void 0!==t[3]&&(a.value=t[3]),i=new bV({props:a}),aU.push((()=>LU(i,"value",o))),{c(){e=MB("div"),n=MB("div"),DU(i.$$.fragment),OB(n,"class","md:flex md:items-center mb-2"),OB(e,"class","w-full max-w-sm")},m(t,r){TB(t,e,r),SB(e,n),FU(i,n,null),s=!0},p(t,e){const n={};16&e&&(n.disabled=t[4]),!r&&8&e&&(r=!0,n.value=t[3],mU((()=>r=!1))),i.$set(n)},i(t){s||(EU(i.$$.fragment,t),s=!0)},o(t){MU(i.$$.fragment,t),s=!1},d(t){t&&_B(e),zU(i)}}}function gxt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[mxt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),88&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function yxt(t,e,n){let i,r,s=Jz,o=()=>(s(),s=aB(u,(t=>n(3,i=t))),u),a=Jz,l=()=>(a(),a=aB(h,(t=>n(4,r=t))),h);t.$$.on_destroy.push((()=>s())),t.$$.on_destroy.push((()=>a()));let{title:c}=e,{value:u}=e;o();let{disabled:h}=e;return l(),t.$$set=t=>{"title"in t&&n(0,c=t.title),"value"in t&&o(n(1,u=t.value)),"disabled"in t&&l(n(2,h=t.disabled))},[c,u,h,i,r,function(t){i=t,u.set(i)}]}class bxt extends UU{constructor(t){super(),BU(this,t,yxt,gxt,rB,{title:0,value:1,disabled:2})}}class vxt extends xK{constructor(t){super(),this.title="number array",this.$value=new eK([],!0),this.$disabled=new eK(!1,!0),void 0!==t&&this.$value.set(t),this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new bxt({target:e,props:{title:this.title,value:this.$value,disabled:this.$disabled}}))}}function xxt(...t){return new vxt(...t)}function wxt(t){let e;return{c(){e=MB("p"),e.textContent="No model loaded"},m(t,n){TB(t,e,n)},p:Jz,d(t){t&&_B(e)}}}function Sxt(t){let e,n,i,r;return{c(){e=MB("p"),n=IB("Model Loaded from "),i=IB(t[2]),r=IB(".")},m(t,s){TB(t,e,s),SB(e,n),SB(e,i),SB(e,r)},p(t,e){4&e&&DB(i,t[2])},d(t){t&&_B(e)}}}function kxt(t){let e;return{c(){e=MB("p"),e.textContent="Loading Model..."},m(t,n){TB(t,e,n)},p:Jz,d(t){t&&_B(e)}}}function Cxt(t){let e;function n(t,e){return"loading"===t[3]?kxt:"loaded"===t[3]?Sxt:wxt}let i=n(t),r=i(t);return{c(){e=MB("div"),r.c(),OB(e,"class","p-2 text-sm text-gray-600")},m(t,n){TB(t,e,n),r.m(e,null)},p(t,s){i===(i=n(t))&&r?r.p(t,s):(r.d(1),r=i(t),r&&(r.c(),r.m(e,null)))},d(t){t&&_B(e),r.d()}}}function Txt(t){let e,n;return e=new DH({props:{title:t[0],loading:"loading"===t[3],$$slots:{default:[Cxt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),8&n&&(i.loading="loading"===t[3]),268&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function _xt(t,e,n){let i,r,s,o=Jz,a=()=>(o(),o=aB(d,(t=>n(7,s=t))),d);var l,c,u;t.$$.on_destroy.push((()=>o()));let{title:h}=e,{training:d}=e;return a(),t.$$set=t=>{"title"in t&&n(0,h=t.title),"training"in t&&a(n(1,d=t.training))},t.$$.update=()=>{128&t.$$.dirty&&n(3,i=s.status),240&t.$$.dirty&&n(2,r=(null===n(4,l=s.data)||void 0===l?void 0:l.source)?"datastore"===s.data.source?`datastore at ${null===n(5,c=s.data)||void 0===c?void 0:c.url}`:"url"===s.data.source?`url ${null===n(6,u=s.data)||void 0===u?void 0:u.url}`:"files":"unknown source")},[h,d,r,i,l,c,u,s]}class Ext extends UU{constructor(t){super(),BU(this,t,_xt,Txt,rB,{title:0,training:1})}}var Mxt;function $xt(t,e){return t===e}function Ixt(t,e){return t===e}class Axt extends i3{constructor({inputType:t,taskType:e,inputShape:n}){super(),this.title="onnx model",this.parameters={},this.serviceName="onnx-models",this.$loading=new eK(!1,!0),this.$ready=new eK(!1,!0),this.modelName="",this.lockLoading=Promise.resolve(),Mxt.set(this,void 0),this.inputType=t,this.taskType=e,this.inputShape=n,this.start()}train(){throw new lK("Model `OnnxModel` cannot be trained")}async predict(t){if(!VX(this,Mxt,"f")||!this.$ready.get())throw new Error("Model is not loaded");const e=this.preprocess(t),n=await VX(this,Mxt,"f").run({[VX(this,Mxt,"f").inputNames[0]]:e});return await this.postprocess(n)}async loadFromUrl(t){this.$training.set({status:"loading"}),this.$ready.set(!1),this.$loading.set(!0);try{await this.loadModel(t,t),this.$training.set({status:"loaded",data:{source:"url",url:t}}),this.$loading.set(!1),this.$ready.set(!0)}catch(t){throw this.$training.set({status:"error"}),this.$loading.set(!1),t}}async loadFromFile(t){if(t){this.$training.set({status:"loading"}),this.$ready.set(!1),this.$loading.set(!0);try{const e=await new Promise(((e,n)=>{const i=new FileReader;i.onload=function(){const t=this.result;e(t)},i.onerror=function(){n()},i.readAsArrayBuffer(t)}));await this.loadModel(e,t.name),this.$training.set({status:"loaded",data:{source:"file"}}),this.$loading.set(!1),this.$ready.set(!0)}catch(t){throw this.$training.set({status:"error"}),this.$loading.set(!1),t}}}async loadModel(t,e){this.ready=!1,this.lockLoading=this.lockLoading.then((()=>ort.InferenceSession.create(t))).then((t=>{WX(this,Mxt,t,"f")})),await this.lockLoading,this.modelName=e;try{await this.warmup()}catch(t){console.log("ONNX Model warmup failed",t)}this.ready=!0}preprocess(t){if($xt(this.inputType,"image"))return this.preprocessImage(t);if($xt(this.inputType,"generic")){const e=t.flat().flat().flat().flat().flat();return new ort.Tensor("float32",Float32Array.from(e),this.inputShape)}throw new Error("Invalid input data type")}preprocessImage(t){throw new Error("ONNX for Images: Not yet implemented")}async postprocess(t){if(Ixt(this.taskType,"classification")){const e=this.labels?t=>this.labels[t]:t=>t.toString(),n=Array.from(t.probabilities.data).reduce(((t,n,i)=>({...t,[e(i)]:n})),{});return{label:e(t.label.data[0]),confidences:n}}if(Ixt(this.taskType,"generic")){const e={};for(const n of VX(this,Mxt,"f").outputNames)e[n]=Array.from(t[n].data);return e}throw new Error("Invalid output data type")}async warmup(){const t=Float32Array.from(Array(this.inputShape.reduce(((t,e)=>t*e),1)),(()=>Math.random())),e=new ort.Tensor("float32",t,this.inputShape);await VX(this,Mxt,"f").run({[VX(this,Mxt,"f").inputNames[0]]:e})}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new Ext({target:e,props:{title:this.title,training:this.$training}}))}save(){throw new Error("OnnxModel does not support saving")}load(){throw new Error("OnnxModel does not support loading")}download(){throw new Error("OnnxModel does not support downloading")}upload(){throw new Error("OnnxModel does not support uploading")}}function Nxt(t){return new Axt(t)}Mxt=new WeakMap,UX([aK],Axt.prototype,"train",null),UX([aK],Axt.prototype,"predict",null),UX([aK],Axt.prototype,"loadFromUrl",null),UX([aK],Axt.prototype,"loadFromFile",null),UX([aK],Axt.prototype,"loadModel",null),UX([aK],Axt.prototype,"preprocess",null),UX([aK],Axt.prototype,"postprocess",null),UX([aK],Axt.prototype,"save",null),UX([aK],Axt.prototype,"load",null),UX([aK],Axt.prototype,"download",null),UX([aK],Axt.prototype,"upload",null);const Rxt=" ".repeat(2),Pxt=" ".repeat(4);function Oxt(t,e={}){const{maxRows:n=15,maxColumns:i=10,maxNumSize:r=8,padMinus:s="auto"}=e;return`${t.constructor.name} {\n${Rxt}[\n${Pxt}${function(t,e,n,i,r){const{rows:s,columns:o}=t,a=Math.min(s,e),l=Math.min(o,n),c=[];if("auto"===r){r=!1;t:for(let e=0;e<a;e++)for(let n=0;n<l;n++)if(t.get(e,n)<0){r=!0;break t}}for(let e=0;e<a;e++){let n=[];for(let s=0;s<l;s++)n.push(Lxt(t.get(e,s),i,r));c.push(`${n.join(" ")}`)}l!==o&&(c[c.length-1]+=` ... ${o-n} more columns`);a!==s&&c.push(`... ${s-e} more rows`);return c.join(`\n${Pxt}`)}(t,n,i,r,s)}\n${Rxt}]\n${Rxt}rows: ${t.rows}\n${Rxt}columns: ${t.columns}\n}`}function Lxt(t,e,n){return(t>=0&&n?` ${Dxt(t,e-1)}`:Dxt(t,e)).padEnd(e)}function Dxt(t,e){let n=t.toString();if(n.length<=e)return n;let i=t.toFixed(e);if(i.length>e&&(i=t.toFixed(Math.max(0,e-(i.length-e)))),i.length<=e&&!i.startsWith("0.000")&&!i.startsWith("-0.000"))return i;let r=t.toExponential(e);return r.length>e&&(r=t.toExponential(Math.max(0,e-(r.length-e)))),r.slice(0)}function Fxt(t,e,n){let i=n?t.rows:t.rows-1;if(e<0||e>i)throw new RangeError("Row index out of range")}function zxt(t,e,n){let i=n?t.columns:t.columns-1;if(e<0||e>i)throw new RangeError("Column index out of range")}function Bxt(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function Uxt(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function Vxt(t,e,n,i,r){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(Hxt("startRow",e),Hxt("endRow",n),Hxt("startColumn",i),Hxt("endColumn",r),e>n||i>r||e<0||e>=t.rows||n<0||n>=t.rows||i<0||i>=t.columns||r<0||r>=t.columns)throw new RangeError("Submatrix indices are out of range")}function Wxt(t,e=0){let n=[];for(let i=0;i<t;i++)n.push(e);return n}function Hxt(t,e){if("number"!=typeof e)throw new TypeError(`${t} must be a number`)}function jxt(t){if(t.isEmpty())throw new Error("Empty matrix has no elements to index")}class Gxt{static from1DArray(t,e,n){if(t*e!==n.length)throw new RangeError("data length does not match given dimensions");let i=new Xxt(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++)i.set(r,t,n[r*e+t]);return i}static rowVector(t){let e=new Xxt(1,t.length);for(let n=0;n<t.length;n++)e.set(0,n,t[n]);return e}static columnVector(t){let e=new Xxt(t.length,1);for(let n=0;n<t.length;n++)e.set(n,0,t[n]);return e}static zeros(t,e){return new Xxt(t,e)}static ones(t,e){return new Xxt(t,e).fill(1)}static rand(t,e,n={}){if("object"!=typeof n)throw new TypeError("options must be an object");const{random:i=Math.random}=n;let r=new Xxt(t,e);for(let n=0;n<t;n++)for(let t=0;t<e;t++)r.set(n,t,i());return r}static randInt(t,e,n={}){if("object"!=typeof n)throw new TypeError("options must be an object");const{min:i=0,max:r=1e3,random:s=Math.random}=n;if(!Number.isInteger(i))throw new TypeError("min must be an integer");if(!Number.isInteger(r))throw new TypeError("max must be an integer");if(i>=r)throw new RangeError("min must be smaller than max");let o=r-i,a=new Xxt(t,e);for(let n=0;n<t;n++)for(let t=0;t<e;t++){let e=i+Math.round(s()*o);a.set(n,t,e)}return a}static eye(t,e,n){void 0===e&&(e=t),void 0===n&&(n=1);let i=Math.min(t,e),r=this.zeros(t,e);for(let t=0;t<i;t++)r.set(t,t,n);return r}static diag(t,e,n){let i=t.length;void 0===e&&(e=i),void 0===n&&(n=e);let r=Math.min(i,e,n),s=this.zeros(e,n);for(let e=0;e<r;e++)s.set(e,e,t[e]);return s}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let n=t.rows,i=t.columns,r=new Xxt(n,i);for(let s=0;s<n;s++)for(let n=0;n<i;n++)r.set(s,n,Math.min(t.get(s,n),e.get(s,n)));return r}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let n=t.rows,i=t.columns,r=new this(n,i);for(let s=0;s<n;s++)for(let n=0;n<i;n++)r.set(s,n,Math.max(t.get(s,n),e.get(s,n)));return r}static checkMatrix(t){return Gxt.isMatrix(t)?t:new Xxt(t)}static isMatrix(t){return null!=t&&"Matrix"===t.klass}get size(){return this.rows*this.columns}apply(t){if("function"!=typeof t)throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t.call(this,e,n);return this}to1DArray(){let t=[];for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t.push(this.get(e,n));return t}to2DArray(){let t=[];for(let e=0;e<this.rows;e++){t.push([]);for(let n=0;n<this.columns;n++)t[e].push(this.get(e,n))}return t}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isEmpty(){return 0===this.rows||0===this.columns}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isEchelonForm(){let t=0,e=0,n=-1,i=!0,r=!1;for(;t<this.rows&&i;){for(e=0,r=!1;e<this.columns&&!1===r;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>n?(r=!0,n=e):(i=!1,r=!0);t++}return i}isReducedEchelonForm(){let t=0,e=0,n=-1,i=!0,r=!1;for(;t<this.rows&&i;){for(e=0,r=!1;e<this.columns&&!1===r;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>n?(r=!0,n=e):(i=!1,r=!0);for(let n=e+1;n<this.rows;n++)0!==this.get(t,n)&&(i=!1);t++}return i}echelonForm(){let t=this.clone(),e=0,n=0;for(;e<t.rows&&n<t.columns;){let i=e;for(let r=e;r<t.rows;r++)t.get(r,n)>t.get(i,n)&&(i=r);if(0===t.get(i,n))n++;else{t.swapRows(e,i);let r=t.get(e,n);for(let i=n;i<t.columns;i++)t.set(e,i,t.get(e,i)/r);for(let i=e+1;i<t.rows;i++){let r=t.get(i,n)/t.get(e,n);t.set(i,n,0);for(let s=n+1;s<t.columns;s++)t.set(i,s,t.get(i,s)-t.get(e,s)*r)}e++,n++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,n=t.rows,i=n-1;for(;i>=0;)if(0===t.maxRow(i))i--;else{let r=0,s=!1;for(;r<n&&!1===s;)1===t.get(i,r)?s=!0:r++;for(let n=0;n<i;n++){let s=t.get(n,r);for(let o=r;o<e;o++){let e=t.get(n,o)-s*t.get(i,o);t.set(n,o,e)}}i--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{rows:e=1,columns:n=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(n)||n<=0)throw new TypeError("columns must be a positive integer");let i=new Xxt(this.rows*e,this.columns*n);for(let t=0;t<e;t++)for(let e=0;e<n;e++)i.setSubMatrix(this,this.rows*t,this.columns*e);return i}fill(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,t);return this}neg(){return this.mulS(-1)}getRow(t){Fxt(this,t);let e=[];for(let n=0;n<this.columns;n++)e.push(this.get(t,n));return e}getRowVector(t){return Xxt.rowVector(this.getRow(t))}setRow(t,e){Fxt(this,t),e=Bxt(this,e);for(let n=0;n<this.columns;n++)this.set(t,n,e[n]);return this}swapRows(t,e){Fxt(this,t),Fxt(this,e);for(let n=0;n<this.columns;n++){let i=this.get(t,n);this.set(t,n,this.get(e,n)),this.set(e,n,i)}return this}getColumn(t){zxt(this,t);let e=[];for(let n=0;n<this.rows;n++)e.push(this.get(n,t));return e}getColumnVector(t){return Xxt.columnVector(this.getColumn(t))}setColumn(t,e){zxt(this,t),e=Uxt(this,e);for(let n=0;n<this.rows;n++)this.set(n,t,e[n]);return this}swapColumns(t,e){zxt(this,t),zxt(this,e);for(let n=0;n<this.rows;n++){let i=this.get(n,t);this.set(n,t,this.get(n,e)),this.set(n,e,i)}return this}addRowVector(t){t=Bxt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)+t[n]);return this}subRowVector(t){t=Bxt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)-t[n]);return this}mulRowVector(t){t=Bxt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)*t[n]);return this}divRowVector(t){t=Bxt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)/t[n]);return this}addColumnVector(t){t=Uxt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)+t[e]);return this}subColumnVector(t){t=Uxt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)-t[e]);return this}mulColumnVector(t){t=Uxt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)*t[e]);return this}divColumnVector(t){t=Uxt(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)/t[e]);return this}mulRow(t,e){Fxt(this,t);for(let n=0;n<this.columns;n++)this.set(t,n,this.get(t,n)*e);return this}mulColumn(t,e){zxt(this,t);for(let n=0;n<this.rows;n++)this.set(n,t,this.get(n,t)*e);return this}max(t){if(this.isEmpty())return NaN;switch(t){case"row":{const t=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.get(e,n)>t[e]&&(t[e]=this.get(e,n));return t}case"column":{const t=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.get(e,n)>t[n]&&(t[n]=this.get(e,n));return t}case void 0:{let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.get(e,n)>t&&(t=this.get(e,n));return t}default:throw new Error(`invalid option: ${t}`)}}maxIndex(){jxt(this);let t=this.get(0,0),e=[0,0];for(let n=0;n<this.rows;n++)for(let i=0;i<this.columns;i++)this.get(n,i)>t&&(t=this.get(n,i),e[0]=n,e[1]=i);return e}min(t){if(this.isEmpty())return NaN;switch(t){case"row":{const t=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.get(e,n)<t[e]&&(t[e]=this.get(e,n));return t}case"column":{const t=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.get(e,n)<t[n]&&(t[n]=this.get(e,n));return t}case void 0:{let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.get(e,n)<t&&(t=this.get(e,n));return t}default:throw new Error(`invalid option: ${t}`)}}minIndex(){jxt(this);let t=this.get(0,0),e=[0,0];for(let n=0;n<this.rows;n++)for(let i=0;i<this.columns;i++)this.get(n,i)<t&&(t=this.get(n,i),e[0]=n,e[1]=i);return e}maxRow(t){if(Fxt(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let n=1;n<this.columns;n++)this.get(t,n)>e&&(e=this.get(t,n));return e}maxRowIndex(t){Fxt(this,t),jxt(this);let e=this.get(t,0),n=[t,0];for(let i=1;i<this.columns;i++)this.get(t,i)>e&&(e=this.get(t,i),n[1]=i);return n}minRow(t){if(Fxt(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let n=1;n<this.columns;n++)this.get(t,n)<e&&(e=this.get(t,n));return e}minRowIndex(t){Fxt(this,t),jxt(this);let e=this.get(t,0),n=[t,0];for(let i=1;i<this.columns;i++)this.get(t,i)<e&&(e=this.get(t,i),n[1]=i);return n}maxColumn(t){if(zxt(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let n=1;n<this.rows;n++)this.get(n,t)>e&&(e=this.get(n,t));return e}maxColumnIndex(t){zxt(this,t),jxt(this);let e=this.get(0,t),n=[0,t];for(let i=1;i<this.rows;i++)this.get(i,t)>e&&(e=this.get(i,t),n[0]=i);return n}minColumn(t){if(zxt(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let n=1;n<this.rows;n++)this.get(n,t)<e&&(e=this.get(n,t));return e}minColumnIndex(t){zxt(this,t),jxt(this);let e=this.get(0,t),n=[0,t];for(let i=1;i<this.rows;i++)this.get(i,t)<e&&(e=this.get(i,t),n[0]=i);return n}diag(){let t=Math.min(this.rows,this.columns),e=[];for(let n=0;n<t;n++)e.push(this.get(n,n));return e}norm(t="frobenius"){let e=0;if("max"===t)return this.max();if("frobenius"===t){for(let t=0;t<this.rows;t++)for(let n=0;n<this.columns;n++)e+=this.get(t,n)*this.get(t,n);return Math.sqrt(e)}throw new RangeError(`unknown norm type: ${t}`)}cumulativeSum(){let t=0;for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t+=this.get(e,n),this.set(e,n,t);return this}dot(t){Gxt.isMatrix(t)&&(t=t.to1DArray());let e=this.to1DArray();if(e.length!==t.length)throw new RangeError("vectors do not have the same size");let n=0;for(let i=0;i<e.length;i++)n+=e[i]*t[i];return n}mmul(t){t=Xxt.checkMatrix(t);let e=this.rows,n=this.columns,i=t.columns,r=new Xxt(e,i),s=new Float64Array(n);for(let o=0;o<i;o++){for(let e=0;e<n;e++)s[e]=t.get(e,o);for(let t=0;t<e;t++){let e=0;for(let i=0;i<n;i++)e+=this.get(t,i)*s[i];r.set(t,o,e)}}return r}strassen2x2(t){t=Xxt.checkMatrix(t);let e=new Xxt(2,2);const n=this.get(0,0),i=t.get(0,0),r=this.get(0,1),s=t.get(0,1),o=this.get(1,0),a=t.get(1,0),l=this.get(1,1),c=t.get(1,1),u=(n+l)*(i+c),h=(o+l)*i,d=n*(s-c),p=l*(a-i),f=(n+r)*c,m=u+p-f+(r-l)*(a+c),g=d+f,y=h+p,b=u-h+d+(o-n)*(i+s);return e.set(0,0,m),e.set(0,1,g),e.set(1,0,y),e.set(1,1,b),e}strassen3x3(t){t=Xxt.checkMatrix(t);let e=new Xxt(3,3);const n=this.get(0,0),i=this.get(0,1),r=this.get(0,2),s=this.get(1,0),o=this.get(1,1),a=this.get(1,2),l=this.get(2,0),c=this.get(2,1),u=this.get(2,2),h=t.get(0,0),d=t.get(0,1),p=t.get(0,2),f=t.get(1,0),m=t.get(1,1),g=t.get(1,2),y=t.get(2,0),b=t.get(2,1),v=t.get(2,2),x=(n-s)*(-d+m),w=(-n+s+o)*(h-d+m),S=(s+o)*(-h+d),k=n*h,C=(-n+l+c)*(h-p+g),T=(-n+l)*(p-g),_=(l+c)*(-h+p),E=(-r+c+u)*(m+y-b),M=(r-u)*(m-b),$=r*y,I=(c+u)*(-y+b),A=(-r+o+a)*(g+y-v),N=(r-a)*(g-v),R=(o+a)*(-y+v),P=k+$+i*f,O=(n+i+r-s-o-c-u)*m+w+S+k+E+$+I,L=k+C+_+(n+i+r-o-a-l-c)*g+$+A+R,D=x+o*(-h+d+f-m-g-y+v)+w+k+$+A+N,F=x+w+S+k+a*b,z=$+A+N+R+s*p,B=k+C+T+c*(-h+p+f-m-g-y+b)+E+M+$,U=E+M+$+I+l*d,V=k+C+T+_+u*v;return e.set(0,0,P),e.set(0,1,O),e.set(0,2,L),e.set(1,0,D),e.set(1,1,F),e.set(1,2,z),e.set(2,0,B),e.set(2,1,U),e.set(2,2,V),e}mmulStrassen(t){t=Xxt.checkMatrix(t);let e=this.clone(),n=e.rows,i=e.columns,r=t.rows,s=t.columns;function o(t,e,n){let i=t.rows,r=t.columns;if(i===e&&r===n)return t;{let i=Gxt.zeros(e,n);return i=i.setSubMatrix(t,0,0),i}}i!==r&&console.warn(`Multiplying ${n} x ${i} and ${r} x ${s} matrix: dimensions do not match.`);let a=Math.max(n,r),l=Math.max(i,s);return e=o(e,a,l),function t(e,n,i,r){if(i<=512||r<=512)return e.mmul(n);i%2==1&&r%2==1?(e=o(e,i+1,r+1),n=o(n,i+1,r+1)):i%2==1?(e=o(e,i+1,r),n=o(n,i+1,r)):r%2==1&&(e=o(e,i,r+1),n=o(n,i,r+1));let s=parseInt(e.rows/2,10),a=parseInt(e.columns/2,10),l=e.subMatrix(0,s-1,0,a-1),c=n.subMatrix(0,s-1,0,a-1),u=e.subMatrix(0,s-1,a,e.columns-1),h=n.subMatrix(0,s-1,a,n.columns-1),d=e.subMatrix(s,e.rows-1,0,a-1),p=n.subMatrix(s,n.rows-1,0,a-1),f=e.subMatrix(s,e.rows-1,a,e.columns-1),m=n.subMatrix(s,n.rows-1,a,n.columns-1),g=t(Gxt.add(l,f),Gxt.add(c,m),s,a),y=t(Gxt.add(d,f),c,s,a),b=t(l,Gxt.sub(h,m),s,a),v=t(f,Gxt.sub(p,c),s,a),x=t(Gxt.add(l,u),m,s,a),w=t(Gxt.sub(d,l),Gxt.add(c,h),s,a),S=t(Gxt.sub(u,f),Gxt.add(p,m),s,a),k=Gxt.add(g,v);k.sub(x),k.add(S);let C=Gxt.add(b,x),T=Gxt.add(y,v),_=Gxt.sub(g,y);_.add(b),_.add(w);let E=Gxt.zeros(2*k.rows,2*k.columns);return E=E.setSubMatrix(k,0,0),E=E.setSubMatrix(C,k.rows,0),E=E.setSubMatrix(T,0,k.columns),E=E.setSubMatrix(_,k.rows,k.columns),E.subMatrix(0,i-1,0,r-1)}(e,t=o(t,a,l),a,l)}scaleRows(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:n=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(n))throw new TypeError("max must be a number");if(e>=n)throw new RangeError("min must be smaller than max");let i=new Xxt(this.rows,this.columns);for(let t=0;t<this.rows;t++){const r=this.getRow(t);r.length>0&&vbt(r,{min:e,max:n,output:r}),i.setRow(t,r)}return i}scaleColumns(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:n=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(n))throw new TypeError("max must be a number");if(e>=n)throw new RangeError("min must be smaller than max");let i=new Xxt(this.rows,this.columns);for(let t=0;t<this.columns;t++){const r=this.getColumn(t);r.length&&vbt(r,{min:e,max:n,output:r}),i.setColumn(t,r)}return i}flipRows(){const t=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let n=0;n<t;n++){let t=this.get(e,n),i=this.get(e,this.columns-1-n);this.set(e,n,i),this.set(e,this.columns-1-n,t)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let n=0;n<t;n++){let t=this.get(n,e),i=this.get(this.rows-1-n,e);this.set(n,e,i),this.set(this.rows-1-n,e,t)}return this}kroneckerProduct(t){t=Xxt.checkMatrix(t);let e=this.rows,n=this.columns,i=t.rows,r=t.columns,s=new Xxt(e*i,n*r);for(let o=0;o<e;o++)for(let e=0;e<n;e++)for(let n=0;n<i;n++)for(let a=0;a<r;a++)s.set(i*o+n,r*e+a,this.get(o,e)*t.get(n,a));return s}kroneckerSum(t){if(t=Xxt.checkMatrix(t),!this.isSquare()||!t.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let e=this.rows,n=t.rows,i=this.kroneckerProduct(Xxt.eye(n,n)),r=Xxt.eye(e,e).kroneckerProduct(t);return i.add(r)}transpose(){let t=new Xxt(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t.set(n,e,this.get(e,n));return t}sortRows(t=qxt){for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(t=qxt){for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,n,i){Vxt(this,t,e,n,i);let r=new Xxt(e-t+1,i-n+1);for(let s=t;s<=e;s++)for(let e=n;e<=i;e++)r.set(s-t,e-n,this.get(s,e));return r}subMatrixRow(t,e,n){if(void 0===e&&(e=0),void 0===n&&(n=this.columns-1),e>n||e<0||e>=this.columns||n<0||n>=this.columns)throw new RangeError("Argument out of range");let i=new Xxt(t.length,n-e+1);for(let r=0;r<t.length;r++)for(let s=e;s<=n;s++){if(t[r]<0||t[r]>=this.rows)throw new RangeError(`Row index out of range: ${t[r]}`);i.set(r,s-e,this.get(t[r],s))}return i}subMatrixColumn(t,e,n){if(void 0===e&&(e=0),void 0===n&&(n=this.rows-1),e>n||e<0||e>=this.rows||n<0||n>=this.rows)throw new RangeError("Argument out of range");let i=new Xxt(n-e+1,t.length);for(let r=0;r<t.length;r++)for(let s=e;s<=n;s++){if(t[r]<0||t[r]>=this.columns)throw new RangeError(`Column index out of range: ${t[r]}`);i.set(s-e,r,this.get(s,t[r]))}return i}setSubMatrix(t,e,n){if((t=Xxt.checkMatrix(t)).isEmpty())return this;Vxt(this,e,e+t.rows-1,n,n+t.columns-1);for(let i=0;i<t.rows;i++)for(let r=0;r<t.columns;r++)this.set(e+i,n+r,t.get(i,r));return this}selection(t,e){!function(t,e){if(!bbt(e))throw new TypeError("row indices must be an array");for(let n=0;n<e.length;n++)if(e[n]<0||e[n]>=t.rows)throw new RangeError("row indices are out of range")}(this,t),function(t,e){if(!bbt(e))throw new TypeError("column indices must be an array");for(let n=0;n<e.length;n++)if(e[n]<0||e[n]>=t.columns)throw new RangeError("column indices are out of range")}(this,e);let n=new Xxt(t.length,e.length);for(let i=0;i<t.length;i++){let r=t[i];for(let t=0;t<e.length;t++){let s=e[t];n.set(i,t,this.get(r,s))}}return n}trace(){let t=Math.min(this.rows,this.columns),e=0;for(let n=0;n<t;n++)e+=this.get(n,n);return e}clone(){let t=new Xxt(this.rows,this.columns);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t.set(e,n,this.get(e,n));return t}sum(t){switch(t){case"row":return function(t){let e=Wxt(t.rows);for(let n=0;n<t.rows;++n)for(let i=0;i<t.columns;++i)e[n]+=t.get(n,i);return e}(this);case"column":return function(t){let e=Wxt(t.columns);for(let n=0;n<t.rows;++n)for(let i=0;i<t.columns;++i)e[i]+=t.get(n,i);return e}(this);case void 0:return function(t){let e=0;for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)e+=t.get(n,i);return e}(this);default:throw new Error(`invalid option: ${t}`)}}product(t){switch(t){case"row":return function(t){let e=Wxt(t.rows,1);for(let n=0;n<t.rows;++n)for(let i=0;i<t.columns;++i)e[n]*=t.get(n,i);return e}(this);case"column":return function(t){let e=Wxt(t.columns,1);for(let n=0;n<t.rows;++n)for(let i=0;i<t.columns;++i)e[i]*=t.get(n,i);return e}(this);case void 0:return function(t){let e=1;for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)e*=t.get(n,i);return e}(this);default:throw new Error(`invalid option: ${t}`)}}mean(t){const e=this.sum(t);switch(t){case"row":for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e;case"column":for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e;case void 0:return e/this.size;default:throw new Error(`invalid option: ${t}`)}}variance(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{unbiased:n=!0,mean:i=this.mean(t)}=e;if("boolean"!=typeof n)throw new TypeError("unbiased must be a boolean");switch(t){case"row":if(!bbt(i))throw new TypeError("mean must be an array");return function(t,e,n){const i=t.rows,r=t.columns,s=[];for(let o=0;o<i;o++){let i=0,a=0,l=0;for(let e=0;e<r;e++)l=t.get(o,e)-n[o],i+=l,a+=l*l;e?s.push((a-i*i/r)/(r-1)):s.push((a-i*i/r)/r)}return s}(this,n,i);case"column":if(!bbt(i))throw new TypeError("mean must be an array");return function(t,e,n){const i=t.rows,r=t.columns,s=[];for(let o=0;o<r;o++){let r=0,a=0,l=0;for(let e=0;e<i;e++)l=t.get(e,o)-n[o],r+=l,a+=l*l;e?s.push((a-r*r/i)/(i-1)):s.push((a-r*r/i)/i)}return s}(this,n,i);case void 0:if("number"!=typeof i)throw new TypeError("mean must be a number");return function(t,e,n){const i=t.rows,r=t.columns,s=i*r;let o=0,a=0,l=0;for(let e=0;e<i;e++)for(let i=0;i<r;i++)l=t.get(e,i)-n,o+=l,a+=l*l;return e?(a-o*o/s)/(s-1):(a-o*o/s)/s}(this,n,i);default:throw new Error(`invalid option: ${t}`)}}standardDeviation(t,e){"object"==typeof t&&(e=t,t=void 0);const n=this.variance(t,e);if(void 0===t)return Math.sqrt(n);for(let t=0;t<n.length;t++)n[t]=Math.sqrt(n[t]);return n}center(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{center:n=this.mean(t)}=e;switch(t){case"row":if(!bbt(n))throw new TypeError("center must be an array");return function(t,e){for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)t.set(n,i,t.get(n,i)-e[n])}(this,n),this;case"column":if(!bbt(n))throw new TypeError("center must be an array");return function(t,e){for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)t.set(n,i,t.get(n,i)-e[i])}(this,n),this;case void 0:if("number"!=typeof n)throw new TypeError("center must be a number");return function(t,e){for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)t.set(n,i,t.get(n,i)-e)}(this,n),this;default:throw new Error(`invalid option: ${t}`)}}scale(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");let n=e.scale;switch(t){case"row":if(void 0===n)n=function(t){const e=[];for(let n=0;n<t.rows;n++){let i=0;for(let e=0;e<t.columns;e++)i+=Math.pow(t.get(n,e),2)/(t.columns-1);e.push(Math.sqrt(i))}return e}(this);else if(!bbt(n))throw new TypeError("scale must be an array");return function(t,e){for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)t.set(n,i,t.get(n,i)/e[n])}(this,n),this;case"column":if(void 0===n)n=function(t){const e=[];for(let n=0;n<t.columns;n++){let i=0;for(let e=0;e<t.rows;e++)i+=Math.pow(t.get(e,n),2)/(t.rows-1);e.push(Math.sqrt(i))}return e}(this);else if(!bbt(n))throw new TypeError("scale must be an array");return function(t,e){for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)t.set(n,i,t.get(n,i)/e[i])}(this,n),this;case void 0:if(void 0===n)n=function(t){const e=t.size-1;let n=0;for(let i=0;i<t.columns;i++)for(let r=0;r<t.rows;r++)n+=Math.pow(t.get(r,i),2)/e;return Math.sqrt(n)}(this);else if("number"!=typeof n)throw new TypeError("scale must be a number");return function(t,e){for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)t.set(n,i,t.get(n,i)/e)}(this,n),this;default:throw new Error(`invalid option: ${t}`)}}toString(t){return Oxt(this,t)}}function qxt(t,e){return t-e}Gxt.prototype.klass="Matrix","undefined"!=typeof Symbol&&(Gxt.prototype[Symbol.for("nodejs.util.inspect.custom")]=function(){return Oxt(this)}),Gxt.random=Gxt.rand,Gxt.randomInt=Gxt.randInt,Gxt.diagonal=Gxt.diag,Gxt.prototype.diagonal=Gxt.prototype.diag,Gxt.identity=Gxt.eye,Gxt.prototype.negate=Gxt.prototype.neg,Gxt.prototype.tensorProduct=Gxt.prototype.kroneckerProduct;class Xxt extends Gxt{constructor(t,e){if(super(),Xxt.isMatrix(t))return t.clone();if(Number.isInteger(t)&&t>=0){if(this.data=[],!(Number.isInteger(e)&&e>=0))throw new TypeError("nColumns must be a positive integer");for(let n=0;n<t;n++)this.data.push(new Float64Array(e))}else{if(!bbt(t))throw new TypeError("First argument must be a positive number or an array");{const n=t;if("number"!=typeof(e=(t=n.length)?n[0].length:0))throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let i=0;i<t;i++){if(n[i].length!==e)throw new RangeError("Inconsistent array dimensions");if(!n[i].every((t=>"number"==typeof t)))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(n[i]))}}}this.rows=t,this.columns=e}set(t,e,n){return this.data[t][e]=n,this}get(t,e){return this.data[t][e]}removeRow(t){return Fxt(this,t),this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return void 0===e&&(e=t,t=this.rows),Fxt(this,t,!0),e=Float64Array.from(Bxt(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){zxt(this,t);for(let e=0;e<this.rows;e++){const n=new Float64Array(this.columns-1);for(let i=0;i<t;i++)n[i]=this.data[e][i];for(let i=t+1;i<this.columns;i++)n[i-1]=this.data[e][i];this.data[e]=n}return this.columns-=1,this}addColumn(t,e){void 0===e&&(e=t,t=this.columns),zxt(this,t,!0),e=Uxt(this,e);for(let n=0;n<this.rows;n++){const i=new Float64Array(this.columns+1);let r=0;for(;r<t;r++)i[r]=this.data[n][r];for(i[r++]=e[n];r<this.columns+1;r++)i[r]=this.data[n][r-1];this.data[n]=i}return this.columns+=1,this}}!function(t,e){t.prototype.add=function(t){return"number"==typeof t?this.addS(t):this.addM(t)},t.prototype.addS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)+t);return this},t.prototype.addM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)+t.get(e,n));return this},t.add=function(t,n){return new e(t).add(n)},t.prototype.sub=function(t){return"number"==typeof t?this.subS(t):this.subM(t)},t.prototype.subS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)-t);return this},t.prototype.subM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)-t.get(e,n));return this},t.sub=function(t,n){return new e(t).sub(n)},t.prototype.subtract=t.prototype.sub,t.prototype.subtractS=t.prototype.subS,t.prototype.subtractM=t.prototype.subM,t.subtract=t.sub,t.prototype.mul=function(t){return"number"==typeof t?this.mulS(t):this.mulM(t)},t.prototype.mulS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)*t);return this},t.prototype.mulM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)*t.get(e,n));return this},t.mul=function(t,n){return new e(t).mul(n)},t.prototype.multiply=t.prototype.mul,t.prototype.multiplyS=t.prototype.mulS,t.prototype.multiplyM=t.prototype.mulM,t.multiply=t.mul,t.prototype.div=function(t){return"number"==typeof t?this.divS(t):this.divM(t)},t.prototype.divS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)/t);return this},t.prototype.divM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)/t.get(e,n));return this},t.div=function(t,n){return new e(t).div(n)},t.prototype.divide=t.prototype.div,t.prototype.divideS=t.prototype.divS,t.prototype.divideM=t.prototype.divM,t.divide=t.div,t.prototype.mod=function(t){return"number"==typeof t?this.modS(t):this.modM(t)},t.prototype.modS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)%t);return this},t.prototype.modM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)%t.get(e,n));return this},t.mod=function(t,n){return new e(t).mod(n)},t.prototype.modulus=t.prototype.mod,t.prototype.modulusS=t.prototype.modS,t.prototype.modulusM=t.prototype.modM,t.modulus=t.mod,t.prototype.and=function(t){return"number"==typeof t?this.andS(t):this.andM(t)},t.prototype.andS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)&t);return this},t.prototype.andM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)&t.get(e,n));return this},t.and=function(t,n){return new e(t).and(n)},t.prototype.or=function(t){return"number"==typeof t?this.orS(t):this.orM(t)},t.prototype.orS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)|t);return this},t.prototype.orM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)|t.get(e,n));return this},t.or=function(t,n){return new e(t).or(n)},t.prototype.xor=function(t){return"number"==typeof t?this.xorS(t):this.xorM(t)},t.prototype.xorS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)^t);return this},t.prototype.xorM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)^t.get(e,n));return this},t.xor=function(t,n){return new e(t).xor(n)},t.prototype.leftShift=function(t){return"number"==typeof t?this.leftShiftS(t):this.leftShiftM(t)},t.prototype.leftShiftS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)<<t);return this},t.prototype.leftShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)<<t.get(e,n));return this},t.leftShift=function(t,n){return new e(t).leftShift(n)},t.prototype.signPropagatingRightShift=function(t){return"number"==typeof t?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},t.prototype.signPropagatingRightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)>>t);return this},t.prototype.signPropagatingRightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)>>t.get(e,n));return this},t.signPropagatingRightShift=function(t,n){return new e(t).signPropagatingRightShift(n)},t.prototype.rightShift=function(t){return"number"==typeof t?this.rightShiftS(t):this.rightShiftM(t)},t.prototype.rightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)>>>t);return this},t.prototype.rightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)>>>t.get(e,n));return this},t.rightShift=function(t,n){return new e(t).rightShift(n)},t.prototype.zeroFillRightShift=t.prototype.rightShift,t.prototype.zeroFillRightShiftS=t.prototype.rightShiftS,t.prototype.zeroFillRightShiftM=t.prototype.rightShiftM,t.zeroFillRightShift=t.rightShift,t.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,~this.get(t,e));return this},t.not=function(t){return new e(t).not()},t.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.abs(this.get(t,e)));return this},t.abs=function(t){return new e(t).abs()},t.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acos(this.get(t,e)));return this},t.acos=function(t){return new e(t).acos()},t.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acosh(this.get(t,e)));return this},t.acosh=function(t){return new e(t).acosh()},t.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asin(this.get(t,e)));return this},t.asin=function(t){return new e(t).asin()},t.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asinh(this.get(t,e)));return this},t.asinh=function(t){return new e(t).asinh()},t.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atan(this.get(t,e)));return this},t.atan=function(t){return new e(t).atan()},t.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atanh(this.get(t,e)));return this},t.atanh=function(t){return new e(t).atanh()},t.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cbrt(this.get(t,e)));return this},t.cbrt=function(t){return new e(t).cbrt()},t.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.ceil(this.get(t,e)));return this},t.ceil=function(t){return new e(t).ceil()},t.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.clz32(this.get(t,e)));return this},t.clz32=function(t){return new e(t).clz32()},t.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cos(this.get(t,e)));return this},t.cos=function(t){return new e(t).cos()},t.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cosh(this.get(t,e)));return this},t.cosh=function(t){return new e(t).cosh()},t.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.exp(this.get(t,e)));return this},t.exp=function(t){return new e(t).exp()},t.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.expm1(this.get(t,e)));return this},t.expm1=function(t){return new e(t).expm1()},t.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.floor(this.get(t,e)));return this},t.floor=function(t){return new e(t).floor()},t.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.fround(this.get(t,e)));return this},t.fround=function(t){return new e(t).fround()},t.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log(this.get(t,e)));return this},t.log=function(t){return new e(t).log()},t.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log1p(this.get(t,e)));return this},t.log1p=function(t){return new e(t).log1p()},t.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log10(this.get(t,e)));return this},t.log10=function(t){return new e(t).log10()},t.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log2(this.get(t,e)));return this},t.log2=function(t){return new e(t).log2()},t.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.round(this.get(t,e)));return this},t.round=function(t){return new e(t).round()},t.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sign(this.get(t,e)));return this},t.sign=function(t){return new e(t).sign()},t.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sin(this.get(t,e)));return this},t.sin=function(t){return new e(t).sin()},t.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sinh(this.get(t,e)));return this},t.sinh=function(t){return new e(t).sinh()},t.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sqrt(this.get(t,e)));return this},t.sqrt=function(t){return new e(t).sqrt()},t.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tan(this.get(t,e)));return this},t.tan=function(t){return new e(t).tan()},t.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tanh(this.get(t,e)));return this},t.tanh=function(t){return new e(t).tanh()},t.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.trunc(this.get(t,e)));return this},t.trunc=function(t){return new e(t).trunc()},t.pow=function(t,n){return new e(t).pow(n)},t.prototype.pow=function(t){return"number"==typeof t?this.powS(t):this.powM(t)},t.prototype.powS=function(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,Math.pow(this.get(e,n),t));return this},t.prototype.powM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,Math.pow(this.get(e,n),t.get(e,n)));return this}}(Gxt,Xxt);class Kxt extends Gxt{constructor(t,e,n){super(),this.matrix=t,this.rows=e,this.columns=n}}class Yxt extends Kxt{constructor(t){super(t,t.columns,t.rows)}set(t,e,n){return this.matrix.set(e,t,n),this}get(t,e){return this.matrix.get(e,t)}}class Zxt extends Gxt{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,e,n){return this.data[t][e]=n,this}get(t,e){return this.data[t][e]}}function Jxt(t,e){let n=0;return Math.abs(t)>Math.abs(e)?(n=e/t,Math.abs(t)*Math.sqrt(1+n*n)):0!==e?(n=t/e,Math.abs(e)*Math.sqrt(1+n*n)):0}class Qxt{constructor(t,e={}){if((t=Zxt.checkMatrix(t)).isEmpty())throw new Error("Matrix must be non-empty");let n=t.rows,i=t.columns;const{computeLeftSingularVectors:r=!0,computeRightSingularVectors:s=!0,autoTranspose:o=!1}=e;let a,l=Boolean(r),c=Boolean(s),u=!1;if(n<i)if(o){a=t.transpose(),n=a.rows,i=a.columns,u=!0;let e=l;l=c,c=e}else a=t.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else a=t.clone();let h=Math.min(n,i),d=Math.min(n+1,i),p=new Float64Array(d),f=new Xxt(n,h),m=new Xxt(i,i),g=new Float64Array(i),y=new Float64Array(n),b=new Float64Array(d);for(let t=0;t<d;t++)b[t]=t;let v=Math.min(n-1,i),x=Math.max(0,Math.min(i-2,n)),w=Math.max(v,x);for(let t=0;t<w;t++){if(t<v){p[t]=0;for(let e=t;e<n;e++)p[t]=Jxt(p[t],a.get(e,t));if(0!==p[t]){a.get(t,t)<0&&(p[t]=-p[t]);for(let e=t;e<n;e++)a.set(e,t,a.get(e,t)/p[t]);a.set(t,t,a.get(t,t)+1)}p[t]=-p[t]}for(let e=t+1;e<i;e++){if(t<v&&0!==p[t]){let i=0;for(let r=t;r<n;r++)i+=a.get(r,t)*a.get(r,e);i=-i/a.get(t,t);for(let r=t;r<n;r++)a.set(r,e,a.get(r,e)+i*a.get(r,t))}g[e]=a.get(t,e)}if(l&&t<v)for(let e=t;e<n;e++)f.set(e,t,a.get(e,t));if(t<x){g[t]=0;for(let e=t+1;e<i;e++)g[t]=Jxt(g[t],g[e]);if(0!==g[t]){g[t+1]<0&&(g[t]=0-g[t]);for(let e=t+1;e<i;e++)g[e]/=g[t];g[t+1]+=1}if(g[t]=-g[t],t+1<n&&0!==g[t]){for(let e=t+1;e<n;e++)y[e]=0;for(let e=t+1;e<n;e++)for(let n=t+1;n<i;n++)y[e]+=g[n]*a.get(e,n);for(let e=t+1;e<i;e++){let i=-g[e]/g[t+1];for(let r=t+1;r<n;r++)a.set(r,e,a.get(r,e)+i*y[r])}}if(c)for(let e=t+1;e<i;e++)m.set(e,t,g[e])}}let S=Math.min(i,n+1);if(v<i&&(p[v]=a.get(v,v)),n<S&&(p[S-1]=0),x+1<S&&(g[x]=a.get(x,S-1)),g[S-1]=0,l){for(let t=v;t<h;t++){for(let e=0;e<n;e++)f.set(e,t,0);f.set(t,t,1)}for(let t=v-1;t>=0;t--)if(0!==p[t]){for(let e=t+1;e<h;e++){let i=0;for(let r=t;r<n;r++)i+=f.get(r,t)*f.get(r,e);i=-i/f.get(t,t);for(let r=t;r<n;r++)f.set(r,e,f.get(r,e)+i*f.get(r,t))}for(let e=t;e<n;e++)f.set(e,t,-f.get(e,t));f.set(t,t,1+f.get(t,t));for(let e=0;e<t-1;e++)f.set(e,t,0)}else{for(let e=0;e<n;e++)f.set(e,t,0);f.set(t,t,1)}}if(c)for(let t=i-1;t>=0;t--){if(t<x&&0!==g[t])for(let e=t+1;e<i;e++){let n=0;for(let r=t+1;r<i;r++)n+=m.get(r,t)*m.get(r,e);n=-n/m.get(t+1,t);for(let r=t+1;r<i;r++)m.set(r,e,m.get(r,e)+n*m.get(r,t))}for(let e=0;e<i;e++)m.set(e,t,0);m.set(t,t,1)}let k=S-1,C=Number.EPSILON;for(;S>0;){let t,e;for(t=S-2;t>=-1&&-1!==t;t--){const e=Number.MIN_VALUE+C*Math.abs(p[t]+Math.abs(p[t+1]));if(Math.abs(g[t])<=e||Number.isNaN(g[t])){g[t]=0;break}}if(t===S-2)e=4;else{let n;for(n=S-1;n>=t&&n!==t;n--){let e=(n!==S?Math.abs(g[n]):0)+(n!==t+1?Math.abs(g[n-1]):0);if(Math.abs(p[n])<=C*e){p[n]=0;break}}n===t?e=3:n===S-1?e=1:(e=2,t=n)}switch(t++,e){case 1:{let e=g[S-2];g[S-2]=0;for(let n=S-2;n>=t;n--){let r=Jxt(p[n],e),s=p[n]/r,o=e/r;if(p[n]=r,n!==t&&(e=-o*g[n-1],g[n-1]=s*g[n-1]),c)for(let t=0;t<i;t++)r=s*m.get(t,n)+o*m.get(t,S-1),m.set(t,S-1,-o*m.get(t,n)+s*m.get(t,S-1)),m.set(t,n,r)}break}case 2:{let e=g[t-1];g[t-1]=0;for(let i=t;i<S;i++){let r=Jxt(p[i],e),s=p[i]/r,o=e/r;if(p[i]=r,e=-o*g[i],g[i]=s*g[i],l)for(let e=0;e<n;e++)r=s*f.get(e,i)+o*f.get(e,t-1),f.set(e,t-1,-o*f.get(e,i)+s*f.get(e,t-1)),f.set(e,i,r)}break}case 3:{const e=Math.max(Math.abs(p[S-1]),Math.abs(p[S-2]),Math.abs(g[S-2]),Math.abs(p[t]),Math.abs(g[t])),r=p[S-1]/e,s=p[S-2]/e,o=g[S-2]/e,a=p[t]/e,u=g[t]/e,h=((s+r)*(s-r)+o*o)/2,d=r*o*(r*o);let y=0;0===h&&0===d||(y=h<0?0-Math.sqrt(h*h+d):Math.sqrt(h*h+d),y=d/(h+y));let b=(a+r)*(a-r)+y,v=a*u;for(let e=t;e<S-1;e++){let r=Jxt(b,v);0===r&&(r=Number.MIN_VALUE);let s=b/r,o=v/r;if(e!==t&&(g[e-1]=r),b=s*p[e]+o*g[e],g[e]=s*g[e]-o*p[e],v=o*p[e+1],p[e+1]=s*p[e+1],c)for(let t=0;t<i;t++)r=s*m.get(t,e)+o*m.get(t,e+1),m.set(t,e+1,-o*m.get(t,e)+s*m.get(t,e+1)),m.set(t,e,r);if(r=Jxt(b,v),0===r&&(r=Number.MIN_VALUE),s=b/r,o=v/r,p[e]=r,b=s*g[e]+o*p[e+1],p[e+1]=-o*g[e]+s*p[e+1],v=o*g[e+1],g[e+1]=s*g[e+1],l&&e<n-1)for(let t=0;t<n;t++)r=s*f.get(t,e)+o*f.get(t,e+1),f.set(t,e+1,-o*f.get(t,e)+s*f.get(t,e+1)),f.set(t,e,r)}g[S-2]=b;break}case 4:if(p[t]<=0&&(p[t]=p[t]<0?-p[t]:0,c))for(let e=0;e<=k;e++)m.set(e,t,-m.get(e,t));for(;t<k&&!(p[t]>=p[t+1]);){let e=p[t];if(p[t]=p[t+1],p[t+1]=e,c&&t<i-1)for(let n=0;n<i;n++)e=m.get(n,t+1),m.set(n,t+1,m.get(n,t)),m.set(n,t,e);if(l&&t<n-1)for(let i=0;i<n;i++)e=f.get(i,t+1),f.set(i,t+1,f.get(i,t)),f.set(i,t,e);t++}S--}}if(u){let t=m;m=f,f=t}this.m=n,this.n=i,this.s=p,this.U=f,this.V=m}solve(t){let e=t,n=this.threshold,i=this.s.length,r=Xxt.zeros(i,i);for(let t=0;t<i;t++)Math.abs(this.s[t])<=n?r.set(t,t,0):r.set(t,t,1/this.s[t]);let s=this.U,o=this.rightSingularVectors,a=o.mmul(r),l=o.rows,c=s.rows,u=Xxt.zeros(l,c);for(let t=0;t<l;t++)for(let e=0;e<c;e++){let n=0;for(let r=0;r<i;r++)n+=a.get(t,r)*s.get(e,r);u.set(t,e,n)}return u.mmul(e)}solveForDiagonal(t){return this.solve(Xxt.diag(t))}inverse(){let t=this.V,e=this.threshold,n=t.rows,i=t.columns,r=new Xxt(n,this.s.length);for(let s=0;s<n;s++)for(let n=0;n<i;n++)Math.abs(this.s[n])>e&&r.set(s,n,t.get(s,n)/this.s[n]);let s=this.U,o=s.rows,a=s.columns,l=new Xxt(n,o);for(let t=0;t<n;t++)for(let e=0;e<o;e++){let n=0;for(let i=0;i<a;i++)n+=r.get(t,i)*s.get(e,i);l.set(t,e,n)}return l}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,n=this.s;for(let i=0,r=n.length;i<r;i++)n[i]>t&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Xxt.diag(this.s)}}class twt{constructor(t,e={}){const{assumeSymmetric:n=!1}=e;if(!(t=Zxt.checkMatrix(t)).isSquare())throw new Error("Matrix is not a square matrix");if(t.isEmpty())throw new Error("Matrix must be non-empty");let i,r,s=t.columns,o=new Xxt(s,s),a=new Float64Array(s),l=new Float64Array(s),c=t,u=!1;if(u=!!n||t.isSymmetric(),u){for(i=0;i<s;i++)for(r=0;r<s;r++)o.set(i,r,c.get(i,r));!function(t,e,n,i){let r,s,o,a,l,c,u,h;for(l=0;l<t;l++)n[l]=i.get(t-1,l);for(a=t-1;a>0;a--){for(h=0,o=0,c=0;c<a;c++)h+=Math.abs(n[c]);if(0===h)for(e[a]=n[a-1],l=0;l<a;l++)n[l]=i.get(a-1,l),i.set(a,l,0),i.set(l,a,0);else{for(c=0;c<a;c++)n[c]/=h,o+=n[c]*n[c];for(r=n[a-1],s=Math.sqrt(o),r>0&&(s=-s),e[a]=h*s,o-=r*s,n[a-1]=r-s,l=0;l<a;l++)e[l]=0;for(l=0;l<a;l++){for(r=n[l],i.set(l,a,r),s=e[l]+i.get(l,l)*r,c=l+1;c<=a-1;c++)s+=i.get(c,l)*n[c],e[c]+=i.get(c,l)*r;e[l]=s}for(r=0,l=0;l<a;l++)e[l]/=o,r+=e[l]*n[l];for(u=r/(o+o),l=0;l<a;l++)e[l]-=u*n[l];for(l=0;l<a;l++){for(r=n[l],s=e[l],c=l;c<=a-1;c++)i.set(c,l,i.get(c,l)-(r*e[c]+s*n[c]));n[l]=i.get(a-1,l),i.set(a,l,0)}}n[a]=o}for(a=0;a<t-1;a++){if(i.set(t-1,a,i.get(a,a)),i.set(a,a,1),o=n[a+1],0!==o){for(c=0;c<=a;c++)n[c]=i.get(c,a+1)/o;for(l=0;l<=a;l++){for(s=0,c=0;c<=a;c++)s+=i.get(c,a+1)*i.get(c,l);for(c=0;c<=a;c++)i.set(c,l,i.get(c,l)-s*n[c])}}for(c=0;c<=a;c++)i.set(c,a+1,0)}for(l=0;l<t;l++)n[l]=i.get(t-1,l),i.set(t-1,l,0);i.set(t-1,t-1,1),e[0]=0}(s,l,a,o),function(t,e,n,i){let r,s,o,a,l,c,u,h,d,p,f,m,g,y,b,v;for(o=1;o<t;o++)e[o-1]=e[o];e[t-1]=0;let x=0,w=0,S=Number.EPSILON;for(c=0;c<t;c++){for(w=Math.max(w,Math.abs(n[c])+Math.abs(e[c])),u=c;u<t&&!(Math.abs(e[u])<=S*w);)u++;if(u>c)do{for(r=n[c],h=(n[c+1]-r)/(2*e[c]),d=Jxt(h,1),h<0&&(d=-d),n[c]=e[c]/(h+d),n[c+1]=e[c]*(h+d),p=n[c+1],s=r-n[c],o=c+2;o<t;o++)n[o]-=s;for(x+=s,h=n[u],f=1,m=f,g=f,y=e[c+1],b=0,v=0,o=u-1;o>=c;o--)for(g=m,m=f,v=b,r=f*e[o],s=f*h,d=Jxt(h,e[o]),e[o+1]=b*d,b=e[o]/d,f=h/d,h=f*n[o]-b*r,n[o+1]=s+b*(f*r+b*n[o]),l=0;l<t;l++)s=i.get(l,o+1),i.set(l,o+1,b*i.get(l,o)+f*s),i.set(l,o,f*i.get(l,o)-b*s);h=-b*v*g*y*e[c]/p,e[c]=b*h,n[c]=f*h}while(Math.abs(e[c])>S*w);n[c]=n[c]+x,e[c]=0}for(o=0;o<t-1;o++){for(l=o,h=n[o],a=o+1;a<t;a++)n[a]<h&&(l=a,h=n[a]);if(l!==o)for(n[l]=n[o],n[o]=h,a=0;a<t;a++)h=i.get(a,o),i.set(a,o,i.get(a,l)),i.set(a,l,h)}}(s,l,a,o)}else{let t=new Xxt(s,s),e=new Float64Array(s);for(r=0;r<s;r++)for(i=0;i<s;i++)t.set(i,r,c.get(i,r));!function(t,e,n,i){let r,s,o,a,l,c,u,h=0,d=t-1;for(c=h+1;c<=d-1;c++){for(u=0,a=c;a<=d;a++)u+=Math.abs(e.get(a,c-1));if(0!==u){for(o=0,a=d;a>=c;a--)n[a]=e.get(a,c-1)/u,o+=n[a]*n[a];for(s=Math.sqrt(o),n[c]>0&&(s=-s),o-=n[c]*s,n[c]=n[c]-s,l=c;l<t;l++){for(r=0,a=d;a>=c;a--)r+=n[a]*e.get(a,l);for(r/=o,a=c;a<=d;a++)e.set(a,l,e.get(a,l)-r*n[a])}for(a=0;a<=d;a++){for(r=0,l=d;l>=c;l--)r+=n[l]*e.get(a,l);for(r/=o,l=c;l<=d;l++)e.set(a,l,e.get(a,l)-r*n[l])}n[c]=u*n[c],e.set(c,c-1,u*s)}}for(a=0;a<t;a++)for(l=0;l<t;l++)i.set(a,l,a===l?1:0);for(c=d-1;c>=h+1;c--)if(0!==e.get(c,c-1)){for(a=c+1;a<=d;a++)n[a]=e.get(a,c-1);for(l=c;l<=d;l++){for(s=0,a=c;a<=d;a++)s+=n[a]*i.get(a,l);for(s=s/n[c]/e.get(c,c-1),a=c;a<=d;a++)i.set(a,l,i.get(a,l)+s*n[a])}}}(s,t,e,o),function(t,e,n,i,r){let s,o,a,l,c,u,h,d,p,f,m,g,y,b,v,x=t-1,w=0,S=t-1,k=Number.EPSILON,C=0,T=0,_=0,E=0,M=0,$=0,I=0,A=0;for(s=0;s<t;s++)for((s<w||s>S)&&(n[s]=r.get(s,s),e[s]=0),o=Math.max(s-1,0);o<t;o++)T+=Math.abs(r.get(s,o));for(;x>=w;){for(l=x;l>w&&($=Math.abs(r.get(l-1,l-1))+Math.abs(r.get(l,l)),0===$&&($=T),!(Math.abs(r.get(l,l-1))<k*$));)l--;if(l===x)r.set(x,x,r.get(x,x)+C),n[x]=r.get(x,x),e[x]=0,x--,A=0;else if(l===x-1){if(h=r.get(x,x-1)*r.get(x-1,x),_=(r.get(x-1,x-1)-r.get(x,x))/2,E=_*_+h,I=Math.sqrt(Math.abs(E)),r.set(x,x,r.get(x,x)+C),r.set(x-1,x-1,r.get(x-1,x-1)+C),d=r.get(x,x),E>=0){for(I=_>=0?_+I:_-I,n[x-1]=d+I,n[x]=n[x-1],0!==I&&(n[x]=d-h/I),e[x-1]=0,e[x]=0,d=r.get(x,x-1),$=Math.abs(d)+Math.abs(I),_=d/$,E=I/$,M=Math.sqrt(_*_+E*E),_/=M,E/=M,o=x-1;o<t;o++)I=r.get(x-1,o),r.set(x-1,o,E*I+_*r.get(x,o)),r.set(x,o,E*r.get(x,o)-_*I);for(s=0;s<=x;s++)I=r.get(s,x-1),r.set(s,x-1,E*I+_*r.get(s,x)),r.set(s,x,E*r.get(s,x)-_*I);for(s=w;s<=S;s++)I=i.get(s,x-1),i.set(s,x-1,E*I+_*i.get(s,x)),i.set(s,x,E*i.get(s,x)-_*I)}else n[x-1]=d+_,n[x]=d+_,e[x-1]=I,e[x]=-I;x-=2,A=0}else{if(d=r.get(x,x),p=0,h=0,l<x&&(p=r.get(x-1,x-1),h=r.get(x,x-1)*r.get(x-1,x)),10===A){for(C+=d,s=w;s<=x;s++)r.set(s,s,r.get(s,s)-d);$=Math.abs(r.get(x,x-1))+Math.abs(r.get(x-1,x-2)),d=p=.75*$,h=-.4375*$*$}if(30===A&&($=(p-d)/2,$=$*$+h,$>0)){for($=Math.sqrt($),p<d&&($=-$),$=d-h/((p-d)/2+$),s=w;s<=x;s++)r.set(s,s,r.get(s,s)-$);C+=$,d=p=h=.964}for(A+=1,c=x-2;c>=l&&(I=r.get(c,c),M=d-I,$=p-I,_=(M*$-h)/r.get(c+1,c)+r.get(c,c+1),E=r.get(c+1,c+1)-I-M-$,M=r.get(c+2,c+1),$=Math.abs(_)+Math.abs(E)+Math.abs(M),_/=$,E/=$,M/=$,c!==l)&&!(Math.abs(r.get(c,c-1))*(Math.abs(E)+Math.abs(M))<k*(Math.abs(_)*(Math.abs(r.get(c-1,c-1))+Math.abs(I)+Math.abs(r.get(c+1,c+1)))));)c--;for(s=c+2;s<=x;s++)r.set(s,s-2,0),s>c+2&&r.set(s,s-3,0);for(a=c;a<=x-1&&(b=a!==x-1,a!==c&&(_=r.get(a,a-1),E=r.get(a+1,a-1),M=b?r.get(a+2,a-1):0,d=Math.abs(_)+Math.abs(E)+Math.abs(M),0!==d&&(_/=d,E/=d,M/=d)),0!==d);a++)if($=Math.sqrt(_*_+E*E+M*M),_<0&&($=-$),0!==$){for(a!==c?r.set(a,a-1,-$*d):l!==c&&r.set(a,a-1,-r.get(a,a-1)),_+=$,d=_/$,p=E/$,I=M/$,E/=_,M/=_,o=a;o<t;o++)_=r.get(a,o)+E*r.get(a+1,o),b&&(_+=M*r.get(a+2,o),r.set(a+2,o,r.get(a+2,o)-_*I)),r.set(a,o,r.get(a,o)-_*d),r.set(a+1,o,r.get(a+1,o)-_*p);for(s=0;s<=Math.min(x,a+3);s++)_=d*r.get(s,a)+p*r.get(s,a+1),b&&(_+=I*r.get(s,a+2),r.set(s,a+2,r.get(s,a+2)-_*M)),r.set(s,a,r.get(s,a)-_),r.set(s,a+1,r.get(s,a+1)-_*E);for(s=w;s<=S;s++)_=d*i.get(s,a)+p*i.get(s,a+1),b&&(_+=I*i.get(s,a+2),i.set(s,a+2,i.get(s,a+2)-_*M)),i.set(s,a,i.get(s,a)-_),i.set(s,a+1,i.get(s,a+1)-_*E)}}}if(0===T)return;for(x=t-1;x>=0;x--)if(_=n[x],E=e[x],0===E)for(l=x,r.set(x,x,1),s=x-1;s>=0;s--){for(h=r.get(s,s)-_,M=0,o=l;o<=x;o++)M+=r.get(s,o)*r.get(o,x);if(e[s]<0)I=h,$=M;else if(l=s,0===e[s]?r.set(s,x,0!==h?-M/h:-M/(k*T)):(d=r.get(s,s+1),p=r.get(s+1,s),E=(n[s]-_)*(n[s]-_)+e[s]*e[s],u=(d*$-I*M)/E,r.set(s,x,u),r.set(s+1,x,Math.abs(d)>Math.abs(I)?(-M-h*u)/d:(-$-p*u)/I)),u=Math.abs(r.get(s,x)),k*u*u>1)for(o=s;o<=x;o++)r.set(o,x,r.get(o,x)/u)}else if(E<0)for(l=x-1,Math.abs(r.get(x,x-1))>Math.abs(r.get(x-1,x))?(r.set(x-1,x-1,E/r.get(x,x-1)),r.set(x-1,x,-(r.get(x,x)-_)/r.get(x,x-1))):(v=ewt(0,-r.get(x-1,x),r.get(x-1,x-1)-_,E),r.set(x-1,x-1,v[0]),r.set(x-1,x,v[1])),r.set(x,x-1,0),r.set(x,x,1),s=x-2;s>=0;s--){for(f=0,m=0,o=l;o<=x;o++)f+=r.get(s,o)*r.get(o,x-1),m+=r.get(s,o)*r.get(o,x);if(h=r.get(s,s)-_,e[s]<0)I=h,M=f,$=m;else if(l=s,0===e[s]?(v=ewt(-f,-m,h,E),r.set(s,x-1,v[0]),r.set(s,x,v[1])):(d=r.get(s,s+1),p=r.get(s+1,s),g=(n[s]-_)*(n[s]-_)+e[s]*e[s]-E*E,y=2*(n[s]-_)*E,0===g&&0===y&&(g=k*T*(Math.abs(h)+Math.abs(E)+Math.abs(d)+Math.abs(p)+Math.abs(I))),v=ewt(d*M-I*f+E*m,d*$-I*m-E*f,g,y),r.set(s,x-1,v[0]),r.set(s,x,v[1]),Math.abs(d)>Math.abs(I)+Math.abs(E)?(r.set(s+1,x-1,(-f-h*r.get(s,x-1)+E*r.get(s,x))/d),r.set(s+1,x,(-m-h*r.get(s,x)-E*r.get(s,x-1))/d)):(v=ewt(-M-p*r.get(s,x-1),-$-p*r.get(s,x),I,E),r.set(s+1,x-1,v[0]),r.set(s+1,x,v[1]))),u=Math.max(Math.abs(r.get(s,x-1)),Math.abs(r.get(s,x))),k*u*u>1)for(o=s;o<=x;o++)r.set(o,x-1,r.get(o,x-1)/u),r.set(o,x,r.get(o,x)/u)}for(s=0;s<t;s++)if(s<w||s>S)for(o=s;o<t;o++)i.set(s,o,r.get(s,o));for(o=t-1;o>=w;o--)for(s=w;s<=S;s++){for(I=0,a=w;a<=Math.min(o,S);a++)I+=i.get(s,a)*r.get(a,o);i.set(s,o,I)}}(s,l,a,o,t)}this.n=s,this.e=l,this.d=a,this.V=o}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let t,e,n=this.n,i=this.e,r=this.d,s=new Xxt(n,n);for(t=0;t<n;t++){for(e=0;e<n;e++)s.set(t,e,0);s.set(t,t,r[t]),i[t]>0?s.set(t,t+1,i[t]):i[t]<0&&s.set(t,t-1,i[t])}return s}}function ewt(t,e,n,i){let r,s;return Math.abs(n)>Math.abs(i)?(r=i/n,s=n+r*i,[(t+r*e)/s,(e-r*t)/s]):(r=n/i,s=i+r*n,[(r*t+e)/s,(r*e-t)/s])}class nwt{constructor(t,e={}){t=Zxt.checkMatrix(t);let{Y:n}=e;const{scaleScores:i=!1,maxIterations:r=1e3,terminationCriteria:s=1e-10}=e;let o;if(n){if(n=bbt(n)&&"number"==typeof n[0]?Xxt.columnVector(n):Zxt.checkMatrix(n),n.rows!==t.rows)throw new Error("Y should have the same number of rows as X");o=n.getColumnVector(0)}else o=t.getColumnVector(0);let a,l,c,u,h=1;for(let e=0;e<r&&h>s;e++)c=t.transpose().mmul(o).div(o.transpose().mmul(o).get(0,0)),c=c.div(c.norm()),a=t.mmul(c).div(c.transpose().mmul(c).get(0,0)),e>0&&(h=a.clone().sub(u).pow(2).sum()),u=a.clone(),n?(l=n.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0)),l=l.div(l.norm()),o=n.mmul(l).div(l.transpose().mmul(l).get(0,0))):o=a;if(n){let e=t.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0));e=e.div(e.norm());let i=t.clone().sub(a.clone().mmul(e.transpose())),r=o.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0)),s=n.clone().sub(a.clone().mulS(r.get(0,0)).mmul(l.transpose()));this.t=a,this.p=e.transpose(),this.w=c.transpose(),this.q=l,this.u=o,this.s=a.transpose().mmul(a),this.xResidual=i,this.yResidual=s,this.betas=r}else this.w=c.transpose(),this.s=a.transpose().mmul(a).sqrt(),this.t=i?a.clone().div(this.s.get(0,0)):a,this.xResidual=t.sub(a.mmul(c.transpose()))}}let iwt=class t{constructor(t,e={},n){if(this.U=null,this.S=null,n)return this.center=n.center,this.scale=n.scale,this.means=n.means,this.stdevs=n.stdevs,this.U=Xxt.checkMatrix(n.U),this.S=n.S,this.R=n.R,void(this.excludedFeatures=n.excludedFeatures||[]);let i;i=(Array.isArray(t),new Xxt(t));const{isCovarianceMatrix:r=!1,method:s="SVD",nCompNIPALS:o=2,center:a=!0,scale:l=!1,ignoreZeroVariance:c=!1}=e;if(this.center=a,this.scale=l,this.means=null,this.stdevs=null,this.excludedFeatures=[],r)this._computeFromCovarianceMatrix(i);else switch(this._adjust(i,c),s){case"covarianceMatrix":{const t=new Yxt(i).mmul(i).div(i.rows-1);this._computeFromCovarianceMatrix(t);break}case"NIPALS":this._computeWithNIPALS(i,o);break;case"SVD":{const t=new Qxt(i,{computeLeftSingularVectors:!1,computeRightSingularVectors:!0,autoTranspose:!0});this.U=t.rightSingularVectors;const e=t.diagonal,n=[];for(const t of e)n.push(t*t/(i.rows-1));this.S=n;break}default:throw new Error(`unknown method: ${s}`)}}static load(e){if("string"!=typeof e.name)throw new TypeError("model must have a name property");if("PCA"!==e.name)throw new RangeError(`invalid model: ${e.name}`);return new t(void 0,void 0,e)}predict(t,e={}){const{nComponents:n=this.U.columns}=e;let i;if(i=(Array.isArray(t),new Xxt(t)),this.center&&(i.subRowVector(this.means),this.scale)){for(let t of this.excludedFeatures)i.removeColumn(t);i.divRowVector(this.stdevs)}let r=i.mmul(this.U);return r.subMatrix(0,r.rows-1,0,n-1)}invert(t){let e=(t=Xxt.checkMatrix(t)).mmul(this.U.transpose());return this.center&&(this.scale&&e.mulRowVector(this.stdevs),e.addRowVector(this.means)),e}getExplainedVariance(){let t=0;if(this.S)for(const e of this.S)t+=e;return this.S?this.S.map((e=>e/t)):[]}getCumulativeVariance(){let t=this.getExplainedVariance();for(let e=1;e<t.length;e++)t[e]+=t[e-1];return t}getEigenvectors(){return this.U}getEigenvalues(){return this.S}getStandardDeviations(){return this.S.map((t=>Math.sqrt(t)))}getLoadings(){return this.U.transpose()}toJSON(){return{name:"PCA",center:this.center,scale:this.scale,means:this.means,stdevs:this.stdevs,U:this.U,S:this.S,excludedFeatures:this.excludedFeatures}}_adjust(t,e){if(this.center){const n=t.mean("column"),i=this.scale?t.standardDeviation("column",{mean:n}):null;if(this.means=n,t.subRowVector(n),this.scale){for(let n=0;n<i.length;n++)if(0===i[n]){if(!e)throw new RangeError(`Cannot scale the dataset (standard deviation is zero at index ${n}`);t.removeColumn(n),i.splice(n,1),this.excludedFeatures.push(n),n--}this.stdevs=i,t.divRowVector(i)}}}_computeFromCovarianceMatrix(t){const e=new twt(t,{assumeSymmetric:!0});this.U=e.eigenvectorMatrix,this.U.flipRows(),this.S=e.realEigenvalues,this.S.reverse()}_computeWithNIPALS(t,e){this.U=new Xxt(e,t.columns),this.S=[];let n=t;for(let t=0;t<e;t++){let e=new nwt(n);this.U.setRow(t,e.w.transpose()),this.S.push(Math.pow(e.s.get(0,0),2)),n=e.xResidual}this.U=this.U.transpose()}};class rwt extends i3{constructor(){super(...arguments),this.title="PCA",this.serviceName="pca",this.parameters={}}async train(t){this.$training.set({status:"start",epochs:-1});const e=n3(t)?t.items():t,n=(await e.toArray()).reduce(((t,{x:e})=>t.concat([e])),[]);this.model=new iwt(n),this.$training.set({status:"success",data:{explainedVariance:this.model.getExplainedVariance()}})}async predict(t){return this.model?this.model.predict([t]).to2DArray()[0].slice(0,2):null}clear(){this.model=null}async save(t,e,n,i=null){const r=await this.write(n);return r.name=e,this.saveToDatastore(t,r,i)}async load(t,e){const n=await this.loadFromDatastore(t,e);return await this.read(n),n}async download(t){const e=await this.write(t);s2(JSON.stringify(e),`${e.name}.json`,"text/plain")}async upload(...t){const e=t.filter((t=>t.name.includes(".json"))),n=await new Promise(((t,n)=>{const i=new FileReader;i.onload=()=>{const e=JSON.parse(i.result);t(e)},i.onerror=n,i.readAsText(e[0])}));return await this.read(n),n}async write(t={}){var e;return{name:a2(this.title),files:[],format:"ml-pca",metadata:{PCAModel:null===(e=this.model)||void 0===e?void 0:e.toJSON(),...t}}}async read(t){const e=t.metadata.PCAModel;e&&(this.model=iwt.load(e),this.$training.set({status:"loaded"}))}}function swt(...t){return new rwt(...t)}var owt={};(function(){var t;function e(t){var e=0;return function(){return e<t.length?{done:!1,value:t[e++]}:{done:!0}}}var n="function"==typeof Object.defineProperties?Object.defineProperty:function(t,e,n){return t==Array.prototype||t==Object.prototype||(t[e]=n.value),t};var i=function(t){t=["object"==typeof globalThis&&globalThis,t,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof Ti&&Ti];for(var e=0;e<t.length;++e){var n=t[e];if(n&&n.Math==Math)return n}throw Error("Cannot find global object")}(this);function r(t,e){if(e)t:{var r=i;t=t.split(".");for(var s=0;s<t.length-1;s++){var o=t[s];if(!(o in r))break t;r=r[o]}(e=e(s=r[t=t[t.length-1]]))!=s&&null!=e&&n(r,t,{configurable:!0,writable:!0,value:e})}}function s(t){return(t={next:t})[Symbol.iterator]=function(){return this},t}function o(t){var n="undefined"!=typeof Symbol&&Symbol.iterator&&t[Symbol.iterator];return n?n.call(t):{next:e(t)}}function a(t){if(!(t instanceof Array)){t=o(t);for(var e,n=[];!(e=t.next()).done;)n.push(e.value);t=n}return t}r("Symbol",(function(t){function e(t,e){this.h=t,n(this,"description",{configurable:!0,writable:!0,value:e})}if(t)return t;e.prototype.toString=function(){return this.h};var i="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",r=0;return function t(n){if(this instanceof t)throw new TypeError("Symbol is not a constructor");return new e(i+(n||"")+"_"+r++,n)}})),r("Symbol.iterator",(function(t){if(t)return t;t=Symbol("Symbol.iterator");for(var r="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),o=0;o<r.length;o++){var a=i[r[o]];"function"==typeof a&&"function"!=typeof a.prototype[t]&&n(a.prototype,t,{configurable:!0,writable:!0,value:function(){return s(e(this))}})}return t}));var l="function"==typeof Object.assign?Object.assign:function(t,e){for(var n=1;n<arguments.length;n++){var i=arguments[n];if(i)for(var r in i)Object.prototype.hasOwnProperty.call(i,r)&&(t[r]=i[r])}return t};r("Object.assign",(function(t){return t||l}));var c,u="function"==typeof Object.create?Object.create:function(t){function e(){}return e.prototype=t,new e};if("function"==typeof Object.setPrototypeOf)c=Object.setPrototypeOf;else{var h;t:{var d={};try{d.__proto__={a:!0},h=d.a;break t}catch(t){}h=!1}c=h?function(t,e){if(t.__proto__=e,t.__proto__!==e)throw new TypeError(t+" is not extensible");return t}:null}var p=c;function f(t,e){if(t.prototype=u(e.prototype),t.prototype.constructor=t,p)p(t,e);else for(var n in e)if("prototype"!=n)if(Object.defineProperties){var i=Object.getOwnPropertyDescriptor(e,n);i&&Object.defineProperty(t,n,i)}else t[n]=e[n];t.za=e.prototype}function m(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function g(t){if(t.m)throw new TypeError("Generator is already running");t.m=!0}function y(t,e){t.l={ma:e,na:!0},t.h=t.s||t.v}function b(t,e,n){return t.h=n,{value:e}}function v(t){this.h=new m,this.i=t}function x(t,e,n,i){try{var r=e.call(t.h.j,n);if(!(r instanceof Object))throw new TypeError("Iterator result "+r+" is not an object");if(!r.done)return t.h.m=!1,r;var s=r.value}catch(e){return t.h.j=null,y(t.h,e),w(t)}return t.h.j=null,i.call(t.h,s),w(t)}function w(t){for(;t.h.h;)try{var e=t.i(t.h);if(e)return t.h.m=!1,{value:e.value,done:!1}}catch(e){t.h.i=void 0,y(t.h,e)}if(t.h.m=!1,t.h.l){if(e=t.h.l,t.h.l=null,e.na)throw e.ma;return{value:e.return,done:!0}}return{value:void 0,done:!0}}function S(t){this.next=function(e){return g(t.h),t.h.j?e=x(t,t.h.j.next,e,t.h.u):(t.h.u(e),e=w(t)),e},this.throw=function(e){return g(t.h),t.h.j?e=x(t,t.h.j.throw,e,t.h.u):(y(t.h,e),e=w(t)),e},this.return=function(e){return function(t,e){g(t.h);var n=t.h.j;return n?x(t,"return"in n?n.return:function(t){return{value:t,done:!0}},e,t.h.return):(t.h.return(e),w(t))}(t,e)},this[Symbol.iterator]=function(){return this}}function k(t){return function(t){function e(e){return t.next(e)}function n(e){return t.throw(e)}return new Promise((function(i,r){!function t(s){s.done?i(s.value):Promise.resolve(s.value).then(e,n).then(t,r)}(t.next())}))}(new S(new v(t)))}function C(t){return t||Array.prototype.fill}m.prototype.u=function(t){this.i=t},m.prototype.return=function(t){this.l={return:t},this.h=this.v},r("Promise",(function(t){function e(t){this.i=0,this.j=void 0,this.h=[],this.u=!1;var e=this.l();try{t(e.resolve,e.reject)}catch(t){e.reject(t)}}function n(){this.h=null}function r(t){return t instanceof e?t:new e((function(e){e(t)}))}if(t)return t;n.prototype.i=function(t){if(null==this.h){this.h=[];var e=this;this.j((function(){e.m()}))}this.h.push(t)};var s=i.setTimeout;n.prototype.j=function(t){s(t,0)},n.prototype.m=function(){for(;this.h&&this.h.length;){var t=this.h;this.h=[];for(var e=0;e<t.length;++e){var n=t[e];t[e]=null;try{n()}catch(t){this.l(t)}}}this.h=null},n.prototype.l=function(t){this.j((function(){throw t}))},e.prototype.l=function(){function t(t){return function(i){n||(n=!0,t.call(e,i))}}var e=this,n=!1;return{resolve:t(this.I),reject:t(this.m)}},e.prototype.I=function(t){if(t===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(t instanceof e)this.L(t);else{t:switch(typeof t){case"object":var n=null!=t;break t;case"function":n=!0;break t;default:n=!1}n?this.F(t):this.s(t)}},e.prototype.F=function(t){var e=void 0;try{e=t.then}catch(t){return void this.m(t)}"function"==typeof e?this.M(e,t):this.s(t)},e.prototype.m=function(t){this.v(2,t)},e.prototype.s=function(t){this.v(1,t)},e.prototype.v=function(t,e){if(0!=this.i)throw Error("Cannot settle("+t+", "+e+"): Promise already settled in state"+this.i);this.i=t,this.j=e,2===this.i&&this.K(),this.H()},e.prototype.K=function(){var t=this;s((function(){if(t.D()){var e=i.console;void 0!==e&&e.error(t.j)}}),1)},e.prototype.D=function(){if(this.u)return!1;var t=i.CustomEvent,e=i.Event,n=i.dispatchEvent;return void 0===n||("function"==typeof t?t=new t("unhandledrejection",{cancelable:!0}):"function"==typeof e?t=new e("unhandledrejection",{cancelable:!0}):(t=i.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,t),t.promise=this,t.reason=this.j,n(t))},e.prototype.H=function(){if(null!=this.h){for(var t=0;t<this.h.length;++t)a.i(this.h[t]);this.h=null}};var a=new n;return e.prototype.L=function(t){var e=this.l();t.T(e.resolve,e.reject)},e.prototype.M=function(t,e){var n=this.l();try{t.call(e,n.resolve,n.reject)}catch(t){n.reject(t)}},e.prototype.then=function(t,n){function i(t,e){return"function"==typeof t?function(e){try{r(t(e))}catch(t){s(t)}}:e}var r,s,o=new e((function(t,e){r=t,s=e}));return this.T(i(t,r),i(n,s)),o},e.prototype.catch=function(t){return this.then(void 0,t)},e.prototype.T=function(t,e){function n(){switch(i.i){case 1:t(i.j);break;case 2:e(i.j);break;default:throw Error("Unexpected state: "+i.i)}}var i=this;null==this.h?a.i(n):this.h.push(n),this.u=!0},e.resolve=r,e.reject=function(t){return new e((function(e,n){n(t)}))},e.race=function(t){return new e((function(e,n){for(var i=o(t),s=i.next();!s.done;s=i.next())r(s.value).T(e,n)}))},e.all=function(t){var n=o(t),i=n.next();return i.done?r([]):new e((function(t,e){function s(e){return function(n){o[e]=n,0==--a&&t(o)}}var o=[],a=0;do{o.push(void 0),a++,r(i.value).T(s(o.length-1),e),i=n.next()}while(!i.done)}))},e})),r("Array.prototype.keys",(function(t){return t||function(){return function(t,e){t instanceof String&&(t+="");var n=0,i=!1,r={next:function(){if(!i&&n<t.length){var r=n++;return{value:e(r,t[r]),done:!1}}return i=!0,{done:!0,value:void 0}}};return r[Symbol.iterator]=function(){return r},r}(this,(function(t){return t}))}})),r("Array.prototype.fill",(function(t){return t||function(t,e,n){var i=this.length||0;for(0>e&&(e=Math.max(0,i+e)),(null==n||n>i)&&(n=i),0>(n=Number(n))&&(n=Math.max(0,i+n)),e=Number(e||0);e<n;e++)this[e]=t;return this}})),r("Int8Array.prototype.fill",C),r("Uint8Array.prototype.fill",C),r("Uint8ClampedArray.prototype.fill",C),r("Int16Array.prototype.fill",C),r("Uint16Array.prototype.fill",C),r("Int32Array.prototype.fill",C),r("Uint32Array.prototype.fill",C),r("Float32Array.prototype.fill",C),r("Float64Array.prototype.fill",C),r("Object.is",(function(t){return t||function(t,e){return t===e?0!==t||1/t==1/e:t!=t&&e!=e}})),r("Array.prototype.includes",(function(t){return t||function(t,e){var n=this;n instanceof String&&(n=String(n));var i=n.length;for(0>(e=e||0)&&(e=Math.max(e+i,0));e<i;e++){var r=n[e];if(r===t||Object.is(r,t))return!0}return!1}})),r("String.prototype.includes",(function(t){return t||function(t,e){if(null==this)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(t instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return-1!==this.indexOf(t,e||0)}}));var T=this||self;function _(t,e){t=t.split(".");var n,i=T;t[0]in i||void 0===i.execScript||i.execScript("var "+t[0]);for(;t.length&&(n=t.shift());)t.length||void 0===e?i=i[n]&&i[n]!==Object.prototype[n]?i[n]:i[n]={}:i[n]=e}function E(t){var e;return(e=T.navigator)&&(e=e.userAgent)||(e=""),-1!=e.indexOf(t)}var M=Array.prototype.map?function(t,e){return Array.prototype.map.call(t,e,void 0)}:function(t,e){for(var n=t.length,i=Array(n),r="string"==typeof t?t.split(""):t,s=0;s<n;s++)s in r&&(i[s]=e.call(void 0,r[s],s,t));return i},$={},I=null;function A(t){var e=t.length,n=3*e/4;n%3?n=Math.floor(n):-1!="=.".indexOf(t[e-1])&&(n=-1!="=.".indexOf(t[e-2])?n-2:n-1);var i=new Uint8Array(n),r=0;return function(t,e){function n(e){for(;i<t.length;){var n=t.charAt(i++),r=I[n];if(null!=r)return r;if(!/^[\s\xa0]*$/.test(n))throw Error("Unknown base64 encoding at char: "+n)}return e}N();for(var i=0;;){var r=n(-1),s=n(0),o=n(64),a=n(64);if(64===a&&-1===r)break;e(r<<2|s>>4),64!=o&&(e(s<<4&240|o>>2),64!=a&&e(o<<6&192|a))}}(t,(function(t){i[r++]=t})),r!==n?i.subarray(0,r):i}function N(){if(!I){I={};for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),e=["+/=","+/","-_=","-_.","-_"],n=0;5>n;n++){var i=t.concat(e[n].split(""));$[n]=i;for(var r=0;r<i.length;r++){var s=i[r];void 0===I[s]&&(I[s]=r)}}}}var R="undefined"!=typeof Uint8Array,P=!(E("Trident")||E("MSIE"))&&"function"==typeof T.btoa;function O(t){if(!P){var e;void 0===e&&(e=0),N(),e=$[e];for(var n=Array(Math.floor(t.length/3)),i=e[64]||"",r=0,s=0;r<t.length-2;r+=3){var o=t[r],a=t[r+1],l=t[r+2],c=e[o>>2];o=e[(3&o)<<4|a>>4],a=e[(15&a)<<2|l>>6],l=e[63&l],n[s++]=c+o+a+l}switch(c=0,l=i,t.length-r){case 2:l=e[(15&(c=t[r+1]))<<2]||i;case 1:t=t[r],n[s]=e[t>>2]+e[(3&t)<<4|c>>4]+l+i}return n.join("")}for(e="";10240<t.length;)e+=String.fromCharCode.apply(null,t.subarray(0,10240)),t=t.subarray(10240);return e+=String.fromCharCode.apply(null,t),btoa(e)}var L,D=RegExp("[-_.]","g");function F(t){switch(t){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function z(t){if(!P)return A(t);D.test(t)&&(t=t.replace(D,F)),t=atob(t);for(var e=new Uint8Array(t.length),n=0;n<t.length;n++)e[n]=t.charCodeAt(n);return e}function B(){return L||(L=new Uint8Array(0))}var U={},V="function"==typeof Uint8Array.prototype.slice,W=0,H=0;function j(t){var e=0>t,n=(t=Math.abs(t))>>>0;t=Math.floor((t-n)/4294967296),e&&(e=(n=o(X(n,t))).next().value,t=n.next().value,n=e),W=n>>>0,H=t>>>0}var G,q="function"==typeof BigInt;function X(t,e){return e=~e,t?t=1+~t:e+=1,[t,e]}function K(t,e){this.i=t>>>0,this.h=e>>>0}function Y(t){if(!t)return G||(G=new K(0,0));if(!/^-?\d+$/.test(t))return null;if(16>t.length)j(Number(t));else if(q)t=BigInt(t),W=Number(t&BigInt(4294967295))>>>0,H=Number(t>>BigInt(32)&BigInt(4294967295));else{var e=+("-"===t[0]);H=W=0;for(var n=t.length,i=e,r=(n-e)%6+e;r<=n;i=r,r+=6)i=Number(t.slice(i,r)),H*=1e6,4294967296<=(W=1e6*W+i)&&(H+=W/4294967296|0,W%=4294967296);e&&(t=(e=o(X(W,H))).next().value,e=e.next().value,W=t,H=e)}return new K(W,H)}function Z(t,e){return Error("Invalid wire type: "+t+" (at position "+e+")")}function J(){return Error("Failed to read varint, encoding is invalid.")}function Q(t,e){return Error("Tried to read past the end of the data "+e+" > "+t)}function tt(){throw Error("Invalid UTF8")}function et(t,e){return e=String.fromCharCode.apply(null,e),null==t?e:t+e}var nt,it,rt,st=void 0,ot="undefined"!=typeof TextDecoder,at="undefined"!=typeof TextEncoder;function lt(t){if(t!==U)throw Error("illegal external caller")}function ct(t,e){if(lt(e),this.V=t,null!=t&&0===t.length)throw Error("ByteString should be constructed with non-empty values")}function ut(){return rt||(rt=new ct(null,U))}function ht(t){lt(U);var e=t.V;return null==(e=null==e||R&&null!=e&&e instanceof Uint8Array?e:"string"==typeof e?z(e):null)?e:t.V=e}function dt(t,e){this.i=null,this.m=!1,this.h=this.j=this.l=0,pt(this,t,e)}function pt(t,e,n){n=void 0===n?{}:n,t.S=void 0!==n.S&&n.S,e&&(e=function(t){if("string"==typeof t)return{buffer:z(t),C:!1};if(Array.isArray(t))return{buffer:new Uint8Array(t),C:!1};if(t.constructor===Uint8Array)return{buffer:t,C:!1};if(t.constructor===ArrayBuffer)return{buffer:new Uint8Array(t),C:!1};if(t.constructor===ct)return{buffer:ht(t)||B(),C:!0};if(t instanceof Uint8Array)return{buffer:new Uint8Array(t.buffer,t.byteOffset,t.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}(e),t.i=e.buffer,t.m=e.C,t.l=0,t.j=t.i.length,t.h=t.l)}function ft(t,e){if(t.h=e,e>t.j)throw Q(t.j,e)}function mt(t){var e=t.i,n=t.h,i=e[n++],r=127&i;if(128&i&&(r|=(127&(i=e[n++]))<<7,128&i&&(r|=(127&(i=e[n++]))<<14,128&i&&(r|=(127&(i=e[n++]))<<21,128&i&&(r|=(i=e[n++])<<28,128&i&&128&e[n++]&&128&e[n++]&&128&e[n++]&&128&e[n++]&&128&e[n++])))))throw J();return ft(t,n),r}function gt(t,e){if(0>e)throw Error("Tried to read a negative byte length: "+e);var n=t.h,i=n+e;if(i>t.j)throw Q(e,t.j-n);return t.h=i,n}dt.prototype.reset=function(){this.h=this.l};var yt=[];function bt(){this.h=[]}function vt(t,e,n){for(;0<n||127<e;)t.h.push(127&e|128),e=(e>>>7|n<<25)>>>0,n>>>=7;t.h.push(e)}function xt(t,e){for(;127<e;)t.h.push(127&e|128),e>>>=7;t.h.push(e)}function wt(t,e){if(yt.length){var n=yt.pop();pt(n,t,e),t=n}else t=new dt(t,e);this.h=t,this.j=this.h.h,this.i=this.l=-1,this.setOptions(e)}function St(t){var e=t.h;if(e.h==e.j)return!1;t.j=t.h.h;var n=mt(t.h)>>>0;if(e=n>>>3,!(0<=(n&=7)&&5>=n))throw Z(n,t.j);if(1>e)throw Error("Invalid field number: "+e+" (at position "+t.j+")");return t.l=e,t.i=n,!0}function kt(t){switch(t.i){case 0:if(0!=t.i)kt(t);else t:{for(var e=(t=t.h).h,n=e+10,i=t.i;e<n;)if(0==(128&i[e++])){ft(t,e);break t}throw J()}break;case 1:ft(t=t.h,t.h+8);break;case 2:2!=t.i?kt(t):(e=mt(t.h)>>>0,ft(t=t.h,t.h+e));break;case 5:ft(t=t.h,t.h+4);break;case 3:for(e=t.l;;){if(!St(t))throw Error("Unmatched start-group tag: stream EOF");if(4==t.i){if(t.l!=e)throw Error("Unmatched end-group tag");break}kt(t)}break;default:throw Z(t.i,t.j)}}bt.prototype.length=function(){return this.h.length},bt.prototype.end=function(){var t=this.h;return this.h=[],t},wt.prototype.setOptions=function(t){t=void 0===t?{}:t,this.ca=void 0!==t.ca&&t.ca},wt.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};var Ct=[];function Tt(){this.j=[],this.i=0,this.h=new bt}function _t(t,e){0!==e.length&&(t.j.push(e),t.i+=e.length)}var Et="function"==typeof Symbol&&"symbol"==typeof Symbol()?Symbol():void 0;function Mt(t,e){return Et?t[Et]|=e:void 0!==t.A?t.A|=e:(Object.defineProperties(t,{A:{value:e,configurable:!0,writable:!0,enumerable:!1}}),e)}function $t(t,e){Et?t[Et]&&(t[Et]&=~e):void 0!==t.A&&(t.A&=~e)}function It(t){var e;return null==(e=Et?t[Et]:t.A)?0:e}function At(t,e){Et?t[Et]=e:void 0!==t.A?t.A=e:Object.defineProperties(t,{A:{value:e,configurable:!0,writable:!0,enumerable:!1}})}function Nt(t){return Mt(t,1),t}function Rt(t,e){At(e,-51&(0|t))}function Pt(t,e){At(e,-41&(18|t))}var Ot={};function Lt(t){return null!==t&&"object"==typeof t&&!Array.isArray(t)&&t.constructor===Object}var Dt,Ft,zt=[];function Bt(t){if(2&It(t.o))throw Error("Cannot mutate an immutable Message")}function Ut(t){var e=t.length;(e=e?t[e-1]:void 0)&&Lt(e)?e.g=1:(e={},t.push((e.g=1,e)))}function Vt(t){var e=t.i+t.G;return t.B||(t.B=t.o[e]={})}function Wt(t,e){return-1===e?null:e>=t.i?t.B?t.B[e]:void 0:t.o[e+t.G]}function Ht(t,e,n,i){Bt(t),jt(t,e,n,i)}function jt(t,e,n,i){t.j&&(t.j=void 0),e>=t.i||i?Vt(t)[e]=n:(t.o[e+t.G]=n,(t=t.B)&&e in t&&delete t[e])}function Gt(t,e,n,i){var r=Wt(t,e);Array.isArray(r)||(r=Dt);var s=It(r);if(1&s||Nt(r),i)2&s||Mt(r,2),1&n||Object.freeze(r);else{i=!(2&n);var o=2&s;1&n||!o?i&&16&s&&!o&&$t(r,16):jt(t,e,r=Nt(Array.prototype.slice.call(r)))}return r}function qt(t,e){var n=Wt(t,e),i=null==n?n:"number"==typeof n||"NaN"===n||"Infinity"===n||"-Infinity"===n?Number(n):void 0;return null!=i&&i!==n&&jt(t,e,i),i}function Xt(t,e,n,i,r){t.h||(t.h={});var s=t.h[n],o=Gt(t,n,3,r);if(!s){var a=o;s=[];var l=!!(16&It(t.o));o=!!(2&It(a));var c=a;!r&&o&&(a=Array.prototype.slice.call(a));for(var u=o,h=0;h<a.length;h++){var d=a[h],p=e,f=!1;if(f=void 0!==f&&f,void 0!==(d=Array.isArray(d)?new p(d):f?new p:void 0)){var m=f=It(p=d.o);o&&(m|=2),l&&(m|=16),m!=f&&At(p,m),p=m,u=u||!!(2&p),s.push(d)}}return t.h[n]=s,e=33|(l=It(a)),l!=(e=u?-9&e:8|e)&&(u=a,Object.isFrozen(u)&&(u=Array.prototype.slice.call(u)),At(u,e),a=u),c!==a&&jt(t,n,a),(r||i&&o)&&Mt(s,2),i&&Object.freeze(s),s}return r||(r=Object.isFrozen(s),i&&!r?Object.freeze(s):!i&&r&&(s=Array.prototype.slice.call(s),t.h[n]=s)),s}function Kt(t,e,n){var i=!!(2&It(t.o));if(e=Xt(t,e,n,i,i),t=Gt(t,n,3,i),!(i||8&It(t))){for(i=0;i<e.length;i++){if(2&It((n=e[i]).o)){var r=ae(n,!1);r.j=n}else r=n;n!==r&&(e[i]=r,t[i]=r.o)}Mt(t,8)}return e}function Yt(t,e,n){if(null!=n&&"number"!=typeof n)throw Error("Value of float/double field must be a number|null|undefined, found "+typeof n+": "+n);Ht(t,e,n)}function Zt(t,e,n,i,r){Bt(t);var s=Xt(t,n,e,!1,!1);return n=null!=i?i:new n,t=Gt(t,e,2,!1),null!=r?(s.splice(r,0,n),t.splice(r,0,n.o)):(s.push(n),t.push(n.o)),n.C()&&$t(t,8),n}function Jt(t,e){return null==t?e:t}function Qt(t,e,n){return n=void 0===n?0:n,Jt(qt(t,e),n)}function te(t,e,n,i){if(null!=t){if(Array.isArray(t))t=ee(t,e,n,void 0!==i);else if(Lt(t)){var r,s={};for(r in t)s[r]=te(t[r],e,n,i);t=s}else t=e(t,i);return t}}function ee(t,e,n,i){var r=It(t);i=i?!!(16&r):void 0,t=Array.prototype.slice.call(t);for(var s=0;s<t.length;s++)t[s]=te(t[s],e,n,i);return n(r,t),t}function ne(t){return t.ja===Ot?t.toJSON():function(t){switch(typeof t){case"number":return isFinite(t)?t:String(t);case"object":if(t)if(Array.isArray(t)){if(0!=(128&It(t)))return Ut(t=Array.prototype.slice.call(t)),t}else{if(R&&null!=t&&t instanceof Uint8Array)return O(t);if(t instanceof ct){var e=t.V;return null==e?"":"string"==typeof e?e:t.V=O(e)}}}return t}(t)}function ie(t,e){128&t&&Ut(e)}function re(t,e,n){if(n=void 0===n?Pt:n,null!=t){if(R&&t instanceof Uint8Array)return t.length?new ct(new Uint8Array(t),U):ut();if(Array.isArray(t)){var i=It(t);return 2&i?t:!e||32&i||!(16&i||0===i)?(4&(e=It(t=ee(t,re,4&i?Pt:n,!0)))&&2&e&&Object.freeze(t),t):(At(t,2|i),t)}return t.ja===Ot?oe(t):t}}function se(t,e,n,i,r,s,o){if(t=t.h&&t.h[n]){if(2&(i=It(t))?i=t:(Pt(i,s=M(t,oe)),Object.freeze(s),i=s),Bt(e),o=null==i?Dt:Nt([]),null!=i){for(s=!!i.length,t=0;t<i.length;t++){var a=i[t];s=s&&!(2&It(a.o)),o[t]=a.o}s=1|(s?8:0),((t=It(o))&s)!==s&&(Object.isFrozen(o)&&(o=Array.prototype.slice.call(o)),At(o,t|s)),e.h||(e.h={}),e.h[n]=i}else e.h&&(e.h[n]=void 0);jt(e,n,o,r)}else Ht(e,n,re(i,s,o),r)}function oe(t){return 2&It(t.o)||Mt((t=ae(t,!0)).o,2),t}function ae(t,e){var n=t.o,i=[];Mt(i,16);var r=t.constructor.h;if(r&&i.push(r),r=t.B){i.length=n.length,i.fill(void 0,i.length,n.length);var s={};i[i.length-1]=s}0!=(128&It(n))&&Ut(i),e=e||t.C()?Pt:Rt,s=t.constructor,Ft=i,i=new s(i),Ft=void 0,t.R&&(i.R=t.R.slice()),s=!!(16&It(n));for(var o=r?n.length-1:n.length,a=0;a<o;a++)se(t,i,a-t.G,n[a],!1,s,e);if(r)for(var l in r)se(t,i,+l,r[l],!0,s,e);return i}function le(t,e,n){null==t&&(t=Ft),Ft=void 0;var i,r=this.constructor.i||0,s=0<r,o=this.constructor.h,a=!1;if(null==t){var l=48,c=!0;s&&(r=0,l|=128),At(t=o?[o]:[],l)}else{if(!Array.isArray(t))throw Error();if(o&&o!==t[0])throw Error();var u=l=Mt(t,0);if((c=0!=(16&u))&&((a=0!=(32&u))||(u|=32)),s){if(128&u)r=0;else if(0<t.length){var h=t[t.length-1];if(Lt(h)&&"g"in h){r=0,u|=128,delete h.g;var d,p=!0;for(d in h){p=!1;break}p&&t.pop()}}}else if(128&u)throw Error();l!==u&&At(t,u)}if(this.G=(o?0:-1)-r,this.h=void 0,this.o=t,r=(o=this.o.length)-1,o&&Lt(o=this.o[r])?(this.B=o,this.i=r-this.G):void 0!==e&&-1<e?(this.i=Math.max(e,r+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE,!s&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(n)for(e=c&&!a&&!0,s=this.i,c=0;c<n.length;c++)(a=n[c])<s?(r=t[a+=this.G])?ce(r,e):t[a]=Dt:(i||(i=Vt(this)),(r=i[a])?ce(r,e):i[a]=Dt)}function ce(t,e){if(Array.isArray(t)){var n=It(t),i=1;!e||2&n||(i|=16),(n&i)!==i&&At(t,n|i)}}function ue(t,e,n){if(n){var i,r={};for(i in n){var s=n[i],o=s.ra;o||(r.J=s.xa||s.oa.W,s.ia?(r.aa=be(s.ia),o=function(t){return function(e,n,i){return t.J(e,n,i,t.aa)}}(r)):s.ka?(r.Z=ve(s.da.P,s.ka),o=function(t){return function(e,n,i){return t.J(e,n,i,t.Z)}}(r)):o=r.J,s.ra=o),o(e,t,s.da),r={J:r.J,aa:r.aa,Z:r.Z}}}!function(t,e){if(e=e.R){_t(t,t.h.end());for(var n=0;n<e.length;n++)_t(t,ht(e[n])||B())}}(e,t)}At(zt,23),Dt=Object.freeze(zt),le.prototype.toJSON=function(){return ee(this.o,ne,ie)},le.prototype.C=function(){return!!(2&It(this.o))},le.prototype.ja=Ot,le.prototype.toString=function(){return this.o.toString()};var he=Symbol();function de(t,e,n){return t[he]||(t[he]=function(t,i){return e(t,i,n)})}function pe(t){var e=t[he];if(!e){var n=Ae(t);e=function(t,e){return Ne(t,e,n)},t[he]=e}return e}function fe(t){var e=function(t){var e=t.ia;return e?pe(e):(e=t.wa)?de(t.da.P,e,t.ka):void 0}(t),n=t.da,i=t.oa.U;return e?function(t,r){return i(t,r,n,e)}:function(t,e){return i(t,e,n)}}function me(t,e){var n=t[e];return"function"==typeof n&&0===n.length&&(n=n(),t[e]=n),Array.isArray(n)&&(_e in n||xe in n||0<n.length&&"function"==typeof n[0])?n:void 0}function ge(t,e,n,i,r,s){e.P=t[0];var o=1;if(t.length>o&&"number"!=typeof t[o]){var a=t[o++];n(e,a)}for(;o<t.length;){n=t[o++];for(var l=o+1;l<t.length&&"number"!=typeof t[l];)l++;switch(a=t[o++],l-=o){case 0:i(e,n,a);break;case 1:(l=me(t,o))?(o++,r(e,n,a,l)):i(e,n,a,t[o++]);break;case 2:r(e,n,a,l=me(t,l=o++),t[o++]);break;case 3:s(e,n,a,t[o++],t[o++],t[o++]);break;case 4:s(e,n,a,t[o++],t[o++],t[o++],t[o++]);break;default:throw Error("unexpected number of binary field arguments: "+l)}}return e}var ye=Symbol();function be(t){var e=t[ye];if(!e){var n=Te(t);e=function(t,e){return Re(t,e,n)},t[ye]=e}return e}function ve(t,e){var n=t[ye];return n||(n=function(t,n){return ue(t,n,e)},t[ye]=n),n}var xe=Symbol();function we(t,e){t.push(e)}function Se(t,e,n){t.push(e,n.W)}function ke(t,e,n,i){var r=be(i),s=Te(i).P,o=n.W;t.push(e,(function(t,e,n){return o(t,e,n,s,r)}))}function Ce(t,e,n,i,r,s){var o=ve(i,s),a=n.W;t.push(e,(function(t,e,n){return a(t,e,n,i,o)}))}function Te(t){var e=t[xe];return e||(e=ge(t,t[xe]=[],we,Se,ke,Ce),_e in t&&xe in t&&(t.length=0),e)}var _e=Symbol();function Ee(t,e){t[0]=e}function Me(t,e,n,i){var r=n.U;t[e]=i?function(t,e,n){return r(t,e,n,i)}:r}function $e(t,e,n,i,r){var s=n.U,o=pe(i),a=Ae(i).P;t[e]=function(t,e,n){return s(t,e,n,a,o,r)}}function Ie(t,e,n,i,r,s,o){var a=n.U,l=de(i,r,s);t[e]=function(t,e,n){return a(t,e,n,i,l,o)}}function Ae(t){var e=t[_e];return e||(e=ge(t,t[_e]={},Ee,Me,$e,Ie),_e in t&&xe in t&&(t.length=0),e)}function Ne(t,e,n){for(;St(e)&&4!=e.i;){var i=e.l,r=n[i];if(!r){var s=n[0];s&&(s=s[i])&&(r=n[i]=fe(s))}if(!r||!r(e,t,i)){i=t,s=(r=e).j,kt(r);var o=r;if(!o.ca){if(r=o.h.h-s,o.h.h=s,o=o.h,0==r)r=ut();else{if(s=gt(o,r),o.S&&o.m)r=o.i.subarray(s,s+r);else{o=o.i;var a=s;r=a===(r=s+r)?B():V?o.slice(a,r):new Uint8Array(o.subarray(a,r))}r=0==r.length?ut():new ct(r,U)}(s=i.R)?s.push(r):i.R=[r]}}}return t}function Re(t,e,n){for(var i=n.length,r=1==i%2,s=r?1:0;s<i;s+=2)(0,n[s+1])(e,t,n[s]);ue(t,e,r?n[0]:void 0)}function Pe(t,e){return{U:t,W:e}}var Oe=Pe((function(t,e,n){if(5!==t.i)return!1;var i=(t=t.h).i,r=t.h,s=i[r],o=i[r+1],a=i[r+2];return i=i[r+3],ft(t,t.h+4),t=2*((o=(s<<0|o<<8|a<<16|i<<24)>>>0)>>31)+1,s=o>>>23&255,o&=8388607,Ht(e,n,255==s?o?NaN:1/0*t:0==s?t*Math.pow(2,-149)*o:t*Math.pow(2,s-150)*(o+Math.pow(2,23))),!0}),(function(t,e,n){if(null!=(e=qt(e,n))){xt(t.h,8*n+5),t=t.h;var i=+e;0===i?0<1/i?W=H=0:(H=0,W=2147483648):isNaN(i)?(H=0,W=2147483647):34028234663852886e22<(i=(n=0>i?-2147483648:0)?-i:i)?(H=0,W=(2139095040|n)>>>0):11754943508222875e-54>i?(i=Math.round(i/Math.pow(2,-149)),H=0,W=(n|i)>>>0):(e=Math.floor(Math.log(i)/Math.LN2),i*=Math.pow(2,-e),16777216<=(i=Math.round(8388608*i))&&++e,H=0,W=(n|e+127<<23|8388607&i)>>>0),n=W,t.h.push(n>>>0&255),t.h.push(n>>>8&255),t.h.push(n>>>16&255),t.h.push(n>>>24&255)}})),Le=Pe((function(t,e,n){if(0!==t.i)return!1;var i=t.h,r=0,s=t=0,o=i.i,a=i.h;do{var l=o[a++];r|=(127&l)<<s,s+=7}while(32>s&&128&l);for(32<s&&(t|=(127&l)>>4),s=3;32>s&&128&l;s+=7)t|=(127&(l=o[a++]))<<s;if(ft(i,a),!(128>l))throw J();return i=r>>>0,(t=2147483648&(l=t>>>0))&&(l=~l>>>0,0==(i=1+~i>>>0)&&(l=l+1>>>0)),i=4294967296*l+(i>>>0),Ht(e,n,t?-i:i),!0}),(function(t,e,n){null!=(e=Wt(e,n))&&("string"==typeof e&&Y(e),null!=e&&(xt(t.h,8*n),"number"==typeof e?(t=t.h,j(e),vt(t,W,H)):(n=Y(e),vt(t.h,n.i,n.h))))})),De=Pe((function(t,e,n){return 0===t.i&&(Ht(e,n,mt(t.h)),!0)}),(function(t,e,n){if(null!=(e=Wt(e,n))&&null!=e)if(xt(t.h,8*n),t=t.h,0<=(n=e))xt(t,n);else{for(e=0;9>e;e++)t.h.push(127&n|128),n>>=7;t.h.push(1)}})),Fe=Pe((function(t,e,n){if(2!==t.i)return!1;var i=mt(t.h)>>>0,r=gt(t=t.h,i);if(t=t.i,ot){var s,o=t;(s=nt)||(s=nt=new TextDecoder("utf-8",{fatal:!0})),t=r+i,o=0===r&&t===o.length?o:o.subarray(r,t);try{var a=s.decode(o)}catch(t){if(void 0===st){try{s.decode(new Uint8Array([128]))}catch(t){}try{s.decode(new Uint8Array([97])),st=!0}catch(t){st=!1}}throw!st&&(nt=void 0),t}}else{i=(a=r)+i,r=[];for(var l,c,u=null;a<i;)128>(l=t[a++])?r.push(l):224>l?a>=i?tt():(c=t[a++],194>l||128!=(192&c)?(a--,tt()):r.push((31&l)<<6|63&c)):240>l?a>=i-1?tt():128!=(192&(c=t[a++]))||224===l&&160>c||237===l&&160<=c||128!=(192&(o=t[a++]))?(a--,tt()):r.push((15&l)<<12|(63&c)<<6|63&o):244>=l?a>=i-2?tt():128!=(192&(c=t[a++]))||0!=c-144+(l<<28)>>30||128!=(192&(o=t[a++]))||128!=(192&(s=t[a++]))?(a--,tt()):(l=(7&l)<<18|(63&c)<<12|(63&o)<<6|63&s,l-=65536,r.push(55296+(l>>10&1023),56320+(1023&l))):tt(),8192<=r.length&&(u=et(u,r),r.length=0);a=et(u,r)}return Ht(e,n,a),!0}),(function(t,e,n){if(null!=(e=Wt(e,n))){var i=!1;if(i=void 0!==i&&i,at){if(i&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(e))throw Error("Found an unpaired surrogate");e=(it||(it=new TextEncoder)).encode(e)}else{for(var r=0,s=new Uint8Array(3*e.length),o=0;o<e.length;o++){var a=e.charCodeAt(o);if(128>a)s[r++]=a;else{if(2048>a)s[r++]=a>>6|192;else{if(55296<=a&&57343>=a){if(56319>=a&&o<e.length){var l=e.charCodeAt(++o);if(56320<=l&&57343>=l){a=1024*(a-55296)+l-56320+65536,s[r++]=a>>18|240,s[r++]=a>>12&63|128,s[r++]=a>>6&63|128,s[r++]=63&a|128;continue}o--}if(i)throw Error("Found an unpaired surrogate");a=65533}s[r++]=a>>12|224,s[r++]=a>>6&63|128}s[r++]=63&a|128}}e=r===s.length?s:s.subarray(0,r)}xt(t.h,8*n+2),xt(t.h,e.length),_t(t,t.h.end()),_t(t,e)}})),ze=Pe((function(t,e,n,i,r){if(2!==t.i)return!1;e=Zt(e,n,i),n=t.h.j,i=mt(t.h)>>>0;var s=t.h.h+i,o=s-n;if(0>=o&&(t.h.j=s,r(e,t,void 0,void 0,void 0),o=s-t.h.h),o)throw Error("Message parsing ended unexpectedly. Expected to read "+i+" bytes, instead read "+(i-o)+" bytes, either the data ended unexpectedly or the message misreported its own length");return t.h.h=s,t.h.j=n,!0}),(function(t,e,n,i,r){if(null!=(e=Kt(e,i,n)))for(i=0;i<e.length;i++){var s=t;xt(s.h,8*n+2);var o=s.h.end();_t(s,o),o.push(s.i),s=o,r(e[i],t),o=t;var a=s.pop();for(a=o.i+o.h.length()-a;127<a;)s.push(127&a|128),a>>>=7,o.i++;s.push(a),o.i++}}));function Be(t){return function(e,n){t:{if(Ct.length){var i=Ct.pop();i.setOptions(n),pt(i.h,e,n),e=i}else e=new wt(e,n);try{var r=Ae(t),s=Ne(new r.P,e,r);break t}finally{(r=e.h).i=null,r.m=!1,r.l=0,r.j=0,r.h=0,r.S=!1,e.l=-1,e.i=-1,100>Ct.length&&Ct.push(e)}s=void 0}return s}}function Ue(t){return function(){var e=new Tt;Re(this,e,Te(t)),_t(e,e.h.end());for(var n=new Uint8Array(e.i),i=e.j,r=i.length,s=0,o=0;o<r;o++){var a=i[o];n.set(a,s),s+=a.length}return e.j=[n],n}}function Ve(t){le.call(this,t)}f(Ve,le);var We=[Ve,1,De,2,Oe,3,Fe,4,Fe];function He(t){le.call(this,t,-1,je)}Ve.prototype.l=Ue(We),f(He,le),He.prototype.addClassification=function(t,e){return Zt(this,1,Ve,t,e),this};var je=[1],Ge=Be([He,1,ze,We]);function qe(t){le.call(this,t)}f(qe,le);var Xe=[qe,1,Oe,2,Oe,3,Oe,4,Oe,5,Oe];function Ke(t){le.call(this,t,-1,Ye)}qe.prototype.l=Ue(Xe),f(Ke,le);var Ye=[1],Ze=Be([Ke,1,ze,Xe]);function Je(t){le.call(this,t)}f(Je,le);var Qe=[Je,1,Oe,2,Oe,3,Oe,4,Oe,5,Oe,6,Le],tn=Be(Qe);function en(t,e,n){if(n=t.createShader(0===n?t.VERTEX_SHADER:t.FRAGMENT_SHADER),t.shaderSource(n,e),t.compileShader(n),!t.getShaderParameter(n,t.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+t.getShaderInfoLog(n));return n}function nn(t){return Kt(t,Ve,1).map((function(t){var e=Wt(t,1);return{index:null==e?0:e,qa:Qt(t,2),label:null!=Wt(t,3)?Jt(Wt(t,3),""):void 0,displayName:null!=Wt(t,4)?Jt(Wt(t,4),""):void 0}}))}function rn(t){return{x:Qt(t,1),y:Qt(t,2),z:Qt(t,3),visibility:null!=qt(t,4)?Qt(t,4):void 0}}function sn(t){return Kt(Ze(t),qe,1).map(rn)}function on(t,e){this.i=t,this.h=e,this.m=0}function an(t,e,n){return function(t,e){var n=t.h;if(void 0===t.s){var i=en(n,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),r=en(n,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),s=n.createProgram();if(n.attachShader(s,i),n.attachShader(s,r),n.linkProgram(s),!n.getProgramParameter(s,n.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+n.getProgramInfoLog(s));i=t.s=s,n.useProgram(i),r=n.getUniformLocation(i,"sampler0"),t.l={O:n.getAttribLocation(i,"aVertex"),N:n.getAttribLocation(i,"aTex"),ya:r},t.v=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,t.v),n.enableVertexAttribArray(t.l.O),n.vertexAttribPointer(t.l.O,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),t.u=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,t.u),n.enableVertexAttribArray(t.l.N),n.vertexAttribPointer(t.l.N,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),n.uniform1i(r,0)}i=t.l,n.useProgram(t.s),n.canvas.width=e.width,n.canvas.height=e.height,n.viewport(0,0,e.width,e.height),n.activeTexture(n.TEXTURE0),t.i.bindTexture2d(e.glName),n.enableVertexAttribArray(i.O),n.bindBuffer(n.ARRAY_BUFFER,t.v),n.vertexAttribPointer(i.O,2,n.FLOAT,!1,0,0),n.enableVertexAttribArray(i.N),n.bindBuffer(n.ARRAY_BUFFER,t.u),n.vertexAttribPointer(i.N,2,n.FLOAT,!1,0,0),n.bindFramebuffer(n.DRAW_FRAMEBUFFER?n.DRAW_FRAMEBUFFER:n.FRAMEBUFFER,null),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),n.colorMask(!0,!0,!0,!0),n.drawArrays(n.TRIANGLE_FAN,0,4),n.disableVertexAttribArray(i.O),n.disableVertexAttribArray(i.N),n.bindBuffer(n.ARRAY_BUFFER,null),t.i.bindTexture2d(0)}(t,e),"function"==typeof t.h.canvas.transferToImageBitmap?Promise.resolve(t.h.canvas.transferToImageBitmap()):n?Promise.resolve(t.h.canvas):"function"==typeof createImageBitmap?createImageBitmap(t.h.canvas):(void 0===t.j&&(t.j=document.createElement("canvas")),new Promise((function(e){t.j.height=t.h.canvas.height,t.j.width=t.h.canvas.width,t.j.getContext("2d",{}).drawImage(t.h.canvas,0,0,t.h.canvas.width,t.h.canvas.height),e(t.j)})))}function ln(t){this.h=t}Je.prototype.l=Ue(Qe);var cn=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function un(t,e){return e+t}function hn(t,e){window[t]=e}function dn(t){if(this.h=t,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=t&&t.locateFile||un,"object"==typeof window)var e=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if("undefined"==typeof location)throw Error("solutions can only be loaded on a web page or in a web worker");e=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.ha=e,t.options)for(var n=(e=o(Object.keys(t.options))).next();!n.done;n=e.next()){n=n.value;var i=t.options[n].default;void 0!==i&&(this.l[n]="function"==typeof i?i():i)}}function pn(t){var e,n,i,r,s,o,l,c,u,h,d;return k((function(p){switch(p.h){case 1:return t.ga?(e=void 0===t.h.files?[]:"function"==typeof t.h.files?t.h.files(t.l):t.h.files,b(p,k((function(t){switch(t.h){case 1:return t.s=2,b(t,WebAssembly.instantiate(cn),4);case 4:t.h=3,t.s=0;break;case 2:return t.s=0,t.l=null,t.return(!1);case 3:return t.return(!0)}})),2)):p.return();case 2:if(n=p.i,"object"==typeof window)return hn("createMediapipeSolutionsWasm",{locateFile:t.locateFile}),hn("createMediapipeSolutionsPackedAssets",{locateFile:t.locateFile}),o=e.filter((function(t){return void 0!==t.data})),l=e.filter((function(t){return void 0===t.data})),c=Promise.all(o.map((function(e){var n=fn(t,e.url);if(void 0!==e.path){var i=e.path;n=n.then((function(e){return t.overrideFile(i,e),Promise.resolve(e)}))}return n}))),u=Promise.all(l.map((function(e){return void 0===e.simd||e.simd&&n||!e.simd&&!n?function(t){var e=document.createElement("script");return e.setAttribute("src",t),e.setAttribute("crossorigin","anonymous"),new Promise((function(t){e.addEventListener("load",(function(){t()}),!1),e.addEventListener("error",(function(){t()}),!1),document.body.appendChild(e)}))}(t.locateFile(e.url,t.ha)):Promise.resolve()}))).then((function(){var e,n,i;return k((function(r){if(1==r.h)return e=window.createMediapipeSolutionsWasm,n=window.createMediapipeSolutionsPackedAssets,i=t,b(r,e(n),2);i.i=r.i,r.h=0}))})),h=k((function(e){return t.h.graph&&t.h.graph.url?e=b(e,fn(t,t.h.graph.url),0):(e.h=0,e=void 0),e})),b(p,Promise.all([u,c,h]),7);if("function"!=typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return i=e.filter((function(t){return void 0===t.simd||t.simd&&n||!t.simd&&!n})).map((function(e){return t.locateFile(e.url,t.ha)})),importScripts.apply(null,a(i)),r=t,b(p,createMediapipeSolutionsWasm(Module),6);case 6:r.i=p.i,t.m=new OffscreenCanvas(1,1),t.i.canvas=t.m,s=t.i.GL.createContext(t.m,{antialias:!1,alpha:!1,va:"undefined"!=typeof WebGL2RenderingContext?2:1}),t.i.GL.makeContextCurrent(s),p.h=4;break;case 7:if(t.m=document.createElement("canvas"),!(d=t.m.getContext("webgl2",{}))&&!(d=t.m.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),p.return();t.K=d,t.i.canvas=t.m,t.i.createContext(t.m,!0,!0,{});case 4:t.j=new t.i.SolutionWasm,t.ga=!1,p.h=0}}))}function fn(t,e){var n,i;return k((function(r){return e in t.L?r.return(t.L[e]):(n=t.locateFile(e,""),i=fetch(n).then((function(t){return t.arrayBuffer()})),t.L[e]=i,r.return(i))}))}function mn(t,e,n){var i,r,s,a,l,c,u,h,d,p,f,m,g,y;return k((function(v){switch(v.h){case 1:if(!n)return v.return(e);for(i={},r=0,s=o(Object.keys(n)),a=s.next();!a.done;a=s.next())l=a.value,"string"!=typeof(c=n[l])&&"texture"===c.type&&void 0!==e[c.stream]&&++r;1<r&&(t.M=!1),u=o(Object.keys(n)),a=u.next();case 2:if(a.done){v.h=4;break}if(h=a.value,"string"==typeof(d=n[h]))return g=i,y=h,b(v,function(t,e,n){var i;return k((function(r){return"number"==typeof n||n instanceof Uint8Array||n instanceof t.i.Uint8BlobList?r.return(n):n instanceof t.i.Texture2dDataOut?((i=t.v[e])||(i=new on(t.i,t.K),t.v[e]=i),r.return(an(i,n,t.M))):r.return(void 0)}))}(t,h,e[d]),14);if(p=e[d.stream],"detection_list"===d.type){if(p){for(var x=p.getRectList(),w=p.getLandmarksList(),S=p.getClassificationsList(),C=[],T=0;T<x.size();++T){var _=tn(x.get(T)),E=void 0;E=void 0===E?0:E,_={la:{sa:Qt(_,1),ta:Qt(_,2),height:Qt(_,3),width:Qt(_,4),rotation:Qt(_,5,0),pa:Jt(Wt(_,6),E)},ea:sn(w.get(T)),ba:nn(Ge(S.get(T)))},C.push(_)}x=C}else x=[];i[h]=x,v.h=7;break}if("proto_list"===d.type){if(p){for(x=Array(p.size()),w=0;w<p.size();w++)x[w]=p.get(w);p.delete()}else x=[];i[h]=x,v.h=7;break}if(void 0===p){v.h=3;break}if("float_list"===d.type){i[h]=p,v.h=7;break}if("proto"===d.type){i[h]=p,v.h=7;break}if("texture"!==d.type)throw Error("Unknown output config type: '"+d.type+"'");return(f=t.v[h])||(f=new on(t.i,t.K),t.v[h]=f),b(v,an(f,p,t.M),13);case 13:m=v.i,i[h]=m;case 7:d.transform&&i[h]&&(i[h]=d.transform(i[h])),v.h=3;break;case 14:g[y]=v.i;case 3:a=u.next(),v.h=2;break;case 4:return v.return(i)}}))}function gn(t,e){for(var n=e.name||"$",i=[].concat(a(e.wants)),r=new t.i.StringList,s=o(e.wants),l=s.next();!l.done;l=s.next())r.push_back(l.value);s=t.i.PacketListener.implement({onResults:function(r){for(var s={},o=0;o<e.wants.length;++o)s[i[o]]=r.get(o);var a=t.listeners[n];a&&(t.I=mn(t,s,e.outs).then((function(n){n=a(n);for(var r=0;r<e.wants.length;++r){var o=s[i[r]];"object"==typeof o&&o.hasOwnProperty&&o.hasOwnProperty("delete")&&o.delete()}n&&(t.I=n)})))}}),t.j.attachMultiListener(r,s),r.delete()}function yn(t){switch(void 0===t&&(t=0),t){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function bn(t){var e=this;t=t||{},this.h=new dn({locateFile:t.locateFile,files:function(t){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:yn(t.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:sn},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:sn},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"object"==typeof window&&void 0!==window.navigator&&("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document)},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(t){var n,i,r;return k((function(s){return 1==s.h?(n=yn(t),i="third_party/mediapipe/modules/pose_landmark/"+n,b(s,fn(e.h,n),2)):(r=s.i,e.h.overrideFile(i,r),s.return(!0))}))}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}(t=dn.prototype).close=function(){return this.j&&this.j.delete(),Promise.resolve()},t.reset=function(){var t=this;return k((function(e){t.j&&(t.j.reset(),t.s={},t.v={}),e.h=0}))},t.setOptions=function(t,e){var n=this;if(e=e||this.h.options){for(var i=[],r=[],s={},a=o(Object.keys(t)),l=a.next();!l.done;s={X:s.X,Y:s.Y},l=a.next())if(!((l=l.value)in this.l)||this.l[l]!==t[l]){this.l[l]=t[l];var c=e[l];void 0!==c&&(c.onChange&&(s.X=c.onChange,s.Y=t[l],i.push(function(t){return function(){return k((function(e){if(1==e.h)return b(e,t.X(t.Y),2);!0===e.i&&(n.u=!0),e.h=0}))}}(s))),c.graphOptionXref&&(l=Object.assign({},{calculatorName:"",calculatorIndex:0},c.graphOptionXref,{valueNumber:1===c.type?t[l]:0,valueBoolean:0===c.type&&t[l],valueString:2===c.type?t[l]:""}),r.push(l)))}0===i.length&&0===r.length||(this.u=!0,this.H=(void 0===this.H?[]:this.H).concat(r),this.F=(void 0===this.F?[]:this.F).concat(i))}},t.initialize=function(){var t=this;return k((function(e){return 1==e.h?b(e,pn(t),2):3!=e.h?b(e,function(t){var e,n,i,r,s,a,l,c;return k((function(u){if(1==u.h)return t.h.graph&&t.h.graph.url&&t.fa===t.h.graph.url?u.return():(t.u=!0,t.h.graph&&t.h.graph.url?(t.fa=t.h.graph.url,b(u,fn(t,t.h.graph.url),3)):void(u.h=2));for(2!=u.h&&(e=u.i,t.j.loadGraph(e)),n=o(Object.keys(t.D)),i=n.next();!i.done;i=n.next())r=i.value,t.j.overrideFile(r,t.D[r]);if(t.D={},t.h.listeners)for(s=o(t.h.listeners),a=s.next();!a.done;a=s.next())l=a.value,gn(t,l);c=t.l,t.l={},t.setOptions(c),u.h=0}))}(t),3):b(e,function(t){var e,n,i,r,s,a;return k((function(l){switch(l.h){case 1:if(!t.u)return l.return();if(!t.F){l.h=2;break}e=o(t.F),n=e.next();case 3:if(n.done){l.h=5;break}return b(l,(0,n.value)(),4);case 4:n=e.next(),l.h=3;break;case 5:t.F=void 0;case 2:if(t.H){for(i=new t.i.GraphOptionChangeRequestList,r=o(t.H),s=r.next();!s.done;s=r.next())a=s.value,i.push_back(a);t.j.changeOptions(i),i.delete(),t.H=void 0}t.u=!1,l.h=0}}))}(t),0)}))},t.overrideFile=function(t,e){this.j?this.j.overrideFile(t,e):this.D[t]=e},t.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},t.send=function(t,e){var n,i,r,s,a,l,c,u,h,d=this;return k((function(p){switch(p.h){case 1:return d.h.inputs?(n=1e3*(null==e?performance.now():e),b(p,d.I,2)):p.return();case 2:return b(p,d.initialize(),3);case 3:for(i=new d.i.PacketDataList,r=o(Object.keys(t)),s=r.next();!s.done;s=r.next())if(a=s.value,l=d.h.inputs[a]){t:{var f=t[a];switch(l.type){case"video":var m=d.s[l.stream];if(m||(m=new on(d.i,d.K),d.s[l.stream]=m),0===m.m&&(m.m=m.i.createTexture()),"undefined"!=typeof HTMLVideoElement&&f instanceof HTMLVideoElement)var g=f.videoWidth,y=f.videoHeight;else"undefined"!=typeof HTMLImageElement&&f instanceof HTMLImageElement?(g=f.naturalWidth,y=f.naturalHeight):(g=f.width,y=f.height);y={glName:m.m,width:g,height:y},(g=m.h).canvas.width=y.width,g.canvas.height=y.height,g.activeTexture(g.TEXTURE0),m.i.bindTexture2d(m.m),g.texImage2D(g.TEXTURE_2D,0,g.RGBA,g.RGBA,g.UNSIGNED_BYTE,f),m.i.bindTexture2d(0),m=y;break t;case"detections":for((m=d.s[l.stream])||(m=new ln(d.i),d.s[l.stream]=m),m.data||(m.data=new m.h.DetectionListData),m.data.reset(f.length),y=0;y<f.length;++y){g=f[y];var v=m.data,x=v.setBoundingBox,w=y,S=g.la,k=new Je;if(Yt(k,1,S.sa),Yt(k,2,S.ta),Yt(k,3,S.height),Yt(k,4,S.width),Yt(k,5,S.rotation),Ht(k,6,S.pa),S=k.l(),x.call(v,w,S),g.ea)for(v=0;v<g.ea.length;++v){k=g.ea[v],w=(x=m.data).addNormalizedLandmark,S=y,k=Object.assign({},k,{visibility:k.visibility?k.visibility:0});var C=new qe;Yt(C,1,k.x),Yt(C,2,k.y),Yt(C,3,k.z),k.visibility&&Yt(C,4,k.visibility),k=C.l(),w.call(x,S,k)}if(g.ba)for(v=0;v<g.ba.length;++v)w=(x=m.data).addClassification,S=y,k=g.ba[v],Yt(C=new Ve,2,k.qa),k.index&&Ht(C,1,k.index),k.label&&Ht(C,3,k.label),k.displayName&&Ht(C,4,k.displayName),k=C.l(),w.call(x,S,k)}m=m.data;break t;default:m={}}}switch(c=m,u=l.stream,l.type){case"video":i.pushTexture2d(Object.assign({},c,{stream:u,timestamp:n}));break;case"detections":(h=c).stream=u,h.timestamp=n,i.pushDetectionList(h);break;default:throw Error("Unknown input config type: '"+l.type+"'")}}return d.j.send(i),b(p,d.I,4);case 4:i.delete(),p.h=0}}))},t.onResults=function(t,e){this.listeners[e||"$"]=t},_("Solution",dn),_("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"}),(t=bn.prototype).reset=function(){this.h.reset()},t.close=function(){return this.h.close(),Promise.resolve()},t.onResults=function(t){this.h.onResults(t)},t.initialize=function(){var t=this;return k((function(e){return b(e,t.h.initialize(),0)}))},t.send=function(t,e){var n=this;return k((function(i){return b(i,n.h.send(t,e),0)}))},t.setOptions=function(t){this.h.setOptions(t)},_("Pose",bn),_("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),_("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),_("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),_("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),_("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),_("VERSION","0.5.1675469404")}).call(Ti);
/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */
var awt=function(t,e){return(awt=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])})(t,e)};function lwt(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function n(){this.constructor=t}awt(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}var cwt=function(){return(cwt=Object.assign||function(t){for(var e,n=1,i=arguments.length;n<i;n++)for(var r in e=arguments[n])Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t}).apply(this,arguments)};function uwt(t,e,n,i){return new(n||(n=Promise))((function(r,s){function o(t){try{l(i.next(t))}catch(t){s(t)}}function a(t){try{l(i.throw(t))}catch(t){s(t)}}function l(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(o,a)}l((i=i.apply(t,e||[])).next())}))}function hwt(t,e){var n,i,r,s,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function a(s){return function(a){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,i&&(r=2&s[0]?i.return:s[0]?i.throw||((r=i.return)&&r.call(i),0):i.next)&&!(r=r.call(i,s[1])).done)return r;switch(i=0,r&&(s=[2&s[0],r.value]),s[0]){case 0:case 1:r=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,i=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!((r=(r=o.trys).length>0&&r[r.length-1])||6!==s[0]&&2!==s[0])){o=0;continue}if(3===s[0]&&(!r||s[1]>r[0]&&s[1]<r[3])){o.label=s[1];break}if(6===s[0]&&o.label<r[1]){o.label=r[1],r=s;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(s);break}r[2]&&o.ops.pop(),o.trys.pop();continue}s=e.call(t,o)}catch(t){s=[6,t],i=0}finally{n=r=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,a])}}}function dwt(t,e,n){if(n||2===arguments.length)for(var i,r=0,s=e.length;r<s;r++)!i&&r in e||(i||(i=Array.prototype.slice.call(e,0,r)),i[r]=e[r]);return t.concat(i||Array.prototype.slice.call(e))}var pwt=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],fwt=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],mwt={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},gwt={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},ywt=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],bwt=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function vwt(t){return t instanceof SVGAnimatedLength?t.baseVal.value:t}function xwt(t){return uwt(this,void 0,void 0,(function(){var e,n;return hwt(this,(function(i){switch(i.label){case 0:return e=document.createElement("canvas"),t instanceof Or?[4,Ap(t,e)]:[3,2];case 1:return i.sent(),[3,3];case 2:e.width=vwt(t.width),e.height=vwt(t.height),n=e.getContext("2d"),t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0),i.label=3;case 3:return[2,e]}}))}))}function wwt(t){return uwt(this,void 0,void 0,(function(){var e,n,i,r,s,o;return hwt(this,(function(a){switch(a.label){case 0:return t instanceof Or?(e=t.shape.slice(0,2),n=e[0],i=e[1],r=ImageData.bind,[4,Ap(t)]):[3,2];case 1:return[2,new(r.apply(ImageData,[void 0,a.sent(),i,n]))];case 2:return s=document.createElement("canvas"),o=s.getContext("2d"),s.width=vwt(t.width),s.height=vwt(t.height),o.drawImage(t,0,0),[2,o.getImageData(0,0,s.width,s.height)]}}))}))}function Swt(t){return uwt(this,void 0,void 0,(function(){var e;return hwt(this,(function(n){switch(n.label){case 0:return t instanceof SVGImageElement||t instanceof OffscreenCanvas?[4,xwt(t)]:[3,2];case 1:return e=n.sent(),[3,3];case 2:e=t,n.label=3;case 3:return[2,Np(e,4)]}}))}))}function kwt(t){if(t<0||t>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(t));if(!Number.isInteger(t))throw new Error("Mask value must be an integer but got ".concat(t))}var Cwt={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},Twt=function(){function t(t){this.mask=t}return t.prototype.toCanvasImageSource=function(){return uwt(this,void 0,void 0,(function(){return hwt(this,(function(t){return[2,this.mask]}))}))},t.prototype.toImageData=function(){return uwt(this,void 0,void 0,(function(){return hwt(this,(function(t){return[2,wwt(this.mask)]}))}))},t.prototype.toTensor=function(){return uwt(this,void 0,void 0,(function(){return hwt(this,(function(t){return[2,Swt(this.mask)]}))}))},t.prototype.getUnderlyingType=function(){return"canvasimagesource"},t}();function _wt(t){return kwt(t),"person"}var Ewt=function(){function t(t){var e,n=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new owt.Pose({locateFile:function(e,n){if(t.solutionPath){var i=t.solutionPath.replace(/\/+$/,"");return"".concat(i,"/").concat(e)}return"".concat(n,"/").concat(e)}}),t.modelType){case"lite":e=0;break;case"heavy":e=2;break;default:e=1}this.poseSolution.setOptions({modelComplexity:e,smoothLandmarks:t.enableSmoothing,enableSegmentation:t.enableSegmentation,smoothSegmentation:t.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults((function(t){if(n.height=t.image.height,n.width=t.image.width,null==t.poseLandmarks)n.poses=[];else{var e=n.translateOutput(t.poseLandmarks,t.poseWorldLandmarks);t.segmentationMask&&(e.segmentation={maskValueToLabel:_wt,mask:new Twt(t.segmentationMask)}),n.poses=[e]}}))}return t.prototype.translateOutput=function(t,e){var n=this,i={keypoints:t.map((function(t,e){return{x:t.x*n.width,y:t.y*n.height,z:t.z,score:t.visibility,name:fwt[e]}}))};return null!=e&&(i.keypoints3D=e.map((function(t,e){return{x:t.x,y:t.y,z:t.z,score:t.visibility,name:fwt[e]}}))),i},t.prototype.estimatePoses=function(t,e,n){return uwt(this,void 0,void 0,(function(){var i,r;return hwt(this,(function(s){switch(s.label){case 0:return e&&e.flipHorizontal&&e.flipHorizontal!==this.selfieMode&&(this.selfieMode=e.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),t instanceof Or?(r=ImageData.bind,[4,Ap(t)]):[3,2];case 1:return i=new(r.apply(ImageData,[void 0,s.sent(),t.shape[1],t.shape[0]])),[3,3];case 2:i=t,s.label=3;case 3:return t=i,[4,this.poseSolution.send({image:t},n)];case 4:return s.sent(),[2,this.poses]}}))}))},t.prototype.dispose=function(){this.poseSolution.close()},t.prototype.reset=function(){this.poseSolution.reset()},t.prototype.initialize=function(){return this.poseSolution.initialize()},t}();function Mwt(t){return uwt(this,void 0,void 0,(function(){var e,n;return hwt(this,(function(i){switch(i.label){case 0:return e=function(t){if(null==t)return cwt({},Cwt);var e=cwt({},t);return e.runtime="mediapipe",null==e.enableSegmentation&&(e.enableSegmentation=Cwt.enableSegmentation),null==e.enableSmoothing&&(e.enableSmoothing=Cwt.enableSmoothing),null==e.smoothSegmentation&&(e.smoothSegmentation=Cwt.smoothSegmentation),null==e.modelType&&(e.modelType=Cwt.modelType),e}(t),[4,(n=new Ewt(e)).initialize()];case 1:return i.sent(),[2,n]}}))}))}function $wt(t){return t instanceof Or?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function Iwt(t){return t-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function Awt(t){return t instanceof Or?t:Np(t)}function Nwt(t,e,n){return Rwt(n,"inputResolution"),[1/n.width*t[0][0]*e.width,1/n.height*t[0][1]*e.width,t[0][3]*e.width,1/n.width*t[1][0]*e.height,1/n.height*t[1][1]*e.height,t[1][3]*e.height,0,0]}function Rwt(t,e){c(0!==t.width,(function(){return"".concat(e," width cannot be 0.")})),c(0!==t.height,(function(){return"".concat(e," height cannot be 0.")}))}function Pwt(t,e,n){var i=n.rotationVectorStartKeypointIndex,r=n.rotationVectorEndKeypointIndex,s=t.locationData,o=s.relativeKeypoints[i].x*e.width,a=s.relativeKeypoints[i].y*e.height,l=s.relativeKeypoints[r].x*e.width,c=s.relativeKeypoints[r].y*e.height,u=2*Math.sqrt((l-o)*(l-o)+(c-a)*(c-a)),h=function(t,e,n){var i,r=t.locationData,s=n.rotationVectorStartKeypointIndex,o=n.rotationVectorEndKeypointIndex;i=n.rotationVectorTargetAngle?n.rotationVectorTargetAngle:Math.PI*n.rotationVectorTargetAngleDegree/180;var a=r.relativeKeypoints[s].x*e.width,l=r.relativeKeypoints[s].y*e.height,c=r.relativeKeypoints[o].x*e.width,u=r.relativeKeypoints[o].y*e.height;return Iwt(i-Math.atan2(-(u-l),c-a))}(t,e,n);return{xCenter:o/e.width,yCenter:a/e.height,width:u/e.width,height:u/e.height,rotation:h}}function Owt(t){if(16!==t.length)throw new Error("Array length must be 16 but got ".concat(t.length));return[[t[0],t[1],t[2],t[3]],[t[4],t[5],t[6],t[7]],[t[8],t[9],t[10],t[11]],[t[12],t[13],t[14],t[15]]]}function Lwt(t,e,n,i,r,s,o){return t[e][r]*(t[n][s]*t[i][o]-t[n][o]*t[i][s])}function Dwt(t,e,n){var i=(e+1)%4,r=(e+2)%4,s=(e+3)%4,o=(n+1)%4,a=(n+2)%4,l=(n+3)%4;return Lwt(t,i,r,s,o,a,l)+Lwt(t,r,s,i,o,a,l)+Lwt(t,s,i,r,o,a,l)}function Fwt(t,e,n){void 0===n&&(n={ignoreRotation:!1});for(var i=[],r=0,s=t;r<s.length;r++){var o=s[r],a=o.x-.5,l=o.y-.5,c=n.ignoreRotation?0:e.rotation,u=Math.cos(c)*a-Math.sin(c)*l,h=Math.sin(c)*a+Math.cos(c)*l;u=u*e.width+e.xCenter,h=h*e.height+e.yCenter;var d=o.z*e.width,p=cwt({},o);p.x=u,p.y=h,p.z=d,i.push(p)}return i}function zwt(t,e){var n=function(t,e,n,i){var r=(i-n)/255;return{scale:r,offset:n-0*r}}(0,0,e[0],e[1]);return Co((function(){return Ao(Po(t,n.scale),n.offset)}))}function Bwt(t,e,n){var i,r,s,o,a,l,c,u,h,d,p,f,m=e.outputTensorSize,g=e.keepAspectRatio,y=e.borderMode,b=e.outputTensorFloatRange,v=$wt(t),x=function(t,e){return e?{xCenter:e.xCenter*t.width,yCenter:e.yCenter*t.height,width:e.width*t.width,height:e.height*t.height,rotation:e.rotation}:{xCenter:.5*t.width,yCenter:.5*t.height,width:t.width,height:t.height,rotation:0}}(v,n),w=function(t,e,n){if(void 0===n&&(n=!1),!n)return{top:0,left:0,right:0,bottom:0};var i=e.height,r=e.width;Rwt(e,"targetSize"),Rwt(t,"roi");var s,o,a=i/r,l=t.height/t.width,c=0,u=0;return a>l?(s=t.width,o=t.width*a,u=(1-l/a)/2):(s=t.height/a,o=t.height,c=(1-a/l)/2),t.width=s,t.height=o,{top:u,left:c,right:c,bottom:u}}(x,m,g),S=(i=x,r=v.width,s=v.height,!1,o=i.width,a=i.height,1,l=Math.cos(i.rotation),c=Math.sin(i.rotation),u=i.xCenter,h=i.yCenter,d=1/r,p=1/s,(f=new Array(16))[0]=o*l*1*d,f[1]=-a*c*d,f[2]=0,f[3]=(-.5*o*l*1+.5*a*c+u)*d,f[4]=o*c*1*p,f[5]=a*l*p,f[6]=0,f[7]=(-.5*a*l-.5*o*c*1+h)*p,f[8]=0,f[9]=0,f[10]=o*d,f[11]=0,f[12]=0,f[13]=0,f[14]=0,f[15]=1,Owt(f));return{imageTensor:Co((function(){var e=Awt(t),n=rh(Nwt(S,v,m),[1,8]),i="zero"===y?"constant":"nearest",r=Bd.transform(Ml(vo(e,"float32")),n,"bilinear",i,0,[m.height,m.width]);return null!=b?zwt(r,b):r})),padding:w,transformationMatrix:S}}function Uwt(t,e,n,i){return 1===i?.5*(t+e):t+(e-t)*n/(i-1)}function Vwt(t){return null!=t&&null!=t.currentTime}function Wwt(t){for(var e={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,r=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,o=0;o<t.length;++o){var a=t[o];n=Math.min(n,a.x),i=Math.max(i,a.x),r=Math.min(r,a.y),s=Math.max(s,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:n,yMin:r,xMax:i,yMax:s,width:i-n,height:s-r},e}function Hwt(t,e,n,i){return uwt(this,void 0,void 0,(function(){var i,r,s,o,a;return hwt(this,(function(l){switch(l.label){case 0:return t.sort((function(t,e){return Math.max.apply(Math,e.score)-Math.max.apply(Math,t.score)})),i=rh(t.map((function(t){return[t.locationData.relativeBoundingBox.yMin,t.locationData.relativeBoundingBox.xMin,t.locationData.relativeBoundingBox.yMax,t.locationData.relativeBoundingBox.xMax]}))),r=ih(t.map((function(t){return t.score[0]}))),[4,Bd.nonMaxSuppressionAsync(i,r,e,n)];case 1:return[4,(s=l.sent()).array()];case 2:return o=l.sent(),a=t.filter((function(t,e){return o.indexOf(e)>-1})),To([i,r,s]),[2,a]}}))}))}function jwt(t,e){return t.map((function(t){var n=cwt(cwt({},t),{x:t.x*e.width,y:t.y*e.height});return null!=t.z&&(n.z=t.z*e.width),n}))}function Gwt(t,e,n){return uwt(this,void 0,void 0,(function(){var i,r,s,o,a,l,c,u,h,d,p,f,m,g,y,b,v,x,w,S,k,C,T,_;return hwt(this,(function(E){switch(E.label){case 0:if(i=Ju(e,[0]),r=i.shape,s=r[0],o=r[1],a=r[2],t.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(t.length,", heatmap length: ").concat(a));return l=[],[4,i.buffer()];case 1:for(c=E.sent(),u=0;u<t.length;u++)if(h=t[u],d=cwt({},h),l.push(d),p=Math.trunc(d.x*o),f=Math.trunc(d.y*s),!(p<0||p>=o||f<0||p>=s)){for(m=Math.trunc((n.kernelSize-1)/2),g=Math.max(0,p-m),y=Math.min(o,p+m+1),b=Math.max(0,f-m),v=Math.min(s,f+m+1),x=0,w=0,S=0,k=0,C=b;C<v;++C)for(T=g;T<y;++T)_=c.get(C,T,u),x+=_,k=Math.max(k,_),w+=T*_,S+=C*_;k>=n.minConfidenceToRefine&&x>0&&(d.x=w/o/x,d.y=S/s/x)}return i.dispose(),[2,l]}}))}))}function qwt(t,e){var n=e.left,i=e.top,r=e.left+e.right,s=e.top+e.bottom;return t.map((function(t){return cwt(cwt({},t),{x:(t.x-n)/(1-r),y:(t.y-i)/(1-s),z:t.z/(1-r)})}))}function Xwt(t,e,n){return uwt(this,void 0,void 0,(function(){var i,r,s,o,a;return hwt(this,(function(l){switch(l.label){case 0:return i=t[0],r=t[1],s=function(t,e,n){return Co((function(){var i,r,s,o;n.reverseOutputOrder?(r=Ju(ma(t,[0,n.boxCoordOffset+0],[-1,1])),i=Ju(ma(t,[0,n.boxCoordOffset+1],[-1,1])),o=Ju(ma(t,[0,n.boxCoordOffset+2],[-1,1])),s=Ju(ma(t,[0,n.boxCoordOffset+3],[-1,1]))):(i=Ju(ma(t,[0,n.boxCoordOffset+0],[-1,1])),r=Ju(ma(t,[0,n.boxCoordOffset+1],[-1,1])),s=Ju(ma(t,[0,n.boxCoordOffset+2],[-1,1])),o=Ju(ma(t,[0,n.boxCoordOffset+3],[-1,1]))),r=Ao(Po(Ro(r,n.xScale),e.w),e.x),i=Ao(Po(Ro(i,n.yScale),e.h),e.y),n.applyExponentialOnBoxSize?(s=Po(El(Ro(s,n.hScale)),e.h),o=Po(El(Ro(o,n.wScale)),e.w)):(s=Po(Ro(s,n.hScale),e.h),o=Po(Ro(o,n.wScale),e.h));var a=Ql(i,Ro(s,2)),l=Ql(r,Ro(o,2)),c=Ao(i,Ro(s,2)),u=Ao(r,Ro(o,2)),h=da([ca(a,[n.numBoxes,1]),ca(l,[n.numBoxes,1]),ca(c,[n.numBoxes,1]),ca(u,[n.numBoxes,1])],1);if(n.numKeypoints)for(var d=0;d<n.numKeypoints;++d){var p=n.keypointCoordOffset+d*n.numValuesPerKeypoint,f=void 0,m=void 0;n.reverseOutputOrder?(f=Ju(ma(t,[0,p],[-1,1])),m=Ju(ma(t,[0,p+1],[-1,1]))):(m=Ju(ma(t,[0,p],[-1,1])),f=Ju(ma(t,[0,p+1],[-1,1])));var g=Ao(Po(Ro(f,n.xScale),e.w),e.x),y=Ao(Po(Ro(m,n.yScale),e.h),e.y);h=da([h,ca(g,[n.numBoxes,1]),ca(y,[n.numBoxes,1])],1)}return h}))}(r,e,n),o=Co((function(){var t=i;return n.sigmoidScore?(null!=n.scoreClippingThresh&&(t=$a(i,-n.scoreClippingThresh,n.scoreClippingThresh)),t=fa(t)):t})),[4,Kwt(s,o,n)];case 1:return a=l.sent(),To([s,o]),[2,a]}}))}))}function Kwt(t,e,n){return uwt(this,void 0,void 0,(function(){var i,r,s,o,a,l,c,u,h,d,p,f;return hwt(this,(function(m){switch(m.label){case 0:return i=[],[4,t.data()];case 1:return r=m.sent(),[4,e.data()];case 2:for(s=m.sent(),o=0;o<n.numBoxes;++o)if(!(null!=n.minScoreThresh&&s[o]<n.minScoreThresh||(a=o*n.numCoords,l=Ywt(r[a+0],r[a+1],r[a+2],r[a+3],s[o],n.flipVertically,o),(c=l.locationData.relativeBoundingBox).width<0||c.height<0))){if(n.numKeypoints>0)for((u=l.locationData).relativeKeypoints=[],h=n.numKeypoints*n.numValuesPerKeypoint,d=0;d<h;d+=n.numValuesPerKeypoint)p=a+n.keypointCoordOffset+d,f={x:r[p+0],y:n.flipVertically?1-r[p+1]:r[p+1]},u.relativeKeypoints.push(f);i.push(l)}return[2,i]}}))}))}function Ywt(t,e,n,i,r,s,o){return{score:[r],ind:o,locationData:{relativeBoundingBox:{xMin:e,yMin:s?1-n:t,xMax:i,yMax:s?1-t:n,width:i-e,height:n-t}}}}function Zwt(t,e){return"none"===t?e:function(t){return 1/(1+Math.exp(-t))}(e)}function Jwt(t,e,n,i){return uwt(this,void 0,void 0,(function(){var r,s,o,a,l,c,u,h;return hwt(this,(function(d){switch(d.label){case 0:return n=n||e.flipHorizontally||!1,i=i||e.flipVertically||!1,r=t.size,s=r/e.numLandmarks,[4,t.data()];case 1:for(o=d.sent(),a=[],l=0;l<e.numLandmarks;++l)c=l*s,(h={x:0,y:0}).x=n?e.inputImageWidth-o[c]:o[c],s>1&&(h.y=i?e.inputImageHeight-o[c+1]:o[c+1]),s>2&&(h.z=o[c+2]),s>3&&(h.score=Zwt(e.visibilityActivation,o[c+3])),a.push(h);for(u=0;u<a.length;++u)(h=a[u]).x=h.x/e.inputImageWidth,h.y=h.y/e.inputImageHeight,h.z=h.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}}))}))}function Qwt(t,e,n){var i=t.width,r=t.height,s=t.rotation;if(null==n.rotation&&null==n.rotationDegree||(s=function(t,e){return null!=e.rotation?t+=e.rotation:null!=e.rotationDegree&&(t+=Math.PI*e.rotationDegree/180),Iwt(t)}(s,n)),0===s)t.xCenter=t.xCenter+i*n.shiftX,t.yCenter=t.yCenter+r*n.shiftY;else{var o=(e.width*i*n.shiftX*Math.cos(s)-e.height*r*n.shiftY*Math.sin(s))/e.width,a=(e.width*i*n.shiftX*Math.sin(s)+e.height*r*n.shiftY*Math.cos(s))/e.height;t.xCenter=t.xCenter+o,t.yCenter=t.yCenter+a}if(n.squareLong){var l=Math.max(i*e.width,r*e.height);i=l/e.width,r=l/e.height}else if(n.squareShort){var c=Math.min(i*e.width,r*e.height);i=c/e.width,r=c/e.height}return t.width=i*n.scaleX,t.height=r*n.scaleY,t}var tSt=function(){function t(t){this.alpha=t,this.initialized=!1}return t.prototype.apply=function(t,e){var n;return this.initialized?n=null==e?this.storedValue+this.alpha*(t-this.storedValue):this.storedValue+this.alpha*e*Math.asinh((t-this.storedValue)/e):(n=t,this.initialized=!0),this.rawValue=t,this.storedValue=n,n},t.prototype.applyWithAlpha=function(t,e,n){return this.alpha=e,this.apply(t,n)},t.prototype.hasLastRawValue=function(){return this.initialized},t.prototype.lastRawValue=function(){return this.rawValue},t.prototype.reset=function(){this.initialized=!1},t}(),eSt=function(){function t(t){this.frequency=t.frequency,this.minCutOff=t.minCutOff,this.beta=t.beta,this.thresholdCutOff=t.thresholdCutOff,this.thresholdBeta=t.thresholdBeta,this.derivateCutOff=t.derivateCutOff,this.x=new tSt(this.getAlpha(this.minCutOff)),this.dx=new tSt(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return t.prototype.apply=function(t,e,n){if(null==t)return t;var i=Math.trunc(e);if(this.lastTimestamp>=i)return t;0!==this.lastTimestamp&&0!==i&&(this.frequency=1/(1e-6*(i-this.lastTimestamp))),this.lastTimestamp=i;var r=this.x.hasLastRawValue()?(t-this.x.lastRawValue())*n*this.frequency:0,s=this.dx.applyWithAlpha(r,this.getAlpha(this.derivateCutOff)),o=this.minCutOff+this.beta*Math.abs(s),a=null!=this.thresholdCutOff?this.thresholdCutOff+this.thresholdBeta*Math.abs(s):null;return this.x.applyWithAlpha(t,this.getAlpha(o),a)},t.prototype.getAlpha=function(t){return 1/(1+this.frequency/(2*Math.PI*t))},t}(),nSt=function(){function t(t){this.config=t}return t.prototype.apply=function(t,e,n){var i=this;if(null==t)return this.reset(),null;this.initializeFiltersIfEmpty(t);var r=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return dwt([],t,!0);r=1/n}return t.map((function(t,n){var s=cwt(cwt({},t),{x:i.xFilters[n].apply(t.x,e,r),y:i.yFilters[n].apply(t.y,e,r)});return null!=t.z&&(s.z=i.zFilters[n].apply(t.z,e,r)),s}))},t.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},t.prototype.initializeFiltersIfEmpty=function(t){var e=this;null!=this.xFilters&&this.xFilters.length===t.length||(this.xFilters=t.map((function(t){return new eSt(e.config)})),this.yFilters=t.map((function(t){return new eSt(e.config)})),this.zFilters=t.map((function(t){return new eSt(e.config)})))},t}(),iSt=function(){function t(t){this.config=t,this.window=[],this.lowPassFilter=new tSt(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return t.prototype.apply=function(t,e,n){if(null==t)return t;var i,r=Math.trunc(e);if(this.lastTimestamp>=r)return t;if(-1===this.lastTimestamp)i=1;else{for(var s=t*n-this.lastValue*this.lastValueScale,o=r-this.lastTimestamp,a=s,l=o,c=(1+this.window.length)*(1e6/30),u=0,h=this.window;u<h.length;u++){var d=h[u];if(l+d.duration>c)break;a+=d.distance,l+=d.duration}var p=a/(1e-6*l);i=1-1/(1+this.config.velocityScale*Math.abs(p)),this.window.unshift({distance:s,duration:o}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=t,this.lastValueScale=n,this.lastTimestamp=r,this.lowPassFilter.applyWithAlpha(t,i)},t}(),rSt=function(){function t(t){this.config=t}return t.prototype.apply=function(t,e,n){var i=this;if(null==t)return this.reset(),null;var r=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return dwt([],t,!0);r=1/n}return this.initializeFiltersIfEmpty(t),t.map((function(t,n){var s=cwt(cwt({},t),{x:i.xFilters[n].apply(t.x,e,r),y:i.yFilters[n].apply(t.y,e,r)});return null!=t.z&&(s.z=i.zFilters[n].apply(t.z,e,r)),s}))},t.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},t.prototype.initializeFiltersIfEmpty=function(t){var e=this;null!=this.xFilters&&this.xFilters.length===t.length||(this.xFilters=t.map((function(t){return new iSt(e.config)})),this.yFilters=t.map((function(t){return new iSt(e.config)})),this.zFilters=t.map((function(t){return new iSt(e.config)})))},t}(),sSt=function(){function t(t){if(null!=t.velocityFilter)this.keypointsFilter=new rSt(t.velocityFilter);else{if(null==t.oneEuroFilter)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(t,"."));this.keypointsFilter=new nSt(t.oneEuroFilter)}}return t.prototype.apply=function(t,e,n,i,r){if(void 0===i&&(i=!1),null==t)return this.keypointsFilter.reset(),null;var s=null!=r?function(t,e){return(t.width*e.width+t.height*e.height)/2}(r,n):1,o=i?jwt(t,n):t,a=this.keypointsFilter.apply(o,e,s);return i?function(t,e){return t.map((function(t){var n=cwt(cwt({},t),{x:t.x/e.width,y:t.y/e.height});return null!=t.z&&(t.z=t.z/e.width),n}))}(a,n):a},t}(),oSt=function(){function t(t){this.alpha=t.alpha}return t.prototype.apply=function(t){var e=this;if(null==t)return this.visibilityFilters=null,null;null!=this.visibilityFilters&&this.visibilityFilters.length===t.length||(this.visibilityFilters=t.map((function(t){return new tSt(e.alpha)})));for(var n=[],i=0;i<t.length;++i){var r=t[i],s=cwt({},r);s.score=this.visibilityFilters[i].apply(r.score),n.push(s)}return n},t}(),aSt={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},lSt={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},cSt={maxPoses:1,flipHorizontal:!1},uSt={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},hSt={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},dSt={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},pSt={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},fSt={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},mSt={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},gSt={kernelSize:7,minConfidenceToRefine:.5},ySt={alpha:.1},bSt={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},vSt={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},xSt={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},wSt={activation:"none"},SSt={combineWithPreviousRatio:.7},kSt=function(){function t(t){this.mask=t}return t.prototype.toCanvasImageSource=function(){return uwt(this,void 0,void 0,(function(){return hwt(this,(function(t){return[2,xwt(this.mask)]}))}))},t.prototype.toImageData=function(){return uwt(this,void 0,void 0,(function(){return hwt(this,(function(t){return[2,wwt(this.mask)]}))}))},t.prototype.toTensor=function(){return uwt(this,void 0,void 0,(function(){return hwt(this,(function(t){return[2,this.mask]}))}))},t.prototype.getUnderlyingType=function(){return"tensor"},t}();function CSt(t){return kwt(t),"person"}var TSt=function(){function t(t,e,n,i,r,s){this.detectorModel=t,this.landmarkModel=e,this.enableSmoothing=n,this.enableSegmentation=i,this.smoothSegmentation=r,this.modelType=s,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(t){null==t.reduceBoxesInLowestLayer&&(t.reduceBoxesInLowestLayer=!1),null==t.interpolatedScaleAspectRatio&&(t.interpolatedScaleAspectRatio=1),null==t.fixedAnchorSize&&(t.fixedAnchorSize=!1);for(var e=[],n=0;n<t.numLayers;){for(var i=[],r=[],s=[],o=[],a=n;a<t.strides.length&&t.strides[a]===t.strides[n];){var l=Uwt(t.minScale,t.maxScale,a,t.strides.length);if(0===a&&t.reduceBoxesInLowestLayer)s.push(1),s.push(2),s.push(.5),o.push(.1),o.push(l),o.push(l);else{for(var c=0;c<t.aspectRatios.length;++c)s.push(t.aspectRatios[c]),o.push(l);if(t.interpolatedScaleAspectRatio>0){var u=a===t.strides.length-1?1:Uwt(t.minScale,t.maxScale,a+1,t.strides.length);o.push(Math.sqrt(l*u)),s.push(t.interpolatedScaleAspectRatio)}}a++}for(var h=0;h<s.length;++h){var d=Math.sqrt(s[h]);i.push(o[h]/d),r.push(o[h]*d)}var p=0,f=0;if(t.featureMapHeight.length>0)p=t.featureMapHeight[n],f=t.featureMapWidth[n];else{var m=t.strides[n];p=Math.ceil(t.inputSizeHeight/m),f=Math.ceil(t.inputSizeWidth/m)}for(var g=0;g<p;++g)for(var y=0;y<f;++y)for(var b=0;b<i.length;++b){var v={xCenter:(y+t.anchorOffsetX)/f,yCenter:(g+t.anchorOffsetY)/p,width:0,height:0};t.fixedAnchorSize?(v.width=1,v.height=1):(v.width=r[b],v.height=i[b]),e.push(v)}n=a}return e}(aSt);var o=ih(this.anchors.map((function(t){return t.width}))),a=ih(this.anchors.map((function(t){return t.height}))),l=ih(this.anchors.map((function(t){return t.xCenter}))),c=ih(this.anchors.map((function(t){return t.yCenter})));this.anchorTensor={x:l,y:c,w:o,h:a},this.prevFilteredSegmentationMask=this.enableSegmentation?rh([],[0,0]):null}return t.prototype.estimatePoses=function(t,e,n){return uwt(this,void 0,void 0,(function(){var i,r,s,o,a,l,c,u,h,d,p,f,m,g,y,b,v,x,w,S,k,C,T;return hwt(this,(function(_){switch(_.label){case 0:return i=function(t){var e;if(null==(e=null==t?cSt:cwt({},t)).maxPoses&&(e.maxPoses=1),e.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(e.maxPoses,". Should be > 0."));if(e.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return e}(e),null==t?(this.reset(),[2,[]]):(this.maxPoses=i.maxPoses,this.timestamp=null!=n?1e3*n:Vwt(t)?1e6*t.currentTime:null,r=$wt(t),s=Co((function(){return vo(Awt(t),"float32")})),null!=(o=this.regionOfInterest)?[3,2]:[4,this.detectPose(s)]);case 1:if(0===(a=_.sent()).length)return this.reset(),s.dispose(),[2,[]];l=a[0],o=this.poseDetectionToRoi(l,r),_.label=2;case 2:return[4,this.poseLandmarksByRoi(o,s)];case 3:return c=_.sent(),s.dispose(),null==c?(this.reset(),[2,[]]):(u=c.landmarks,h=c.auxiliaryLandmarks,d=c.poseScore,p=c.worldLandmarks,f=c.segmentationMask,m=this.poseLandmarkFiltering(u,h,p,r),g=m.actualLandmarksFiltered,y=m.auxiliaryLandmarksFiltered,b=m.actualWorldLandmarksFiltered,v=this.poseLandmarksToRoi(y,r),this.regionOfInterest=v,x=this.smoothSegmentation&&null!=f?this.poseSegmentationFiltering(f):f,null!=(w=null!=g?jwt(g,r):null)&&w.forEach((function(t,e){t.name=fwt[e]})),null!=(S=b)&&S.forEach((function(t,e){t.name=fwt[e]})),k={score:d,keypoints:w,keypoints3D:S},null!==x&&(C=Co((function(){var t=Ml(x,2),e=Ec(t,[[0,0],[0,0],[0,1]]);return bc(e,[[0,0],[0,0],[0,2]],"symmetric")})),this.smoothSegmentation||To(x),T={maskValueToLabel:CSt,mask:new kSt(C)},k.segmentation=T),[2,[k]])}}))}))},t.prototype.poseSegmentationFiltering=function(t){var e=this.prevFilteredSegmentationMask;return 0===e.size?this.prevFilteredSegmentationMask=t:(this.prevFilteredSegmentationMask=function(t,e,n){return"webgl"===Mo()?function(t,e,n){var i=n.combineWithPreviousRatio.toFixed(2),r={variableNames:["prevMask","newMask"],outputShape:t.shape,userCode:"\n  void main() {\n      ivec2 coords = getOutputCoords();\n      int height = coords[0];\n      int width = coords[1];\n\n      float prevMaskValue = getPrevMask(height, width);\n      float newMaskValue = getNewMask(height, width);\n\n      /*\n      * Assume p := newMaskValue\n      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)\n      * uncertainty alpha(p) =\n      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the\n      * uncertainty]\n      *\n      * The following polynomial approximates uncertainty alpha as a\n      * function of (p + 0.5):\n      */\n      const float c1 = 5.68842;\n      const float c2 = -0.748699;\n      const float c3 = -57.8051;\n      const float c4 = 291.309;\n      const float c5 = -624.717;\n      float t = newMaskValue - 0.5;\n      float x = t * t;\n\n      float uncertainty =\n        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));\n\n      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *\n                             (uncertainty * ".concat(i,");\n\n      setOutput(outputValue);\n    }\n")},s=Io();return Co((function(){var n=s.compileAndRun(r,[t,e]);return So().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}))}(t,e,n):Co((function(){var i=Ql(e,.5),r=Sl(i),s=Ql(1,yc(1,Po(r,Ao(5.68842,Po(r,Ao(-.748699,Po(r,Ao(-57.8051,Po(r,Ao(291.309,Po(r,-624.717)))))))))));return Ao(e,Po(Ql(t,e),Po(s,n.combineWithPreviousRatio)))}))}(e,t,SSt),To(t)),To(e),this.prevFilteredSegmentationMask},t.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),To([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},t.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(To(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=rh([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},t.prototype.detectPose=function(t){return uwt(this,void 0,void 0,(function(){var e,n,i,r,s,o,a,l,c,u;return hwt(this,(function(h){switch(h.label){case 0:return e=Bwt(t,dSt),n=e.imageTensor,i=e.padding,r=this.detectorModel.predict(n),s=function(t){return Co((function(){var e=function(t){return Co((function(){return[ma(t,[0,0,0],[1,-1,1]),ma(t,[0,0,1],[1,-1,-1])]}))}(t),n=e[0],i=e[1];return{boxes:Ju(i),logits:Ju(n)}}))}(r),o=s.boxes,[4,Xwt([a=s.logits,o],this.anchorTensor,uSt)];case 1:return 0===(l=h.sent()).length?(To([n,r,a,o]),[2,l]):[4,Hwt(l,this.maxPoses,.3)];case 2:return c=h.sent(),u=function(t,e){void 0===t&&(t=[]);for(var n=e.left,i=e.top,r=e.left+e.right,s=e.top+e.bottom,o=0;o<t.length;o++){var a=t[o],l=a.locationData.relativeBoundingBox,c=(l.xMin-n)/(1-r),u=(l.yMin-i)/(1-s),h=l.width/(1-r),d=l.height/(1-s);l.xMin=c,l.yMin=u,l.width=h,l.height=d,l.xMax=c+h,l.yMax=u+d;var p=a.locationData.relativeKeypoints;p&&p.forEach((function(t){var e=(t.x-n)/(1-r),o=(t.y-i)/(1-s);t.x=e,t.y=o}))}return t}(c,i),To([n,r,a,o]),[2,u]}}))}))},t.prototype.poseDetectionToRoi=function(t,e){return Qwt(Pwt(t,e,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),e,hSt)},t.prototype.poseLandmarksByRoi=function(t,e){return uwt(this,void 0,void 0,(function(){var n,i,r,s,o,a,l,c,u,h,d,p,f,m;return hwt(this,(function(g){switch(g.label){case 0:if(n=$wt(e),i=Bwt(e,pSt,t),r=i.imageTensor,s=i.padding,o=i.transformationMatrix,"lite"!==this.modelType&&"full"!==this.modelType&&"heavy"!==this.modelType)throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return a=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&a.push("activation_segmentation"),l=this.landmarkModel.execute(r,a),[4,this.tensorsToPoseLandmarksAndSegmentation(l)];case 1:return null==(c=g.sent())?(To(l),To(r),[2,null]):(u=c.landmarks,h=c.auxiliaryLandmarks,d=c.poseScore,p=c.worldLandmarks,f=c.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(n,t,s,o,u,h,p,f)]);case 2:return m=g.sent(),To(l),To(r),[2,cwt({poseScore:d},m)]}}))}))},t.prototype.poseLandmarksAndSegmentationInverseProjection=function(t,e,n,i,r,s,o,a){return uwt(this,void 0,void 0,(function(){var l,c,u,h,d,p;return hwt(this,(function(f){return l=qwt(r,n),c=qwt(s,n),u=Fwt(l,e),h=Fwt(c,e),d=function(t,e){for(var n=[],i=0,r=t;i<r.length;i++){var s=r[i],o=s.x,a=s.y,l=e.rotation,c=Math.cos(l)*o-Math.sin(l)*a,u=Math.sin(l)*o+Math.cos(l)*a,h=cwt({},s);h.x=c,h.y=u,n.push(h)}return n}(o,e),p=null,this.enableSegmentation&&(p=Co((function(){var e=a.shape,n=e[0],r=e[1],s=function(t){var e=Owt(new Array(16).fill(0));e[0][0]=Dwt(t,0,0),e[1][0]=-Dwt(t,0,1),e[2][0]=Dwt(t,0,2),e[3][0]=-Dwt(t,0,3),e[0][2]=Dwt(t,2,0),e[1][2]=-Dwt(t,2,1),e[2][2]=Dwt(t,2,2),e[3][2]=-Dwt(t,2,3),e[0][1]=-Dwt(t,1,0),e[1][1]=Dwt(t,1,1),e[2][1]=-Dwt(t,1,2),e[3][1]=Dwt(t,1,3),e[0][3]=-Dwt(t,3,0),e[1][3]=Dwt(t,3,1),e[2][3]=-Dwt(t,3,2),e[3][3]=Dwt(t,3,3);for(var n=t[0][0]*e[0][0]+t[1][0]*e[0][1]+t[2][0]*e[0][2]+t[3][0]*e[0][3],i=0;i<e.length;i++)for(var r=0;r<e.length;r++)e[i][r]/=n;return e}(i),o=rh(Nwt(s,{width:r,height:n},t),[1,8]),l=[1,n,r,1];return Ju(Bd.transform(ca(a,l),o,"bilinear","constant",0,[t.height,t.width]),[0,3])})),To(a)),[2,{landmarks:u,auxiliaryLandmarks:h,worldLandmarks:d,segmentationMask:p}]}))}))},t.prototype.tensorsToPoseLandmarksAndSegmentation=function(t){return uwt(this,void 0,void 0,(function(){var e,n,i,r,s,o,a,l,c,u,h,d,p;return hwt(this,(function(f){switch(f.label){case 0:return e=t[0],n=t[1],i=t[2],r=t[3],s=this.enableSegmentation?t[4]:null,[4,n.data()];case 1:return(o=f.sent()[0])<.5?[2,null]:[4,Jwt(e,fSt)];case 2:return[4,Gwt(f.sent(),i,gSt)];case 3:return a=f.sent(),l=a.slice(0,33),c=a.slice(33,35),[4,Jwt(r,mSt)];case 4:return u=f.sent(),h=u.slice(0,33),d=function(t,e,n){void 0===n&&(n=!0);for(var i=[],r=0;r<t.length;r++){var s=cwt({},e[r]);n&&(s.score=t[r].score),i.push(s)}return i}(l,h,!0),p=this.enableSegmentation?function(t,e,n){return Co((function(){var n=Ju(t,[0]),i=n.shape[2];if(1===i){var r=n;switch(e.activation){case"none":break;case"sigmoid":r=fa(r);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(e.activation,")"))}return Ju(r,[2])}throw new Error("Unsupported number of tensor channels ".concat(i))}))}(s,wSt):null,[2,{landmarks:l,auxiliaryLandmarks:c,poseScore:o,worldLandmarks:d,segmentationMask:p}]}}))}))},t.prototype.poseLandmarksToRoi=function(t,e){return Qwt(Pwt(Wwt(t),e,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),e,hSt)},t.prototype.poseLandmarkFiltering=function(t,e,n,i){var r,s,o;if(null!=this.timestamp&&this.enableSmoothing){var a=Pwt(Wwt(e),i,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});null==this.visibilitySmoothingFilterActual&&(this.visibilitySmoothingFilterActual=new oSt(ySt)),r=this.visibilitySmoothingFilterActual.apply(t),null==this.visibilitySmoothingFilterAuxiliary&&(this.visibilitySmoothingFilterAuxiliary=new oSt(ySt)),s=this.visibilitySmoothingFilterAuxiliary.apply(e),o=this.visibilitySmoothingFilterActual.apply(n),null==this.landmarksSmoothingFilterActual&&(this.landmarksSmoothingFilterActual=new sSt(bSt)),r=this.landmarksSmoothingFilterActual.apply(r,this.timestamp,i,!0,a),null==this.landmarksSmoothingFilterAuxiliary&&(this.landmarksSmoothingFilterAuxiliary=new sSt(vSt)),s=this.landmarksSmoothingFilterAuxiliary.apply(s,this.timestamp,i,!0,a),null==this.worldLandmarksSmoothingFilterActual&&(this.worldLandmarksSmoothingFilterActual=new sSt(xSt)),o=this.worldLandmarksSmoothingFilterActual.apply(n,this.timestamp)}else r=t,s=e,o=n;return{actualLandmarksFiltered:r,auxiliaryLandmarksFiltered:s,actualWorldLandmarksFiltered:o}},t}();function _St(t){return uwt(this,void 0,void 0,(function(){var e,n,i,r,s,o;return hwt(this,(function(a){switch(a.label){case 0:return e=function(t){var e=cwt({},null==t?lSt:t);if(null==e.enableSmoothing&&(e.enableSmoothing=lSt.enableSmoothing),null==e.enableSegmentation&&(e.enableSegmentation=lSt.enableSegmentation),null==e.smoothSegmentation&&(e.smoothSegmentation=lSt.smoothSegmentation),null==e.modelType&&(e.modelType=lSt.modelType),null==e.detectorModelUrl&&(e.detectorModelUrl=lSt.detectorModelUrl),null==e.landmarkModelUrl)switch(e.modelType){case"lite":e.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":e.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;default:e.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return e}(t),n="string"==typeof e.detectorModelUrl&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,i="string"==typeof e.landmarkModelUrl&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([C4(e.detectorModelUrl,{fromTFHub:n}),C4(e.landmarkModelUrl,{fromTFHub:i})])];case 1:return r=a.sent(),s=r[0],o=r[1],[2,new TSt(s,o,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}}))}))}var ESt,MSt,$St=function(){function t(t){!function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(t.maxTracks));if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(t.maxAge));if(void 0!==t.keypointTrackerParams){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(t.keypointTrackerParams.keypointConfidenceThreshold));if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(t.keypointTrackerParams.minNumberOfKeypoints));for(var e=0,n=t.keypointTrackerParams.keypointFalloff;e<n.length;e++){var i=n[e];if(i<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(i))}}}(t),this.tracks=[],this.maxTracks=t.maxTracks,this.maxAge=1e3*t.maxAge,this.minSimilarity=t.minSimilarity,this.nextID=1}return t.prototype.apply=function(t,e){this.filterOldTracks(e);var n=this.computeSimilarity(t);return this.assignTracks(t,n,e),this.updateTracks(e),t},t.prototype.getTracks=function(){return this.tracks.slice()},t.prototype.getTrackIDs=function(){return new Set(this.tracks.map((function(t){return t.id})))},t.prototype.filterOldTracks=function(t){var e=this;this.tracks=this.tracks.filter((function(n){return t-n.lastTimestamp<=e.maxAge}))},t.prototype.assignTracks=function(t,e,n){for(var i=Array.from(Array(e[0].length).keys()),r=[],s=0,o=Array.from(Array(t.length).keys());s<o.length;s++){var a=o[s];if(0!==i.length){for(var l=-1,c=-1,u=0,h=i;u<h.length;u++){var d=h[u],p=e[a][d];p>=this.minSimilarity&&p>c&&(l=d,c=p)}if(l>=0){var f=this.tracks[l];f=Object.assign(f,this.createTrack(t[a],n,f.id)),t[a].id=f.id;var m=i.indexOf(l);i.splice(m,1)}else r.push(a)}else r.push(a)}for(var g=0,y=r;g<y.length;g++){a=y[g];var b=this.createTrack(t[a],n);this.tracks.push(b),t[a].id=b.id}},t.prototype.updateTracks=function(t){this.tracks.sort((function(t,e){return e.lastTimestamp-t.lastTimestamp})),this.tracks=this.tracks.slice(0,this.maxTracks)},t.prototype.createTrack=function(t,e,n){var i={id:n||this.nextTrackID(),lastTimestamp:e,keypoints:dwt([],t.keypoints,!0).map((function(t){return cwt({},t)}))};return void 0!==t.box&&(i.box=cwt({},t.box)),i},t.prototype.nextTrackID=function(){var t=this.nextID;return this.nextID+=1,t},t.prototype.remove=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];this.tracks=this.tracks.filter((function(e){return!t.includes(e.id)}))},t.prototype.reset=function(){this.tracks=[]},t}(),ISt=function(t){function e(e){return t.call(this,e)||this}return lwt(e,t),e.prototype.computeSimilarity=function(t){var e=this;return 0===t.length||0===this.tracks.length?[[]]:t.map((function(t){return e.tracks.map((function(n){return e.iou(t,n)}))}))},e.prototype.iou=function(t,e){var n=Math.max(t.box.xMin,e.box.xMin),i=Math.max(t.box.yMin,e.box.yMin),r=Math.min(t.box.xMax,e.box.xMax),s=Math.min(t.box.yMax,e.box.yMax);if(n>=r||i>=s)return 0;var o=(r-n)*(s-i);return o/(t.box.width*t.box.height+e.box.width*e.box.height-o)},e}($St),ASt=function(t){function e(e){var n=t.call(this,e)||this;return n.keypointThreshold=e.keypointTrackerParams.keypointConfidenceThreshold,n.keypointFalloff=e.keypointTrackerParams.keypointFalloff,n.minNumKeyoints=e.keypointTrackerParams.minNumberOfKeypoints,n}return lwt(e,t),e.prototype.computeSimilarity=function(t){if(0===t.length||0===this.tracks.length)return[[]];for(var e=[],n=0,i=t;n<i.length;n++){for(var r=i[n],s=[],o=0,a=this.tracks;o<a.length;o++){var l=a[o];s.push(this.oks(r,l))}e.push(s)}return e},e.prototype.oks=function(t,e){for(var n=this.area(e.keypoints)+1e-6,i=0,r=0,s=0;s<t.keypoints.length;++s){var o=t.keypoints[s],a=e.keypoints[s];if(!(o.score<this.keypointThreshold||a.score<this.keypointThreshold)){r+=1;var l=Math.pow(o.x-a.x,2)+Math.pow(o.y-a.y,2),c=2*this.keypointFalloff[s];i+=Math.exp(-1*l/(2*n*Math.pow(c,2)))}}return r<this.minNumKeyoints?0:i/r},e.prototype.area=function(t){var e=this,n=t.filter((function(t){return t.score>e.keypointThreshold})),i=Math.min.apply(Math,dwt([1],n.map((function(t){return t.x})),!1)),r=Math.max.apply(Math,dwt([0],n.map((function(t){return t.x})),!1)),s=Math.min.apply(Math,dwt([1],n.map((function(t){return t.y})),!1));return(r-i)*(Math.max.apply(Math,dwt([0],n.map((function(t){return t.y})),!1))-s)},e}($St);function NSt(t){switch(t){case MSt.BlazePose:return fwt.reduce((function(t,e,n){return t[e]=n,t}),{});case MSt.PoseNet:case MSt.MoveNet:return pwt.reduce((function(t,e,n){return t[e]=n,t}),{});default:throw new Error("Model ".concat(t," is not supported."))}}!function(t){t.Keypoint="keypoint",t.BoundingBox="boundingBox"}(ESt||(ESt={})),function(t){t.MoveNet="MoveNet",t.BlazePose="BlazePose",t.PoseNet="PoseNet"}(MSt||(MSt={}));var RSt=Object.freeze({__proto__:null,getKeypointIndexBySide:function(t){switch(t){case MSt.BlazePose:return mwt;case MSt.PoseNet:case MSt.MoveNet:return gwt;default:throw new Error("Model ".concat(t," is not supported."))}},getAdjacentPairs:function(t){switch(t){case MSt.BlazePose:return bwt;case MSt.PoseNet:case MSt.MoveNet:return ywt;default:throw new Error("Model ".concat(t," is not supported."))}},getKeypointIndexByName:NSt}),PSt=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],OSt={modelType:"SinglePose.Lightning",enableSmoothing:!0},LSt={},DSt={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},FSt={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},zSt={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function BSt(t,e){var n,i,r,s;return t?e.width>e.height?(n=1,i=e.height/e.width,r=0,s=(e.width/2-e.height/2)/e.width):(n=e.width/e.height,i=1,r=(e.height/2-e.width/2)/e.height,s=0):e.width>e.height?(n=e.width/e.height,i=1,r=(e.height/2-e.width/2)/e.height,s=0):(n=1,i=e.height/e.width,r=0,s=(e.width/2-e.height/2)/e.width),{yMin:r,xMin:s,yMax:r+n,xMax:s+i,height:n,width:i}}function USt(t,e){var n={maxTracks:t.maxTracks,maxAge:t.maxAge,minSimilarity:t.minSimilarity};return null!=e.maxTracks&&(n.maxTracks=e.maxTracks),null!=e.maxAge&&(n.maxAge=e.maxAge),null!=e.minSimilarity&&(n.minSimilarity=e.minSimilarity),n}var VSt=function(){function t(t,e){this.moveNetModel=t,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=NSt(MSt.MoveNet),"SinglePose.Lightning"===e.modelType?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):"SinglePose.Thunder"===e.modelType&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel="MultiPose.Lightning"===e.modelType,this.multiPoseModel||(this.keypointFilter=new nSt(DSt),this.cropRegionFilterYMin=new tSt(.9),this.cropRegionFilterXMin=new tSt(.9),this.cropRegionFilterYMax=new tSt(.9),this.cropRegionFilterXMax=new tSt(.9)),this.enableSmoothing=e.enableSmoothing,e.minPoseScore?this.minPoseScore=e.minPoseScore:this.minPoseScore=.25,e.multiPoseMaxDimension?this.multiPoseMaxDimension=e.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=e.enableTracking,this.multiPoseModel&&this.enableTracking&&(e.trackerType===ESt.Keypoint?this.tracker=new ASt(e.trackerConfig):e.trackerType===ESt.BoundingBox&&(this.tracker=new ISt(e.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return t.prototype.runSinglePersonPoseModel=function(t){return uwt(this,void 0,void 0,(function(){var e,n,i,r,s;return hwt(this,(function(o){switch(o.label){case 0:if(4!==(e=this.moveNetModel.execute(t)).shape.length||1!==e.shape[0]||1!==e.shape[1]||17!==e.shape[2]||3!==e.shape[3])throw e.dispose(),new Error("Unexpected output shape from model: [".concat(e.shape,"]"));return"webgpu"===Mo()?[3,1]:(n=e.dataSync(),[3,3]);case 1:return[4,e.data()];case 2:n=o.sent(),o.label=3;case 3:for(e.dispose(),i={keypoints:[],score:0},r=0,s=0;s<17;++s)i.keypoints[s]={y:n[3*s],x:n[3*s+1],score:n[3*s+2]},i.keypoints[s].score>.2&&(++r,i.score+=i.keypoints[s].score);return r>0&&(i.score/=r),[2,i]}}))}))},t.prototype.runMultiPersonPoseModel=function(t){return uwt(this,void 0,void 0,(function(){var e,n,i,r,s,o,a,l;return hwt(this,(function(c){switch(c.label){case 0:if(3!==(e=this.moveNetModel.execute(t)).shape.length||1!==e.shape[0]||56!==e.shape[2])throw e.dispose(),new Error("Unexpected output shape from model: [".concat(e.shape,"]"));return"webgpu"===Mo()?[3,1]:(n=e.dataSync(),[3,3]);case 1:return[4,e.data()];case 2:n=c.sent(),c.label=3;case 3:for(e.dispose(),i=[],r=n.length/56,s=0;s<r;++s)for(i[s]={keypoints:[]},o=56*s+51,i[s].box={yMin:n[o],xMin:n[o+1],yMax:n[o+2],xMax:n[o+3],width:n[o+3]-n[o+1],height:n[o+2]-n[o]},a=56*s+55,i[s].score=n[a],i[s].keypoints=[],l=0;l<17;++l)i[s].keypoints[l]={y:n[56*s+3*l],x:n[56*s+3*l+1],score:n[56*s+3*l+2]};return[2,i]}}))}))},t.prototype.estimatePoses=function(t,e,n){return void 0===e&&(e=LSt),uwt(this,void 0,void 0,(function(){var i,r,s,o,a,l;return hwt(this,(function(c){switch(c.label){case 0:return e=function(t){return null==t?LSt:cwt({},t)}(e),null==t?(this.reset(),[2,[]]):(null==n?Vwt(t)&&(n=1e6*t.currentTime):n*=1e3,i=Awt(t),r=$wt(i),s=Ml(i,0),t instanceof Or||i.dispose(),o=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(s,r,n)]);case 1:return o=c.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(s,r,n)];case 3:o=c.sent(),c.label=4;case 4:for(a=0;a<o.length;++a)for(l=0;l<o[a].keypoints.length;++l)o[a].keypoints[l].name=pwt[l],o[a].keypoints[l].y*=r.height,o[a].keypoints[l].x*=r.width;return[2,o]}}))}))},t.prototype.estimateSinglePose=function(t,e,n){return uwt(this,void 0,void 0,(function(){var i,r,s,o,a=this;return hwt(this,(function(l){switch(l.label){case 0:return this.cropRegion||(this.cropRegion=BSt(null==this.cropRegion,e)),i=Co((function(){var e=rh([[a.cropRegion.yMin,a.cropRegion.xMin,a.cropRegion.yMax,a.cropRegion.xMax]]),n=fc([1],"int32"),i=[a.modelInputResolution.height,a.modelInputResolution.width];return vo(Bd.cropAndResize(t,e,n,i,"bilinear",0),"int32")})),t.dispose(),[4,this.runSinglePersonPoseModel(i)];case 1:if(r=l.sent(),i.dispose(),r.score<this.minPoseScore)return this.reset(),[2,[]];for(s=0;s<r.keypoints.length;++s)r.keypoints[s].y=this.cropRegion.yMin+r.keypoints[s].y*this.cropRegion.height,r.keypoints[s].x=this.cropRegion.xMin+r.keypoints[s].x*this.cropRegion.width;return null!=n&&this.enableSmoothing&&(r.keypoints=this.keypointFilter.apply(r.keypoints,n,1)),o=function(t,e,n,i){for(var r={},s=0,o=pwt;s<o.length;s++){var a=o[s];r[a]=[e[n[a]].y*i.height,e[n[a]].x*i.width]}if(function(t,e){return(t[e.left_hip].score>.2||t[e.right_hip].score>.2)&&(t[e.left_shoulder].score>.2||t[e.right_shoulder].score>.2)}(e,n)){var l=(r.left_hip[0]+r.right_hip[0])/2,c=(r.left_hip[1]+r.right_hip[1])/2,u=function(t,e,n,i,r){for(var s=["left_shoulder","right_shoulder","left_hip","right_hip"],o=0,a=0,l=0;l<s.length;l++)(p=Math.abs(i-n[s[l]][0]))>o&&(o=p),(f=Math.abs(r-n[s[l]][1]))>a&&(a=f);for(var c=0,u=0,h=0,d=Object.keys(n);h<d.length;h++){var p,f,m=d[h];t[e[m]].score<.2||((p=Math.abs(i-n[m][0]))>c&&(c=p),(f=Math.abs(r-n[m][1]))>u&&(u=f))}return[o,a,c,u]}(e,n,r,l,c),h=u[0],d=u[1],p=u[2],f=u[3],m=Math.max(1.9*d,1.9*h,1.2*p,1.2*f),g=[l-(m=Math.min(m,Math.max(c,i.width-c,l,i.height-l))),c-m];if(m>Math.max(i.width,i.height)/2)return BSt(null==t,i);var y=2*m;return{yMin:g[0]/i.height,xMin:g[1]/i.width,yMax:(g[0]+y)/i.height,xMax:(g[1]+y)/i.width,height:(g[0]+y)/i.height-g[0]/i.height,width:(g[1]+y)/i.width-g[1]/i.width}}return BSt(null==t,i)}(this.cropRegion,r.keypoints,this.keypointIndexByName,e),this.cropRegion=this.filterCropRegion(o),[2,[r]]}}))}))},t.prototype.estimateMultiplePoses=function(t,e,n){return uwt(this,void 0,void 0,(function(){var i,r,s,o,a,l,c,u,h,d,p,f=this;return hwt(this,(function(m){switch(m.label){case 0:return e.width>e.height?(r=this.multiPoseMaxDimension,s=Math.round(this.multiPoseMaxDimension*e.height/e.width),i=Bd.resizeBilinear(t,[s,r]),a=r,l=32*Math.ceil(s/32),o=Ec(i,[[0,0],[0,l-s],[0,0],[0,0]])):(r=Math.round(this.multiPoseMaxDimension*e.width/e.height),s=this.multiPoseMaxDimension,i=Bd.resizeBilinear(t,[s,r]),a=32*Math.ceil(r/32),l=s,o=Ec(i,[[0,0],[0,0],[0,a-r],[0,0]])),i.dispose(),t.dispose(),c=vo(o,"int32"),o.dispose(),[4,this.runMultiPersonPoseModel(c)];case 1:for(u=m.sent(),c.dispose(),u=u.filter((function(t){return t.score>=f.minPoseScore})),d=0;d<u.length;++d)for(h=0;h<u[d].keypoints.length;++h)u[d].keypoints[h].y*=l/s,u[d].keypoints[h].x*=a/r;if(this.enableTracking&&(this.tracker.apply(u,n),this.enableSmoothing)){for(d=0;d<u.length;++d)this.keypointFilterMap.has(u[d].id)||this.keypointFilterMap.set(u[d].id,new nSt(DSt)),u[d].keypoints=this.keypointFilterMap.get(u[d].id).apply(u[d].keypoints,n,1);p=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach((function(t,e){p.has(e)||f.keypointFilterMap.delete(e)}))}return[2,u]}}))}))},t.prototype.filterCropRegion=function(t){if(t){var e=this.cropRegionFilterYMin.apply(t.yMin),n=this.cropRegionFilterXMin.apply(t.xMin),i=this.cropRegionFilterYMax.apply(t.yMax),r=this.cropRegionFilterXMax.apply(t.xMax);return{yMin:e,xMin:n,yMax:i,xMax:r,height:i-e,width:r-n}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},t.prototype.dispose=function(){this.moveNetModel.dispose()},t.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},t.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},t}();function WSt(t){return void 0===t&&(t=OSt),uwt(this,void 0,void 0,(function(){var e,n,i,r;return hwt(this,(function(s){switch(s.label){case 0:return e=function(t){var e,n=null==t?OSt:cwt({},t);if(null==n.modelType)n.modelType="SinglePose.Lightning";else if(PSt.indexOf(n.modelType)<0)throw new Error("Invalid architecture ".concat(n.modelType,". ")+"Should be one of ".concat(PSt));if(null==n.enableSmoothing&&(n.enableSmoothing=!0),null!=n.minPoseScore&&(n.minPoseScore<0||n.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(null!=n.multiPoseMaxDimension&&(n.multiPoseMaxDimension%32!=0||n.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if("MultiPose.Lightning"===n.modelType&&null==n.enableTracking&&(n.enableTracking=!0),"MultiPose.Lightning"===n.modelType&&!0===n.enableTracking)if(null==n.trackerType&&(n.trackerType=ESt.BoundingBox),n.trackerType===ESt.Keypoint)null!=n.trackerConfig?n.trackerConfig=function(t){var e=USt(FSt,t);return e.keypointTrackerParams=cwt({},FSt.keypointTrackerParams),null!=t.keypointTrackerParams&&(null!=t.keypointTrackerParams.keypointConfidenceThreshold&&(e.keypointTrackerParams.keypointConfidenceThreshold=t.keypointTrackerParams.keypointConfidenceThreshold),null!=t.keypointTrackerParams.keypointFalloff&&(e.keypointTrackerParams.keypointFalloff=t.keypointTrackerParams.keypointFalloff),null!=t.keypointTrackerParams.minNumberOfKeypoints&&(e.keypointTrackerParams.minNumberOfKeypoints=t.keypointTrackerParams.minNumberOfKeypoints)),e}(n.trackerConfig):n.trackerConfig=FSt;else{if(n.trackerType!==ESt.BoundingBox)throw new Error("Tracker type not supported by MoveNet");null!=n.trackerConfig?n.trackerConfig=(e=n.trackerConfig,USt(zSt,e)):n.trackerConfig=zSt}return n}(t),i=!0,e.modelUrl?(i="string"==typeof e.modelUrl&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,C4(e.modelUrl,{fromTFHub:i})]):[3,2];case 1:return n=s.sent(),[3,4];case 2:return r=void 0,"SinglePose.Lightning"===e.modelType?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":"SinglePose.Thunder"===e.modelType?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":"MultiPose.Lightning"===e.modelType&&(r="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,C4(r,{fromTFHub:i})];case 3:n=s.sent(),s.label=4;case 4:return"webgl"===Mo()&&Y().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new VSt(n,e)]}}))}))}var HSt={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},jSt=["MobileNetV1","ResNet50"],GSt={MobileNetV1:[8,16],ResNet50:[16]},qSt=[8,16,32],XSt={MobileNetV1:[.5,.75,1],ResNet50:[1]},KSt=[1,2,4],YSt={maxPoses:1,flipHorizontal:!1},ZSt={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},JSt=[-123.15,-115.9,-103.06];function QSt(t){return Math.floor(t/2)}var tkt=function(){function t(t,e){this.priorityQueue=new Array(t),this.numberOfElements=-1,this.getElementValue=e}return t.prototype.enqueue=function(t){this.priorityQueue[++this.numberOfElements]=t,this.swim(this.numberOfElements)},t.prototype.dequeue=function(){var t=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,t},t.prototype.empty=function(){return-1===this.numberOfElements},t.prototype.size=function(){return this.numberOfElements+1},t.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},t.prototype.max=function(){return this.priorityQueue[0]},t.prototype.swim=function(t){for(;t>0&&this.less(QSt(t),t);)this.exchange(t,QSt(t)),t=QSt(t)},t.prototype.sink=function(t){for(;2*t<=this.numberOfElements;){var e=2*t;if(e<this.numberOfElements&&this.less(e,e+1)&&e++,!this.less(t,e))break;this.exchange(t,e),t=e}},t.prototype.getValueAt=function(t){return this.getElementValue(this.priorityQueue[t])},t.prototype.less=function(t,e){return this.getValueAt(t)<this.getValueAt(e)},t.prototype.exchange=function(t,e){var n=this.priorityQueue[t];this.priorityQueue[t]=this.priorityQueue[e],this.priorityQueue[e]=n},t}();function ekt(t,e,n,i,r,s){for(var o=s.shape,a=o[0],l=o[1],c=!0,u=Math.max(n-r,0),h=Math.min(n+r+1,a),d=u;d<h;++d){for(var p=Math.max(i-r,0),f=Math.min(i+r+1,l),m=p;m<f;++m)if(s.get(d,m,t)>e){c=!1;break}if(!c)break}return c}function nkt(t){return uwt(this,void 0,void 0,(function(){return hwt(this,(function(e){return[2,Promise.all(t.map((function(t){return t.buffer()})))]}))}))}function ikt(t,e,n,i){return{y:i.get(t,e,n),x:i.get(t,e,n+17)}}function rkt(t,e,n){var i=ikt(t.heatmapY,t.heatmapX,t.id,n),r=i.y,s=i.x;return{x:t.heatmapX*e+s,y:t.heatmapY*e+r}}function skt(t,e,n,i){var r=n.x,s=n.y;return t.some((function(t){var n,o,a,l,c=t.keypoints;return n=s,o=r,(a=c[i].y-n)*a+(l=c[i].x-o)*l<=e}))}var okt=pwt.reduce((function(t,e,n){return t[e]=n,t}),{}),akt=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map((function(t){var e=t[0],n=t[1];return[okt[e],okt[n]]})),lkt=akt.map((function(t){return t[1]})),ckt=akt.map((function(t){return t[0]}));function ukt(t,e,n){return t<e?e:t>n?n:t}function hkt(t,e,n,i){return{y:ukt(Math.round(t.y/e),0,n-1),x:ukt(Math.round(t.x/e),0,i-1)}}function dkt(t,e){return{x:t.x+e.x,y:t.y+e.y}}function pkt(t,e,n,i,r,s,o,a){void 0===a&&(a=2);for(var l=i.shape,c=l[0],u=l[1],h={y:e.y,x:e.x},d=dkt(h,function(t,e,n){var i=n.shape[2]/2;return{y:n.get(e.y,e.x,t),x:n.get(e.y,e.x,i+t)}}(t,hkt(h,s,c,u),o)),p=0;p<a;p++){var f=hkt(d,s,c,u),m=ikt(f.y,f.x,n,r);d=dkt({x:f.x*s,y:f.y*s},{x:m.x,y:m.y})}var g=hkt(d,s,c,u),y=i.get(g.y,g.x,n);return{y:d.y,x:d.x,name:pwt[n],score:y}}function fkt(t,e,n,i,r,s){var o=e.shape[2],a=lkt.length,l=new Array(o),c=t.part,u=t.score,h=rkt(c,i,n);l[c.id]={score:u,name:pwt[c.id],y:h.y,x:h.x};for(var d=a-1;d>=0;--d){var p=lkt[d],f=ckt[d];l[p]&&!l[f]&&(l[f]=pkt(d,l[p],f,e,n,i,s))}for(d=0;d<a;++d)p=ckt[d],f=lkt[d],l[p]&&!l[f]&&(l[f]=pkt(d,l[p],f,e,n,i,r));return l}function mkt(t,e,n){return n.reduce((function(n,i,r){var s=i.y,o=i.x,a=i.score;return skt(t,e,{y:s,x:o},r)||(n+=a),n}),0)/n.length}function gkt(t,e,n,i,r,s,o,a){return void 0===o&&(o=.5),void 0===a&&(a=20),uwt(this,void 0,void 0,(function(){var l,c,u,h,d,p,f,m,g,y,b,v;return hwt(this,(function(x){switch(x.label){case 0:return[4,nkt([t,e,n,i])];case 1:for(l=x.sent(),c=l[0],u=l[1],h=l[2],d=l[3],p=[],f=function(t,e,n){for(var i=n.shape,r=i[0],s=i[1],o=i[2],a=new tkt(r*s*o,(function(t){return t.score})),l=0;l<r;++l)for(var c=0;c<s;++c)for(var u=0;u<o;++u){var h=n.get(l,c,u);h<t||ekt(u,h,l,c,1,n)&&a.enqueue({score:h,part:{heatmapY:l,heatmapX:c,id:u}})}return a}(o,0,c),m=a*a;p.length<s&&!f.empty();)g=f.dequeue(),y=rkt(g.part,r,u),skt(p,m,y,g.part.id)||(b=fkt(g,c,u,r,h,d),v=mkt(p,m,b),p.push({keypoints:b,score:v}));return[2,p]}}))}))}function ykt(){for(var t,e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];switch(e.length){case 0:t="fn main() ";break;case 1:t="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return t}var bkt=function(){function t(t){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[t[0],1],this.dispatchLayout=fA(this.outputShape),this.dispatch=hA(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return t.prototype.getUserCode=function(){return"\n        ".concat(ykt("index")," {\n          if (index < uniforms.size) {\n            let y = B[index * 2];\n            let x = B[index * 2 + 1];\n            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;\n            result[index] = A[outIndex];\n          }\n        }\n        ")},t}();var vkt=function(){function t(t){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,2!==t.length||t[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(t));this.workgroupSize=[32,1,1],this.outputShape=t;var e=[t[0],1];this.dispatchLayout=fA(e),this.dispatch=hA(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return t.prototype.getUserCode=function(){return"\n    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {\n      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;\n      let outIndexX = outIndexY + uniforms.bShape.z;\n      let outY = i32(B[outIndexY]);\n      let outX = i32(B[outIndexX]);\n      return vec2<i32>(outY, outX);\n    }\n\n    ".concat(ykt("index")," {\n      if (index < uniforms.size) {\n        let indexY = index * ").concat(this.supportedLastDimension,";\n        let indexX = indexY + 1;\n        let heatmapY = A[indexY];\n        let heatmapX = A[indexX];\n        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);\n        result[indexY] = f32(out[0]);\n        result[indexX] = f32(out[1]);\n      }\n    }\n    ")},t}();function xkt(t){var e=t.shape,n=e[0],i=e[1],r=e[2];return Co((function(){var e,s,o=ca(t,[n*i,r]),a=Uo(o,0),l=Ml(Ro(a,xl(i,"int32")),1),c=Ml((e=a,s=i,Co((function(){var t=Ro(e,xl(s,"int32"));return Ql(e,Po(t,xl(s,"int32")))}))),1);return da([l,c],1)}))}function wkt(t,e,n){return Co((function(){var i=function(t,e){for(var n=[],i=0;i<pwt.length;i++){var r=Skt(t.get(i,0).valueOf(),t.get(i,1).valueOf(),i,e),s=r.x,o=r.y;n.push(o),n.push(s)}return rh(n,[pwt.length,2])}(t,n);return Ao(vo(Po(t.toTensor(),xl(e,"int32")),"float32"),i)}))}function Skt(t,e,n,i){return{y:i.get(t,e,n),x:i.get(t,e,n+pwt.length)}}function kkt(t,e,n){return uwt(this,void 0,void 0,(function(){var i,r,s,o,a,l,c,u,h,d;return hwt(this,(function(p){switch(p.label){case 0:return i=0,r=xkt(t),[4,Promise.all([t.buffer(),e.buffer(),r.buffer()])];case 1:return s=p.sent(),o=s[0],a=s[1],l=s[2],[4,(c=wkt(l,n,a)).buffer()];case 2:return u=p.sent(),h=Array.from(function(t,e){for(var n=e.shape[0],i=new Float32Array(n),r=0;r<n;r++){var s=e.get(r,0),o=e.get(r,1);i[r]=t.get(s,o,r)}return i}(o,l)),d=h.map((function(t,e){return i+=t,{y:u.get(e,0),x:u.get(e,1),score:t,name:pwt[e]}})),r.dispose(),c.dispose(),[2,{keypoints:d,score:i/d.length}]}}))}))}function Ckt(t,e,n){return uwt(this,void 0,void 0,(function(){var i,r,s;return hwt(this,(function(o){return i=xkt(t),r=function(t,e,n){return Co((function(){var i=function(t,e){if(Io()instanceof xA)return function(t,e){var n=Io(),i=new vkt(t.shape),r=n.runWebGPUProgram(i,[t,e],"float32");return So().makeTensorFromTensorInfo(r)}(t,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}(t,n);return Ao(vo(Po(t,xl(e,"int32")),"float32"),i)}))}(i,n,e),s=function(t,e){if(Io()instanceof xA)return function(t,e){var n=Io(),i=new bkt(e.shape),r=n.runWebGPUProgram(i,[t,e],"float32");return So().makeTensorFromTensorInfo(r)}(t,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}(t,i),[2,[r,s]]}))}))}function Tkt(t,e){return(t-1)%e==0}var _kt="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",Ekt="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function Mkt(t,e){return function(t,e){return(t-1)%e==0}(t,e)?t:Math.floor(t/e)*e+1}var $kt=function(){function t(t,e){this.posenetModel=t;var n=this.posenetModel.inputs[0].shape;c(-1===n[1]&&-1===n[2],(function(){return"Input shape [".concat(n[1],", ").concat(n[2],"] ")+"must both be equal to or -1"}));var i,r,s=(i=e.inputResolution,r=e.outputStride,{height:Mkt(i.height,r),width:Mkt(i.width,r)});!function(t){c(qSt.indexOf(t)>=0,(function(){return"outputStride of ".concat(t," is invalid. ")+"It must be either 8 or 16."}))}(e.outputStride),function(t,e){c(Tkt(t.height,e),(function(){return"height of ".concat(t.height," is invalid for output stride ")+"".concat(e,".")})),c(Tkt(t.width,e),(function(){return"width of ".concat(t.width," is invalid for output stride ")+"".concat(e,".")}))}(s,e.outputStride),this.inputResolution=s,this.outputStride=e.outputStride,this.architecture=e.architecture}return t.prototype.estimatePoses=function(t,e){return void 0===e&&(e=YSt),uwt(this,void 0,void 0,(function(){return hwt(this,(function(n){return[2,this.estimatePosesGPU(t,e,!1)]}))}))},t.prototype.estimatePosesGPU=function(t,e,n){return void 0===e&&(e=YSt),void 0===n&&(n=!1),uwt(this,void 0,void 0,(function(){var i,r,s,o,a,l,c,u,h,d,p,f,m,g,y,b,v,x;return hwt(this,(function(w){switch(w.label){case 0:return i=function(t){var e=t;if(null==e.maxPoses&&(e.maxPoses=1),e.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(e.maxPoses,". Should be > 0."));if(e.maxPoses>1){if((e=cwt(cwt({},ZSt),e)).scoreThreshold<0||e.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(e.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(e.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(e.nmsRadius,"."))}return e}(e),null==t?[2,n?[[],[]]:[]]:(this.maxPoses=i.maxPoses,r=Bwt(t,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),s=r.imageTensor,o=r.padding,a="ResNet50"===this.architecture?Ao(s,JSt):zwt(s,[-1,1]),l=this.posenetModel.predict(a),"ResNet50"===this.architecture?(c=Ju(l[2],[0]),u=Ju(l[3],[0]),h=Ju(l[0],[0]),d=Ju(l[1],[0])):(c=Ju(l[0],[0]),u=Ju(l[1],[0]),h=Ju(l[2],[0]),d=Ju(l[3],[0])),p=fa(u),1!==this.maxPoses?[3,5]:n?[4,Ckt(p,c,this.outputStride)]:[3,2]);case 1:return m=w.sent(),y=m[0],g=m[1],f=[y,g],[3,4];case 2:return[4,kkt(p,c,this.outputStride)];case 3:y=w.sent(),f=[y],w.label=4;case 4:return[3,7];case 5:if(n)throw new Error("GPU renderer only supports single pose!");return[4,gkt(p,c,h,d,this.outputStride,this.maxPoses,i.scoreThreshold,i.nmsRadius)];case 6:f=w.sent(),w.label=7;case 7:if(n){if(!0===i.flipHorizontal)throw new Error("flipHorizontal is not supported!");b=this.getCanvasInfo($wt(t),this.inputResolution,o)}else x=$wt(t),v=function(t,e,n,i){var r=e.height,s=e.width,o=r/(n.height*(1-i.top-i.bottom)),a=s/(n.width*(1-i.left-i.right)),l=-i.top*n.height,c=-i.left*n.width;if(1===a&&1===o&&0===l&&0===c)return t;for(var u=0,h=t;u<h.length;u++)for(var d=0,p=h[u].keypoints;d<p.length;d++){var f=p[d];f.x=(f.x+c)*a,f.y=(f.y+l)*o}return t}(f,x,this.inputResolution,o),i.flipHorizontal&&(v=function(t,e){for(var n=0,i=t;n<i.length;n++)for(var r=0,s=i[n].keypoints;r<s.length;r++){var o=s[r];o.x=e.width-1-o.x}return t}(v,x));return s.dispose(),a.dispose(),To(l),c.dispose(),u.dispose(),h.dispose(),d.dispose(),p.dispose(),[2,n?[f,b]:v]}}))}))},t.prototype.getCanvasInfo=function(t,e,n){var i=t.height,r=t.width,s=i/(e.height*(1-n.top-n.bottom)),o=r/(e.width*(1-n.left-n.right)),a=-n.top*e.height;return[-n.left*e.width,a,o,s,t.width,t.height]},t.prototype.dispose=function(){this.posenetModel.dispose()},t.prototype.reset=function(){},t}();function Ikt(t){return void 0===t&&(t=HSt),uwt(this,void 0,void 0,(function(){var e,n,i,r,s;return hwt(this,(function(o){switch(o.label){case 0:return"ResNet50"!==(e=function(t){var e=t||HSt;if(null==e.architecture&&(e.architecture="MobileNetV1"),jSt.indexOf(e.architecture)<0)throw new Error("Invalid architecture ".concat(e.architecture,". ")+"Should be one of ".concat(jSt));if(null==e.inputResolution&&(e.inputResolution={height:257,width:257}),null==e.outputStride&&(e.outputStride=16),GSt[e.architecture].indexOf(e.outputStride)<0)throw new Error("Invalid outputStride ".concat(e.outputStride,". ")+"Should be one of ".concat(GSt[e.architecture]," ")+"for architecture ".concat(e.architecture,"."));if(null==e.multiplier&&(e.multiplier=1),XSt[e.architecture].indexOf(e.multiplier)<0)throw new Error("Invalid multiplier ".concat(e.multiplier,". ")+"Should be one of ".concat(XSt[e.architecture]," ")+"for architecture ".concat(e.architecture,"."));if(null==e.quantBytes&&(e.quantBytes=4),KSt.indexOf(e.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(e.quantBytes,". ")+"Should be one of ".concat(KSt," ")+"for architecture ".concat(e.architecture,"."));if("MobileNetV1"===e.architecture&&32===e.outputStride&&1!==e.multiplier)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return e}(t)).architecture?[3,2]:(a=e.outputStride,l=e.quantBytes,c="model-stride".concat(a,".json"),n=4===l?Ekt+"float/"+c:Ekt+"quant".concat(l,"/")+c,[4,C4(e.modelUrl||n)]);case 1:return i=o.sent(),[2,new $kt(i,e)];case 2:return r=function(t,e,n){var i={1:"100",.75:"075",.5:"050"},r="model-stride".concat(t,".json");return 4===n?_kt+"float/".concat(i[e],"/")+r:_kt+"quant".concat(n,"/").concat(i[e],"/")+r}(e.outputStride,e.multiplier,e.quantBytes),[4,C4(e.modelUrl||r)];case 3:return s=o.sent(),[2,new $kt(s,e)]}var a,l,c}))}))}const Akt={MoveNet:.35,PoseNet:.5,BlazePose:.65},Nkt=["#ffffff","#800000","#469990","#e6194b","#42d4f4","#fabed4","#aaffc3","#9a6324","#000075","#f58231","#4363d8","#ffd8b1","#dcbeff","#808000","#ffe119","#911eb4","#bfef45","#f032e6","#3cb44b","#a9a9a9"];class Rkt{constructor(t,e){this.model=t,this.width=e,this.params={lineWidth:2,radius:4,scoreThreshold:Akt[t]},this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.width,this.ctx=this.canvas.getContext("2d")}drawKeypoint(t){if((null!=t.score?t.score:1)>=this.params.scoreThreshold){const e=new Path2D;e.arc(t.x,t.y,this.params.radius,0,2*Math.PI),this.ctx.fill(e),this.ctx.stroke(e)}}drawKeypoints(t){const e=RSt.getKeypointIndexBySide(this.model);this.ctx.fillStyle="Red",this.ctx.strokeStyle="White",this.ctx.lineWidth=this.params.lineWidth;for(const n of e.middle)this.drawKeypoint(t[n]);this.ctx.fillStyle="Green";for(const n of e.left)this.drawKeypoint(t[n]);this.ctx.fillStyle="Orange";for(const n of e.right)this.drawKeypoint(t[n])}drawSkeleton(t,e){const n=null!=e?Nkt[e%20]:"White";this.ctx.fillStyle=n,this.ctx.strokeStyle=n,this.ctx.lineWidth=this.params.lineWidth,RSt.getAdjacentPairs(this.model).forEach((([e,n])=>{const i=t[e],r=t[n],s=null!=i.score?i.score:1,o=null!=r.score?r.score:1,a=this.params.scoreThreshold||0;s>=a&&o>=a&&(this.ctx.beginPath(),this.ctx.moveTo(i.x,i.y),this.ctx.lineTo(r.x,r.y),this.ctx.stroke())}))}drawResult(t){if(null!=t.keypoints&&(this.drawKeypoints(t.keypoints),this.drawSkeleton(t.keypoints,t.id)),null!=t.keypoints3D)throw new Error("Keypoints 3D is not Implemented...")}drawResults(t){for(const e of t)this.drawResult(e)}drawImage(t){this.ctx.clearRect(0,0,t.width,t.width),this.canvas.height=t.height,this.canvas.width=t.width,this.ctx.putImageData(t,0,0)}render(t,e,n="ImageData"){return this.drawImage(t),this.drawResults(e),"ImageData"===n?this.ctx.getImageData(0,0,this.width,this.width):this.canvas.toDataURL("image/jpeg")}}function Pkt(t){let e,n,i;return{c(){e=IB("Using "),n=IB(t[2]),i=IB(" pose detector.")},m(t,r){TB(t,e,r),TB(t,n,r),TB(t,i,r)},p(t,e){4&e&&DB(n,t[2])},d(t){t&&_B(e),t&&_B(n),t&&_B(i)}}}function Okt(t){let e;return{c(){e=IB("")},m(t,n){TB(t,e,n)},p:Jz,d(t){t&&_B(e)}}}function Lkt(t){let e;function n(t,e){return t[3]?Okt:Pkt}let i=n(t),r=i(t);return{c(){e=MB("p"),r.c(),OB(e,"class","p-2 text-sm text-gray-600")},m(t,n){TB(t,e,n),r.m(e,null)},p(t,s){i===(i=n(t))&&r?r.p(t,s):(r.d(1),r=i(t),r&&(r.c(),r.m(e,null)))},d(t){t&&_B(e),r.d()}}}function Dkt(t){let e,n;return e=new DH({props:{title:t[0],loading:t[3],$$slots:{default:[Lkt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),8&n&&(i.loading=t[3]),28&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function Fkt(t,e,n){let i,r=Jz,s=()=>(r(),r=aB(a,(t=>n(3,i=t))),a);t.$$.on_destroy.push((()=>r()));let{title:o}=e,{loading:a}=e;s();let{model:l}=e;return t.$$set=t=>{"title"in t&&n(0,o=t.title),"loading"in t&&s(n(1,a=t.loading)),"model"in t&&n(2,l=t.model)},[o,a,l,i]}class zkt extends UU{constructor(t){super(),BU(this,t,Fkt,Dkt,rB,{title:0,loading:1,model:2})}}var Bkt,Ukt,Vkt;class Wkt extends i3{constructor(t="MoveNet",e){super(),this.model=t,this.modelConfig=e,this.title="Pose Detection",this.parameters={},this.serviceName="undefined",Bkt.set(this,void 0),this.$loading=new eK(!0,!0),this.$bodyParts=new eK("Full body",!1),Ukt.set(this,void 0),Vkt.set(this,void 0),WX(this,Ukt,new Rkt(MSt[t],224),"f"),WX(this,Vkt,new Rkt(MSt[t],60),"f"),this.start(),this.setup(t,e)}async setup(t,e){await Eo(),WX(this,Bkt,await function(t,e){return uwt(this,void 0,void 0,(function(){var n,i;return hwt(this,(function(r){switch(t){case MSt.PoseNet:return[2,Ikt(e)];case MSt.BlazePose:if(i=void 0,null!=(n=e)){if("tfjs"===n.runtime)return[2,_St(e)];if("mediapipe"===n.runtime)return[2,Mwt(e)];i=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(i));case MSt.MoveNet:return[2,WSt(e)];default:throw new Error("".concat(t," is not a supported model name."))}}))}))}(MSt[t],e),"f"),sK.info(`${t} loaded`),this.$loading.set(!1),this.start()}async predict(t){if(!VX(this,Bkt,"f"))return sK.error("Movenet is not loaded"),[];return await VX(this,Bkt,"f").estimatePoses(t)}postprocess(t,e){const n=e&&Array.isArray(e)&&e.length>0?(t,n)=>e.includes(n):()=>!0;return t.map((t=>{const e=t.keypoints[0];return t.keypoints.filter(n).reduce(((t,n)=>[...t,(n.x-e.x)/100,(n.y-e.y)/100]),[])})).reduce(((t,e)=>[...t,...e]),[])}thumbnail(t,e){return VX(this,Vkt,"f").render(t,e,"dataURL")}render(t,e){return VX(this,Ukt,"f").render(t,e)}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new zkt({target:e,props:{title:this.title,loading:this.$loading,model:this.model}}))}train(){throw new lK("Model `MobileNet` cannot be trained")}save(){throw new Error("MobileNet does not support saving")}load(){throw new Error("MobileNet does not support loading")}download(){throw new Error("MobileNet does not support downloading")}upload(){throw new Error("MobileNet does not support uploading")}}function Hkt(...t){return new Wkt(...t)}Bkt=new WeakMap,Ukt=new WeakMap,Vkt=new WeakMap,UX([aK],Wkt.prototype,"train",null),UX([aK],Wkt.prototype,"save",null),UX([aK],Wkt.prototype,"load",null),UX([aK],Wkt.prototype,"download",null),UX([aK],Wkt.prototype,"upload",null);var jkt={},Gkt={},qkt={};const Xkt="125",Kkt={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Ykt={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},Zkt=0,Jkt=1,Qkt=2,tCt=1,eCt=2,nCt=3,iCt=0,rCt=1,sCt=2,oCt=0,aCt=1,lCt=2,cCt=3,uCt=4,hCt=5,dCt=100,pCt=101,fCt=102,mCt=103,gCt=104,yCt=200,bCt=201,vCt=202,xCt=203,wCt=204,SCt=205,kCt=206,CCt=207,TCt=208,_Ct=209,ECt=210,MCt=0,$Ct=1,ICt=2,ACt=3,NCt=4,RCt=5,PCt=6,OCt=7,LCt=0,DCt=1,FCt=2,zCt=0,BCt=1,UCt=2,VCt=3,WCt=4,HCt=5,jCt=300,GCt=301,qCt=302,XCt=303,KCt=304,YCt=306,ZCt=307,JCt=1e3,QCt=1001,tTt=1002,eTt=1003,nTt=1004,iTt=1005,rTt=1006,sTt=1007,oTt=1008,aTt=1009,lTt=1010,cTt=1011,uTt=1012,hTt=1013,dTt=1014,pTt=1015,fTt=1016,mTt=1017,gTt=1018,yTt=1019,bTt=1020,vTt=1021,xTt=1022,wTt=1023,STt=1024,kTt=1025,CTt=wTt,TTt=1026,_Tt=1027,ETt=1028,MTt=1029,$Tt=1030,ITt=1031,ATt=1032,NTt=1033,RTt=33776,PTt=33777,OTt=33778,LTt=33779,DTt=35840,FTt=35841,zTt=35842,BTt=35843,UTt=36196,VTt=37492,WTt=37496,HTt=37808,jTt=37809,GTt=37810,qTt=37811,XTt=37812,KTt=37813,YTt=37814,ZTt=37815,JTt=37816,QTt=37817,t_t=37818,e_t=37819,n_t=37820,i_t=37821,r_t=36492,s_t=37840,o_t=37841,a_t=37842,l_t=37843,c_t=37844,u_t=37845,h_t=37846,d_t=37847,p_t=37848,f_t=37849,m_t=37850,g_t=37851,y_t=37852,b_t=37853,v_t=2300,x_t=2301,w_t=2302,S_t=2400,k_t=2401,C_t=2402,T_t=2500,__t=2501,E_t=3e3,M_t=3001,$_t=3007,I_t=3002,A_t=3003,N_t=3004,R_t=3005,P_t=3006,O_t=3200,L_t=3201,D_t=0,F_t=1,z_t=7680,B_t=519,U_t=35044,V_t=35048,W_t="300 es";function H_t(){}Object.assign(H_t.prototype,{addEventListener:function(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)},hasEventListener:function(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)},removeEventListener:function(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}},dispatchEvent:function(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,i=n.length;e<i;e++)n[e].call(this,t)}}});const j_t=[];for(let t=0;t<256;t++)j_t[t]=(t<16?"0":"")+t.toString(16);let G_t=1234567;const q_t={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(j_t[255&t]+j_t[t>>8&255]+j_t[t>>16&255]+j_t[t>>24&255]+"-"+j_t[255&e]+j_t[e>>8&255]+"-"+j_t[e>>16&15|64]+j_t[e>>24&255]+"-"+j_t[63&n|128]+j_t[n>>8&255]+"-"+j_t[n>>16&255]+j_t[n>>24&255]+j_t[255&i]+j_t[i>>8&255]+j_t[i>>16&255]+j_t[i>>24&255]).toUpperCase()},clamp:function(t,e,n){return Math.max(e,Math.min(n,t))},euclideanModulo:function(t,e){return(t%e+e)%e},mapLinear:function(t,e,n,i,r){return i+(t-e)*(r-i)/(n-e)},lerp:function(t,e,n){return(1-n)*t+n*e},damp:function(t,e,n,i){return q_t.lerp(t,e,1-Math.exp(-n*i))},pingpong:function(t,e=1){return e-Math.abs(q_t.euclideanModulo(t,2*e)-e)},smoothstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*(3-2*t)},smootherstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){return void 0!==t&&(G_t=t%2147483647),G_t=16807*G_t%2147483647,(G_t-1)/2147483646},degToRad:function(t){return t*q_t.DEG2RAD},radToDeg:function(t){return t*q_t.RAD2DEG},isPowerOfTwo:function(t){return 0==(t&t-1)&&0!==t},ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:function(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))},setQuaternionFromProperEuler:function(t,e,n,i,r){const s=Math.cos,o=Math.sin,a=s(n/2),l=o(n/2),c=s((e+i)/2),u=o((e+i)/2),h=s((e-i)/2),d=o((e-i)/2),p=s((i-e)/2),f=o((i-e)/2);switch(r){case"XYX":t.set(a*u,l*h,l*d,a*c);break;case"YZY":t.set(l*d,a*u,l*h,a*c);break;case"ZXZ":t.set(l*h,l*d,a*u,a*c);break;case"XZX":t.set(a*u,l*f,l*p,a*c);break;case"YXY":t.set(l*p,a*u,l*f,a*c);break;case"ZYZ":t.set(l*f,l*p,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}};class X_t{constructor(t=0,e=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,s=this.y-t.y;return this.x=r*n-s*i+t.x,this.y=r*i+s*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}class K_t{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,s,o,a,l){const c=this.elements;return c[0]=t,c[1]=i,c[2]=o,c[3]=e,c[4]=r,c[5]=a,c[6]=n,c[7]=s,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return(new this.constructor).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],o=n[3],a=n[6],l=n[1],c=n[4],u=n[7],h=n[2],d=n[5],p=n[8],f=i[0],m=i[3],g=i[6],y=i[1],b=i[4],v=i[7],x=i[2],w=i[5],S=i[8];return r[0]=s*f+o*y+a*x,r[3]=s*m+o*b+a*w,r[6]=s*g+o*v+a*S,r[1]=l*f+c*y+u*x,r[4]=l*m+c*b+u*w,r[7]=l*g+c*v+u*S,r[2]=h*f+d*y+p*x,r[5]=h*m+d*b+p*w,r[8]=h*g+d*v+p*S,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8];return e*s*c-e*o*l-n*r*c+n*o*a+i*r*l-i*s*a}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8],u=c*s-o*l,h=o*a-c*r,d=l*r-s*a,p=e*u+n*h+i*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return t[0]=u*f,t[1]=(i*l-c*n)*f,t[2]=(o*n-i*s)*f,t[3]=h*f,t[4]=(c*e-i*a)*f,t[5]=(i*r-o*e)*f,t[6]=d*f,t[7]=(n*a-l*e)*f,t[8]=(s*e-n*r)*f,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).copy(this).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,s,o){const a=Math.cos(r),l=Math.sin(r);return this.set(n*a,n*l,-n*(a*s+l*o)+s+t,-i*l,i*a,-i*(-l*s+a*o)+o+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),i=this.elements,r=i[0],s=i[3],o=i[6],a=i[1],l=i[4],c=i[7];return i[0]=e*r+n*a,i[3]=e*s+n*l,i[6]=e*o+n*c,i[1]=-n*r+e*a,i[4]=-n*s+e*l,i[7]=-n*o+e*c,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<9;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}}let Y_t;const Z_t={getDataURL:function(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===Y_t&&(Y_t=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),Y_t.width=t.width,Y_t.height=t.height;const n=Y_t.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=Y_t}return e.width>2048||e.height>2048?e.toDataURL("image/jpeg",.6):e.toDataURL("image/png")}};let J_t=0;function Q_t(t=Q_t.DEFAULT_IMAGE,e=Q_t.DEFAULT_MAPPING,n=QCt,i=QCt,r=rTt,s=oTt,o=wTt,a=aTt,l=1,c=E_t){Object.defineProperty(this,"id",{value:J_t++}),this.uuid=q_t.generateUUID(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=s,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new X_t(0,0),this.repeat=new X_t(1,1),this.center=new X_t(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new K_t,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.version=0,this.onUpdate=null}function tEt(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?Z_t.getDataURL(t):t.data?{data:Array.prototype.slice.call(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}Q_t.DEFAULT_IMAGE=void 0,Q_t.DEFAULT_MAPPING=jCt,Q_t.prototype=Object.assign(Object.create(H_t.prototype),{constructor:Q_t,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this},toJSON:function(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const i=this.image;if(void 0===i.uuid&&(i.uuid=q_t.generateUUID()),!e&&void 0===t.images[i.uuid]){let e;if(Array.isArray(i)){e=[];for(let t=0,n=i.length;t<n;t++)i[t].isDataTexture?e.push(tEt(i[t].image)):e.push(tEt(i[t]))}else e=tEt(i);t.images[i.uuid]={uuid:i.uuid,url:e}}n.image=i.uuid}return e||(t.textures[this.uuid]=n),n},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(t){if(this.mapping!==jCt)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case JCt:t.x=t.x-Math.floor(t.x);break;case QCt:t.x=t.x<0?0:1;break;case tTt:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case JCt:t.y=t.y-Math.floor(t.y);break;case QCt:t.y=t.y<0?0:1;break;case tTt:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}}),Object.defineProperty(Q_t.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}});class eEt{constructor(t=0,e=0,n=0,i=1){Object.defineProperty(this,"isVector4",{value:!0}),this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=this.w,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i+s[12]*r,this.y=s[1]*e+s[5]*n+s[9]*i+s[13]*r,this.z=s[2]*e+s[6]*n+s[10]*i+s[14]*r,this.w=s[3]*e+s[7]*n+s[11]*i+s[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,r;const s=.01,o=.1,a=t.elements,l=a[0],c=a[4],u=a[8],h=a[1],d=a[5],p=a[9],f=a[2],m=a[6],g=a[10];if(Math.abs(c-h)<s&&Math.abs(u-f)<s&&Math.abs(p-m)<s){if(Math.abs(c+h)<o&&Math.abs(u+f)<o&&Math.abs(p+m)<o&&Math.abs(l+d+g-3)<o)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,a=(d+1)/2,y=(g+1)/2,b=(c+h)/4,v=(u+f)/4,x=(p+m)/4;return t>a&&t>y?t<s?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(t),i=b/n,r=v/n):a>y?a<s?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(a),n=b/i,r=x/i):y<s?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(y),n=v/r,i=x/r),this.set(n,i,r,e),this}let y=Math.sqrt((m-p)*(m-p)+(u-f)*(u-f)+(h-c)*(h-c));return Math.abs(y)<.001&&(y=1),this.x=(m-p)/y,this.y=(u-f)/y,this.z=(h-c)/y,this.w=Math.acos((l+d+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}class nEt extends H_t{constructor(t,e,n){super(),Object.defineProperty(this,"isWebGLRenderTarget",{value:!0}),this.width=t,this.height=e,this.scissor=new eEt(0,0,t,e),this.scissorTest=!1,this.viewport=new eEt(0,0,t,e),n=n||{},this.texture=new Q_t(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=t,this.texture.image.height=e,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:rTt,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}setSize(t,e){this.width===t&&this.height===e||(this.width=t,this.height=e,this.texture.image.width=t,this.texture.image.height=e,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}class iEt{constructor(t=0,e=0,n=0,i=1){Object.defineProperty(this,"isQuaternion",{value:!0}),this._x=t,this._y=e,this._z=n,this._w=i}static slerp(t,e,n,i){return n.copy(t).slerp(e,i)}static slerpFlat(t,e,n,i,r,s,o){let a=n[i+0],l=n[i+1],c=n[i+2],u=n[i+3];const h=r[s+0],d=r[s+1],p=r[s+2],f=r[s+3];if(u!==f||a!==h||l!==d||c!==p){let t=1-o;const e=a*h+l*d+c*p+u*f,n=e>=0?1:-1,i=1-e*e;if(i>Number.EPSILON){const r=Math.sqrt(i),s=Math.atan2(r,e*n);t=Math.sin(t*s)/r,o=Math.sin(o*s)/r}const r=o*n;if(a=a*t+h*r,l=l*t+d*r,c=c*t+p*r,u=u*t+f*r,t===1-o){const t=1/Math.sqrt(a*a+l*l+c*c+u*u);a*=t,l*=t,c*=t,u*=t}}t[e]=a,t[e+1]=l,t[e+2]=c,t[e+3]=u}static multiplyQuaternionsFlat(t,e,n,i,r,s){const o=n[i],a=n[i+1],l=n[i+2],c=n[i+3],u=r[s],h=r[s+1],d=r[s+2],p=r[s+3];return t[e]=o*p+c*u+a*d-l*h,t[e+1]=a*p+c*h+l*u-o*d,t[e+2]=l*p+c*d+o*h-a*u,t[e+3]=c*p-o*u-a*h-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,i=t._y,r=t._z,s=t._order,o=Math.cos,a=Math.sin,l=o(n/2),c=o(i/2),u=o(r/2),h=a(n/2),d=a(i/2),p=a(r/2);switch(s){case"XYZ":this._x=h*c*u+l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u-h*d*p;break;case"YXZ":this._x=h*c*u+l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u+h*d*p;break;case"ZXY":this._x=h*c*u-l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u-h*d*p;break;case"ZYX":this._x=h*c*u-l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u+h*d*p;break;case"YZX":this._x=h*c*u+l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u-h*d*p;break;case"XZY":this._x=h*c*u-l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u+h*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],r=e[8],s=e[1],o=e[5],a=e[9],l=e[2],c=e[6],u=e[10],h=n+o+u;if(h>0){const t=.5/Math.sqrt(h+1);this._w=.25/t,this._x=(c-a)*t,this._y=(r-l)*t,this._z=(s-i)*t}else if(n>o&&n>u){const t=2*Math.sqrt(1+n-o-u);this._w=(c-a)/t,this._x=.25*t,this._y=(i+s)/t,this._z=(r+l)/t}else if(o>u){const t=2*Math.sqrt(1+o-n-u);this._w=(r-l)/t,this._x=(i+s)/t,this._y=.25*t,this._z=(a+c)/t}else{const t=2*Math.sqrt(1+u-n-o);this._w=(s-i)/t,this._x=(r+l)/t,this._y=(a+c)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<1e-6?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(q_t.clamp(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return void 0!==e?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,r=t._z,s=t._w,o=e._x,a=e._y,l=e._z,c=e._w;return this._x=n*c+s*o+i*l-r*a,this._y=i*c+s*a+r*o-n*l,this._z=r*c+s*l+n*a-i*o,this._w=s*c-n*o-i*a-r*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._x,i=this._y,r=this._z,s=this._w;let o=s*t._w+n*t._x+i*t._y+r*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=s,this._x=n,this._y=i,this._z=r,this;const a=1-o*o;if(a<=Number.EPSILON){const t=1-e;return this._w=t*s+e*this._w,this._x=t*n+e*this._x,this._y=t*i+e*this._y,this._z=t*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(a),c=Math.atan2(l,o),u=Math.sin((1-e)*c)/l,h=Math.sin(e*c)/l;return this._w=s*u+this._w*h,this._x=n*u+this._x*h,this._y=i*u+this._y*h,this._z=r*u+this._z*h,this._onChangeCallback(),this}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}class rEt{constructor(t=0,e=0,n=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(oEt.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(oEt.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=t.elements,s=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*s,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*s,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*s,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,r=t.x,s=t.y,o=t.z,a=t.w,l=a*e+s*i-o*n,c=a*n+o*e-r*i,u=a*i+r*n-s*e,h=-r*e-s*n-o*i;return this.x=l*a+h*-r+c*-o-u*-s,this.y=c*a+h*-s+u*-r-l*-o,this.z=u*a+h*-o+l*-s-c*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return void 0!==e?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,r=t.z,s=e.x,o=e.y,a=e.z;return this.x=i*a-r*o,this.y=r*s-n*a,this.z=n*o-i*s,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return sEt.copy(this).projectOnVector(t),this.sub(sEt)}reflect(t){return this.sub(sEt.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(q_t.clamp(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}const sEt=new rEt,oEt=new iEt;class aEt{constructor(t,e){Object.defineProperty(this,"isBox3",{value:!0}),this.min=void 0!==t?t:new rEt(1/0,1/0,1/0),this.max=void 0!==e?e:new rEt(-1/0,-1/0,-1/0)}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,o=-1/0;for(let a=0,l=t.length;a<l;a+=3){const l=t[a],c=t[a+1],u=t[a+2];l<e&&(e=l),c<n&&(n=c),u<i&&(i=u),l>r&&(r=l),c>s&&(s=c),u>o&&(o=u)}return this.min.set(e,n,i),this.max.set(r,s,o),this}setFromBufferAttribute(t){let e=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,o=-1/0;for(let a=0,l=t.count;a<l;a++){const l=t.getX(a),c=t.getY(a),u=t.getZ(a);l<e&&(e=l),c<n&&(n=c),u<i&&(i=u),l>r&&(r=l),c>s&&(s=c),u>o&&(o=u)}return this.min.set(e,n,i),this.max.set(r,s,o),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=uEt.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return void 0===t&&(console.warn("THREE.Box3: .getCenter() target is now required"),t=new rEt),this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return void 0===t&&(console.warn("THREE.Box3: .getSize() target is now required"),t=new rEt),this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;void 0!==e&&(null===e.boundingBox&&e.computeBoundingBox(),hEt.copy(e.boundingBox),hEt.applyMatrix4(t.matrixWorld),this.union(hEt));const n=t.children;for(let t=0,e=n.length;t<e;t++)this.expandByObject(n[t]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return void 0===e&&(console.warn("THREE.Box3: .getParameter() target is now required"),e=new rEt),e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,uEt),uEt.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(bEt),vEt.subVectors(this.max,bEt),dEt.subVectors(t.a,bEt),pEt.subVectors(t.b,bEt),fEt.subVectors(t.c,bEt),mEt.subVectors(pEt,dEt),gEt.subVectors(fEt,pEt),yEt.subVectors(dEt,fEt);let e=[0,-mEt.z,mEt.y,0,-gEt.z,gEt.y,0,-yEt.z,yEt.y,mEt.z,0,-mEt.x,gEt.z,0,-gEt.x,yEt.z,0,-yEt.x,-mEt.y,mEt.x,0,-gEt.y,gEt.x,0,-yEt.y,yEt.x,0];return!!lEt(e,dEt,pEt,fEt,vEt)&&(e=[1,0,0,0,1,0,0,0,1],!!lEt(e,dEt,pEt,fEt,vEt)&&(xEt.crossVectors(mEt,gEt),e=[xEt.x,xEt.y,xEt.z],lEt(e,dEt,pEt,fEt,vEt)))}clampPoint(t,e){return void 0===e&&(console.warn("THREE.Box3: .clampPoint() target is now required"),e=new rEt),e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return uEt.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return void 0===t&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(t.center),t.radius=.5*this.getSize(uEt).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(cEt[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),cEt[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),cEt[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),cEt[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),cEt[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),cEt[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),cEt[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),cEt[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(cEt)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}function lEt(t,e,n,i,r){for(let s=0,o=t.length-3;s<=o;s+=3){wEt.fromArray(t,s);const o=r.x*Math.abs(wEt.x)+r.y*Math.abs(wEt.y)+r.z*Math.abs(wEt.z),a=e.dot(wEt),l=n.dot(wEt),c=i.dot(wEt);if(Math.max(-Math.max(a,l,c),Math.min(a,l,c))>o)return!1}return!0}const cEt=[new rEt,new rEt,new rEt,new rEt,new rEt,new rEt,new rEt,new rEt],uEt=new rEt,hEt=new aEt,dEt=new rEt,pEt=new rEt,fEt=new rEt,mEt=new rEt,gEt=new rEt,yEt=new rEt,bEt=new rEt,vEt=new rEt,xEt=new rEt,wEt=new rEt,SEt=new aEt;class kEt{constructor(t,e){this.center=void 0!==t?t:new rEt,this.radius=void 0!==e?e:-1}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):SEt.setFromPoints(t).getCenter(n);let i=0;for(let e=0,r=t.length;e<r;e++)i=Math.max(i,n.distanceToSquared(t[e]));return this.radius=Math.sqrt(i),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return void 0===e&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),e=new rEt),e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return void 0===t&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),t=new aEt),this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}}const CEt=new rEt,TEt=new rEt,_Et=new rEt,EEt=new rEt,MEt=new rEt,$Et=new rEt,IEt=new rEt;class AEt{constructor(t,e){this.origin=void 0!==t?t:new rEt,this.direction=void 0!==e?e:new rEt(0,0,-1)}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return void 0===e&&(console.warn("THREE.Ray: .at() target is now required"),e=new rEt),e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,CEt)),this}closestPointToPoint(t,e){void 0===e&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),e=new rEt),e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=CEt.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(CEt.copy(this.direction).multiplyScalar(e).add(this.origin),CEt.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){TEt.copy(t).add(e).multiplyScalar(.5),_Et.copy(e).sub(t).normalize(),EEt.copy(this.origin).sub(TEt);const r=.5*t.distanceTo(e),s=-this.direction.dot(_Et),o=EEt.dot(this.direction),a=-EEt.dot(_Et),l=EEt.lengthSq(),c=Math.abs(1-s*s);let u,h,d,p;if(c>0)if(u=s*a-o,h=s*o-a,p=r*c,u>=0)if(h>=-p)if(h<=p){const t=1/c;u*=t,h*=t,d=u*(u+s*h+2*o)+h*(s*u+h+2*a)+l}else h=r,u=Math.max(0,-(s*h+o)),d=-u*u+h*(h+2*a)+l;else h=-r,u=Math.max(0,-(s*h+o)),d=-u*u+h*(h+2*a)+l;else h<=-p?(u=Math.max(0,-(-s*r+o)),h=u>0?-r:Math.min(Math.max(-r,-a),r),d=-u*u+h*(h+2*a)+l):h<=p?(u=0,h=Math.min(Math.max(-r,-a),r),d=h*(h+2*a)+l):(u=Math.max(0,-(s*r+o)),h=u>0?r:Math.min(Math.max(-r,-a),r),d=-u*u+h*(h+2*a)+l);else h=s>0?-r:r,u=Math.max(0,-(s*h+o)),d=-u*u+h*(h+2*a)+l;return n&&n.copy(this.direction).multiplyScalar(u).add(this.origin),i&&i.copy(_Et).multiplyScalar(h).add(TEt),d}intersectSphere(t,e){CEt.subVectors(t.center,this.origin);const n=CEt.dot(this.direction),i=CEt.dot(CEt)-n*n,r=t.radius*t.radius;if(i>r)return null;const s=Math.sqrt(r-i),o=n-s,a=n+s;return o<0&&a<0?null:o<0?this.at(a,e):this.at(o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);if(0===e)return!0;return t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,r,s,o,a;const l=1/this.direction.x,c=1/this.direction.y,u=1/this.direction.z,h=this.origin;return l>=0?(n=(t.min.x-h.x)*l,i=(t.max.x-h.x)*l):(n=(t.max.x-h.x)*l,i=(t.min.x-h.x)*l),c>=0?(r=(t.min.y-h.y)*c,s=(t.max.y-h.y)*c):(r=(t.max.y-h.y)*c,s=(t.min.y-h.y)*c),n>s||r>i?null:((r>n||n!=n)&&(n=r),(s<i||i!=i)&&(i=s),u>=0?(o=(t.min.z-h.z)*u,a=(t.max.z-h.z)*u):(o=(t.max.z-h.z)*u,a=(t.min.z-h.z)*u),n>a||o>i?null:((o>n||n!=n)&&(n=o),(a<i||i!=i)&&(i=a),i<0?null:this.at(n>=0?n:i,e)))}intersectsBox(t){return null!==this.intersectBox(t,CEt)}intersectTriangle(t,e,n,i,r){MEt.subVectors(e,t),$Et.subVectors(n,t),IEt.crossVectors(MEt,$Et);let s,o=this.direction.dot(IEt);if(o>0){if(i)return null;s=1}else{if(!(o<0))return null;s=-1,o=-o}EEt.subVectors(this.origin,t);const a=s*this.direction.dot($Et.crossVectors(EEt,$Et));if(a<0)return null;const l=s*this.direction.dot(MEt.cross(EEt));if(l<0)return null;if(a+l>o)return null;const c=-s*EEt.dot(IEt);return c<0?null:this.at(c/o,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}}class NEt{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,s,o,a,l,c,u,h,d,p,f,m){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=i,g[1]=r,g[5]=s,g[9]=o,g[13]=a,g[2]=l,g[6]=c,g[10]=u,g[14]=h,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new NEt).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/REt.setFromMatrixColumn(t,0).length(),r=1/REt.setFromMatrixColumn(t,1).length(),s=1/REt.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=0,e[8]=n[8]*s,e[9]=n[9]*s,e[10]=n[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,i=t.y,r=t.z,s=Math.cos(n),o=Math.sin(n),a=Math.cos(i),l=Math.sin(i),c=Math.cos(r),u=Math.sin(r);if("XYZ"===t.order){const t=s*c,n=s*u,i=o*c,r=o*u;e[0]=a*c,e[4]=-a*u,e[8]=l,e[1]=n+i*l,e[5]=t-r*l,e[9]=-o*a,e[2]=r-t*l,e[6]=i+n*l,e[10]=s*a}else if("YXZ"===t.order){const t=a*c,n=a*u,i=l*c,r=l*u;e[0]=t+r*o,e[4]=i*o-n,e[8]=s*l,e[1]=s*u,e[5]=s*c,e[9]=-o,e[2]=n*o-i,e[6]=r+t*o,e[10]=s*a}else if("ZXY"===t.order){const t=a*c,n=a*u,i=l*c,r=l*u;e[0]=t-r*o,e[4]=-s*u,e[8]=i+n*o,e[1]=n+i*o,e[5]=s*c,e[9]=r-t*o,e[2]=-s*l,e[6]=o,e[10]=s*a}else if("ZYX"===t.order){const t=s*c,n=s*u,i=o*c,r=o*u;e[0]=a*c,e[4]=i*l-n,e[8]=t*l+r,e[1]=a*u,e[5]=r*l+t,e[9]=n*l-i,e[2]=-l,e[6]=o*a,e[10]=s*a}else if("YZX"===t.order){const t=s*a,n=s*l,i=o*a,r=o*l;e[0]=a*c,e[4]=r-t*u,e[8]=i*u+n,e[1]=u,e[5]=s*c,e[9]=-o*c,e[2]=-l*c,e[6]=n*u+i,e[10]=t-r*u}else if("XZY"===t.order){const t=s*a,n=s*l,i=o*a,r=o*l;e[0]=a*c,e[4]=-u,e[8]=l*c,e[1]=t*u+r,e[5]=s*c,e[9]=n*u-i,e[2]=i*u-n,e[6]=o*c,e[10]=r*u+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(OEt,t,LEt)}lookAt(t,e,n){const i=this.elements;return zEt.subVectors(t,e),0===zEt.lengthSq()&&(zEt.z=1),zEt.normalize(),DEt.crossVectors(n,zEt),0===DEt.lengthSq()&&(1===Math.abs(n.z)?zEt.x+=1e-4:zEt.z+=1e-4,zEt.normalize(),DEt.crossVectors(n,zEt)),DEt.normalize(),FEt.crossVectors(zEt,DEt),i[0]=DEt.x,i[4]=FEt.x,i[8]=zEt.x,i[1]=DEt.y,i[5]=FEt.y,i[9]=zEt.y,i[2]=DEt.z,i[6]=FEt.z,i[10]=zEt.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],o=n[4],a=n[8],l=n[12],c=n[1],u=n[5],h=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],y=n[3],b=n[7],v=n[11],x=n[15],w=i[0],S=i[4],k=i[8],C=i[12],T=i[1],_=i[5],E=i[9],M=i[13],$=i[2],I=i[6],A=i[10],N=i[14],R=i[3],P=i[7],O=i[11],L=i[15];return r[0]=s*w+o*T+a*$+l*R,r[4]=s*S+o*_+a*I+l*P,r[8]=s*k+o*E+a*A+l*O,r[12]=s*C+o*M+a*N+l*L,r[1]=c*w+u*T+h*$+d*R,r[5]=c*S+u*_+h*I+d*P,r[9]=c*k+u*E+h*A+d*O,r[13]=c*C+u*M+h*N+d*L,r[2]=p*w+f*T+m*$+g*R,r[6]=p*S+f*_+m*I+g*P,r[10]=p*k+f*E+m*A+g*O,r[14]=p*C+f*M+m*N+g*L,r[3]=y*w+b*T+v*$+x*R,r[7]=y*S+b*_+v*I+x*P,r[11]=y*k+b*E+v*A+x*O,r[15]=y*C+b*M+v*N+x*L,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],r=t[12],s=t[1],o=t[5],a=t[9],l=t[13],c=t[2],u=t[6],h=t[10],d=t[14];return t[3]*(+r*a*u-i*l*u-r*o*h+n*l*h+i*o*d-n*a*d)+t[7]*(+e*a*d-e*l*h+r*s*h-i*s*d+i*l*c-r*a*c)+t[11]*(+e*l*u-e*o*d-r*s*u+n*s*d+r*o*c-n*l*c)+t[15]*(-i*o*c-e*a*u+e*o*h+i*s*u-n*s*h+n*a*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],a=t[6],l=t[7],c=t[8],u=t[9],h=t[10],d=t[11],p=t[12],f=t[13],m=t[14],g=t[15],y=u*m*l-f*h*l+f*a*d-o*m*d-u*a*g+o*h*g,b=p*h*l-c*m*l-p*a*d+s*m*d+c*a*g-s*h*g,v=c*f*l-p*u*l+p*o*d-s*f*d-c*o*g+s*u*g,x=p*u*a-c*f*a-p*o*h+s*f*h+c*o*m-s*u*m,w=e*y+n*b+i*v+r*x;if(0===w)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const S=1/w;return t[0]=y*S,t[1]=(f*h*r-u*m*r-f*i*d+n*m*d+u*i*g-n*h*g)*S,t[2]=(o*m*r-f*a*r+f*i*l-n*m*l-o*i*g+n*a*g)*S,t[3]=(u*a*r-o*h*r-u*i*l+n*h*l+o*i*d-n*a*d)*S,t[4]=b*S,t[5]=(c*m*r-p*h*r+p*i*d-e*m*d-c*i*g+e*h*g)*S,t[6]=(p*a*r-s*m*r-p*i*l+e*m*l+s*i*g-e*a*g)*S,t[7]=(s*h*r-c*a*r+c*i*l-e*h*l-s*i*d+e*a*d)*S,t[8]=v*S,t[9]=(p*u*r-c*f*r-p*n*d+e*f*d+c*n*g-e*u*g)*S,t[10]=(s*f*r-p*o*r+p*n*l-e*f*l-s*n*g+e*o*g)*S,t[11]=(c*o*r-s*u*r-c*n*l+e*u*l+s*n*d-e*o*d)*S,t[12]=x*S,t[13]=(c*f*i-p*u*i+p*n*h-e*f*h-c*n*m+e*u*m)*S,t[14]=(p*o*i-s*f*i-p*n*a+e*f*a+s*n*m-e*o*m)*S,t[15]=(s*u*i-c*o*i+c*n*a-e*u*a-s*n*h+e*o*h)*S,this}scale(t){const e=this.elements,n=t.x,i=t.y,r=t.z;return e[0]*=n,e[4]*=i,e[8]*=r,e[1]*=n,e[5]*=i,e[9]*=r,e[2]*=n,e[6]*=i,e[10]*=r,e[3]*=n,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),r=1-n,s=t.x,o=t.y,a=t.z,l=r*s,c=r*o;return this.set(l*s+n,l*o-i*a,l*a+i*o,0,l*o+i*a,c*o+n,c*a-i*s,0,l*a-i*o,c*a+i*s,r*a*a+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n){return this.set(1,e,n,0,t,1,n,0,t,e,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,r=e._x,s=e._y,o=e._z,a=e._w,l=r+r,c=s+s,u=o+o,h=r*l,d=r*c,p=r*u,f=s*c,m=s*u,g=o*u,y=a*l,b=a*c,v=a*u,x=n.x,w=n.y,S=n.z;return i[0]=(1-(f+g))*x,i[1]=(d+v)*x,i[2]=(p-b)*x,i[3]=0,i[4]=(d-v)*w,i[5]=(1-(h+g))*w,i[6]=(m+y)*w,i[7]=0,i[8]=(p+b)*S,i[9]=(m-y)*S,i[10]=(1-(h+f))*S,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let r=REt.set(i[0],i[1],i[2]).length();const s=REt.set(i[4],i[5],i[6]).length(),o=REt.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],PEt.copy(this);const a=1/r,l=1/s,c=1/o;return PEt.elements[0]*=a,PEt.elements[1]*=a,PEt.elements[2]*=a,PEt.elements[4]*=l,PEt.elements[5]*=l,PEt.elements[6]*=l,PEt.elements[8]*=c,PEt.elements[9]*=c,PEt.elements[10]*=c,e.setFromRotationMatrix(PEt),n.x=r,n.y=s,n.z=o,this}makePerspective(t,e,n,i,r,s){void 0===s&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,a=2*r/(e-t),l=2*r/(n-i),c=(e+t)/(e-t),u=(n+i)/(n-i),h=-(s+r)/(s-r),d=-2*s*r/(s-r);return o[0]=a,o[4]=0,o[8]=c,o[12]=0,o[1]=0,o[5]=l,o[9]=u,o[13]=0,o[2]=0,o[6]=0,o[10]=h,o[14]=d,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,n,i,r,s){const o=this.elements,a=1/(e-t),l=1/(n-i),c=1/(s-r),u=(e+t)*a,h=(n+i)*l,d=(s+r)*c;return o[0]=2*a,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-h,o[2]=0,o[6]=0,o[10]=-2*c,o[14]=-d,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<16;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const REt=new rEt,PEt=new NEt,OEt=new rEt(0,0,0),LEt=new rEt(1,1,1),DEt=new rEt,FEt=new rEt,zEt=new rEt;class BEt{constructor(t=0,e=0,n=0,i=BEt.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._order=i||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e,n){const i=q_t.clamp,r=t.elements,s=r[0],o=r[4],a=r[8],l=r[1],c=r[5],u=r[9],h=r[2],d=r[6],p=r[10];switch(e=e||this._order){case"XYZ":this._y=Math.asin(i(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-i(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-h,s),this._z=0);break;case"ZXY":this._x=Math.asin(i(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,p),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-i(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(i(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-h,s)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-i(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!1!==n&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return UEt.makeRotationFromQuaternion(t),this.setFromRotationMatrix(UEt,e,n)}setFromVector3(t,e){return this.set(t.x,t.y,t.z,e||this._order)}reorder(t){return VEt.setFromEuler(this),this.setFromQuaternion(VEt,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new rEt(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}BEt.DefaultOrder="XYZ",BEt.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];const UEt=new NEt,VEt=new iEt;class WEt{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}}let HEt=0;const jEt=new rEt,GEt=new iEt,qEt=new NEt,XEt=new rEt,KEt=new rEt,YEt=new rEt,ZEt=new iEt,JEt=new rEt(1,0,0),QEt=new rEt(0,1,0),tMt=new rEt(0,0,1),eMt={type:"added"},nMt={type:"removed"};function iMt(){Object.defineProperty(this,"id",{value:HEt++}),this.uuid=q_t.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=iMt.DefaultUp.clone();const t=new rEt,e=new BEt,n=new iEt,i=new rEt(1,1,1);e._onChange((function(){n.setFromEuler(e,!1)})),n._onChange((function(){e.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new NEt},normalMatrix:{value:new K_t}}),this.matrix=new NEt,this.matrixWorld=new NEt,this.matrixAutoUpdate=iMt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new WEt,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}iMt.DefaultUp=new rEt(0,1,0),iMt.DefaultMatrixAutoUpdate=!0,iMt.prototype=Object.assign(Object.create(H_t.prototype),{constructor:iMt,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(t){return this.quaternion.premultiply(t),this},setRotationFromAxisAngle:function(t,e){this.quaternion.setFromAxisAngle(t,e)},setRotationFromEuler:function(t){this.quaternion.setFromEuler(t,!0)},setRotationFromMatrix:function(t){this.quaternion.setFromRotationMatrix(t)},setRotationFromQuaternion:function(t){this.quaternion.copy(t)},rotateOnAxis:function(t,e){return GEt.setFromAxisAngle(t,e),this.quaternion.multiply(GEt),this},rotateOnWorldAxis:function(t,e){return GEt.setFromAxisAngle(t,e),this.quaternion.premultiply(GEt),this},rotateX:function(t){return this.rotateOnAxis(JEt,t)},rotateY:function(t){return this.rotateOnAxis(QEt,t)},rotateZ:function(t){return this.rotateOnAxis(tMt,t)},translateOnAxis:function(t,e){return jEt.copy(t).applyQuaternion(this.quaternion),this.position.add(jEt.multiplyScalar(e)),this},translateX:function(t){return this.translateOnAxis(JEt,t)},translateY:function(t){return this.translateOnAxis(QEt,t)},translateZ:function(t){return this.translateOnAxis(tMt,t)},localToWorld:function(t){return t.applyMatrix4(this.matrixWorld)},worldToLocal:function(t){return t.applyMatrix4(qEt.copy(this.matrixWorld).invert())},lookAt:function(t,e,n){t.isVector3?XEt.copy(t):XEt.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),KEt.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?qEt.lookAt(KEt,XEt,this.up):qEt.lookAt(XEt,KEt,this.up),this.quaternion.setFromRotationMatrix(qEt),i&&(qEt.extractRotation(i.matrixWorld),GEt.setFromRotationMatrix(qEt),this.quaternion.premultiply(GEt.invert()))},add:function(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(eMt)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)},remove:function(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(nMt)),this},clear:function(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(nMt)}return this.children.length=0,this},attach:function(t){return this.updateWorldMatrix(!0,!1),qEt.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),qEt.multiply(t.parent.matrixWorld)),t.applyMatrix4(qEt),t.updateWorldMatrix(!1,!1),this.add(t),this},getObjectById:function(t){return this.getObjectByProperty("id",t)},getObjectByName:function(t){return this.getObjectByProperty("name",t)},getObjectByProperty:function(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const i=this.children[n].getObjectByProperty(t,e);if(void 0!==i)return i}},getWorldPosition:function(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),t=new rEt),this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),t=new iEt),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(KEt,t,YEt),t},getWorldScale:function(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),t=new rEt),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(KEt,ZEt,t),t},getWorldDirection:function(t){void 0===t&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),t=new rEt),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()},raycast:function(){},traverse:function(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)},traverseVisible:function(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)},traverseAncestors:function(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)},updateWorldMatrix:function(t,e){const n=this.parent;if(!0===t&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateWorldMatrix(!1,!0)}},toJSON:function(t){const e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};function r(e,n){return void 0===e[n.uuid]&&(e[n.uuid]=n.toJSON(t)),n.uuid}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON()),this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const n=e.shapes;if(Array.isArray(n))for(let e=0,i=n.length;e<i;e++){const i=n[e];r(t.shapes,i)}else r(t.shapes,n)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let n=0,i=this.material.length;n<i;n++)e.push(r(t.materials,this.material[n]));i.material=e}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let e=0;e<this.children.length;e++)i.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let e=0;e<this.animations.length;e++){const n=this.animations[e];i.animations.push(r(t.animations,n))}}if(e){const e=s(t.geometries),i=s(t.materials),r=s(t.textures),o=s(t.images),a=s(t.shapes),l=s(t.skeletons),c=s(t.animations);e.length>0&&(n.geometries=e),i.length>0&&(n.materials=i),r.length>0&&(n.textures=r),o.length>0&&(n.images=o),a.length>0&&(n.shapes=a),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c)}return n.object=i,n;function s(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}},clone:function(t){return(new this.constructor).copy(this,t)},copy:function(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const n=t.children[e];this.add(n.clone())}return this}});const rMt=new rEt,sMt=new rEt,oMt=new K_t;class aMt{constructor(t,e){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=void 0!==t?t:new rEt(1,0,0),this.constant=void 0!==e?e:0}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=rMt.subVectors(n,e).cross(sMt.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return void 0===e&&(console.warn("THREE.Plane: .projectPoint() target is now required"),e=new rEt),e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){void 0===e&&(console.warn("THREE.Plane: .intersectLine() target is now required"),e=new rEt);const n=t.delta(rMt),i=this.normal.dot(n);if(0===i)return 0===this.distanceToPoint(t.start)?e.copy(t.start):void 0;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?void 0:e.copy(n).multiplyScalar(r).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return void 0===t&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),t=new rEt),t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||oMt.getNormalMatrix(t),i=this.coplanarPoint(rMt).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}}const lMt=new rEt,cMt=new rEt,uMt=new rEt,hMt=new rEt,dMt=new rEt,pMt=new rEt,fMt=new rEt,mMt=new rEt,gMt=new rEt,yMt=new rEt;class bMt{constructor(t,e,n){this.a=void 0!==t?t:new rEt,this.b=void 0!==e?e:new rEt,this.c=void 0!==n?n:new rEt}static getNormal(t,e,n,i){void 0===i&&(console.warn("THREE.Triangle: .getNormal() target is now required"),i=new rEt),i.subVectors(n,e),lMt.subVectors(t,e),i.cross(lMt);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,n,i,r){lMt.subVectors(i,e),cMt.subVectors(n,e),uMt.subVectors(t,e);const s=lMt.dot(lMt),o=lMt.dot(cMt),a=lMt.dot(uMt),l=cMt.dot(cMt),c=cMt.dot(uMt),u=s*l-o*o;if(void 0===r&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),r=new rEt),0===u)return r.set(-2,-1,-1);const h=1/u,d=(l*a-o*c)*h,p=(s*c-o*a)*h;return r.set(1-d-p,p,d)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,hMt),hMt.x>=0&&hMt.y>=0&&hMt.x+hMt.y<=1}static getUV(t,e,n,i,r,s,o,a){return this.getBarycoord(t,e,n,i,hMt),a.set(0,0),a.addScaledVector(r,hMt.x),a.addScaledVector(s,hMt.y),a.addScaledVector(o,hMt.z),a}static isFrontFacing(t,e,n,i){return lMt.subVectors(n,e),cMt.subVectors(t,e),lMt.cross(cMt).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return lMt.subVectors(this.c,this.b),cMt.subVectors(this.a,this.b),.5*lMt.cross(cMt).length()}getMidpoint(t){return void 0===t&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),t=new rEt),t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return bMt.getNormal(this.a,this.b,this.c,t)}getPlane(t){return void 0===t&&(console.warn("THREE.Triangle: .getPlane() target is now required"),t=new aMt),t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return bMt.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,r){return bMt.getUV(t,this.a,this.b,this.c,e,n,i,r)}containsPoint(t){return bMt.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return bMt.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){void 0===e&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),e=new rEt);const n=this.a,i=this.b,r=this.c;let s,o;dMt.subVectors(i,n),pMt.subVectors(r,n),mMt.subVectors(t,n);const a=dMt.dot(mMt),l=pMt.dot(mMt);if(a<=0&&l<=0)return e.copy(n);gMt.subVectors(t,i);const c=dMt.dot(gMt),u=pMt.dot(gMt);if(c>=0&&u<=c)return e.copy(i);const h=a*u-c*l;if(h<=0&&a>=0&&c<=0)return s=a/(a-c),e.copy(n).addScaledVector(dMt,s);yMt.subVectors(t,r);const d=dMt.dot(yMt),p=pMt.dot(yMt);if(p>=0&&d<=p)return e.copy(r);const f=d*l-a*p;if(f<=0&&l>=0&&p<=0)return o=l/(l-p),e.copy(n).addScaledVector(pMt,o);const m=c*p-d*u;if(m<=0&&u-c>=0&&d-p>=0)return fMt.subVectors(r,i),o=(u-c)/(u-c+(d-p)),e.copy(i).addScaledVector(fMt,o);const g=1/(m+f+h);return s=f*g,o=h*g,e.copy(n).addScaledVector(dMt,s).addScaledVector(pMt,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const vMt={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},xMt={h:0,s:0,l:0},wMt={h:0,s:0,l:0};function SMt(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}function kMt(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function CMt(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}class TMt{constructor(t,e,n){return Object.defineProperty(this,"isColor",{value:!0}),void 0===e&&void 0===n?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=q_t.euclideanModulo(t,1),e=q_t.clamp(e,0,1),n=q_t.clamp(n,0,1),0===e)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,r=2*n-i;this.r=SMt(r,i,t+1/3),this.g=SMt(r,i,t),this.b=SMt(r,i,t-1/3)}return this}setStyle(t){function e(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let t;const i=n[1],r=n[2];switch(i){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return this.r=Math.min(255,parseInt(t[1],10))/255,this.g=Math.min(255,parseInt(t[2],10))/255,this.b=Math.min(255,parseInt(t[3],10))/255,e(t[4]),this;if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return this.r=Math.min(100,parseInt(t[1],10))/100,this.g=Math.min(100,parseInt(t[2],10))/100,this.b=Math.min(100,parseInt(t[3],10))/100,e(t[4]),this;break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)){const n=parseFloat(t[1])/360,i=parseInt(t[2],10)/100,r=parseInt(t[3],10)/100;return e(t[4]),this.setHSL(n,i,r)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const t=n[1],e=t.length;if(3===e)return this.r=parseInt(t.charAt(0)+t.charAt(0),16)/255,this.g=parseInt(t.charAt(1)+t.charAt(1),16)/255,this.b=parseInt(t.charAt(2)+t.charAt(2),16)/255,this;if(6===e)return this.r=parseInt(t.charAt(0)+t.charAt(1),16)/255,this.g=parseInt(t.charAt(2)+t.charAt(3),16)/255,this.b=parseInt(t.charAt(4)+t.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=vMt[t];return void 0!==e?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=kMt(t.r),this.g=kMt(t.g),this.b=kMt(t.b),this}copyLinearToSRGB(t){return this.r=CMt(t.r),this.g=CMt(t.g),this.b=CMt(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){void 0===t&&(console.warn("THREE.Color: .getHSL() target is now required"),t={h:0,s:0,l:0});const e=this.r,n=this.g,i=this.b,r=Math.max(e,n,i),s=Math.min(e,n,i);let o,a;const l=(s+r)/2;if(s===r)o=0,a=0;else{const t=r-s;switch(a=l<=.5?t/(r+s):t/(2-r-s),r){case e:o=(n-i)/t+(n<i?6:0);break;case n:o=(i-e)/t+2;break;case i:o=(e-n)/t+4}o/=6}return t.h=o,t.s=a,t.l=l,t}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(t,e,n){return this.getHSL(xMt),xMt.h+=t,xMt.s+=e,xMt.l+=n,this.setHSL(xMt.h,xMt.s,xMt.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(xMt),t.getHSL(wMt);const n=q_t.lerp(xMt.h,wMt.h,e),i=q_t.lerp(xMt.s,wMt.s,e),r=q_t.lerp(xMt.l,wMt.l,e);return this.setHSL(n,i,r),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),!0===t.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}TMt.NAMES=vMt,TMt.prototype.r=1,TMt.prototype.g=1,TMt.prototype.b=1;class _Mt{constructor(t,e,n,i,r,s=0){this.a=t,this.b=e,this.c=n,this.normal=i&&i.isVector3?i:new rEt,this.vertexNormals=Array.isArray(i)?i:[],this.color=r&&r.isColor?r:new TMt,this.vertexColors=Array.isArray(r)?r:[],this.materialIndex=s}clone(){return(new this.constructor).copy(this)}copy(t){this.a=t.a,this.b=t.b,this.c=t.c,this.normal.copy(t.normal),this.color.copy(t.color),this.materialIndex=t.materialIndex;for(let e=0,n=t.vertexNormals.length;e<n;e++)this.vertexNormals[e]=t.vertexNormals[e].clone();for(let e=0,n=t.vertexColors.length;e<n;e++)this.vertexColors[e]=t.vertexColors[e].clone();return this}}let EMt=0;function MMt(){Object.defineProperty(this,"id",{value:EMt++}),this.uuid=q_t.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=aCt,this.side=iCt,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=wCt,this.blendDst=SCt,this.blendEquation=dCt,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=ACt,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=B_t,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=z_t,this.stencilZFail=z_t,this.stencilZPass=z_t,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}function $Mt(t){MMt.call(this),this.type="MeshBasicMaterial",this.color=new TMt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=LCt,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(t)}MMt.prototype=Object.assign(Object.create(H_t.prototype),{constructor:MMt,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if("shading"===e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===n;continue}const i=this[e];void 0!==i?i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}},toJSON:function(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function i(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(n.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,n.reflectivity=this.reflectivity,n.refractionRatio=this.refractionRatio,void 0!==this.combine&&(n.combine=this.combine),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.size&&(n.size=this.size),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==aCt&&(n.blending=this.blending),!0===this.flatShading&&(n.flatShading=this.flatShading),this.side!==iCt&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.morphTargets&&(n.morphTargets=!0),!0===this.morphNormals&&(n.morphNormals=!0),!0===this.skinning&&(n.skinning=!0),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e){const e=i(t.textures),r=i(t.images);e.length>0&&(n.textures=e),r.length>0&&(n.images=r)}return n},clone:function(){return(new this.constructor).copy(this)},copy:function(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.flatShading=t.flatShading,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let i=0;i!==t;++i)n[i]=e[i].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(MMt.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),$Mt.prototype=Object.create(MMt.prototype),$Mt.prototype.constructor=$Mt,$Mt.prototype.isMeshBasicMaterial=!0,$Mt.prototype.copy=function(t){return MMt.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this};const IMt=new rEt,AMt=new X_t;function NMt(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=!0===n,this.usage=U_t,this.updateRange={offset:0,count:-1},this.version=0}function RMt(t,e,n){NMt.call(this,new Int8Array(t),e,n)}function PMt(t,e,n){NMt.call(this,new Uint8Array(t),e,n)}function OMt(t,e,n){NMt.call(this,new Uint8ClampedArray(t),e,n)}function LMt(t,e,n){NMt.call(this,new Int16Array(t),e,n)}function DMt(t,e,n){NMt.call(this,new Uint16Array(t),e,n)}function FMt(t,e,n){NMt.call(this,new Int32Array(t),e,n)}function zMt(t,e,n){NMt.call(this,new Uint32Array(t),e,n)}function BMt(t,e,n){NMt.call(this,new Uint16Array(t),e,n)}function UMt(t,e,n){NMt.call(this,new Float32Array(t),e,n)}function VMt(t,e,n){NMt.call(this,new Float64Array(t),e,n)}function WMt(t){if(0===t.length)return-1/0;let e=t[0];for(let n=1,i=t.length;n<i;++n)t[n]>e&&(e=t[n]);return e}Object.defineProperty(NMt.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),Object.assign(NMt.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(t){return this.usage=t,this},copy:function(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this},copyAt:function(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[n+i];return this},copyArray:function(t){return this.array.set(t),this},copyColorsArray:function(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),r=new TMt),e[n++]=r.r,e[n++]=r.g,e[n++]=r.b}return this},copyVector2sArray:function(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),r=new X_t),e[n++]=r.x,e[n++]=r.y}return this},copyVector3sArray:function(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),r=new rEt),e[n++]=r.x,e[n++]=r.y,e[n++]=r.z}return this},copyVector4sArray:function(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let r=t[i];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),r=new eEt),e[n++]=r.x,e[n++]=r.y,e[n++]=r.z,e[n++]=r.w}return this},applyMatrix3:function(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)AMt.fromBufferAttribute(this,e),AMt.applyMatrix3(t),this.setXY(e,AMt.x,AMt.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)IMt.fromBufferAttribute(this,e),IMt.applyMatrix3(t),this.setXYZ(e,IMt.x,IMt.y,IMt.z);return this},applyMatrix4:function(t){for(let e=0,n=this.count;e<n;e++)IMt.x=this.getX(e),IMt.y=this.getY(e),IMt.z=this.getZ(e),IMt.applyMatrix4(t),this.setXYZ(e,IMt.x,IMt.y,IMt.z);return this},applyNormalMatrix:function(t){for(let e=0,n=this.count;e<n;e++)IMt.x=this.getX(e),IMt.y=this.getY(e),IMt.z=this.getZ(e),IMt.applyNormalMatrix(t),this.setXYZ(e,IMt.x,IMt.y,IMt.z);return this},transformDirection:function(t){for(let e=0,n=this.count;e<n;e++)IMt.x=this.getX(e),IMt.y=this.getY(e),IMt.z=this.getZ(e),IMt.transformDirection(t),this.setXYZ(e,IMt.x,IMt.y,IMt.z);return this},set:function(t,e=0){return this.array.set(t,e),this},getX:function(t){return this.array[t*this.itemSize]},setX:function(t,e){return this.array[t*this.itemSize]=e,this},getY:function(t){return this.array[t*this.itemSize+1]},setY:function(t,e){return this.array[t*this.itemSize+1]=e,this},getZ:function(t){return this.array[t*this.itemSize+2]},setZ:function(t,e){return this.array[t*this.itemSize+2]=e,this},getW:function(t){return this.array[t*this.itemSize+3]},setW:function(t,e){return this.array[t*this.itemSize+3]=e,this},setXY:function(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this},setXYZ:function(t,e,n,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this},setXYZW:function(t,e,n,i,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=r,this},onUpload:function(t){return this.onUploadCallback=t,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}}),RMt.prototype=Object.create(NMt.prototype),RMt.prototype.constructor=RMt,PMt.prototype=Object.create(NMt.prototype),PMt.prototype.constructor=PMt,OMt.prototype=Object.create(NMt.prototype),OMt.prototype.constructor=OMt,LMt.prototype=Object.create(NMt.prototype),LMt.prototype.constructor=LMt,DMt.prototype=Object.create(NMt.prototype),DMt.prototype.constructor=DMt,FMt.prototype=Object.create(NMt.prototype),FMt.prototype.constructor=FMt,zMt.prototype=Object.create(NMt.prototype),zMt.prototype.constructor=zMt,BMt.prototype=Object.create(NMt.prototype),BMt.prototype.constructor=BMt,BMt.prototype.isFloat16BufferAttribute=!0,UMt.prototype=Object.create(NMt.prototype),UMt.prototype.constructor=UMt,VMt.prototype=Object.create(NMt.prototype),VMt.prototype.constructor=VMt;const HMt={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:"undefined"!=typeof Uint8ClampedArray?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function jMt(t,e){return new HMt[t](e)}let GMt=0;const qMt=new NEt,XMt=new iMt,KMt=new rEt,YMt=new aEt,ZMt=new aEt,JMt=new rEt;function QMt(){Object.defineProperty(this,"id",{value:GMt++}),this.uuid=q_t.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}QMt.prototype=Object.assign(Object.create(H_t.prototype),{constructor:QMt,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(t){return Array.isArray(t)?this.index=new(WMt(t)>65535?zMt:DMt)(t,1):this.index=t,this},getAttribute:function(t){return this.attributes[t]},setAttribute:function(t,e){return this.attributes[t]=e,this},deleteAttribute:function(t){return delete this.attributes[t],this},hasAttribute:function(t){return void 0!==this.attributes[t]},addGroup:function(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})},clearGroups:function(){this.groups=[]},setDrawRange:function(t,e){this.drawRange.start=t,this.drawRange.count=e},applyMatrix4:function(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new K_t).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(t),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},rotateX:function(t){return qMt.makeRotationX(t),this.applyMatrix4(qMt),this},rotateY:function(t){return qMt.makeRotationY(t),this.applyMatrix4(qMt),this},rotateZ:function(t){return qMt.makeRotationZ(t),this.applyMatrix4(qMt),this},translate:function(t,e,n){return qMt.makeTranslation(t,e,n),this.applyMatrix4(qMt),this},scale:function(t,e,n){return qMt.makeScale(t,e,n),this.applyMatrix4(qMt),this},lookAt:function(t){return XMt.lookAt(t),XMt.updateMatrix(),this.applyMatrix4(XMt.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(KMt).negate(),this.translate(KMt.x,KMt.y,KMt.z),this},setFromPoints:function(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];e.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new UMt(e,3)),this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new aEt);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new rEt(-1/0,-1/0,-1/0),new rEt(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];YMt.setFromBufferAttribute(n),this.morphTargetsRelative?(JMt.addVectors(this.boundingBox.min,YMt.min),this.boundingBox.expandByPoint(JMt),JMt.addVectors(this.boundingBox.max,YMt.max),this.boundingBox.expandByPoint(JMt)):(this.boundingBox.expandByPoint(YMt.min),this.boundingBox.expandByPoint(YMt.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new kEt);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new rEt,1/0);if(t){const n=this.boundingSphere.center;if(YMt.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];ZMt.setFromBufferAttribute(n),this.morphTargetsRelative?(JMt.addVectors(YMt.min,ZMt.min),YMt.expandByPoint(JMt),JMt.addVectors(YMt.max,ZMt.max),YMt.expandByPoint(JMt)):(YMt.expandByPoint(ZMt.min),YMt.expandByPoint(ZMt.max))}YMt.getCenter(n);let i=0;for(let e=0,r=t.count;e<r;e++)JMt.fromBufferAttribute(t,e),i=Math.max(i,n.distanceToSquared(JMt));if(e)for(let r=0,s=e.length;r<s;r++){const s=e[r],o=this.morphTargetsRelative;for(let e=0,r=s.count;e<r;e++)JMt.fromBufferAttribute(s,e),o&&(KMt.fromBufferAttribute(t,e),JMt.add(KMt)),i=Math.max(i,n.distanceToSquared(JMt))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeTangents:function(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,i=e.position.array,r=e.normal.array,s=e.uv.array,o=i.length/3;void 0===e.tangent&&this.setAttribute("tangent",new NMt(new Float32Array(4*o),4));const a=e.tangent.array,l=[],c=[];for(let t=0;t<o;t++)l[t]=new rEt,c[t]=new rEt;const u=new rEt,h=new rEt,d=new rEt,p=new X_t,f=new X_t,m=new X_t,g=new rEt,y=new rEt;function b(t,e,n){u.fromArray(i,3*t),h.fromArray(i,3*e),d.fromArray(i,3*n),p.fromArray(s,2*t),f.fromArray(s,2*e),m.fromArray(s,2*n),h.sub(u),d.sub(u),f.sub(p),m.sub(p);const r=1/(f.x*m.y-m.x*f.y);isFinite(r)&&(g.copy(h).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(r),y.copy(d).multiplyScalar(f.x).addScaledVector(h,-m.x).multiplyScalar(r),l[t].add(g),l[e].add(g),l[n].add(g),c[t].add(y),c[e].add(y),c[n].add(y))}let v=this.groups;0===v.length&&(v=[{start:0,count:n.length}]);for(let t=0,e=v.length;t<e;++t){const e=v[t],i=e.start;for(let t=i,r=i+e.count;t<r;t+=3)b(n[t+0],n[t+1],n[t+2])}const x=new rEt,w=new rEt,S=new rEt,k=new rEt;function C(t){S.fromArray(r,3*t),k.copy(S);const e=l[t];x.copy(e),x.sub(S.multiplyScalar(S.dot(e))).normalize(),w.crossVectors(k,e);const n=w.dot(c[t])<0?-1:1;a[4*t]=x.x,a[4*t+1]=x.y,a[4*t+2]=x.z,a[4*t+3]=n}for(let t=0,e=v.length;t<e;++t){const e=v[t],i=e.start;for(let t=i,r=i+e.count;t<r;t+=3)C(n[t+0]),C(n[t+1]),C(n[t+2])}},computeVertexNormals:function(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new NMt(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const i=new rEt,r=new rEt,s=new rEt,o=new rEt,a=new rEt,l=new rEt,c=new rEt,u=new rEt;if(t)for(let h=0,d=t.count;h<d;h+=3){const d=t.getX(h+0),p=t.getX(h+1),f=t.getX(h+2);i.fromBufferAttribute(e,d),r.fromBufferAttribute(e,p),s.fromBufferAttribute(e,f),c.subVectors(s,r),u.subVectors(i,r),c.cross(u),o.fromBufferAttribute(n,d),a.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),o.add(c),a.add(c),l.add(c),n.setXYZ(d,o.x,o.y,o.z),n.setXYZ(p,a.x,a.y,a.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let t=0,o=e.count;t<o;t+=3)i.fromBufferAttribute(e,t+0),r.fromBufferAttribute(e,t+1),s.fromBufferAttribute(e,t+2),c.subVectors(s,r),u.subVectors(i,r),c.cross(u),n.setXYZ(t+0,c.x,c.y,c.z),n.setXYZ(t+1,c.x,c.y,c.z),n.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}},merge:function(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(void 0===t.attributes[i])continue;const r=n[i].array,s=t.attributes[i],o=s.array,a=s.itemSize*e,l=Math.min(o.length,r.length-a);for(let t=0,e=a;t<l;t++,e++)r[e]=o[t]}return this},normalizeNormals:function(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)JMt.fromBufferAttribute(t,e),JMt.normalize(),t.setXYZ(e,JMt.x,JMt.y,JMt.z)},toNonIndexed:function(){function t(t,e){const n=t.array,i=t.itemSize,r=t.normalized,s=new n.constructor(e.length*i);let o=0,a=0;for(let t=0,r=e.length;t<r;t++){o=e[t]*i;for(let t=0;t<i;t++)s[a++]=n[o++]}return new NMt(s,i,r)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new QMt,n=this.index.array,i=this.attributes;for(const r in i){const s=t(i[r],n);e.setAttribute(r,s)}const r=this.morphAttributes;for(const i in r){const s=[],o=r[i];for(let e=0,i=o.length;e<i;e++){const i=t(o[e],n);s.push(i)}e.morphAttributes[i]=s}e.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let t=0,n=s.length;t<n;t++){const n=s[t];e.addGroup(n.start,n.count,n.materialIndex)}return e},toJSON:function(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const e in n){const i=n[e],r=i.toJSON(t.data);""!==i.name&&(r.name=i.name),t.data.attributes[e]=r}const i={};let r=!1;for(const e in this.morphAttributes){const n=this.morphAttributes[e],s=[];for(let e=0,i=n.length;e<i;e++){const i=n[e],r=i.toJSON(t.data);""!==i.name&&(r.name=i.name),s.push(r)}s.length>0&&(i[e]=s,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));const o=this.boundingSphere;return null!==o&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t},clone:function(){return(new QMt).copy(this)},copy:function(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const i=t.attributes;for(const t in i){const n=i[t];this.setAttribute(t,n.clone(e))}const r=t.morphAttributes;for(const t in r){const n=[],i=r[t];for(let t=0,r=i.length;t<r;t++)n.push(i[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const s=t.groups;for(let t=0,e=s.length;t<e;t++){const e=s[t];this.addGroup(e.start,e.count,e.materialIndex)}const o=t.boundingBox;null!==o&&(this.boundingBox=o.clone());const a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const t$t=new NEt,e$t=new AEt,n$t=new kEt,i$t=new rEt,r$t=new rEt,s$t=new rEt,o$t=new rEt,a$t=new rEt,l$t=new rEt,c$t=new rEt,u$t=new rEt,h$t=new rEt,d$t=new X_t,p$t=new X_t,f$t=new X_t,m$t=new rEt,g$t=new rEt;function y$t(t=new QMt,e=new $Mt){iMt.call(this),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}function b$t(t,e,n,i,r,s,o,a,l,c,u,h){i$t.fromBufferAttribute(r,c),r$t.fromBufferAttribute(r,u),s$t.fromBufferAttribute(r,h);const d=t.morphTargetInfluences;if(e.morphTargets&&s&&d){c$t.set(0,0,0),u$t.set(0,0,0),h$t.set(0,0,0);for(let t=0,e=s.length;t<e;t++){const e=d[t],n=s[t];0!==e&&(o$t.fromBufferAttribute(n,c),a$t.fromBufferAttribute(n,u),l$t.fromBufferAttribute(n,h),o?(c$t.addScaledVector(o$t,e),u$t.addScaledVector(a$t,e),h$t.addScaledVector(l$t,e)):(c$t.addScaledVector(o$t.sub(i$t),e),u$t.addScaledVector(a$t.sub(r$t),e),h$t.addScaledVector(l$t.sub(s$t),e)))}i$t.add(c$t),r$t.add(u$t),s$t.add(h$t)}t.isSkinnedMesh&&(t.boneTransform(c,i$t),t.boneTransform(u,r$t),t.boneTransform(h,s$t));const p=function(t,e,n,i,r,s,o,a){let l;if(l=e.side===rCt?i.intersectTriangle(o,s,r,!0,a):i.intersectTriangle(r,s,o,e.side!==sCt,a),null===l)return null;g$t.copy(a),g$t.applyMatrix4(t.matrixWorld);const c=n.ray.origin.distanceTo(g$t);return c<n.near||c>n.far?null:{distance:c,point:g$t.clone(),object:t}}(t,e,n,i,i$t,r$t,s$t,m$t);if(p){a&&(d$t.fromBufferAttribute(a,c),p$t.fromBufferAttribute(a,u),f$t.fromBufferAttribute(a,h),p.uv=bMt.getUV(m$t,i$t,r$t,s$t,d$t,p$t,f$t,new X_t)),l&&(d$t.fromBufferAttribute(l,c),p$t.fromBufferAttribute(l,u),f$t.fromBufferAttribute(l,h),p.uv2=bMt.getUV(m$t,i$t,r$t,s$t,d$t,p$t,f$t,new X_t));const t=new _Mt(c,u,h);bMt.getNormal(i$t,r$t,s$t,t.normal),p.face=t}return p}y$t.prototype=Object.assign(Object.create(iMt.prototype),{constructor:y$t,isMesh:!0,copy:function(t){return iMt.prototype.copy.call(this,t),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this},updateMorphTargets:function(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(t,e){const n=this.geometry,i=this.material,r=this.matrixWorld;if(void 0===i)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),n$t.copy(n.boundingSphere),n$t.applyMatrix4(r),!1===t.ray.intersectsSphere(n$t))return;if(t$t.copy(r).invert(),e$t.copy(t.ray).applyMatrix4(t$t),null!==n.boundingBox&&!1===e$t.intersectsBox(n.boundingBox))return;let s;if(n.isBufferGeometry){const r=n.index,o=n.attributes.position,a=n.morphAttributes.position,l=n.morphTargetsRelative,c=n.attributes.uv,u=n.attributes.uv2,h=n.groups,d=n.drawRange;if(null!==r)if(Array.isArray(i))for(let n=0,p=h.length;n<p;n++){const p=h[n],f=i[p.materialIndex];for(let n=Math.max(p.start,d.start),i=Math.min(p.start+p.count,d.start+d.count);n<i;n+=3){const i=r.getX(n),h=r.getX(n+1),d=r.getX(n+2);s=b$t(this,f,t,e$t,o,a,l,c,u,i,h,d),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=p.materialIndex,e.push(s))}}else{for(let n=Math.max(0,d.start),h=Math.min(r.count,d.start+d.count);n<h;n+=3){const h=r.getX(n),d=r.getX(n+1),p=r.getX(n+2);s=b$t(this,i,t,e$t,o,a,l,c,u,h,d,p),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}}else if(void 0!==o)if(Array.isArray(i))for(let n=0,r=h.length;n<r;n++){const r=h[n],p=i[r.materialIndex];for(let n=Math.max(r.start,d.start),i=Math.min(r.start+r.count,d.start+d.count);n<i;n+=3){s=b$t(this,p,t,e$t,o,a,l,c,u,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=r.materialIndex,e.push(s))}}else{for(let n=Math.max(0,d.start),r=Math.min(o.count,d.start+d.count);n<r;n+=3){s=b$t(this,i,t,e$t,o,a,l,c,u,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}});class v$t extends QMt{constructor(t=1,e=1,n=1,i=1,r=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:r,depthSegments:s};const o=this;i=Math.floor(i),r=Math.floor(r),s=Math.floor(s);const a=[],l=[],c=[],u=[];let h=0,d=0;function p(t,e,n,i,r,s,p,f,m,g,y){const b=s/m,v=p/g,x=s/2,w=p/2,S=f/2,k=m+1,C=g+1;let T=0,_=0;const E=new rEt;for(let s=0;s<C;s++){const o=s*v-w;for(let a=0;a<k;a++){const h=a*b-x;E[t]=h*i,E[e]=o*r,E[n]=S,l.push(E.x,E.y,E.z),E[t]=0,E[e]=0,E[n]=f>0?1:-1,c.push(E.x,E.y,E.z),u.push(a/m),u.push(1-s/g),T+=1}}for(let t=0;t<g;t++)for(let e=0;e<m;e++){const n=h+e+k*t,i=h+e+k*(t+1),r=h+(e+1)+k*(t+1),s=h+(e+1)+k*t;a.push(n,i,s),a.push(i,r,s),_+=6}o.addGroup(d,_,y),d+=_,h+=T}p("z","y","x",-1,-1,n,e,t,s,r,0),p("z","y","x",1,-1,n,e,-t,s,r,1),p("x","z","y",1,1,t,n,e,i,s,2),p("x","z","y",1,-1,t,n,-e,i,s,3),p("x","y","z",1,-1,t,e,n,i,r,4),p("x","y","z",-1,-1,t,e,-n,i,r,5),this.setIndex(a),this.setAttribute("position",new UMt(l,3)),this.setAttribute("normal",new UMt(c,3)),this.setAttribute("uv",new UMt(u,2))}}function x$t(t){const e={};for(const n in t){e[n]={};for(const i in t[n]){const r=t[n][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture)?e[n][i]=r.clone():Array.isArray(r)?e[n][i]=r.slice():e[n][i]=r}}return e}function w$t(t){const e={};for(let n=0;n<t.length;n++){const i=x$t(t[n]);for(const t in i)e[t]=i[t]}return e}const S$t={clone:x$t,merge:w$t};var k$t="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",C$t="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";function T$t(t){MMt.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=k$t,this.fragmentShader=C$t,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&(void 0!==t.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}function _$t(){iMt.call(this),this.type="Camera",this.matrixWorldInverse=new NEt,this.projectionMatrix=new NEt,this.projectionMatrixInverse=new NEt}function E$t(t=50,e=1,n=.1,i=2e3){_$t.call(this),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}T$t.prototype=Object.create(MMt.prototype),T$t.prototype.constructor=T$t,T$t.prototype.isShaderMaterial=!0,T$t.prototype.copy=function(t){return MMt.prototype.copy.call(this,t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=x$t(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this},T$t.prototype.toJSON=function(t){const e=MMt.prototype.toJSON.call(this,t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const i=this.uniforms[n].value;i&&i.isTexture?e.uniforms[n]={type:"t",value:i.toJSON(t).uuid}:i&&i.isColor?e.uniforms[n]={type:"c",value:i.getHex()}:i&&i.isVector2?e.uniforms[n]={type:"v2",value:i.toArray()}:i&&i.isVector3?e.uniforms[n]={type:"v3",value:i.toArray()}:i&&i.isVector4?e.uniforms[n]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?e.uniforms[n]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?e.uniforms[n]={type:"m4",value:i.toArray()}:e.uniforms[n]={value:i}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const t in this.extensions)!0===this.extensions[t]&&(n[t]=!0);return Object.keys(n).length>0&&(e.extensions=n),e},_$t.prototype=Object.assign(Object.create(iMt.prototype),{constructor:_$t,isCamera:!0,copy:function(t,e){return iMt.prototype.copy.call(this,t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this},getWorldDirection:function(t){void 0===t&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),t=new rEt),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()},updateMatrixWorld:function(t){iMt.prototype.updateMatrixWorld.call(this,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(t,e){iMt.prototype.updateWorldMatrix.call(this,t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return(new this.constructor).copy(this)}}),E$t.prototype=Object.assign(Object.create(_$t.prototype),{constructor:E$t,isPerspectiveCamera:!0,copy:function(t,e){return _$t.prototype.copy.call(this,t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this},setFocalLength:function(t){const e=.5*this.getFilmHeight()/t;this.fov=2*q_t.RAD2DEG*Math.atan(e),this.updateProjectionMatrix()},getFocalLength:function(){const t=Math.tan(.5*q_t.DEG2RAD*this.fov);return.5*this.getFilmHeight()/t},getEffectiveFOV:function(){return 2*q_t.RAD2DEG*Math.atan(Math.tan(.5*q_t.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(t,e,n,i,r,s){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const t=this.near;let e=t*Math.tan(.5*q_t.DEG2RAD*this.fov)/this.zoom,n=2*e,i=this.aspect*n,r=-.5*i;const s=this.view;if(null!==this.view&&this.view.enabled){const t=s.fullWidth,o=s.fullHeight;r+=s.offsetX*i/t,e-=s.offsetY*n/o,i*=s.width/t,n*=s.height/o}const o=this.filmOffset;0!==o&&(r+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(t){const e=iMt.prototype.toJSON.call(this,t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}});const M$t=90;function $$t(t,e,n){if(iMt.call(this),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const i=new E$t(M$t,1,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new rEt(1,0,0)),this.add(i);const r=new E$t(M$t,1,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new rEt(-1,0,0)),this.add(r);const s=new E$t(M$t,1,t,e);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new rEt(0,1,0)),this.add(s);const o=new E$t(M$t,1,t,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new rEt(0,-1,0)),this.add(o);const a=new E$t(M$t,1,t,e);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new rEt(0,0,1)),this.add(a);const l=new E$t(M$t,1,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new rEt(0,0,-1)),this.add(l),this.update=function(t,e){null===this.parent&&this.updateMatrixWorld();const c=t.xr.enabled,u=t.getRenderTarget();t.xr.enabled=!1;const h=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,i),t.setRenderTarget(n,1),t.render(e,r),t.setRenderTarget(n,2),t.render(e,s),t.setRenderTarget(n,3),t.render(e,o),t.setRenderTarget(n,4),t.render(e,a),n.texture.generateMipmaps=h,t.setRenderTarget(n,5),t.render(e,l),t.setRenderTarget(u),t.xr.enabled=c}}function I$t(t,e,n,i,r,s,o,a,l,c){t=void 0!==t?t:[],e=void 0!==e?e:GCt,o=void 0!==o?o:xTt,Q_t.call(this,t,e,n,i,r,s,o,a,l,c),this.flipY=!1,this._needsFlipEnvMap=!0}$$t.prototype=Object.create(iMt.prototype),$$t.prototype.constructor=$$t,I$t.prototype=Object.create(Q_t.prototype),I$t.prototype.constructor=I$t,I$t.prototype.isCubeTexture=!0,Object.defineProperty(I$t.prototype,"images",{get:function(){return this.image},set:function(t){this.image=t}});class A$t extends nEt{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n),super(t,t,e),Object.defineProperty(this,"isWebGLCubeRenderTarget",{value:!0}),e=e||{},this.texture=new I$t(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=wTt,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"},i=new v$t(5,5,5),r=new T$t({name:"CubemapFromEquirect",uniforms:x$t(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:rCt,blending:oCt});r.uniforms.tEquirect.value=e;const s=new y$t(i,r),o=e.minFilter;e.minFilter===oTt&&(e.minFilter=rTt);return new $$t(1,10,this).update(t,s),e.minFilter=o,s.geometry.dispose(),s.material.dispose(),this}clear(t,e,n,i){const r=t.getRenderTarget();for(let r=0;r<6;r++)t.setRenderTarget(this,r),t.clear(e,n,i);t.setRenderTarget(r)}}function N$t(t,e,n,i,r,s,o,a,l,c,u,h){Q_t.call(this,null,s,o,a,l,c,i,r,u,h),this.image={data:t||null,width:e||1,height:n||1},this.magFilter=void 0!==l?l:eTt,this.minFilter=void 0!==c?c:eTt,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}N$t.prototype=Object.create(Q_t.prototype),N$t.prototype.constructor=N$t,N$t.prototype.isDataTexture=!0;const R$t=new kEt,P$t=new rEt;class O$t{constructor(t,e,n,i,r,s){this.planes=[void 0!==t?t:new aMt,void 0!==e?e:new aMt,void 0!==n?n:new aMt,void 0!==i?i:new aMt,void 0!==r?r:new aMt,void 0!==s?s:new aMt]}set(t,e,n,i,r,s){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(n),o[3].copy(i),o[4].copy(r),o[5].copy(s),this}clone(){return(new this.constructor).copy(this)}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,i=n[0],r=n[1],s=n[2],o=n[3],a=n[4],l=n[5],c=n[6],u=n[7],h=n[8],d=n[9],p=n[10],f=n[11],m=n[12],g=n[13],y=n[14],b=n[15];return e[0].setComponents(o-i,u-a,f-h,b-m).normalize(),e[1].setComponents(o+i,u+a,f+h,b+m).normalize(),e[2].setComponents(o+r,u+l,f+d,b+g).normalize(),e[3].setComponents(o-r,u-l,f-d,b-g).normalize(),e[4].setComponents(o-s,u-c,f-p,b-y).normalize(),e[5].setComponents(o+s,u+c,f+p,b+y).normalize(),this}intersectsObject(t){const e=t.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),R$t.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(R$t)}intersectsSprite(t){return R$t.center.set(0,0,0),R$t.radius=.7071067811865476,R$t.applyMatrix4(t.matrixWorld),this.intersectsSphere(R$t)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let t=0;t<6;t++){if(e[t].distanceToPoint(n)<i)return!1}return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(P$t.x=i.normal.x>0?t.max.x:t.min.x,P$t.y=i.normal.y>0?t.max.y:t.min.y,P$t.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(P$t)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}}function L$t(){let t=null,e=!1,n=null,i=null;function r(e,s){n(e,s),i=t.requestAnimationFrame(r)}return{start:function(){!0!==e&&null!==n&&(i=t.requestAnimationFrame(r),e=!0)},stop:function(){t.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function D$t(t,e){const n=e.isWebGL2,i=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),i.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);const n=i.get(e);n&&(t.deleteBuffer(n.buffer),i.delete(e))},update:function(e,r){if(e.isGLBufferAttribute){const t=i.get(e);return void((!t||t.version<e.version)&&i.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const s=i.get(e);void 0===s?i.set(e,function(e,i){const r=e.array,s=e.usage,o=t.createBuffer();t.bindBuffer(i,o),t.bufferData(i,r,s),e.onUploadCallback();let a=5126;return r instanceof Float32Array?a=5126:r instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):r instanceof Uint16Array?e.isFloat16BufferAttribute?n?a=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):a=5123:r instanceof Int16Array?a=5122:r instanceof Uint32Array?a=5125:r instanceof Int32Array?a=5124:r instanceof Int8Array?a=5120:r instanceof Uint8Array&&(a=5121),{buffer:o,type:a,bytesPerElement:r.BYTES_PER_ELEMENT,version:e.version}}(e,r)):s.version<e.version&&(!function(e,i,r){const s=i.array,o=i.updateRange;t.bindBuffer(r,e),-1===o.count?t.bufferSubData(r,0,s):(n?t.bufferSubData(r,o.offset*s.BYTES_PER_ELEMENT,s,o.offset,o.count):t.bufferSubData(r,o.offset*s.BYTES_PER_ELEMENT,s.subarray(o.offset,o.offset+o.count)),o.count=-1)}(s.buffer,e,r),s.version=e.version)}}}class F$t extends QMt{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const r=t/2,s=e/2,o=Math.floor(n),a=Math.floor(i),l=o+1,c=a+1,u=t/o,h=e/a,d=[],p=[],f=[],m=[];for(let t=0;t<c;t++){const e=t*h-s;for(let n=0;n<l;n++){const i=n*u-r;p.push(i,-e,0),f.push(0,0,1),m.push(n/o),m.push(1-t/a)}}for(let t=0;t<a;t++)for(let e=0;e<o;e++){const n=e+l*t,i=e+l*(t+1),r=e+1+l*(t+1),s=e+1+l*t;d.push(n,i,s),d.push(i,r,s)}this.setIndex(d),this.setAttribute("position",new UMt(p,3)),this.setAttribute("normal",new UMt(f,3)),this.setAttribute("uv",new UMt(m,2))}}const z$t={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",normal_fragment_begin:"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmissionmap_fragment:"#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",transmissionmap_pars_fragment:"#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"},B$t={common:{diffuse:{value:new TMt(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new K_t},uv2Transform:{value:new K_t},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new X_t(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new TMt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new TMt(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new K_t}},sprite:{diffuse:{value:new TMt(15658734)},opacity:{value:1},center:{value:new X_t(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new K_t}}},U$t={basic:{uniforms:w$t([B$t.common,B$t.specularmap,B$t.envmap,B$t.aomap,B$t.lightmap,B$t.fog]),vertexShader:z$t.meshbasic_vert,fragmentShader:z$t.meshbasic_frag},lambert:{uniforms:w$t([B$t.common,B$t.specularmap,B$t.envmap,B$t.aomap,B$t.lightmap,B$t.emissivemap,B$t.fog,B$t.lights,{emissive:{value:new TMt(0)}}]),vertexShader:z$t.meshlambert_vert,fragmentShader:z$t.meshlambert_frag},phong:{uniforms:w$t([B$t.common,B$t.specularmap,B$t.envmap,B$t.aomap,B$t.lightmap,B$t.emissivemap,B$t.bumpmap,B$t.normalmap,B$t.displacementmap,B$t.fog,B$t.lights,{emissive:{value:new TMt(0)},specular:{value:new TMt(1118481)},shininess:{value:30}}]),vertexShader:z$t.meshphong_vert,fragmentShader:z$t.meshphong_frag},standard:{uniforms:w$t([B$t.common,B$t.envmap,B$t.aomap,B$t.lightmap,B$t.emissivemap,B$t.bumpmap,B$t.normalmap,B$t.displacementmap,B$t.roughnessmap,B$t.metalnessmap,B$t.fog,B$t.lights,{emissive:{value:new TMt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:z$t.meshphysical_vert,fragmentShader:z$t.meshphysical_frag},toon:{uniforms:w$t([B$t.common,B$t.aomap,B$t.lightmap,B$t.emissivemap,B$t.bumpmap,B$t.normalmap,B$t.displacementmap,B$t.gradientmap,B$t.fog,B$t.lights,{emissive:{value:new TMt(0)}}]),vertexShader:z$t.meshtoon_vert,fragmentShader:z$t.meshtoon_frag},matcap:{uniforms:w$t([B$t.common,B$t.bumpmap,B$t.normalmap,B$t.displacementmap,B$t.fog,{matcap:{value:null}}]),vertexShader:z$t.meshmatcap_vert,fragmentShader:z$t.meshmatcap_frag},points:{uniforms:w$t([B$t.points,B$t.fog]),vertexShader:z$t.points_vert,fragmentShader:z$t.points_frag},dashed:{uniforms:w$t([B$t.common,B$t.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:z$t.linedashed_vert,fragmentShader:z$t.linedashed_frag},depth:{uniforms:w$t([B$t.common,B$t.displacementmap]),vertexShader:z$t.depth_vert,fragmentShader:z$t.depth_frag},normal:{uniforms:w$t([B$t.common,B$t.bumpmap,B$t.normalmap,B$t.displacementmap,{opacity:{value:1}}]),vertexShader:z$t.normal_vert,fragmentShader:z$t.normal_frag},sprite:{uniforms:w$t([B$t.sprite,B$t.fog]),vertexShader:z$t.sprite_vert,fragmentShader:z$t.sprite_frag},background:{uniforms:{uvTransform:{value:new K_t},t2D:{value:null}},vertexShader:z$t.background_vert,fragmentShader:z$t.background_frag},cube:{uniforms:w$t([B$t.envmap,{opacity:{value:1}}]),vertexShader:z$t.cube_vert,fragmentShader:z$t.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:z$t.equirect_vert,fragmentShader:z$t.equirect_frag},distanceRGBA:{uniforms:w$t([B$t.common,B$t.displacementmap,{referencePosition:{value:new rEt},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:z$t.distanceRGBA_vert,fragmentShader:z$t.distanceRGBA_frag},shadow:{uniforms:w$t([B$t.lights,B$t.fog,{color:{value:new TMt(0)},opacity:{value:1}}]),vertexShader:z$t.shadow_vert,fragmentShader:z$t.shadow_frag}};function V$t(t,e,n,i,r){const s=new TMt(0);let o,a,l=0,c=null,u=0,h=null;function d(t,e){n.buffers.color.setClear(t.r,t.g,t.b,e,r)}return{getClearColor:function(){return s},setClearColor:function(t,e=1){s.set(t),l=e,d(s,l)},getClearAlpha:function(){return l},setClearAlpha:function(t){l=t,d(s,l)},render:function(n,r,p,f){let m=!0===r.isScene?r.background:null;m&&m.isTexture&&(m=e.get(m));const g=t.xr,y=g.getSession&&g.getSession();y&&"additive"===y.environmentBlendMode&&(m=null),null===m?d(s,l):m&&m.isColor&&(d(m,1),f=!0),(t.autoClear||f)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),m&&(m.isCubeTexture||m.isWebGLCubeRenderTarget||m.mapping===YCt)?(void 0===a&&(a=new y$t(new v$t(1,1,1),new T$t({name:"BackgroundCubeMaterial",uniforms:x$t(U$t.cube.uniforms),vertexShader:U$t.cube.vertexShader,fragmentShader:U$t.cube.fragmentShader,side:rCt,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),a.geometry.deleteAttribute("uv"),a.onBeforeRender=function(t,e,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(a.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(a)),m.isWebGLCubeRenderTarget&&(m=m.texture),a.material.uniforms.envMap.value=m,a.material.uniforms.flipEnvMap.value=m.isCubeTexture&&m._needsFlipEnvMap?-1:1,c===m&&u===m.version&&h===t.toneMapping||(a.material.needsUpdate=!0,c=m,u=m.version,h=t.toneMapping),n.unshift(a,a.geometry,a.material,0,0,null)):m&&m.isTexture&&(void 0===o&&(o=new y$t(new F$t(2,2),new T$t({name:"BackgroundMaterial",uniforms:x$t(U$t.background.uniforms),vertexShader:U$t.background.vertexShader,fragmentShader:U$t.background.fragmentShader,side:iCt,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(o)),o.material.uniforms.t2D.value=m,!0===m.matrixAutoUpdate&&m.updateMatrix(),o.material.uniforms.uvTransform.value.copy(m.matrix),c===m&&u===m.version&&h===t.toneMapping||(o.material.needsUpdate=!0,c=m,u=m.version,h=t.toneMapping),n.unshift(o,o.geometry,o.material,0,0,null))}}}function W$t(t,e,n,i){const r=t.getParameter(34921),s=i.isWebGL2?null:e.get("OES_vertex_array_object"),o=i.isWebGL2||null!==s,a={},l=d(null);let c=l;function u(e){return i.isWebGL2?t.bindVertexArray(e):s.bindVertexArrayOES(e)}function h(e){return i.isWebGL2?t.deleteVertexArray(e):s.deleteVertexArrayOES(e)}function d(t){const e=[],n=[],i=[];for(let t=0;t<r;t++)e[t]=0,n[t]=0,i[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:i,object:t,attributes:{},index:null}}function p(){const t=c.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function f(t){m(t,0)}function m(n,r){const s=c.newAttributes,o=c.enabledAttributes,a=c.attributeDivisors;if(s[n]=1,0===o[n]&&(t.enableVertexAttribArray(n),o[n]=1),a[n]!==r){(i.isWebGL2?t:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,r),a[n]=r}}function g(){const e=c.newAttributes,n=c.enabledAttributes;for(let i=0,r=n.length;i<r;i++)n[i]!==e[i]&&(t.disableVertexAttribArray(i),n[i]=0)}function y(e,n,r,s,o,a){!0!==i.isWebGL2||5124!==r&&5125!==r?t.vertexAttribPointer(e,n,r,s,o,a):t.vertexAttribIPointer(e,n,r,o,a)}function b(){v(),c!==l&&(c=l,u(c.object))}function v(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(r,l,h,b,v){let x=!1;if(o){const e=function(e,n,r){const o=!0===r.wireframe;let l=a[e.id];void 0===l&&(l={},a[e.id]=l);let c=l[n.id];void 0===c&&(c={},l[n.id]=c);let u=c[o];void 0===u&&(u=d(i.isWebGL2?t.createVertexArray():s.createVertexArrayOES()),c[o]=u);return u}(b,h,l);c!==e&&(c=e,u(c.object)),x=function(t,e){const n=c.attributes,i=t.attributes;let r=0;for(const t in i){const e=n[t],s=i[t];if(void 0===e)return!0;if(e.attribute!==s)return!0;if(e.data!==s.data)return!0;r++}return c.attributesNum!==r||c.index!==e}(b,v),x&&function(t,e){const n={},i=t.attributes;let r=0;for(const t in i){const e=i[t],s={};s.attribute=e,e.data&&(s.data=e.data),n[t]=s,r++}c.attributes=n,c.attributesNum=r,c.index=e}(b,v)}else{const t=!0===l.wireframe;c.geometry===b.id&&c.program===h.id&&c.wireframe===t||(c.geometry=b.id,c.program=h.id,c.wireframe=t,x=!0)}!0===r.isInstancedMesh&&(x=!0),null!==v&&n.update(v,34963),x&&(!function(r,s,o,a){if(!1===i.isWebGL2&&(r.isInstancedMesh||a.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;p();const l=a.attributes,c=o.getAttributes(),u=s.defaultAttributeValues;for(const e in c){const i=c[e];if(i>=0){const s=l[e];if(void 0!==s){const e=s.normalized,r=s.itemSize,o=n.get(s);if(void 0===o)continue;const l=o.buffer,c=o.type,u=o.bytesPerElement;if(s.isInterleavedBufferAttribute){const n=s.data,o=n.stride,h=s.offset;n&&n.isInstancedInterleavedBuffer?(m(i,n.meshPerAttribute),void 0===a._maxInstanceCount&&(a._maxInstanceCount=n.meshPerAttribute*n.count)):f(i),t.bindBuffer(34962,l),y(i,r,c,e,o*u,h*u)}else s.isInstancedBufferAttribute?(m(i,s.meshPerAttribute),void 0===a._maxInstanceCount&&(a._maxInstanceCount=s.meshPerAttribute*s.count)):f(i),t.bindBuffer(34962,l),y(i,r,c,e,0,0)}else if("instanceMatrix"===e){const e=n.get(r.instanceMatrix);if(void 0===e)continue;const s=e.buffer,o=e.type;m(i+0,1),m(i+1,1),m(i+2,1),m(i+3,1),t.bindBuffer(34962,s),t.vertexAttribPointer(i+0,4,o,!1,64,0),t.vertexAttribPointer(i+1,4,o,!1,64,16),t.vertexAttribPointer(i+2,4,o,!1,64,32),t.vertexAttribPointer(i+3,4,o,!1,64,48)}else if("instanceColor"===e){const e=n.get(r.instanceColor);if(void 0===e)continue;const s=e.buffer,o=e.type;m(i,1),t.bindBuffer(34962,s),t.vertexAttribPointer(i,3,o,!1,12,0)}else if(void 0!==u){const n=u[e];if(void 0!==n)switch(n.length){case 2:t.vertexAttrib2fv(i,n);break;case 3:t.vertexAttrib3fv(i,n);break;case 4:t.vertexAttrib4fv(i,n);break;default:t.vertexAttrib1fv(i,n)}}}}g()}(r,l,h,b),null!==v&&t.bindBuffer(34963,n.get(v).buffer))},reset:b,resetDefaultState:v,dispose:function(){b();for(const t in a){const e=a[t];for(const t in e){const n=e[t];for(const t in n)h(n[t].object),delete n[t];delete e[t]}delete a[t]}},releaseStatesOfGeometry:function(t){if(void 0===a[t.id])return;const e=a[t.id];for(const t in e){const n=e[t];for(const t in n)h(n[t].object),delete n[t];delete e[t]}delete a[t.id]},releaseStatesOfProgram:function(t){for(const e in a){const n=a[e];if(void 0===n[t.id])continue;const i=n[t.id];for(const t in i)h(i[t].object),delete i[t];delete n[t.id]}},initAttributes:p,enableAttribute:f,disableUnusedAttributes:g}}function H$t(t,e,n,i){const r=i.isWebGL2;let s;this.setMode=function(t){s=t},this.render=function(e,i){t.drawArrays(s,e,i),n.update(i,s,1)},this.renderInstances=function(i,o,a){if(0===a)return;let l,c;if(r)l=t,c="drawArraysInstanced";else if(l=e.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](s,i,o,a),n.update(o,s,a)}}function j$t(t,e,n){let i;function r(e){if("highp"===e){if(t.getShaderPrecisionFormat(35633,36338).precision>0&&t.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(35633,36337).precision>0&&t.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const s="undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&t instanceof WebGL2ComputeRenderingContext;let o=void 0!==n.precision?n.precision:"highp";const a=r(o);a!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",a,"instead."),o=a);const l=!0===n.logarithmicDepthBuffer,c=t.getParameter(34930),u=t.getParameter(35660),h=t.getParameter(3379),d=t.getParameter(34076),p=t.getParameter(34921),f=t.getParameter(36347),m=t.getParameter(36348),g=t.getParameter(36349),y=u>0,b=s||!!e.get("OES_texture_float");return{isWebGL2:s,getMaxAnisotropy:function(){if(void 0!==i)return i;const n=e.get("EXT_texture_filter_anisotropic");return i=null!==n?t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,i},getMaxPrecision:r,precision:o,logarithmicDepthBuffer:l,maxTextures:c,maxVertexTextures:u,maxTextureSize:h,maxCubemapSize:d,maxAttributes:p,maxVertexUniforms:f,maxVaryings:m,maxFragmentUniforms:g,vertexTextures:y,floatFragmentTextures:b,floatVertexTextures:y&&b,maxSamples:s?t.getParameter(36183):0}}function G$t(t){const e=this;let n=null,i=0,r=!1,s=!1;const o=new aMt,a=new K_t,l={value:null,needsUpdate:!1};function c(){l.value!==n&&(l.value=n,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function u(t,n,i,r){const s=null!==t?t.length:0;let c=null;if(0!==s){if(c=l.value,!0!==r||null===c){const e=i+4*s,r=n.matrixWorldInverse;a.getNormalMatrix(r),(null===c||c.length<e)&&(c=new Float32Array(e));for(let e=0,n=i;e!==s;++e,n+=4)o.copy(t[e]).applyMatrix4(r,a),o.normal.toArray(c,n),c[n+3]=o.constant}l.value=c,l.needsUpdate=!0}return e.numPlanes=s,e.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e,s){const o=0!==t.length||e||0!==i||r;return r=e,n=u(t,s,0),i=t.length,o},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1,c()},this.setState=function(e,o,a){const h=e.clippingPlanes,d=e.clipIntersection,p=e.clipShadows,f=t.get(e);if(!r||null===h||0===h.length||s&&!p)s?u(null):c();else{const t=s?0:i,e=4*t;let r=f.clippingState||null;l.value=r,r=u(h,o,e,a);for(let t=0;t!==e;++t)r[t]=n[t];f.clippingState=r,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function q$t(t){let e=new WeakMap;function n(t,e){return e===XCt?t.mapping=GCt:e===KCt&&(t.mapping=qCt),t}function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(r){if(r&&r.isTexture){const s=r.mapping;if(s===XCt||s===KCt){if(e.has(r)){return n(e.get(r).texture,r.mapping)}{const s=r.image;if(s&&s.height>0){const o=t.getRenderList(),a=t.getRenderTarget(),l=new A$t(s.height/2);return l.fromEquirectangularTexture(t,r),e.set(r,l),t.setRenderTarget(a),t.setRenderList(o),r.addEventListener("dispose",i),n(l.texture,r.mapping)}return null}}}return r},dispose:function(){e=new WeakMap}}}function X$t(t){const e={};function n(n){if(void 0!==e[n])return e[n];let i;switch(n){case"WEBGL_depth_texture":i=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=t.getExtension(n)}return e[n]=i,i}return{has:function(t){return null!==n(t)},init:function(t){t.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float")},get:function(t){const e=n(t);return null===e&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function K$t(t,e,n,i){const r={},s=new WeakMap;function o(t){const a=t.target;null!==a.index&&e.remove(a.index);for(const t in a.attributes)e.remove(a.attributes[t]);a.removeEventListener("dispose",o),delete r[a.id];const l=s.get(a);l&&(e.remove(l),s.delete(a)),i.releaseStatesOfGeometry(a),!0===a.isInstancedBufferGeometry&&delete a._maxInstanceCount,n.memory.geometries--}function a(t){const n=[],i=t.index,r=t.attributes.position;let o=0;if(null!==i){const t=i.array;o=i.version;for(let e=0,i=t.length;e<i;e+=3){const i=t[e+0],r=t[e+1],s=t[e+2];n.push(i,r,r,s,s,i)}}else{const t=r.array;o=r.version;for(let e=0,i=t.length/3-1;e<i;e+=3){const t=e+0,i=e+1,r=e+2;n.push(t,i,i,r,r,t)}}const a=new(WMt(n)>65535?zMt:DMt)(n,1);a.version=o;const l=s.get(t);l&&e.remove(l),s.set(t,a)}return{get:function(t,e){return!0===r[e.id]||(e.addEventListener("dispose",o),r[e.id]=!0,n.memory.geometries++),e},update:function(t){const n=t.attributes;for(const t in n)e.update(n[t],34962);const i=t.morphAttributes;for(const t in i){const n=i[t];for(let t=0,i=n.length;t<i;t++)e.update(n[t],34962)}},getWireframeAttribute:function(t){const e=s.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&a(t)}else a(t);return s.get(t)}}}function Y$t(t,e,n,i){const r=i.isWebGL2;let s,o,a;this.setMode=function(t){s=t},this.setIndex=function(t){o=t.type,a=t.bytesPerElement},this.render=function(e,i){t.drawElements(s,i,o,e*a),n.update(i,s,1)},this.renderInstances=function(i,l,c){if(0===c)return;let u,h;if(r)u=t,h="drawElementsInstanced";else if(u=e.get("ANGLE_instanced_arrays"),h="drawElementsInstancedANGLE",null===u)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");u[h](s,l,o,i*a,c),n.update(l,s,c)}}function Z$t(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(t,n,i){switch(e.calls++,n){case 4:e.triangles+=i*(t/3);break;case 1:e.lines+=i*(t/2);break;case 3:e.lines+=i*(t-1);break;case 2:e.lines+=i*t;break;case 0:e.points+=i*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function J$t(t,e){return t[0]-e[0]}function Q$t(t,e){return Math.abs(e[1])-Math.abs(t[1])}function tIt(t){const e={},n=new Float32Array(8),i=[];for(let t=0;t<8;t++)i[t]=[t,0];return{update:function(r,s,o,a){const l=r.morphTargetInfluences,c=void 0===l?0:l.length;let u=e[s.id];if(void 0===u){u=[];for(let t=0;t<c;t++)u[t]=[t,0];e[s.id]=u}for(let t=0;t<c;t++){const e=u[t];e[0]=t,e[1]=l[t]}u.sort(Q$t);for(let t=0;t<8;t++)t<c&&u[t][1]?(i[t][0]=u[t][0],i[t][1]=u[t][1]):(i[t][0]=Number.MAX_SAFE_INTEGER,i[t][1]=0);i.sort(J$t);const h=o.morphTargets&&s.morphAttributes.position,d=o.morphNormals&&s.morphAttributes.normal;let p=0;for(let t=0;t<8;t++){const e=i[t],r=e[0],o=e[1];r!==Number.MAX_SAFE_INTEGER&&o?(h&&s.getAttribute("morphTarget"+t)!==h[r]&&s.setAttribute("morphTarget"+t,h[r]),d&&s.getAttribute("morphNormal"+t)!==d[r]&&s.setAttribute("morphNormal"+t,d[r]),n[t]=o,p+=o):(h&&!0===s.hasAttribute("morphTarget"+t)&&s.deleteAttribute("morphTarget"+t),d&&!0===s.hasAttribute("morphNormal"+t)&&s.deleteAttribute("morphNormal"+t),n[t]=0)}const f=s.morphTargetsRelative?1:1-p;a.getUniforms().setValue(t,"morphTargetBaseInfluence",f),a.getUniforms().setValue(t,"morphTargetInfluences",n)}}}function eIt(t,e,n,i){let r=new WeakMap;function s(t){const e=t.target;e.removeEventListener("dispose",s),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(t){const o=i.render.frame,a=t.geometry,l=e.get(t,a);return r.get(l)!==o&&(e.update(l),r.set(l,o)),t.isInstancedMesh&&(!1===t.hasEventListener("dispose",s)&&t.addEventListener("dispose",s),n.update(t.instanceMatrix,34962),null!==t.instanceColor&&n.update(t.instanceColor,34962)),l},dispose:function(){r=new WeakMap}}}function nIt(t=null,e=1,n=1,i=1){Q_t.call(this,null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=eTt,this.minFilter=eTt,this.wrapR=QCt,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}function iIt(t=null,e=1,n=1,i=1){Q_t.call(this,null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=eTt,this.minFilter=eTt,this.wrapR=QCt,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}U$t.physical={uniforms:w$t([U$t.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new X_t(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new TMt(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:z$t.meshphysical_vert,fragmentShader:z$t.meshphysical_frag},nIt.prototype=Object.create(Q_t.prototype),nIt.prototype.constructor=nIt,nIt.prototype.isDataTexture2DArray=!0,iIt.prototype=Object.create(Q_t.prototype),iIt.prototype.constructor=iIt,iIt.prototype.isDataTexture3D=!0;const rIt=new Q_t,sIt=new nIt,oIt=new iIt,aIt=new I$t,lIt=[],cIt=[],uIt=new Float32Array(16),hIt=new Float32Array(9),dIt=new Float32Array(4);function pIt(t,e,n){const i=t[0];if(i<=0||i>0)return t;const r=e*n;let s=lIt[r];if(void 0===s&&(s=new Float32Array(r),lIt[r]=s),0!==e){i.toArray(s,0);for(let i=1,r=0;i!==e;++i)r+=n,t[i].toArray(s,r)}return s}function fIt(t,e){if(t.length!==e.length)return!1;for(let n=0,i=t.length;n<i;n++)if(t[n]!==e[n])return!1;return!0}function mIt(t,e){for(let n=0,i=e.length;n<i;n++)t[n]=e[n]}function gIt(t,e){let n=cIt[e];void 0===n&&(n=new Int32Array(e),cIt[e]=n);for(let i=0;i!==e;++i)n[i]=t.allocateTextureUnit();return n}function yIt(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function bIt(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(fIt(n,e))return;t.uniform2fv(this.addr,e),mIt(n,e)}}function vIt(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(fIt(n,e))return;t.uniform3fv(this.addr,e),mIt(n,e)}}function xIt(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(fIt(n,e))return;t.uniform4fv(this.addr,e),mIt(n,e)}}function wIt(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(fIt(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),mIt(n,e)}else{if(fIt(n,i))return;dIt.set(i),t.uniformMatrix2fv(this.addr,!1,dIt),mIt(n,i)}}function SIt(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(fIt(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),mIt(n,e)}else{if(fIt(n,i))return;hIt.set(i),t.uniformMatrix3fv(this.addr,!1,hIt),mIt(n,i)}}function kIt(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(fIt(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),mIt(n,e)}else{if(fIt(n,i))return;uIt.set(i),t.uniformMatrix4fv(this.addr,!1,uIt),mIt(n,i)}}function CIt(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.safeSetTexture2D(e||rIt,r)}function TIt(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture2DArray(e||sIt,r)}function _It(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture3D(e||oIt,r)}function EIt(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.safeSetTextureCube(e||aIt,r)}function MIt(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function $It(t,e){const n=this.cache;fIt(n,e)||(t.uniform2iv(this.addr,e),mIt(n,e))}function IIt(t,e){const n=this.cache;fIt(n,e)||(t.uniform3iv(this.addr,e),mIt(n,e))}function AIt(t,e){const n=this.cache;fIt(n,e)||(t.uniform4iv(this.addr,e),mIt(n,e))}function NIt(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function RIt(t,e){t.uniform1fv(this.addr,e)}function PIt(t,e){t.uniform1iv(this.addr,e)}function OIt(t,e){t.uniform2iv(this.addr,e)}function LIt(t,e){t.uniform3iv(this.addr,e)}function DIt(t,e){t.uniform4iv(this.addr,e)}function FIt(t,e){const n=pIt(e,this.size,2);t.uniform2fv(this.addr,n)}function zIt(t,e){const n=pIt(e,this.size,3);t.uniform3fv(this.addr,n)}function BIt(t,e){const n=pIt(e,this.size,4);t.uniform4fv(this.addr,n)}function UIt(t,e){const n=pIt(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function VIt(t,e){const n=pIt(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function WIt(t,e){const n=pIt(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function HIt(t,e,n){const i=e.length,r=gIt(n,i);t.uniform1iv(this.addr,r);for(let t=0;t!==i;++t)n.safeSetTexture2D(e[t]||rIt,r[t])}function jIt(t,e,n){const i=e.length,r=gIt(n,i);t.uniform1iv(this.addr,r);for(let t=0;t!==i;++t)n.safeSetTextureCube(e[t]||aIt,r[t])}function GIt(t,e,n){this.id=t,this.addr=n,this.cache=[],this.setValue=function(t){switch(t){case 5126:return yIt;case 35664:return bIt;case 35665:return vIt;case 35666:return xIt;case 35674:return wIt;case 35675:return SIt;case 35676:return kIt;case 5124:case 35670:return MIt;case 35667:case 35671:return $It;case 35668:case 35672:return IIt;case 35669:case 35673:return AIt;case 5125:return NIt;case 35678:case 36198:case 36298:case 36306:case 35682:return CIt;case 35679:case 36299:case 36307:return _It;case 35680:case 36300:case 36308:case 36293:return EIt;case 36289:case 36303:case 36311:case 36292:return TIt}}(e.type)}function qIt(t,e,n){this.id=t,this.addr=n,this.cache=[],this.size=e.size,this.setValue=function(t){switch(t){case 5126:return RIt;case 35664:return FIt;case 35665:return zIt;case 35666:return BIt;case 35674:return UIt;case 35675:return VIt;case 35676:return WIt;case 5124:case 35670:return PIt;case 35667:case 35671:return OIt;case 35668:case 35672:return LIt;case 35669:case 35673:return DIt;case 35678:case 36198:case 36298:case 36306:case 35682:return HIt;case 35680:case 36300:case 36308:case 36293:return jIt}}(e.type)}function XIt(t){this.id=t,this.seq=[],this.map={}}qIt.prototype.updateCache=function(t){const e=this.cache;t instanceof Float32Array&&e.length!==t.length&&(this.cache=new Float32Array(t.length)),mIt(e,t)},XIt.prototype.setValue=function(t,e,n){const i=this.seq;for(let r=0,s=i.length;r!==s;++r){const s=i[r];s.setValue(t,e[s.id],n)}};const KIt=/(\w+)(\])?(\[|\.)?/g;function YIt(t,e){t.seq.push(e),t.map[e.id]=e}function ZIt(t,e,n){const i=t.name,r=i.length;for(KIt.lastIndex=0;;){const s=KIt.exec(i),o=KIt.lastIndex;let a=s[1];const l="]"===s[2],c=s[3];if(l&&(a|=0),void 0===c||"["===c&&o+2===r){YIt(n,void 0===c?new GIt(a,t,e):new qIt(a,t,e));break}{let t=n.map[a];void 0===t&&(t=new XIt(a),YIt(n,t)),n=t}}}function JIt(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,35718);for(let i=0;i<n;++i){const n=t.getActiveUniform(e,i);ZIt(n,t.getUniformLocation(e,n.name),this)}}function QIt(t,e,n){const i=t.createShader(e);return t.shaderSource(i,n),t.compileShader(i),i}JIt.prototype.setValue=function(t,e,n,i){const r=this.map[e];void 0!==r&&r.setValue(t,n,i)},JIt.prototype.setOptional=function(t,e,n){const i=e[n];void 0!==i&&this.setValue(t,n,i)},JIt.upload=function(t,e,n,i){for(let r=0,s=e.length;r!==s;++r){const s=e[r],o=n[s.id];!1!==o.needsUpdate&&s.setValue(t,o.value,i)}},JIt.seqWithValue=function(t,e){const n=[];for(let i=0,r=t.length;i!==r;++i){const r=t[i];r.id in e&&n.push(r)}return n};let tAt=0;function eAt(t){switch(t){case E_t:return["Linear","( value )"];case M_t:return["sRGB","( value )"];case I_t:return["RGBE","( value )"];case N_t:return["RGBM","( value, 7.0 )"];case R_t:return["RGBM","( value, 16.0 )"];case P_t:return["RGBD","( value, 256.0 )"];case $_t:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case A_t:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",t),["Linear","( value )"]}}function nAt(t,e,n){const i=t.getShaderParameter(e,35713),r=t.getShaderInfoLog(e).trim();if(i&&""===r)return"";return"THREE.WebGLShader: gl.getShaderInfoLog() "+n+"\n"+r+function(t){const e=t.split("\n");for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join("\n")}(t.getShaderSource(e))}function iAt(t,e){const n=eAt(e);return"vec4 "+t+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function rAt(t,e){const n=eAt(e);return"vec4 "+t+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function sAt(t,e){let n;switch(e){case BCt:n="Linear";break;case UCt:n="Reinhard";break;case VCt:n="OptimizedCineon";break;case WCt:n="ACESFilmic";break;case HCt:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function oAt(t){return""!==t}function aAt(t,e){return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function lAt(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const cAt=/^[ \t]*#include +<([\w\d./]+)>/gm;function uAt(t){return t.replace(cAt,hAt)}function hAt(t,e){const n=z$t[e];if(void 0===n)throw new Error("Can not resolve #include <"+e+">");return uAt(n)}const dAt=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,pAt=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function fAt(t){return t.replace(pAt,gAt).replace(dAt,mAt)}function mAt(t,e,n,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),gAt(t,e,n,i)}function gAt(t,e,n,i){let r="";for(let t=parseInt(e);t<parseInt(n);t++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return r}function yAt(t){let e="precision "+t.precision+" float;\nprecision "+t.precision+" int;";return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function bAt(t,e,n,i){const r=t.getContext(),s=n.defines;let o=n.vertexShader,a=n.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return t.shadowMapType===tCt?e="SHADOWMAP_TYPE_PCF":t.shadowMapType===eCt?e="SHADOWMAP_TYPE_PCF_SOFT":t.shadowMapType===nCt&&(e="SHADOWMAP_TYPE_VSM"),e}(n),c=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case GCt:case qCt:e="ENVMAP_TYPE_CUBE";break;case YCt:case ZCt:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),u=function(t){let e="ENVMAP_MODE_REFLECTION";if(t.envMap)switch(t.envMapMode){case qCt:case ZCt:e="ENVMAP_MODE_REFRACTION"}return e}(n),h=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case LCt:e="ENVMAP_BLENDING_MULTIPLY";break;case DCt:e="ENVMAP_BLENDING_MIX";break;case FCt:e="ENVMAP_BLENDING_ADD"}return e}(n),d=t.gammaFactor>0?t.gammaFactor:1,p=n.isWebGL2?"":function(t){return[t.extensionDerivatives||t.envMapCubeUV||t.bumpMap||t.tangentSpaceNormalMap||t.clearcoatNormalMap||t.flatShading||"physical"===t.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",t.extensionDrawBuffers&&t.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(oAt).join("\n")}(n),f=function(t){const e=[];for(const n in t){const i=t[n];!1!==i&&e.push("#define "+n+" "+i)}return e.join("\n")}(s),m=r.createProgram();let g,y,b=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(g=[f].filter(oAt).join("\n"),g.length>0&&(g+="\n"),y=[p,f].filter(oAt).join("\n"),y.length>0&&(y+="\n")):(g=[yAt(n),"#define SHADER_NAME "+n.shaderName,f,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#ifdef USE_COLOR","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(oAt).join("\n"),y=[p,yAt(n),"#define SHADER_NAME "+n.shaderName,f,n.alphaTest?"#define ALPHATEST "+n.alphaTest+(n.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+d,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+u:"",n.envMap?"#define "+h:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.sheen?"#define USE_SHEEN":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==zCt?"#define TONE_MAPPING":"",n.toneMapping!==zCt?z$t.tonemapping_pars_fragment:"",n.toneMapping!==zCt?sAt("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",z$t.encodings_pars_fragment,n.map?iAt("mapTexelToLinear",n.mapEncoding):"",n.matcap?iAt("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?iAt("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?iAt("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.lightMap?iAt("lightMapTexelToLinear",n.lightMapEncoding):"",rAt("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(oAt).join("\n")),o=uAt(o),o=aAt(o,n),o=lAt(o,n),a=uAt(a),a=aAt(a,n),a=lAt(a,n),o=fAt(o),a=fAt(a),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(b="#version 300 es\n",g=["#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+g,y=["#define varying in",n.glslVersion===W_t?"":"out highp vec4 pc_fragColor;",n.glslVersion===W_t?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+y);const v=b+y+a,x=QIt(r,35633,b+g+o),w=QIt(r,35632,v);if(r.attachShader(m,x),r.attachShader(m,w),void 0!==n.index0AttributeName?r.bindAttribLocation(m,0,n.index0AttributeName):!0===n.morphTargets&&r.bindAttribLocation(m,0,"position"),r.linkProgram(m),t.debug.checkShaderErrors){const t=r.getProgramInfoLog(m).trim(),e=r.getShaderInfoLog(x).trim(),n=r.getShaderInfoLog(w).trim();let i=!0,s=!0;if(!1===r.getProgramParameter(m,35714)){i=!1;const e=nAt(r,x,"vertex"),n=nAt(r,w,"fragment");console.error("THREE.WebGLProgram: shader error: ",r.getError(),"35715",r.getProgramParameter(m,35715),"gl.getProgramInfoLog",t,e,n)}else""!==t?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",t):""!==e&&""!==n||(s=!1);s&&(this.diagnostics={runnable:i,programLog:t,vertexShader:{log:e,prefix:g},fragmentShader:{log:n,prefix:y}})}let S,k;return r.deleteShader(x),r.deleteShader(w),this.getUniforms=function(){return void 0===S&&(S=new JIt(r,m)),S},this.getAttributes=function(){return void 0===k&&(k=function(t,e){const n={},i=t.getProgramParameter(e,35721);for(let r=0;r<i;r++){const i=t.getActiveAttrib(e,r).name;n[i]=t.getAttribLocation(e,i)}return n}(r,m)),k},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(m),this.program=void 0},this.name=n.shaderName,this.id=tAt++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=x,this.fragmentShader=w,this}function vAt(t,e,n,i,r,s){const o=[],a=i.isWebGL2,l=i.logarithmicDepthBuffer,c=i.floatVertexTextures,u=i.maxVertexUniforms,h=i.vertexTextures;let d=i.precision;const p={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},f=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function m(t){let e;return t&&t.isTexture?e=t.encoding:t&&t.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),e=t.texture.encoding):e=E_t,e}return{getParameters:function(r,o,f,g,y){const b=g.fog,v=r.isMeshStandardMaterial?g.environment:null,x=e.get(r.envMap||v),w=p[r.type],S=y.isSkinnedMesh?function(t){const e=t.skeleton.bones;if(c)return 1024;{const t=u,n=Math.floor((t-20)/4),i=Math.min(n,e.length);return i<e.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+e.length+" bones. This GPU supports "+i+"."),0):i}}(y):0;let k,C;if(null!==r.precision&&(d=i.getMaxPrecision(r.precision),d!==r.precision&&console.warn("THREE.WebGLProgram.getParameters:",r.precision,"not supported, using",d,"instead.")),w){const t=U$t[w];k=t.vertexShader,C=t.fragmentShader}else k=r.vertexShader,C=r.fragmentShader;const T=t.getRenderTarget();return{isWebGL2:a,shaderID:w,shaderName:r.type,vertexShader:k,fragmentShader:C,defines:r.defines,isRawShaderMaterial:!0===r.isRawShaderMaterial,glslVersion:r.glslVersion,precision:d,instancing:!0===y.isInstancedMesh,instancingColor:!0===y.isInstancedMesh&&null!==y.instanceColor,supportsVertexTextures:h,outputEncoding:null!==T?m(T.texture):t.outputEncoding,map:!!r.map,mapEncoding:m(r.map),matcap:!!r.matcap,matcapEncoding:m(r.matcap),envMap:!!x,envMapMode:x&&x.mapping,envMapEncoding:m(x),envMapCubeUV:!!x&&(x.mapping===YCt||x.mapping===ZCt),lightMap:!!r.lightMap,lightMapEncoding:m(r.lightMap),aoMap:!!r.aoMap,emissiveMap:!!r.emissiveMap,emissiveMapEncoding:m(r.emissiveMap),bumpMap:!!r.bumpMap,normalMap:!!r.normalMap,objectSpaceNormalMap:r.normalMapType===F_t,tangentSpaceNormalMap:r.normalMapType===D_t,clearcoatMap:!!r.clearcoatMap,clearcoatRoughnessMap:!!r.clearcoatRoughnessMap,clearcoatNormalMap:!!r.clearcoatNormalMap,displacementMap:!!r.displacementMap,roughnessMap:!!r.roughnessMap,metalnessMap:!!r.metalnessMap,specularMap:!!r.specularMap,alphaMap:!!r.alphaMap,gradientMap:!!r.gradientMap,sheen:!!r.sheen,transmissionMap:!!r.transmissionMap,combine:r.combine,vertexTangents:r.normalMap&&r.vertexTangents,vertexColors:r.vertexColors,vertexUvs:!!(r.map||r.bumpMap||r.normalMap||r.specularMap||r.alphaMap||r.emissiveMap||r.roughnessMap||r.metalnessMap||r.clearcoatMap||r.clearcoatRoughnessMap||r.clearcoatNormalMap||r.displacementMap||r.transmissionMap),uvsVertexOnly:!(r.map||r.bumpMap||r.normalMap||r.specularMap||r.alphaMap||r.emissiveMap||r.roughnessMap||r.metalnessMap||r.clearcoatNormalMap||r.transmissionMap||!r.displacementMap),fog:!!b,useFog:r.fog,fogExp2:b&&b.isFogExp2,flatShading:r.flatShading,sizeAttenuation:r.sizeAttenuation,logarithmicDepthBuffer:l,skinning:r.skinning&&S>0,maxBones:S,useVertexTexture:c,morphTargets:r.morphTargets,morphNormals:r.morphNormals,maxMorphTargets:t.maxMorphTargets,maxMorphNormals:t.maxMorphNormals,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:r.dithering,shadowMapEnabled:t.shadowMap.enabled&&f.length>0,shadowMapType:t.shadowMap.type,toneMapping:r.toneMapped?t.toneMapping:zCt,physicallyCorrectLights:t.physicallyCorrectLights,premultipliedAlpha:r.premultipliedAlpha,alphaTest:r.alphaTest,doubleSided:r.side===sCt,flipSided:r.side===rCt,depthPacking:void 0!==r.depthPacking&&r.depthPacking,index0AttributeName:r.index0AttributeName,extensionDerivatives:r.extensions&&r.extensions.derivatives,extensionFragDepth:r.extensions&&r.extensions.fragDepth,extensionDrawBuffers:r.extensions&&r.extensions.drawBuffers,extensionShaderTextureLOD:r.extensions&&r.extensions.shaderTextureLOD,rendererExtensionFragDepth:a||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:a||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:a||n.has("EXT_shader_texture_lod"),customProgramCacheKey:r.customProgramCacheKey()}},getProgramCacheKey:function(e){const n=[];if(e.shaderID?n.push(e.shaderID):(n.push(e.fragmentShader),n.push(e.vertexShader)),void 0!==e.defines)for(const t in e.defines)n.push(t),n.push(e.defines[t]);if(!1===e.isRawShaderMaterial){for(let t=0;t<f.length;t++)n.push(e[f[t]]);n.push(t.outputEncoding),n.push(t.gammaFactor)}return n.push(e.customProgramCacheKey),n.join()},getUniforms:function(t){const e=p[t.type];let n;if(e){const t=U$t[e];n=S$t.clone(t.uniforms)}else n=t.uniforms;return n},acquireProgram:function(e,n){let i;for(let t=0,e=o.length;t<e;t++){const e=o[t];if(e.cacheKey===n){i=e,++i.usedTimes;break}}return void 0===i&&(i=new bAt(t,n,e,r),o.push(i)),i},releaseProgram:function(t){if(0==--t.usedTimes){const e=o.indexOf(t);o[e]=o[o.length-1],o.pop(),t.destroy()}},programs:o}}function xAt(){let t=new WeakMap;return{get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,i){t.get(e)[n]=i},dispose:function(){t=new WeakMap}}}function wAt(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.program!==e.program?t.program.id-e.program.id:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function SAt(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function kAt(t){const e=[];let n=0;const i=[],r=[],s={id:-1};function o(i,r,o,a,l,c){let u=e[n];const h=t.get(o);return void 0===u?(u={id:i.id,object:i,geometry:r,material:o,program:h.program||s,groupOrder:a,renderOrder:i.renderOrder,z:l,group:c},e[n]=u):(u.id=i.id,u.object=i,u.geometry=r,u.material=o,u.program=h.program||s,u.groupOrder=a,u.renderOrder=i.renderOrder,u.z=l,u.group=c),n++,u}return{opaque:i,transparent:r,init:function(){n=0,i.length=0,r.length=0},push:function(t,e,n,s,a,l){const c=o(t,e,n,s,a,l);(!0===n.transparent?r:i).push(c)},unshift:function(t,e,n,s,a,l){const c=o(t,e,n,s,a,l);(!0===n.transparent?r:i).unshift(c)},finish:function(){for(let t=n,i=e.length;t<i;t++){const n=e[t];if(null===n.id)break;n.id=null,n.object=null,n.geometry=null,n.material=null,n.program=null,n.group=null}},sort:function(t,e){i.length>1&&i.sort(t||wAt),r.length>1&&r.sort(e||SAt)}}}function CAt(t){let e=new WeakMap;return{get:function(n,i){const r=e.get(n);let s;return void 0===r?(s=new kAt(t),e.set(n,new WeakMap),e.get(n).set(i,s)):(s=r.get(i),void 0===s&&(s=new kAt(t),r.set(i,s))),s},dispose:function(){e=new WeakMap}}}function TAt(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new rEt,color:new TMt};break;case"SpotLight":n={position:new rEt,direction:new rEt,color:new TMt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new rEt,color:new TMt,distance:0,decay:0};break;case"HemisphereLight":n={direction:new rEt,skyColor:new TMt,groundColor:new TMt};break;case"RectAreaLight":n={color:new TMt,position:new rEt,halfWidth:new rEt,halfHeight:new rEt}}return t[e.id]=n,n}}}let _At=0;function EAt(t,e){return(e.castShadow?1:0)-(t.castShadow?1:0)}function MAt(t,e){const n=new TAt,i=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new X_t};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new X_t,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=n,n}}}(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let t=0;t<9;t++)r.probe.push(new rEt);const s=new rEt,o=new NEt,a=new NEt;return{setup:function(s){let o=0,a=0,l=0;for(let t=0;t<9;t++)r.probe[t].set(0,0,0);let c=0,u=0,h=0,d=0,p=0,f=0,m=0,g=0;s.sort(EAt);for(let t=0,e=s.length;t<e;t++){const e=s[t],y=e.color,b=e.intensity,v=e.distance,x=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)o+=y.r*b,a+=y.g*b,l+=y.b*b;else if(e.isLightProbe)for(let t=0;t<9;t++)r.probe[t].addScaledVector(e.sh.coefficients[t],b);else if(e.isDirectionalLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity),e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,r.directionalShadow[c]=n,r.directionalShadowMap[c]=x,r.directionalShadowMatrix[c]=e.shadow.matrix,f++}r.directional[c]=t,c++}else if(e.isSpotLight){const t=n.get(e);if(t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(y).multiplyScalar(b),t.distance=v,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,r.spotShadow[h]=n,r.spotShadowMap[h]=x,r.spotShadowMatrix[h]=e.shadow.matrix,g++}r.spot[h]=t,h++}else if(e.isRectAreaLight){const t=n.get(e);t.color.copy(y).multiplyScalar(b),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),r.rectArea[d]=t,d++}else if(e.isPointLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity),t.distance=e.distance,t.decay=e.decay,e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,r.pointShadow[u]=n,r.pointShadowMap[u]=x,r.pointShadowMatrix[u]=e.shadow.matrix,m++}r.point[u]=t,u++}else if(e.isHemisphereLight){const t=n.get(e);t.skyColor.copy(e.color).multiplyScalar(b),t.groundColor.copy(e.groundColor).multiplyScalar(b),r.hemi[p]=t,p++}}d>0&&(e.isWebGL2||!0===t.has("OES_texture_float_linear")?(r.rectAreaLTC1=B$t.LTC_FLOAT_1,r.rectAreaLTC2=B$t.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(r.rectAreaLTC1=B$t.LTC_HALF_1,r.rectAreaLTC2=B$t.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=o,r.ambient[1]=a,r.ambient[2]=l;const y=r.hash;y.directionalLength===c&&y.pointLength===u&&y.spotLength===h&&y.rectAreaLength===d&&y.hemiLength===p&&y.numDirectionalShadows===f&&y.numPointShadows===m&&y.numSpotShadows===g||(r.directional.length=c,r.spot.length=h,r.rectArea.length=d,r.point.length=u,r.hemi.length=p,r.directionalShadow.length=f,r.directionalShadowMap.length=f,r.pointShadow.length=m,r.pointShadowMap.length=m,r.spotShadow.length=g,r.spotShadowMap.length=g,r.directionalShadowMatrix.length=f,r.pointShadowMatrix.length=m,r.spotShadowMatrix.length=g,y.directionalLength=c,y.pointLength=u,y.spotLength=h,y.rectAreaLength=d,y.hemiLength=p,y.numDirectionalShadows=f,y.numPointShadows=m,y.numSpotShadows=g,r.version=_At++)},setupView:function(t,e){let n=0,i=0,l=0,c=0,u=0;const h=e.matrixWorldInverse;for(let e=0,d=t.length;e<d;e++){const d=t[e];if(d.isDirectionalLight){const t=r.directional[n];t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(h),n++}else if(d.isSpotLight){const t=r.spot[l];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(h),t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(h),l++}else if(d.isRectAreaLight){const t=r.rectArea[c];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(h),a.identity(),o.copy(d.matrixWorld),o.premultiply(h),a.extractRotation(o),t.halfWidth.set(.5*d.width,0,0),t.halfHeight.set(0,.5*d.height,0),t.halfWidth.applyMatrix4(a),t.halfHeight.applyMatrix4(a),c++}else if(d.isPointLight){const t=r.point[i];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(h),i++}else if(d.isHemisphereLight){const t=r.hemi[u];t.direction.setFromMatrixPosition(d.matrixWorld),t.direction.transformDirection(h),t.direction.normalize(),u++}}},state:r}}function $At(t,e){const n=new MAt(t,e),i=[],r=[];return{init:function(){i.length=0,r.length=0},state:{lightsArray:i,shadowsArray:r,lights:n},setupLights:function(){n.setup(i)},setupLightsView:function(t){n.setupView(i,t)},pushLight:function(t){i.push(t)},pushShadow:function(t){r.push(t)}}}function IAt(t,e){let n=new WeakMap;return{get:function(i,r=0){let s;return!1===n.has(i)?(s=new $At(t,e),n.set(i,[]),n.get(i).push(s)):r>=n.get(i).length?(s=new $At(t,e),n.get(i).push(s)):s=n.get(i)[r],s},dispose:function(){n=new WeakMap}}}function AAt(t){MMt.call(this),this.type="MeshDepthMaterial",this.depthPacking=O_t,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}function NAt(t){MMt.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new rEt,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}AAt.prototype=Object.create(MMt.prototype),AAt.prototype.constructor=AAt,AAt.prototype.isMeshDepthMaterial=!0,AAt.prototype.copy=function(t){return MMt.prototype.copy.call(this,t),this.depthPacking=t.depthPacking,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this},NAt.prototype=Object.create(MMt.prototype),NAt.prototype.constructor=NAt,NAt.prototype.isMeshDistanceMaterial=!0,NAt.prototype.copy=function(t){return MMt.prototype.copy.call(this,t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this};var RAt="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",PAt="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";function OAt(t,e,n){let i=new O$t;const r=new X_t,s=new X_t,o=new eEt,a=[],l=[],c={},u={0:rCt,1:iCt,2:sCt},h=new T$t({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new X_t},radius:{value:4}},vertexShader:PAt,fragmentShader:RAt}),d=h.clone();d.defines.HORIZONTAL_PASS=1;const p=new QMt;p.setAttribute("position",new NMt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const f=new y$t(p,h),m=this;function g(n,i){const r=e.update(f);h.uniforms.shadow_pass.value=n.map.texture,h.uniforms.resolution.value=n.mapSize,h.uniforms.radius.value=n.radius,t.setRenderTarget(n.mapPass),t.clear(),t.renderBufferDirect(i,null,r,h,f,null),d.uniforms.shadow_pass.value=n.mapPass.texture,d.uniforms.resolution.value=n.mapSize,d.uniforms.radius.value=n.radius,t.setRenderTarget(n.map),t.clear(),t.renderBufferDirect(i,null,r,d,f,null)}function y(t,e,n){const i=t<<0|e<<1|n<<2;let r=a[i];return void 0===r&&(r=new AAt({depthPacking:L_t,morphTargets:t,skinning:e}),a[i]=r),r}function b(t,e,n){const i=t<<0|e<<1|n<<2;let r=l[i];return void 0===r&&(r=new NAt({morphTargets:t,skinning:e}),l[i]=r),r}function v(e,n,i,r,s,o,a){let l=null,h=y,d=e.customDepthMaterial;if(!0===r.isPointLight&&(h=b,d=e.customDistanceMaterial),void 0===d){let t=!1;!0===i.morphTargets&&(t=n.morphAttributes&&n.morphAttributes.position&&n.morphAttributes.position.length>0);let r=!1;!0===e.isSkinnedMesh&&(!0===i.skinning?r=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",e));l=h(t,r,!0===e.isInstancedMesh)}else l=d;if(t.localClippingEnabled&&!0===i.clipShadows&&0!==i.clippingPlanes.length){const t=l.uuid,e=i.uuid;let n=c[t];void 0===n&&(n={},c[t]=n);let r=n[e];void 0===r&&(r=l.clone(),n[e]=r),l=r}return l.visible=i.visible,l.wireframe=i.wireframe,l.side=a===nCt?null!==i.shadowSide?i.shadowSide:i.side:null!==i.shadowSide?i.shadowSide:u[i.side],l.clipShadows=i.clipShadows,l.clippingPlanes=i.clippingPlanes,l.clipIntersection=i.clipIntersection,l.wireframeLinewidth=i.wireframeLinewidth,l.linewidth=i.linewidth,!0===r.isPointLight&&!0===l.isMeshDistanceMaterial&&(l.referencePosition.setFromMatrixPosition(r.matrixWorld),l.nearDistance=s,l.farDistance=o),l}function x(n,r,s,o,a){if(!1===n.visible)return;if(n.layers.test(r.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&a===nCt)&&(!n.frustumCulled||i.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const i=e.update(n),r=n.material;if(Array.isArray(r)){const e=i.groups;for(let l=0,c=e.length;l<c;l++){const c=e[l],u=r[c.materialIndex];if(u&&u.visible){const e=v(n,i,u,o,s.near,s.far,a);t.renderBufferDirect(s,null,i,e,n,c)}}}else if(r.visible){const e=v(n,i,r,o,s.near,s.far,a);t.renderBufferDirect(s,null,i,e,n,null)}}const l=n.children;for(let t=0,e=l.length;t<e;t++)x(l[t],r,s,o,a)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=tCt,this.render=function(e,a,l){if(!1===m.enabled)return;if(!1===m.autoUpdate&&!1===m.needsUpdate)return;if(0===e.length)return;const c=t.getRenderTarget(),u=t.getActiveCubeFace(),h=t.getActiveMipmapLevel(),d=t.state;d.setBlending(oCt),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);for(let c=0,u=e.length;c<u;c++){const u=e[c],h=u.shadow;if(void 0===h){console.warn("THREE.WebGLShadowMap:",u,"has no shadow.");continue}if(!1===h.autoUpdate&&!1===h.needsUpdate)continue;r.copy(h.mapSize);const p=h.getFrameExtents();if(r.multiply(p),s.copy(h.mapSize),(r.x>n||r.y>n)&&(r.x>n&&(s.x=Math.floor(n/p.x),r.x=s.x*p.x,h.mapSize.x=s.x),r.y>n&&(s.y=Math.floor(n/p.y),r.y=s.y*p.y,h.mapSize.y=s.y)),null===h.map&&!h.isPointLightShadow&&this.type===nCt){const t={minFilter:rTt,magFilter:rTt,format:wTt};h.map=new nEt(r.x,r.y,t),h.map.texture.name=u.name+".shadowMap",h.mapPass=new nEt(r.x,r.y,t),h.camera.updateProjectionMatrix()}if(null===h.map){const t={minFilter:eTt,magFilter:eTt,format:wTt};h.map=new nEt(r.x,r.y,t),h.map.texture.name=u.name+".shadowMap",h.camera.updateProjectionMatrix()}t.setRenderTarget(h.map),t.clear();const f=h.getViewportCount();for(let t=0;t<f;t++){const e=h.getViewport(t);o.set(s.x*e.x,s.y*e.y,s.x*e.z,s.y*e.w),d.viewport(o),h.updateMatrices(u,t),i=h.getFrustum(),x(a,l,h.camera,u,this.type)}h.isPointLightShadow||this.type!==nCt||g(h,l),h.needsUpdate=!1}m.needsUpdate=!1,t.setRenderTarget(c,u,h)}}function LAt(t,e,n){const i=n.isWebGL2;const r=new function(){let e=!1;const n=new eEt;let i=null;const r=new eEt(0,0,0,0);return{setMask:function(n){i===n||e||(t.colorMask(n,n,n,n),i=n)},setLocked:function(t){e=t},setClear:function(e,i,s,o,a){!0===a&&(e*=o,i*=o,s*=o),n.set(e,i,s,o),!1===r.equals(n)&&(t.clearColor(e,i,s,o),r.copy(n))},reset:function(){e=!1,i=null,r.set(-1,0,0,0)}}},s=new function(){let e=!1,n=null,i=null,r=null;return{setTest:function(t){t?R(2929):P(2929)},setMask:function(i){n===i||e||(t.depthMask(i),n=i)},setFunc:function(e){if(i!==e){if(e)switch(e){case MCt:t.depthFunc(512);break;case $Ct:t.depthFunc(519);break;case ICt:t.depthFunc(513);break;case ACt:t.depthFunc(515);break;case NCt:t.depthFunc(514);break;case RCt:t.depthFunc(518);break;case PCt:t.depthFunc(516);break;case OCt:t.depthFunc(517);break;default:t.depthFunc(515)}else t.depthFunc(515);i=e}},setLocked:function(t){e=t},setClear:function(e){r!==e&&(t.clearDepth(e),r=e)},reset:function(){e=!1,n=null,i=null,r=null}}},o=new function(){let e=!1,n=null,i=null,r=null,s=null,o=null,a=null,l=null,c=null;return{setTest:function(t){e||(t?R(2960):P(2960))},setMask:function(i){n===i||e||(t.stencilMask(i),n=i)},setFunc:function(e,n,o){i===e&&r===n&&s===o||(t.stencilFunc(e,n,o),i=e,r=n,s=o)},setOp:function(e,n,i){o===e&&a===n&&l===i||(t.stencilOp(e,n,i),o=e,a=n,l=i)},setLocked:function(t){e=t},setClear:function(e){c!==e&&(t.clearStencil(e),c=e)},reset:function(){e=!1,n=null,i=null,r=null,s=null,o=null,a=null,l=null,c=null}}};let a={},l=null,c=null,u=null,h=null,d=null,p=null,f=null,m=null,g=null,y=!1,b=null,v=null,x=null,w=null,S=null;const k=t.getParameter(35661);let C=!1,T=0;const _=t.getParameter(7938);-1!==_.indexOf("WebGL")?(T=parseFloat(/^WebGL (\d)/.exec(_)[1]),C=T>=1):-1!==_.indexOf("OpenGL ES")&&(T=parseFloat(/^OpenGL ES (\d)/.exec(_)[1]),C=T>=2);let E=null,M={};const $=new eEt,I=new eEt;function A(e,n,i){const r=new Uint8Array(4),s=t.createTexture();t.bindTexture(e,s),t.texParameteri(e,10241,9728),t.texParameteri(e,10240,9728);for(let e=0;e<i;e++)t.texImage2D(n+e,0,6408,1,1,0,6408,5121,r);return s}const N={};function R(e){!0!==a[e]&&(t.enable(e),a[e]=!0)}function P(e){!1!==a[e]&&(t.disable(e),a[e]=!1)}N[3553]=A(3553,3553,1),N[34067]=A(34067,34069,6),r.setClear(0,0,0,1),s.setClear(1),o.setClear(0),R(2929),s.setFunc(ACt),F(!1),z(Jkt),R(2884),D(oCt);const O={[dCt]:32774,[pCt]:32778,[fCt]:32779};if(i)O[mCt]=32775,O[gCt]=32776;else{const t=e.get("EXT_blend_minmax");null!==t&&(O[mCt]=t.MIN_EXT,O[gCt]=t.MAX_EXT)}const L={[yCt]:0,[bCt]:1,[vCt]:768,[wCt]:770,[ECt]:776,[TCt]:774,[kCt]:772,[xCt]:769,[SCt]:771,[_Ct]:775,[CCt]:773};function D(e,n,i,r,s,o,a,l){if(e!==oCt){if(c||(R(3042),c=!0),e===hCt)s=s||n,o=o||i,a=a||r,n===h&&s===f||(t.blendEquationSeparate(O[n],O[s]),h=n,f=s),i===d&&r===p&&o===m&&a===g||(t.blendFuncSeparate(L[i],L[r],L[o],L[a]),d=i,p=r,m=o,g=a),u=e,y=null;else if(e!==u||l!==y){if(h===dCt&&f===dCt||(t.blendEquation(32774),h=dCt,f=dCt),l)switch(e){case aCt:t.blendFuncSeparate(1,771,1,771);break;case lCt:t.blendFunc(1,1);break;case cCt:t.blendFuncSeparate(0,0,769,771);break;case uCt:t.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case aCt:t.blendFuncSeparate(770,771,1,771);break;case lCt:t.blendFunc(770,1);break;case cCt:t.blendFunc(0,769);break;case uCt:t.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}d=null,p=null,m=null,g=null,u=e,y=l}}else c&&(P(3042),c=!1)}function F(e){b!==e&&(e?t.frontFace(2304):t.frontFace(2305),b=e)}function z(e){e!==Zkt?(R(2884),e!==v&&(e===Jkt?t.cullFace(1029):e===Qkt?t.cullFace(1028):t.cullFace(1032))):P(2884),v=e}function B(e,n,i){e?(R(32823),w===n&&S===i||(t.polygonOffset(n,i),w=n,S=i)):P(32823)}function U(e){void 0===e&&(e=33984+k-1),E!==e&&(t.activeTexture(e),E=e)}return{buffers:{color:r,depth:s,stencil:o},enable:R,disable:P,useProgram:function(e){return l!==e&&(t.useProgram(e),l=e,!0)},setBlending:D,setMaterial:function(t,e){t.side===sCt?P(2884):R(2884);let n=t.side===rCt;e&&(n=!n),F(n),t.blending===aCt&&!1===t.transparent?D(oCt):D(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),s.setFunc(t.depthFunc),s.setTest(t.depthTest),s.setMask(t.depthWrite),r.setMask(t.colorWrite);const i=t.stencilWrite;o.setTest(i),i&&(o.setMask(t.stencilWriteMask),o.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),o.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),B(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits)},setFlipSided:F,setCullFace:z,setLineWidth:function(e){e!==x&&(C&&t.lineWidth(e),x=e)},setPolygonOffset:B,setScissorTest:function(t){t?R(3089):P(3089)},activeTexture:U,bindTexture:function(e,n){null===E&&U();let i=M[E];void 0===i&&(i={type:void 0,texture:void 0},M[E]=i),i.type===e&&i.texture===n||(t.bindTexture(e,n||N[e]),i.type=e,i.texture=n)},unbindTexture:function(){const e=M[E];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(e){!1===$.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),$.copy(e))},viewport:function(e){!1===I.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),I.copy(e))},reset:function(){a={},E=null,M={},l=null,c=null,u=null,h=null,d=null,p=null,f=null,m=null,g=null,y=!1,b=null,v=null,x=null,w=null,S=null,r.reset(),s.reset(),o.reset()}}}function DAt(t,e,n,i,r,s,o){const a=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,u=r.maxTextureSize,h=r.maxSamples,d=new WeakMap;let p,f=!1;try{f="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function m(t,e){return f?new OffscreenCanvas(t,e):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function g(t,e,n,i){let r=1;if((t.width>i||t.height>i)&&(r=i/Math.max(t.width,t.height)),r<1||!0===e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const i=e?q_t.floorPowerOfTwo:Math.floor,s=i(r*t.width),o=i(r*t.height);void 0===p&&(p=m(s,o));const a=n?m(s,o):p;a.width=s,a.height=o;return a.getContext("2d").drawImage(t,0,0,s,o),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+s+"x"+o+")."),a}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+")."),t}return t}function y(t){return q_t.isPowerOfTwo(t.width)&&q_t.isPowerOfTwo(t.height)}function b(t,e){return t.generateMipmaps&&e&&t.minFilter!==eTt&&t.minFilter!==rTt}function v(e,n,r,s){t.generateMipmap(e);i.get(n).__maxMipLevel=Math.log(Math.max(r,s))*Math.LOG2E}function x(n,i,r){if(!1===a)return i;if(null!==n){if(void 0!==t[n])return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let s=i;return 6403===i&&(5126===r&&(s=33326),5131===r&&(s=33325),5121===r&&(s=33321)),6407===i&&(5126===r&&(s=34837),5131===r&&(s=34843),5121===r&&(s=32849)),6408===i&&(5126===r&&(s=34836),5131===r&&(s=34842),5121===r&&(s=32856)),33325!==s&&33326!==s&&34842!==s&&34836!==s||e.get("EXT_color_buffer_float"),s}function w(t){return t===eTt||t===nTt||t===iTt?9728:9729}function S(e){const n=e.target;n.removeEventListener("dispose",S),function(e){const n=i.get(e);if(void 0===n.__webglInit)return;t.deleteTexture(n.__webglTexture),i.remove(e)}(n),n.isVideoTexture&&d.delete(n),o.memory.textures--}function k(e){const n=e.target;n.removeEventListener("dispose",k),function(e){const n=i.get(e),r=i.get(e.texture);if(!e)return;void 0!==r.__webglTexture&&t.deleteTexture(r.__webglTexture);e.depthTexture&&e.depthTexture.dispose();if(e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++)t.deleteFramebuffer(n.__webglFramebuffer[e]),n.__webglDepthbuffer&&t.deleteRenderbuffer(n.__webglDepthbuffer[e]);else t.deleteFramebuffer(n.__webglFramebuffer),n.__webglDepthbuffer&&t.deleteRenderbuffer(n.__webglDepthbuffer),n.__webglMultisampledFramebuffer&&t.deleteFramebuffer(n.__webglMultisampledFramebuffer),n.__webglColorRenderbuffer&&t.deleteRenderbuffer(n.__webglColorRenderbuffer),n.__webglDepthRenderbuffer&&t.deleteRenderbuffer(n.__webglDepthRenderbuffer);i.remove(e.texture),i.remove(e)}(n),o.memory.textures--}let C=0;function T(t,e){const r=i.get(t);if(t.isVideoTexture&&function(t){const e=o.render.frame;d.get(t)!==e&&(d.set(t,e),t.update())}(t),t.version>0&&r.__version!==t.version){const n=t.image;if(void 0===n)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==n.complete)return void A(r,t,e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+e),n.bindTexture(3553,r.__webglTexture)}function _(e,r){const o=i.get(e);e.version>0&&o.__version!==e.version?function(e,i,r){if(6!==i.image.length)return;I(e,i),n.activeTexture(33984+r),n.bindTexture(34067,e.__webglTexture),t.pixelStorei(37440,i.flipY),t.pixelStorei(37441,i.premultiplyAlpha),t.pixelStorei(3317,i.unpackAlignment);const o=i&&(i.isCompressedTexture||i.image[0].isCompressedTexture),l=i.image[0]&&i.image[0].isDataTexture,u=[];for(let t=0;t<6;t++)u[t]=o||l?l?i.image[t].image:i.image[t]:g(i.image[t],!1,!0,c);const h=u[0],d=y(h)||a,p=s.convert(i.format),f=s.convert(i.type),m=x(i.internalFormat,p,f);let w;if($(34067,i,d),o){for(let t=0;t<6;t++){w=u[t].mipmaps;for(let e=0;e<w.length;e++){const r=w[e];i.format!==wTt&&i.format!==xTt?null!==p?n.compressedTexImage2D(34069+t,e,m,r.width,r.height,0,r.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(34069+t,e,m,r.width,r.height,0,p,f,r.data)}}e.__maxMipLevel=w.length-1}else{w=i.mipmaps;for(let t=0;t<6;t++)if(l){n.texImage2D(34069+t,0,m,u[t].width,u[t].height,0,p,f,u[t].data);for(let e=0;e<w.length;e++){const i=w[e].image[t].image;n.texImage2D(34069+t,e+1,m,i.width,i.height,0,p,f,i.data)}}else{n.texImage2D(34069+t,0,m,p,f,u[t]);for(let e=0;e<w.length;e++){const i=w[e];n.texImage2D(34069+t,e+1,m,p,f,i.image[t])}}e.__maxMipLevel=w.length}b(i,d)&&v(34067,i,h.width,h.height);e.__version=i.version,i.onUpdate&&i.onUpdate(i)}(o,e,r):(n.activeTexture(33984+r),n.bindTexture(34067,o.__webglTexture))}const E={[JCt]:10497,[QCt]:33071,[tTt]:33648},M={[eTt]:9728,[nTt]:9984,[iTt]:9986,[rTt]:9729,[sTt]:9985,[oTt]:9987};function $(n,s,o){o?(t.texParameteri(n,10242,E[s.wrapS]),t.texParameteri(n,10243,E[s.wrapT]),32879!==n&&35866!==n||t.texParameteri(n,32882,E[s.wrapR]),t.texParameteri(n,10240,M[s.magFilter]),t.texParameteri(n,10241,M[s.minFilter])):(t.texParameteri(n,10242,33071),t.texParameteri(n,10243,33071),32879!==n&&35866!==n||t.texParameteri(n,32882,33071),s.wrapS===QCt&&s.wrapT===QCt||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),t.texParameteri(n,10240,w(s.magFilter)),t.texParameteri(n,10241,w(s.minFilter)),s.minFilter!==eTt&&s.minFilter!==rTt&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const l=e.get("EXT_texture_filter_anisotropic");if(l){if(s.type===pTt&&null===e.get("OES_texture_float_linear"))return;if(s.type===fTt&&null===(a||e.get("OES_texture_half_float_linear")))return;(s.anisotropy>1||i.get(s).__currentAnisotropy)&&(t.texParameterf(n,l.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,r.getMaxAnisotropy())),i.get(s).__currentAnisotropy=s.anisotropy)}}function I(e,n){void 0===e.__webglInit&&(e.__webglInit=!0,n.addEventListener("dispose",S),e.__webglTexture=t.createTexture(),o.memory.textures++)}function A(e,i,r){let o=3553;i.isDataTexture2DArray&&(o=35866),i.isDataTexture3D&&(o=32879),I(e,i),n.activeTexture(33984+r),n.bindTexture(o,e.__webglTexture),t.pixelStorei(37440,i.flipY),t.pixelStorei(37441,i.premultiplyAlpha),t.pixelStorei(3317,i.unpackAlignment);const l=function(t){return!a&&(t.wrapS!==QCt||t.wrapT!==QCt||t.minFilter!==eTt&&t.minFilter!==rTt)}(i)&&!1===y(i.image),c=g(i.image,l,!1,u),h=y(c)||a,d=s.convert(i.format);let p,f=s.convert(i.type),m=x(i.internalFormat,d,f);$(o,i,h);const w=i.mipmaps;if(i.isDepthTexture)m=6402,a?m=i.type===pTt?36012:i.type===dTt?33190:i.type===bTt?35056:33189:i.type===pTt&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),i.format===TTt&&6402===m&&i.type!==uTt&&i.type!==dTt&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),i.type=uTt,f=s.convert(i.type)),i.format===_Tt&&6402===m&&(m=34041,i.type!==bTt&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),i.type=bTt,f=s.convert(i.type))),n.texImage2D(3553,0,m,c.width,c.height,0,d,f,null);else if(i.isDataTexture)if(w.length>0&&h){for(let t=0,e=w.length;t<e;t++)p=w[t],n.texImage2D(3553,t,m,p.width,p.height,0,d,f,p.data);i.generateMipmaps=!1,e.__maxMipLevel=w.length-1}else n.texImage2D(3553,0,m,c.width,c.height,0,d,f,c.data),e.__maxMipLevel=0;else if(i.isCompressedTexture){for(let t=0,e=w.length;t<e;t++)p=w[t],i.format!==wTt&&i.format!==xTt?null!==d?n.compressedTexImage2D(3553,t,m,p.width,p.height,0,p.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(3553,t,m,p.width,p.height,0,d,f,p.data);e.__maxMipLevel=w.length-1}else if(i.isDataTexture2DArray)n.texImage3D(35866,0,m,c.width,c.height,c.depth,0,d,f,c.data),e.__maxMipLevel=0;else if(i.isDataTexture3D)n.texImage3D(32879,0,m,c.width,c.height,c.depth,0,d,f,c.data),e.__maxMipLevel=0;else if(w.length>0&&h){for(let t=0,e=w.length;t<e;t++)p=w[t],n.texImage2D(3553,t,m,d,f,p);i.generateMipmaps=!1,e.__maxMipLevel=w.length-1}else n.texImage2D(3553,0,m,d,f,c),e.__maxMipLevel=0;b(i,h)&&v(o,i,c.width,c.height),e.__version=i.version,i.onUpdate&&i.onUpdate(i)}function N(e,r,o,a){const l=s.convert(r.texture.format),c=s.convert(r.texture.type),u=x(r.texture.internalFormat,l,c);n.texImage2D(a,0,u,r.width,r.height,0,l,c,null),t.bindFramebuffer(36160,e),t.framebufferTexture2D(36160,o,a,i.get(r.texture).__webglTexture,0),t.bindFramebuffer(36160,null)}function R(e,n,i){if(t.bindRenderbuffer(36161,e),n.depthBuffer&&!n.stencilBuffer){let r=33189;if(i){const e=n.depthTexture;e&&e.isDepthTexture&&(e.type===pTt?r=36012:e.type===dTt&&(r=33190));const i=O(n);t.renderbufferStorageMultisample(36161,i,r,n.width,n.height)}else t.renderbufferStorage(36161,r,n.width,n.height);t.framebufferRenderbuffer(36160,36096,36161,e)}else if(n.depthBuffer&&n.stencilBuffer){if(i){const e=O(n);t.renderbufferStorageMultisample(36161,e,35056,n.width,n.height)}else t.renderbufferStorage(36161,34041,n.width,n.height);t.framebufferRenderbuffer(36160,33306,36161,e)}else{const e=s.convert(n.texture.format),r=s.convert(n.texture.type),o=x(n.texture.internalFormat,e,r);if(i){const e=O(n);t.renderbufferStorageMultisample(36161,e,o,n.width,n.height)}else t.renderbufferStorage(36161,o,n.width,n.height)}t.bindRenderbuffer(36161,null)}function P(e){const n=i.get(e),r=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture){if(r)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,n){if(n&&n.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,e),!n.depthTexture||!n.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");i.get(n.depthTexture).__webglTexture&&n.depthTexture.image.width===n.width&&n.depthTexture.image.height===n.height||(n.depthTexture.image.width=n.width,n.depthTexture.image.height=n.height,n.depthTexture.needsUpdate=!0),T(n.depthTexture,0);const r=i.get(n.depthTexture).__webglTexture;if(n.depthTexture.format===TTt)t.framebufferTexture2D(36160,36096,3553,r,0);else{if(n.depthTexture.format!==_Tt)throw new Error("Unknown depthTexture format");t.framebufferTexture2D(36160,33306,3553,r,0)}}(n.__webglFramebuffer,e)}else if(r){n.__webglDepthbuffer=[];for(let i=0;i<6;i++)t.bindFramebuffer(36160,n.__webglFramebuffer[i]),n.__webglDepthbuffer[i]=t.createRenderbuffer(),R(n.__webglDepthbuffer[i],e,!1)}else t.bindFramebuffer(36160,n.__webglFramebuffer),n.__webglDepthbuffer=t.createRenderbuffer(),R(n.__webglDepthbuffer,e,!1);t.bindFramebuffer(36160,null)}function O(t){return a&&t.isWebGLMultisampleRenderTarget?Math.min(h,t.samples):0}let L=!1,D=!1;this.allocateTextureUnit=function(){const t=C;return t>=l&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+l),C+=1,t},this.resetTextureUnits=function(){C=0},this.setTexture2D=T,this.setTexture2DArray=function(t,e){const r=i.get(t);t.version>0&&r.__version!==t.version?A(r,t,e):(n.activeTexture(33984+e),n.bindTexture(35866,r.__webglTexture))},this.setTexture3D=function(t,e){const r=i.get(t);t.version>0&&r.__version!==t.version?A(r,t,e):(n.activeTexture(33984+e),n.bindTexture(32879,r.__webglTexture))},this.setTextureCube=_,this.setupRenderTarget=function(e){const r=i.get(e),l=i.get(e.texture);e.addEventListener("dispose",k),l.__webglTexture=t.createTexture(),o.memory.textures++;const c=!0===e.isWebGLCubeRenderTarget,u=!0===e.isWebGLMultisampleRenderTarget,h=y(e)||a;if(!a||e.texture.format!==xTt||e.texture.type!==pTt&&e.texture.type!==fTt||(e.texture.format=wTt,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),c){r.__webglFramebuffer=[];for(let e=0;e<6;e++)r.__webglFramebuffer[e]=t.createFramebuffer()}else if(r.__webglFramebuffer=t.createFramebuffer(),u)if(a){r.__webglMultisampledFramebuffer=t.createFramebuffer(),r.__webglColorRenderbuffer=t.createRenderbuffer(),t.bindRenderbuffer(36161,r.__webglColorRenderbuffer);const n=s.convert(e.texture.format),i=s.convert(e.texture.type),o=x(e.texture.internalFormat,n,i),a=O(e);t.renderbufferStorageMultisample(36161,a,o,e.width,e.height),t.bindFramebuffer(36160,r.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(36160,36064,36161,r.__webglColorRenderbuffer),t.bindRenderbuffer(36161,null),e.depthBuffer&&(r.__webglDepthRenderbuffer=t.createRenderbuffer(),R(r.__webglDepthRenderbuffer,e,!0)),t.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(c){n.bindTexture(34067,l.__webglTexture),$(34067,e.texture,h);for(let t=0;t<6;t++)N(r.__webglFramebuffer[t],e,36064,34069+t);b(e.texture,h)&&v(34067,e.texture,e.width,e.height),n.bindTexture(34067,null)}else n.bindTexture(3553,l.__webglTexture),$(3553,e.texture,h),N(r.__webglFramebuffer,e,36064,3553),b(e.texture,h)&&v(3553,e.texture,e.width,e.height),n.bindTexture(3553,null);e.depthBuffer&&P(e)},this.updateRenderTargetMipmap=function(t){const e=t.texture;if(b(e,y(t)||a)){const r=t.isWebGLCubeRenderTarget?34067:3553,s=i.get(e).__webglTexture;n.bindTexture(r,s),v(r,e,t.width,t.height),n.bindTexture(r,null)}},this.updateMultisampleRenderTarget=function(e){if(e.isWebGLMultisampleRenderTarget)if(a){const n=i.get(e);t.bindFramebuffer(36008,n.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,n.__webglFramebuffer);const r=e.width,s=e.height;let o=16384;e.depthBuffer&&(o|=256),e.stencilBuffer&&(o|=1024),t.blitFramebuffer(0,0,r,s,0,0,r,s,o,9728),t.bindFramebuffer(36160,n.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(t,e){t&&t.isWebGLRenderTarget&&(!1===L&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),L=!0),t=t.texture),T(t,e)},this.safeSetTextureCube=function(t,e){t&&t.isWebGLCubeRenderTarget&&(!1===D&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),D=!0),t=t.texture),_(t,e)}}function FAt(t,e,n){const i=n.isWebGL2;return{convert:function(t){let n;if(t===aTt)return 5121;if(t===mTt)return 32819;if(t===gTt)return 32820;if(t===yTt)return 33635;if(t===lTt)return 5120;if(t===cTt)return 5122;if(t===uTt)return 5123;if(t===hTt)return 5124;if(t===dTt)return 5125;if(t===pTt)return 5126;if(t===fTt)return i?5131:(n=e.get("OES_texture_half_float"),null!==n?n.HALF_FLOAT_OES:null);if(t===vTt)return 6406;if(t===xTt)return 6407;if(t===wTt)return 6408;if(t===STt)return 6409;if(t===kTt)return 6410;if(t===TTt)return 6402;if(t===_Tt)return 34041;if(t===ETt)return 6403;if(t===MTt)return 36244;if(t===$Tt)return 33319;if(t===ITt)return 33320;if(t===ATt)return 36248;if(t===NTt)return 36249;if(t===RTt||t===PTt||t===OTt||t===LTt){if(n=e.get("WEBGL_compressed_texture_s3tc"),null===n)return null;if(t===RTt)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(t===PTt)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(t===OTt)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(t===LTt)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(t===DTt||t===FTt||t===zTt||t===BTt){if(n=e.get("WEBGL_compressed_texture_pvrtc"),null===n)return null;if(t===DTt)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(t===FTt)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(t===zTt)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(t===BTt)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(t===UTt)return n=e.get("WEBGL_compressed_texture_etc1"),null!==n?n.COMPRESSED_RGB_ETC1_WEBGL:null;if((t===VTt||t===WTt)&&(n=e.get("WEBGL_compressed_texture_etc"),null!==n)){if(t===VTt)return n.COMPRESSED_RGB8_ETC2;if(t===WTt)return n.COMPRESSED_RGBA8_ETC2_EAC}return t===HTt||t===jTt||t===GTt||t===qTt||t===XTt||t===KTt||t===YTt||t===ZTt||t===JTt||t===QTt||t===t_t||t===e_t||t===n_t||t===i_t||t===s_t||t===o_t||t===a_t||t===l_t||t===c_t||t===u_t||t===h_t||t===d_t||t===p_t||t===f_t||t===m_t||t===g_t||t===y_t||t===b_t?(n=e.get("WEBGL_compressed_texture_astc"),null!==n?t:null):t===r_t?(n=e.get("EXT_texture_compression_bptc"),null!==n?t:null):t===bTt?i?34042:(n=e.get("WEBGL_depth_texture"),null!==n?n.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}function zAt(t=[]){E$t.call(this),this.cameras=t}function BAt(){iMt.call(this),this.type="Group"}function UAt(){this._targetRay=null,this._grip=null,this._hand=null}function VAt(t,e){const n=this;let i=null,r=1,s=null,o="local-floor",a=null;const l=[],c=new Map,u=new E$t;u.layers.enable(1),u.viewport=new eEt;const h=new E$t;h.layers.enable(2),h.viewport=new eEt;const d=[u,h],p=new zAt;p.layers.enable(1),p.layers.enable(2);let f=null,m=null;function g(t){const e=c.get(t.inputSource);e&&e.dispatchEvent({type:t.type,data:t.inputSource})}function y(){c.forEach((function(t,e){t.disconnect(e)})),c.clear(),f=null,m=null,t.setFramebuffer(null),t.setRenderTarget(t.getRenderTarget()),k.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function b(t){const e=i.inputSources;for(let t=0;t<l.length;t++)c.set(e[t],l[t]);for(let e=0;e<t.removed.length;e++){const n=t.removed[e],i=c.get(n);i&&(i.dispatchEvent({type:"disconnected",data:n}),c.delete(n))}for(let e=0;e<t.added.length;e++){const n=t.added[e],i=c.get(n);i&&i.dispatchEvent({type:"connected",data:n})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=l[t];return void 0===e&&(e=new UAt,l[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=l[t];return void 0===e&&(e=new UAt,l[t]=e),e.getGripSpace()},this.getHand=function(t){let e=l[t];return void 0===e&&(e=new UAt,l[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){r=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){o=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return s},this.getSession=function(){return i},this.setSession=async function(t){if(i=t,null!==i){i.addEventListener("select",g),i.addEventListener("selectstart",g),i.addEventListener("selectend",g),i.addEventListener("squeeze",g),i.addEventListener("squeezestart",g),i.addEventListener("squeezeend",g),i.addEventListener("end",y),i.addEventListener("inputsourceschange",b);const t=e.getContextAttributes();!0!==t.xrCompatible&&await e.makeXRCompatible();const a={antialias:t.antialias,alpha:t.alpha,depth:t.depth,stencil:t.stencil,framebufferScaleFactor:r},l=new XRWebGLLayer(i,e,a);i.updateRenderState({baseLayer:l}),s=await i.requestReferenceSpace(o),k.setContext(i),k.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const v=new rEt,x=new rEt;function w(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.getCamera=function(t){p.near=h.near=u.near=t.near,p.far=h.far=u.far=t.far,f===p.near&&m===p.far||(i.updateRenderState({depthNear:p.near,depthFar:p.far}),f=p.near,m=p.far);const e=t.parent,n=p.cameras;w(p,e);for(let t=0;t<n.length;t++)w(n[t],e);t.matrixWorld.copy(p.matrixWorld),t.matrix.copy(p.matrix),t.matrix.decompose(t.position,t.quaternion,t.scale);const r=t.children;for(let t=0,e=r.length;t<e;t++)r[t].updateMatrixWorld(!0);return 2===n.length?function(t,e,n){v.setFromMatrixPosition(e.matrixWorld),x.setFromMatrixPosition(n.matrixWorld);const i=v.distanceTo(x),r=e.projectionMatrix.elements,s=n.projectionMatrix.elements,o=r[14]/(r[10]-1),a=r[14]/(r[10]+1),l=(r[9]+1)/r[5],c=(r[9]-1)/r[5],u=(r[8]-1)/r[0],h=(s[8]+1)/s[0],d=o*u,p=o*h,f=i/(-u+h),m=f*-u;e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(m),t.translateZ(f),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();const g=o+f,y=a+f,b=d-m,w=p+(i-m),S=l*a/y*g,k=c*a/y*g;t.projectionMatrix.makePerspective(b,w,S,k,g,y)}(p,u,h):p.projectionMatrix.copy(u.projectionMatrix),p};let S=null;const k=new L$t;k.setAnimationLoop((function(e,n){if(a=n.getViewerPose(s),null!==a){const e=a.views,n=i.renderState.baseLayer;t.setFramebuffer(n.framebuffer);let r=!1;e.length!==p.cameras.length&&(p.cameras.length=0,r=!0);for(let t=0;t<e.length;t++){const i=e[t],s=n.getViewport(i),o=d[t];o.matrix.fromArray(i.transform.matrix),o.projectionMatrix.fromArray(i.projectionMatrix),o.viewport.set(s.x,s.y,s.width,s.height),0===t&&p.matrix.copy(o.matrix),!0===r&&p.cameras.push(o)}}const r=i.inputSources;for(let t=0;t<l.length;t++){const e=l[t],i=r[t];e.update(i,n,s)}S&&S(e,n)})),this.setAnimationLoop=function(t){S=t},this.dispose=function(){}}function WAt(t){function e(e,n){e.opacity.value=n.opacity,n.color&&e.diffuse.value.copy(n.color),n.emissive&&e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(e.map.value=n.map),n.alphaMap&&(e.alphaMap.value=n.alphaMap),n.specularMap&&(e.specularMap.value=n.specularMap);const i=t.get(n).envMap;if(i){e.envMap.value=i,e.flipEnvMap.value=i.isCubeTexture&&i._needsFlipEnvMap?-1:1,e.reflectivity.value=n.reflectivity,e.refractionRatio.value=n.refractionRatio;const r=t.get(i).__maxMipLevel;void 0!==r&&(e.maxMipLevel.value=r)}let r,s;n.lightMap&&(e.lightMap.value=n.lightMap,e.lightMapIntensity.value=n.lightMapIntensity),n.aoMap&&(e.aoMap.value=n.aoMap,e.aoMapIntensity.value=n.aoMapIntensity),n.map?r=n.map:n.specularMap?r=n.specularMap:n.displacementMap?r=n.displacementMap:n.normalMap?r=n.normalMap:n.bumpMap?r=n.bumpMap:n.roughnessMap?r=n.roughnessMap:n.metalnessMap?r=n.metalnessMap:n.alphaMap?r=n.alphaMap:n.emissiveMap?r=n.emissiveMap:n.clearcoatMap?r=n.clearcoatMap:n.clearcoatNormalMap?r=n.clearcoatNormalMap:n.clearcoatRoughnessMap&&(r=n.clearcoatRoughnessMap),void 0!==r&&(r.isWebGLRenderTarget&&(r=r.texture),!0===r.matrixAutoUpdate&&r.updateMatrix(),e.uvTransform.value.copy(r.matrix)),n.aoMap?s=n.aoMap:n.lightMap&&(s=n.lightMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),e.uv2Transform.value.copy(s.matrix))}function n(e,n){e.roughness.value=n.roughness,e.metalness.value=n.metalness,n.roughnessMap&&(e.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(e.metalnessMap.value=n.metalnessMap),n.emissiveMap&&(e.emissiveMap.value=n.emissiveMap),n.bumpMap&&(e.bumpMap.value=n.bumpMap,e.bumpScale.value=n.bumpScale,n.side===rCt&&(e.bumpScale.value*=-1)),n.normalMap&&(e.normalMap.value=n.normalMap,e.normalScale.value.copy(n.normalScale),n.side===rCt&&e.normalScale.value.negate()),n.displacementMap&&(e.displacementMap.value=n.displacementMap,e.displacementScale.value=n.displacementScale,e.displacementBias.value=n.displacementBias);t.get(n).envMap&&(e.envMapIntensity.value=n.envMapIntensity)}return{refreshFogUniforms:function(t,e){t.fogColor.value.copy(e.color),e.isFog?(t.fogNear.value=e.near,t.fogFar.value=e.far):e.isFogExp2&&(t.fogDensity.value=e.density)},refreshMaterialUniforms:function(t,i,r,s){i.isMeshBasicMaterial?e(t,i):i.isMeshLambertMaterial?(e(t,i),function(t,e){e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap)}(t,i)):i.isMeshToonMaterial?(e(t,i),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap);e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap);e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,e.side===rCt&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),e.side===rCt&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshPhongMaterial?(e(t,i),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap);e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,e.side===rCt&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),e.side===rCt&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshStandardMaterial?(e(t,i),i.isMeshPhysicalMaterial?function(t,e){n(t,e),t.reflectivity.value=e.reflectivity,t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.sheen&&t.sheen.value.copy(e.sheen);e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap);e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap);e.clearcoatNormalMap&&(t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),t.clearcoatNormalMap.value=e.clearcoatNormalMap,e.side===rCt&&t.clearcoatNormalScale.value.negate());t.transmission.value=e.transmission,e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap)}(t,i):n(t,i)):i.isMeshMatcapMaterial?(e(t,i),function(t,e){e.matcap&&(t.matcap.value=e.matcap);e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,e.side===rCt&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),e.side===rCt&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshDepthMaterial?(e(t,i),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isMeshDistanceMaterial?(e(t,i),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias);t.referencePosition.value.copy(e.referencePosition),t.nearDistance.value=e.nearDistance,t.farDistance.value=e.farDistance}(t,i)):i.isMeshNormalMaterial?(e(t,i),function(t,e){e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,e.side===rCt&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),e.side===rCt&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,i)):i.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity}(t,i),i.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,i)):i.isPointsMaterial?function(t,e,n,i){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*n,t.scale.value=.5*i,e.map&&(t.map.value=e.map);e.alphaMap&&(t.alphaMap.value=e.alphaMap);let r;e.map?r=e.map:e.alphaMap&&(r=e.alphaMap);void 0!==r&&(!0===r.matrixAutoUpdate&&r.updateMatrix(),t.uvTransform.value.copy(r.matrix))}(t,i,r,s):i.isSpriteMaterial?function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map);e.alphaMap&&(t.alphaMap.value=e.alphaMap);let n;e.map?n=e.map:e.alphaMap&&(n=e.alphaMap);void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),t.uvTransform.value.copy(n.matrix))}(t,i):i.isShadowMaterial?(t.color.value.copy(i.color),t.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function HAt(t){const e=void 0!==(t=t||{}).canvas?t.canvas:function(){const t=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return t.style.display="block",t}(),n=void 0!==t.context?t.context:null,i=void 0!==t.alpha&&t.alpha,r=void 0===t.depth||t.depth,s=void 0===t.stencil||t.stencil,o=void 0!==t.antialias&&t.antialias,a=void 0===t.premultipliedAlpha||t.premultipliedAlpha,l=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,c=void 0!==t.powerPreference?t.powerPreference:"default",u=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat;let h=null,d=null;const p=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=E_t,this.physicallyCorrectLights=!1,this.toneMapping=zCt,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const f=this;let m=!1,g=null,y=0,b=0,v=null,x=null,w=-1,S=null;const k=new eEt,C=new eEt;let T=null,_=e.width,E=e.height,M=1,$=null,I=null;const A=new eEt(0,0,_,E),N=new eEt(0,0,_,E);let R=!1;const P=new O$t;let O=!1,L=!1;const D=new NEt,F=new rEt,z={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function B(){return null===v?M:1}let U,V,W,H,j,G,q,X,K,Y,Z,J,Q,tt,et,nt,it,rt,st,ot,at,lt=n;function ct(t,n){for(let i=0;i<t.length;i++){const r=t[i],s=e.getContext(r,n);if(null!==s)return s}return null}try{const t={alpha:i,depth:r,stencil:s,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:u};if(e.addEventListener("webglcontextlost",pt,!1),e.addEventListener("webglcontextrestored",ft,!1),null===lt){const e=["webgl2","webgl","experimental-webgl"];if(!0===f.isWebGL1Renderer&&e.shift(),lt=ct(e,t),null===lt)throw ct(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===lt.getShaderPrecisionFormat&&(lt.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function ut(){U=new X$t(lt),V=new j$t(lt,U,t),U.init(V),ot=new FAt(lt,U,V),W=new LAt(lt,U,V),W.scissor(C.copy(N).multiplyScalar(M).floor()),W.viewport(k.copy(A).multiplyScalar(M).floor()),H=new Z$t,j=new xAt,G=new DAt(lt,U,W,j,V,ot,H),q=new q$t(f),X=new D$t(lt,V),at=new W$t(lt,U,X,V),K=new K$t(lt,X,H,at),Y=new eIt(lt,K,X,H),it=new tIt(lt),et=new G$t(j),Z=new vAt(f,q,U,V,at,et),J=new WAt(j),Q=new CAt(j),tt=new IAt(U,V),nt=new V$t(f,q,W,Y,a),rt=new H$t(lt,U,H,V),st=new Y$t(lt,U,H,V),H.programs=Z.programs,f.capabilities=V,f.extensions=U,f.properties=j,f.renderLists=Q,f.state=W,f.info=H}ut();const ht=new VAt(f,lt);this.xr=ht;const dt=new OAt(f,Y,V.maxTextureSize);function pt(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),m=!0}function ft(){console.log("THREE.WebGLRenderer: Context Restored."),m=!1,ut()}function mt(t){const e=t.target;e.removeEventListener("dispose",mt),function(t){gt(t),j.remove(t)}(e)}function gt(t){const e=j.get(t).program;void 0!==e&&Z.releaseProgram(e)}this.shadowMap=dt,this.getContext=function(){return lt},this.getContextAttributes=function(){return lt.getContextAttributes()},this.forceContextLoss=function(){const t=U.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=U.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return M},this.setPixelRatio=function(t){void 0!==t&&(M=t,this.setSize(_,E,!1))},this.getSize=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),t=new X_t),t.set(_,E)},this.setSize=function(t,n,i){ht.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(_=t,E=n,e.width=Math.floor(t*M),e.height=Math.floor(n*M),!1!==i&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n))},this.getDrawingBufferSize=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),t=new X_t),t.set(_*M,E*M).floor()},this.setDrawingBufferSize=function(t,n,i){_=t,E=n,M=i,e.width=Math.floor(t*i),e.height=Math.floor(n*i),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),t=new eEt),t.copy(k)},this.getViewport=function(t){return t.copy(A)},this.setViewport=function(t,e,n,i){t.isVector4?A.set(t.x,t.y,t.z,t.w):A.set(t,e,n,i),W.viewport(k.copy(A).multiplyScalar(M).floor())},this.getScissor=function(t){return t.copy(N)},this.setScissor=function(t,e,n,i){t.isVector4?N.set(t.x,t.y,t.z,t.w):N.set(t,e,n,i),W.scissor(C.copy(N).multiplyScalar(M).floor())},this.getScissorTest=function(){return R},this.setScissorTest=function(t){W.setScissorTest(R=t)},this.setOpaqueSort=function(t){$=t},this.setTransparentSort=function(t){I=t},this.getClearColor=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),t=new TMt),t.copy(nt.getClearColor())},this.setClearColor=function(){nt.setClearColor.apply(nt,arguments)},this.getClearAlpha=function(){return nt.getClearAlpha()},this.setClearAlpha=function(){nt.setClearAlpha.apply(nt,arguments)},this.clear=function(t,e,n){let i=0;(void 0===t||t)&&(i|=16384),(void 0===e||e)&&(i|=256),(void 0===n||n)&&(i|=1024),lt.clear(i)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",pt,!1),e.removeEventListener("webglcontextrestored",ft,!1),Q.dispose(),tt.dispose(),j.dispose(),q.dispose(),Y.dispose(),at.dispose(),ht.dispose(),bt.stop()},this.renderBufferImmediate=function(t,e){at.initAttributes();const n=j.get(t);t.hasPositions&&!n.position&&(n.position=lt.createBuffer()),t.hasNormals&&!n.normal&&(n.normal=lt.createBuffer()),t.hasUvs&&!n.uv&&(n.uv=lt.createBuffer()),t.hasColors&&!n.color&&(n.color=lt.createBuffer());const i=e.getAttributes();t.hasPositions&&(lt.bindBuffer(34962,n.position),lt.bufferData(34962,t.positionArray,35048),at.enableAttribute(i.position),lt.vertexAttribPointer(i.position,3,5126,!1,0,0)),t.hasNormals&&(lt.bindBuffer(34962,n.normal),lt.bufferData(34962,t.normalArray,35048),at.enableAttribute(i.normal),lt.vertexAttribPointer(i.normal,3,5126,!1,0,0)),t.hasUvs&&(lt.bindBuffer(34962,n.uv),lt.bufferData(34962,t.uvArray,35048),at.enableAttribute(i.uv),lt.vertexAttribPointer(i.uv,2,5126,!1,0,0)),t.hasColors&&(lt.bindBuffer(34962,n.color),lt.bufferData(34962,t.colorArray,35048),at.enableAttribute(i.color),lt.vertexAttribPointer(i.color,3,5126,!1,0,0)),at.disableUnusedAttributes(),lt.drawArrays(4,0,t.count),t.count=0},this.renderBufferDirect=function(t,e,n,i,r,s){null===e&&(e=z);const o=r.isMesh&&r.matrixWorld.determinant()<0,a=kt(t,e,i,r);W.setMaterial(i,o);let l=n.index;const c=n.attributes.position;if(null===l){if(void 0===c||0===c.count)return}else if(0===l.count)return;let u,h=1;!0===i.wireframe&&(l=K.getWireframeAttribute(n),h=2),(i.morphTargets||i.morphNormals)&&it.update(r,n,i,a),at.setup(r,i,a,n,l);let d=rt;null!==l&&(u=X.get(l),d=st,d.setIndex(u));const p=null!==l?l.count:c.count,f=n.drawRange.start*h,m=n.drawRange.count*h,g=null!==s?s.start*h:0,y=null!==s?s.count*h:1/0,b=Math.max(f,g),v=Math.min(p,f+m,g+y)-1,x=Math.max(0,v-b+1);if(0!==x){if(r.isMesh)!0===i.wireframe?(W.setLineWidth(i.wireframeLinewidth*B()),d.setMode(1)):d.setMode(4);else if(r.isLine){let t=i.linewidth;void 0===t&&(t=1),W.setLineWidth(t*B()),r.isLineSegments?d.setMode(1):r.isLineLoop?d.setMode(2):d.setMode(3)}else r.isPoints?d.setMode(0):r.isSprite&&d.setMode(4);if(r.isInstancedMesh)d.renderInstances(b,x,r.count);else if(n.isInstancedBufferGeometry){const t=Math.min(n.instanceCount,n._maxInstanceCount);d.renderInstances(b,x,t)}else d.render(b,x)}},this.compile=function(t,e){d=tt.get(t),d.init(),t.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&(d.pushLight(t),t.castShadow&&d.pushShadow(t))})),d.setupLights();const n=new WeakMap;t.traverse((function(e){const i=e.material;if(i)if(Array.isArray(i))for(let r=0;r<i.length;r++){const s=i[r];!1===n.has(s)&&(St(s,t,e),n.set(s))}else!1===n.has(i)&&(St(i,t,e),n.set(i))}))};let yt=null;const bt=new L$t;function vt(t,e,n,i){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)d.pushLight(t),t.castShadow&&d.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||P.intersectsSprite(t)){i&&F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(D);const e=Y.update(t),r=t.material;r.visible&&h.push(t,e,r,n,F.z,null)}}else if(t.isImmediateRenderObject)i&&F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(D),h.push(t,null,t.material,n,F.z,null);else if((t.isMesh||t.isLine||t.isPoints)&&(t.isSkinnedMesh&&t.skeleton.frame!==H.render.frame&&(t.skeleton.update(),t.skeleton.frame=H.render.frame),!t.frustumCulled||P.intersectsObject(t))){i&&F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(D);const e=Y.update(t),r=t.material;if(Array.isArray(r)){const i=e.groups;for(let s=0,o=i.length;s<o;s++){const o=i[s],a=r[o.materialIndex];a&&a.visible&&h.push(t,e,a,n,F.z,o)}}else r.visible&&h.push(t,e,r,n,F.z,null)}const r=t.children;for(let t=0,s=r.length;t<s;t++)vt(r[t],e,n,i)}function xt(t,e,n){const i=!0===e.isScene?e.overrideMaterial:null;for(let r=0,s=t.length;r<s;r++){const s=t[r],o=s.object,a=s.geometry,l=null===i?s.material:i,c=s.group;if(n.isArrayCamera){const t=n.cameras;for(let n=0,i=t.length;n<i;n++){const i=t[n];o.layers.test(i.layers)&&(W.viewport(k.copy(i.viewport)),d.setupLightsView(i),wt(o,e,i,a,l,c))}}else wt(o,e,n,a,l,c)}}function wt(t,e,n,i,r,s){if(t.onBeforeRender(f,e,n,i,r,s),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),t.isImmediateRenderObject){const i=kt(n,e,r,t);W.setMaterial(r),at.reset(),function(t,e){t.render((function(t){f.renderBufferImmediate(t,e)}))}(t,i)}else f.renderBufferDirect(n,e,i,r,t,s);t.onAfterRender(f,e,n,i,r,s)}function St(t,e,n){!0!==e.isScene&&(e=z);const i=j.get(t),r=d.state.lights,s=d.state.shadowsArray,o=r.state.version,a=Z.getParameters(t,r.state,s,e,n),l=Z.getProgramCacheKey(a);let c=i.program,u=!0;if(i.environment=t.isMeshStandardMaterial?e.environment:null,i.fog=e.fog,i.envMap=q.get(t.envMap||i.environment),void 0===c)t.addEventListener("dispose",mt);else if(c.cacheKey!==l)gt(t);else if(i.lightsStateVersion!==o)u=!1;else{if(void 0!==a.shaderID)return;u=!1}u&&(a.uniforms=Z.getUniforms(t),t.onBeforeCompile(a,f),c=Z.acquireProgram(a,l),i.program=c,i.uniforms=a.uniforms,i.outputEncoding=a.outputEncoding);const h=i.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(i.numClippingPlanes=et.numPlanes,i.numIntersection=et.numIntersection,h.clippingPlanes=et.uniform),i.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),i.lightsStateVersion=o,i.needsLights&&(h.ambientLightColor.value=r.state.ambient,h.lightProbe.value=r.state.probe,h.directionalLights.value=r.state.directional,h.directionalLightShadows.value=r.state.directionalShadow,h.spotLights.value=r.state.spot,h.spotLightShadows.value=r.state.spotShadow,h.rectAreaLights.value=r.state.rectArea,h.ltc_1.value=r.state.rectAreaLTC1,h.ltc_2.value=r.state.rectAreaLTC2,h.pointLights.value=r.state.point,h.pointLightShadows.value=r.state.pointShadow,h.hemisphereLights.value=r.state.hemi,h.directionalShadowMap.value=r.state.directionalShadowMap,h.directionalShadowMatrix.value=r.state.directionalShadowMatrix,h.spotShadowMap.value=r.state.spotShadowMap,h.spotShadowMatrix.value=r.state.spotShadowMatrix,h.pointShadowMap.value=r.state.pointShadowMap,h.pointShadowMatrix.value=r.state.pointShadowMatrix);const p=i.program.getUniforms(),m=JIt.seqWithValue(p.seq,h);i.uniformsList=m}function kt(t,e,n,i){!0!==e.isScene&&(e=z),G.resetTextureUnits();const r=e.fog,s=n.isMeshStandardMaterial?e.environment:null,o=null===v?f.outputEncoding:v.texture.encoding,a=q.get(n.envMap||s),l=j.get(n),c=d.state.lights;if(!0===O&&(!0===L||t!==S)){const e=t===S&&n.id===w;et.setState(n,t,e)}n.version===l.__version?n.fog&&l.fog!==r||l.environment!==s||l.needsLights&&l.lightsStateVersion!==c.state.version?St(n,e,i):void 0===l.numClippingPlanes||l.numClippingPlanes===et.numPlanes&&l.numIntersection===et.numIntersection?(l.outputEncoding!==o||l.envMap!==a)&&St(n,e,i):St(n,e,i):(St(n,e,i),l.__version=n.version);let u=!1,h=!1,p=!1;const m=l.program,g=m.getUniforms(),y=l.uniforms;if(W.useProgram(m.program)&&(u=!0,h=!0,p=!0),n.id!==w&&(w=n.id,h=!0),u||S!==t){if(g.setValue(lt,"projectionMatrix",t.projectionMatrix),V.logarithmicDepthBuffer&&g.setValue(lt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),S!==t&&(S=t,h=!0,p=!0),n.isShaderMaterial||n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshStandardMaterial||n.envMap){const e=g.map.cameraPosition;void 0!==e&&e.setValue(lt,F.setFromMatrixPosition(t.matrixWorld))}(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&g.setValue(lt,"isOrthographic",!0===t.isOrthographicCamera),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial||n.isShadowMaterial||n.skinning)&&g.setValue(lt,"viewMatrix",t.matrixWorldInverse)}if(n.skinning){g.setOptional(lt,i,"bindMatrix"),g.setOptional(lt,i,"bindMatrixInverse");const t=i.skeleton;if(t){const e=t.bones;if(V.floatVertexTextures){if(null===t.boneTexture){let n=Math.sqrt(4*e.length);n=q_t.ceilPowerOfTwo(n),n=Math.max(n,4);const i=new Float32Array(n*n*4);i.set(t.boneMatrices);const r=new N$t(i,n,n,wTt,pTt);t.boneMatrices=i,t.boneTexture=r,t.boneTextureSize=n}g.setValue(lt,"boneTexture",t.boneTexture,G),g.setValue(lt,"boneTextureSize",t.boneTextureSize)}else g.setOptional(lt,t,"boneMatrices")}}var b,x;return(h||l.receiveShadow!==i.receiveShadow)&&(l.receiveShadow=i.receiveShadow,g.setValue(lt,"receiveShadow",i.receiveShadow)),h&&(g.setValue(lt,"toneMappingExposure",f.toneMappingExposure),l.needsLights&&(x=p,(b=y).ambientLightColor.needsUpdate=x,b.lightProbe.needsUpdate=x,b.directionalLights.needsUpdate=x,b.directionalLightShadows.needsUpdate=x,b.pointLights.needsUpdate=x,b.pointLightShadows.needsUpdate=x,b.spotLights.needsUpdate=x,b.spotLightShadows.needsUpdate=x,b.rectAreaLights.needsUpdate=x,b.hemisphereLights.needsUpdate=x),r&&n.fog&&J.refreshFogUniforms(y,r),J.refreshMaterialUniforms(y,n,M,E),JIt.upload(lt,l.uniformsList,y,G)),n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(JIt.upload(lt,l.uniformsList,y,G),n.uniformsNeedUpdate=!1),n.isSpriteMaterial&&g.setValue(lt,"center",i.center),g.setValue(lt,"modelViewMatrix",i.modelViewMatrix),g.setValue(lt,"normalMatrix",i.normalMatrix),g.setValue(lt,"modelMatrix",i.matrixWorld),m}bt.setAnimationLoop((function(t){ht.isPresenting||yt&&yt(t)})),"undefined"!=typeof window&&bt.setContext(window),this.setAnimationLoop=function(t){yt=t,ht.setAnimationLoop(t),null===t?bt.stop():bt.start()},this.render=function(t,e){let n,i;if(void 0!==arguments[2]&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),n=arguments[2]),void 0!==arguments[3]&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),i=arguments[3]),void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===m)return;at.resetDefaultState(),w=-1,S=null,!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),!0===ht.enabled&&!0===ht.isPresenting&&(e=ht.getCamera(e)),!0===t.isScene&&t.onBeforeRender(f,t,e,n||v),d=tt.get(t,p.length),d.init(),p.push(d),D.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),P.setFromProjectionMatrix(D),L=this.localClippingEnabled,O=et.init(this.clippingPlanes,L,e),h=Q.get(t,e),h.init(),vt(t,e,0,f.sortObjects),h.finish(),!0===f.sortObjects&&h.sort($,I),!0===O&&et.beginShadows();const r=d.state.shadowsArray;dt.render(r,t,e),d.setupLights(),d.setupLightsView(e),!0===O&&et.endShadows(),!0===this.info.autoReset&&this.info.reset(),void 0!==n&&this.setRenderTarget(n),nt.render(h,t,e,i);const s=h.opaque,o=h.transparent;s.length>0&&xt(s,t,e),o.length>0&&xt(o,t,e),!0===t.isScene&&t.onAfterRender(f,t,e),null!==v&&(G.updateRenderTargetMipmap(v),G.updateMultisampleRenderTarget(v)),W.buffers.depth.setTest(!0),W.buffers.depth.setMask(!0),W.buffers.color.setMask(!0),W.setPolygonOffset(!1),p.pop(),d=p.length>0?p[p.length-1]:null,h=null},this.setFramebuffer=function(t){g!==t&&null===v&&lt.bindFramebuffer(36160,t),g=t},this.getActiveCubeFace=function(){return y},this.getActiveMipmapLevel=function(){return b},this.getRenderList=function(){return h},this.setRenderList=function(t){h=t},this.getRenderTarget=function(){return v},this.setRenderTarget=function(t,e=0,n=0){v=t,y=e,b=n,t&&void 0===j.get(t).__webglFramebuffer&&G.setupRenderTarget(t);let i=g,r=!1;if(t){const n=j.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(i=n[e],r=!0):i=t.isWebGLMultisampleRenderTarget?j.get(t).__webglMultisampledFramebuffer:n,k.copy(t.viewport),C.copy(t.scissor),T=t.scissorTest}else k.copy(A).multiplyScalar(M).floor(),C.copy(N).multiplyScalar(M).floor(),T=R;if(x!==i&&(lt.bindFramebuffer(36160,i),x=i),W.viewport(k),W.scissor(C),W.setScissorTest(T),r){const i=j.get(t.texture);lt.framebufferTexture2D(36160,36064,34069+e,i.__webglTexture,n)}},this.readRenderTargetPixels=function(t,e,n,i,r,s,o){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let a=j.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==o&&(a=a[o]),a){let o=!1;a!==x&&(lt.bindFramebuffer(36160,a),o=!0);try{const o=t.texture,a=o.format,l=o.type;if(a!==wTt&&ot.convert(a)!==lt.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const c=l===fTt&&(U.has("EXT_color_buffer_half_float")||V.isWebGL2&&U.has("EXT_color_buffer_float"));if(!(l===aTt||ot.convert(l)===lt.getParameter(35738)||l===pTt&&(V.isWebGL2||U.has("OES_texture_float")||U.has("WEBGL_color_buffer_float"))||c))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===lt.checkFramebufferStatus(36160)?e>=0&&e<=t.width-i&&n>=0&&n<=t.height-r&&lt.readPixels(e,n,i,r,ot.convert(a),ot.convert(l),s):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{o&&lt.bindFramebuffer(36160,x)}}},this.copyFramebufferToTexture=function(t,e,n=0){const i=Math.pow(2,-n),r=Math.floor(e.image.width*i),s=Math.floor(e.image.height*i),o=ot.convert(e.format);G.setTexture2D(e,0),lt.copyTexImage2D(3553,n,o,t.x,t.y,r,s,0),W.unbindTexture()},this.copyTextureToTexture=function(t,e,n,i=0){const r=e.image.width,s=e.image.height,o=ot.convert(n.format),a=ot.convert(n.type);G.setTexture2D(n,0),lt.pixelStorei(37440,n.flipY),lt.pixelStorei(37441,n.premultiplyAlpha),lt.pixelStorei(3317,n.unpackAlignment),e.isDataTexture?lt.texSubImage2D(3553,i,t.x,t.y,r,s,o,a,e.image.data):e.isCompressedTexture?lt.compressedTexSubImage2D(3553,i,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,o,e.mipmaps[0].data):lt.texSubImage2D(3553,i,t.x,t.y,o,a,e.image),0===i&&n.generateMipmaps&&lt.generateMipmap(3553),W.unbindTexture()},this.initTexture=function(t){G.setTexture2D(t,0),W.unbindTexture()},this.resetState=function(){W.reset(),at.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function jAt(t){HAt.call(this,t)}zAt.prototype=Object.assign(Object.create(E$t.prototype),{constructor:zAt,isArrayCamera:!0}),BAt.prototype=Object.assign(Object.create(iMt.prototype),{constructor:BAt,isGroup:!0}),Object.assign(UAt.prototype,{constructor:UAt,getHandSpace:function(){return null===this._hand&&(this._hand=new BAt,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand},getTargetRaySpace:function(){return null===this._targetRay&&(this._targetRay=new BAt,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return null===this._grip&&(this._grip=new BAt,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this},disconnect:function(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this},update:function(t,e,n){let i=null,r=null,s=null;const o=this._targetRay,a=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState)if(l&&t.hand){s=!0;for(const i of t.hand.values()){const t=e.getJointPose(i,n);if(void 0===l.joints[i.jointName]){const t=new BAt;t.matrixAutoUpdate=!1,t.visible=!1,l.joints[i.jointName]=t,l.add(t)}const r=l.joints[i.jointName];null!==t&&(r.matrix.fromArray(t.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale),r.jointRadius=t.radius),r.visible=null!==t}const i=l.joints["index-finger-tip"],r=l.joints["thumb-tip"],o=i.position.distanceTo(r.position),a=.02,c=.005;l.inputState.pinching&&o>a+c?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&o<=a-c&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==o&&(i=e.getPose(t.targetRaySpace,n),null!==i&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale))),null!==a&&t.gripSpace&&(r=e.getPose(t.gripSpace,n),null!==r&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale)));return null!==o&&(o.visible=null!==i),null!==a&&(a.visible=null!==r),null!==l&&(l.visible=null!==s),this}}),Object.assign(VAt.prototype,H_t.prototype),jAt.prototype=Object.assign(Object.create(HAt.prototype),{constructor:jAt,isWebGL1Renderer:!0});class GAt{constructor(t,e){Object.defineProperty(this,"isFogExp2",{value:!0}),this.name="",this.color=new TMt(t),this.density=void 0!==e?e:25e-5}clone(){return new GAt(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class qAt{constructor(t,e,n){Object.defineProperty(this,"isFog",{value:!0}),this.name="",this.color=new TMt(t),this.near=void 0!==e?e:1,this.far=void 0!==n?n:1e3}clone(){return new qAt(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class XAt extends iMt{constructor(){super(),Object.defineProperty(this,"isScene",{value:!0}),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.background&&(e.object.background=this.background.toJSON(t)),null!==this.environment&&(e.object.environment=this.environment.toJSON(t)),null!==this.fog&&(e.object.fog=this.fog.toJSON()),e}}function KAt(t,e){this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=U_t,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=q_t.generateUUID()}Object.defineProperty(KAt.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),Object.assign(KAt.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(t){return this.usage=t,this},copy:function(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this},copyAt:function(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[n+i];return this},set:function(t,e=0){return this.array.set(t,e),this},clone:function(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=q_t.generateUUID()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new KAt(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),this.stride);return e.setUsage(this.usage),e},onUpload:function(t){return this.onUploadCallback=t,this},toJSON:function(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=q_t.generateUUID()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const YAt=new rEt;function ZAt(t,e,n,i){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=!0===i}function JAt(t){MMt.call(this),this.type="SpriteMaterial",this.color=new TMt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}let QAt;Object.defineProperties(ZAt.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(t){this.data.needsUpdate=t}}}),Object.assign(ZAt.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(t){for(let e=0,n=this.data.count;e<n;e++)YAt.x=this.getX(e),YAt.y=this.getY(e),YAt.z=this.getZ(e),YAt.applyMatrix4(t),this.setXYZ(e,YAt.x,YAt.y,YAt.z);return this},setX:function(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this},setY:function(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this},setZ:function(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this},setW:function(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this},getX:function(t){return this.data.array[t*this.data.stride+this.offset]},getY:function(t){return this.data.array[t*this.data.stride+this.offset+1]},getZ:function(t){return this.data.array[t*this.data.stride+this.offset+2]},getW:function(t){return this.data.array[t*this.data.stride+this.offset+3]},setXY:function(t,e,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this},setXYZ:function(t,e,n,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this},setXYZW:function(t,e,n,i,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=r,this},clone:function(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return new NMt(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new ZAt(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}),JAt.prototype=Object.create(MMt.prototype),JAt.prototype.constructor=JAt,JAt.prototype.isSpriteMaterial=!0,JAt.prototype.copy=function(t){return MMt.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this};const tNt=new rEt,eNt=new rEt,nNt=new rEt,iNt=new X_t,rNt=new X_t,sNt=new NEt,oNt=new rEt,aNt=new rEt,lNt=new rEt,cNt=new X_t,uNt=new X_t,hNt=new X_t;function dNt(t){if(iMt.call(this),this.type="Sprite",void 0===QAt){QAt=new QMt;const t=new KAt(new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),5);QAt.setIndex([0,1,2,0,2,3]),QAt.setAttribute("position",new ZAt(t,3,0,!1)),QAt.setAttribute("uv",new ZAt(t,2,3,!1))}this.geometry=QAt,this.material=void 0!==t?t:new JAt,this.center=new X_t(.5,.5)}function pNt(t,e,n,i,r,s){iNt.subVectors(t,n).addScalar(.5).multiply(i),void 0!==r?(rNt.x=s*iNt.x-r*iNt.y,rNt.y=r*iNt.x+s*iNt.y):rNt.copy(iNt),t.copy(e),t.x+=rNt.x,t.y+=rNt.y,t.applyMatrix4(sNt)}dNt.prototype=Object.assign(Object.create(iMt.prototype),{constructor:dNt,isSprite:!0,raycast:function(t,e){null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),eNt.setFromMatrixScale(this.matrixWorld),sNt.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),nNt.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&eNt.multiplyScalar(-nNt.z);const n=this.material.rotation;let i,r;0!==n&&(r=Math.cos(n),i=Math.sin(n));const s=this.center;pNt(oNt.set(-.5,-.5,0),nNt,s,eNt,i,r),pNt(aNt.set(.5,-.5,0),nNt,s,eNt,i,r),pNt(lNt.set(.5,.5,0),nNt,s,eNt,i,r),cNt.set(0,0),uNt.set(1,0),hNt.set(1,1);let o=t.ray.intersectTriangle(oNt,aNt,lNt,!1,tNt);if(null===o&&(pNt(aNt.set(-.5,.5,0),nNt,s,eNt,i,r),uNt.set(0,1),o=t.ray.intersectTriangle(oNt,lNt,aNt,!1,tNt),null===o))return;const a=t.ray.origin.distanceTo(tNt);a<t.near||a>t.far||e.push({distance:a,point:tNt.clone(),uv:bMt.getUV(tNt,oNt,aNt,lNt,cNt,uNt,hNt,new X_t),face:null,object:this})},copy:function(t){return iMt.prototype.copy.call(this,t),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}});const fNt=new rEt,mNt=new rEt;function gNt(){iMt.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}gNt.prototype=Object.assign(Object.create(iMt.prototype),{constructor:gNt,isLOD:!0,copy:function(t){iMt.prototype.copy.call(this,t,!1);const e=t.levels;for(let t=0,n=e.length;t<n;t++){const n=e[t];this.addLevel(n.object.clone(),n.distance)}return this.autoUpdate=t.autoUpdate,this},addLevel:function(t,e=0){e=Math.abs(e);const n=this.levels;let i;for(i=0;i<n.length&&!(e<n[i].distance);i++);return n.splice(i,0,{distance:e,object:t}),this.add(t),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(t){const e=this.levels;if(e.length>0){let n,i;for(n=1,i=e.length;n<i&&!(t<e[n].distance);n++);return e[n-1].object}return null},raycast:function(t,e){if(this.levels.length>0){fNt.setFromMatrixPosition(this.matrixWorld);const n=t.ray.origin.distanceTo(fNt);this.getObjectForDistance(n).raycast(t,e)}},update:function(t){const e=this.levels;if(e.length>1){fNt.setFromMatrixPosition(t.matrixWorld),mNt.setFromMatrixPosition(this.matrixWorld);const n=fNt.distanceTo(mNt)/t.zoom;let i,r;for(e[0].object.visible=!0,i=1,r=e.length;i<r&&n>=e[i].distance;i++)e[i-1].object.visible=!1,e[i].object.visible=!0;for(this._currentLevel=i-1;i<r;i++)e[i].object.visible=!1}},toJSON:function(t){const e=iMt.prototype.toJSON.call(this,t);!1===this.autoUpdate&&(e.object.autoUpdate=!1),e.object.levels=[];const n=this.levels;for(let t=0,i=n.length;t<i;t++){const i=n[t];e.object.levels.push({object:i.object.uuid,distance:i.distance})}return e}});const yNt=new rEt,bNt=new eEt,vNt=new eEt,xNt=new rEt,wNt=new NEt;function SNt(t,e){t&&t.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),y$t.call(this,t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new NEt,this.bindMatrixInverse=new NEt}function kNt(){iMt.call(this),this.type="Bone"}SNt.prototype=Object.assign(Object.create(y$t.prototype),{constructor:SNt,isSkinnedMesh:!0,copy:function(t){return y$t.prototype.copy.call(this,t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this},bind:function(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const t=new eEt,e=this.geometry.attributes.skinWeight;for(let n=0,i=e.count;n<i;n++){t.x=e.getX(n),t.y=e.getY(n),t.z=e.getZ(n),t.w=e.getW(n);const i=1/t.manhattanLength();i!==1/0?t.multiplyScalar(i):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}},updateMatrixWorld:function(t){y$t.prototype.updateMatrixWorld.call(this,t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(t,e){const n=this.skeleton,i=this.geometry;bNt.fromBufferAttribute(i.attributes.skinIndex,t),vNt.fromBufferAttribute(i.attributes.skinWeight,t),yNt.fromBufferAttribute(i.attributes.position,t).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const i=vNt.getComponent(t);if(0!==i){const r=bNt.getComponent(t);wNt.multiplyMatrices(n.bones[r].matrixWorld,n.boneInverses[r]),e.addScaledVector(xNt.copy(yNt).applyMatrix4(wNt),i)}}return e.applyMatrix4(this.bindMatrixInverse)}}),kNt.prototype=Object.assign(Object.create(iMt.prototype),{constructor:kNt,isBone:!0});const CNt=new NEt,TNt=new NEt;function _Nt(t=[],e=[]){this.uuid=q_t.generateUUID(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}Object.assign(_Nt.prototype,{init:function(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new NEt)}},calculateInverses:function(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new NEt;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}},pose:function(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}},update:function(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let i=0,r=t.length;i<r;i++){const r=t[i]?t[i].matrixWorld:TNt;CNt.multiplyMatrices(r,e[i]),CNt.toArray(n,16*i)}null!==i&&(i.needsUpdate=!0)},clone:function(){return new _Nt(this.bones,this.boneInverses)},getBoneByName:function(t){for(let e=0,n=this.bones.length;e<n;e++){const n=this.bones[e];if(n.name===t)return n}},dispose:function(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)},fromJSON:function(t,e){this.uuid=t.uuid;for(let n=0,i=t.bones.length;n<i;n++){const i=t.bones[n];let r=e[i];void 0===r&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),r=new kNt),this.bones.push(r),this.boneInverses.push((new NEt).fromArray(t.boneInverses[n]))}return this.init(),this},toJSON:function(){const t={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let i=0,r=e.length;i<r;i++){const r=e[i];t.bones.push(r.uuid);const s=n[i];t.boneInverses.push(s.toArray())}return t}});const ENt=new NEt,MNt=new NEt,$Nt=[],INt=new y$t;function ANt(t,e,n){y$t.call(this,t,e),this.instanceMatrix=new NMt(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}function NNt(t){MMt.call(this),this.type="LineBasicMaterial",this.color=new TMt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(t)}ANt.prototype=Object.assign(Object.create(y$t.prototype),{constructor:ANt,isInstancedMesh:!0,copy:function(t){return y$t.prototype.copy.call(this,t),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this},getColorAt:function(t,e){e.fromArray(this.instanceColor.array,3*t)},getMatrixAt:function(t,e){e.fromArray(this.instanceMatrix.array,16*t)},raycast:function(t,e){const n=this.matrixWorld,i=this.count;if(INt.geometry=this.geometry,INt.material=this.material,void 0!==INt.material)for(let r=0;r<i;r++){this.getMatrixAt(r,ENt),MNt.multiplyMatrices(n,ENt),INt.matrixWorld=MNt,INt.raycast(t,$Nt);for(let t=0,n=$Nt.length;t<n;t++){const n=$Nt[t];n.instanceId=r,n.object=this,e.push(n)}$Nt.length=0}},setColorAt:function(t,e){null===this.instanceColor&&(this.instanceColor=new NMt(new Float32Array(3*this.count),3)),e.toArray(this.instanceColor.array,3*t)},setMatrixAt:function(t,e){e.toArray(this.instanceMatrix.array,16*t)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}}),NNt.prototype=Object.create(MMt.prototype),NNt.prototype.constructor=NNt,NNt.prototype.isLineBasicMaterial=!0,NNt.prototype.copy=function(t){return MMt.prototype.copy.call(this,t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.morphTargets=t.morphTargets,this};const RNt=new rEt,PNt=new rEt,ONt=new NEt,LNt=new AEt,DNt=new kEt;function FNt(t=new QMt,e=new NNt){iMt.call(this),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}FNt.prototype=Object.assign(Object.create(iMt.prototype),{constructor:FNt,isLine:!0,copy:function(t){return iMt.prototype.copy.call(this,t),this.material=t.material,this.geometry=t.geometry,this},computeLineDistances:function(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[0];for(let t=1,i=e.count;t<i;t++)RNt.fromBufferAttribute(e,t-1),PNt.fromBufferAttribute(e,t),n[t]=n[t-1],n[t]+=RNt.distanceTo(PNt);t.setAttribute("lineDistance",new UMt(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this},raycast:function(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Line.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),DNt.copy(n.boundingSphere),DNt.applyMatrix4(i),DNt.radius+=r,!1===t.ray.intersectsSphere(DNt))return;ONt.copy(i).invert(),LNt.copy(t.ray).applyMatrix4(ONt);const s=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s,a=new rEt,l=new rEt,c=new rEt,u=new rEt,h=this.isLineSegments?2:1;if(n.isBufferGeometry){const i=n.index,r=n.attributes.position;if(null!==i){const n=i.array;for(let i=0,s=n.length-1;i<s;i+=h){const s=n[i],h=n[i+1];a.fromBufferAttribute(r,s),l.fromBufferAttribute(r,h);if(LNt.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const d=t.ray.origin.distanceTo(u);d<t.near||d>t.far||e.push({distance:d,point:c.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this})}}else for(let n=0,i=r.count-1;n<i;n+=h){a.fromBufferAttribute(r,n),l.fromBufferAttribute(r,n+1);if(LNt.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const i=t.ray.origin.distanceTo(u);i<t.near||i>t.far||e.push({distance:i,point:c.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const zNt=new rEt,BNt=new rEt;function UNt(t,e){FNt.call(this,t,e),this.type="LineSegments"}function VNt(t,e){FNt.call(this,t,e),this.type="LineLoop"}function WNt(t){MMt.call(this),this.type="PointsMaterial",this.color=new TMt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(t)}UNt.prototype=Object.assign(Object.create(FNt.prototype),{constructor:UNt,isLineSegments:!0,computeLineDistances:function(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[];for(let t=0,i=e.count;t<i;t+=2)zNt.fromBufferAttribute(e,t),BNt.fromBufferAttribute(e,t+1),n[t]=0===t?0:n[t-1],n[t+1]=n[t]+zNt.distanceTo(BNt);t.setAttribute("lineDistance",new UMt(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}),VNt.prototype=Object.assign(Object.create(FNt.prototype),{constructor:VNt,isLineLoop:!0}),WNt.prototype=Object.create(MMt.prototype),WNt.prototype.constructor=WNt,WNt.prototype.isPointsMaterial=!0,WNt.prototype.copy=function(t){return MMt.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.morphTargets=t.morphTargets,this};const HNt=new NEt,jNt=new AEt,GNt=new kEt,qNt=new rEt;function XNt(t=new QMt,e=new WNt){iMt.call(this),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}function KNt(t,e,n,i,r,s,o){const a=jNt.distanceSqToPoint(t);if(a<n){const n=new rEt;jNt.closestPointToPoint(t,n),n.applyMatrix4(i);const l=r.ray.origin.distanceTo(n);if(l<r.near||l>r.far)return;s.push({distance:l,distanceToRay:Math.sqrt(a),point:n,index:e,face:null,object:o})}}function YNt(t,e,n,i,r,s,o,a,l){Q_t.call(this,t,e,n,i,r,s,o,a,l),this.format=void 0!==o?o:xTt,this.minFilter=void 0!==s?s:rTt,this.magFilter=void 0!==r?r:rTt,this.generateMipmaps=!1;const c=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback((function e(){c.needsUpdate=!0,t.requestVideoFrameCallback(e)}))}function ZNt(t,e,n,i,r,s,o,a,l,c,u,h){Q_t.call(this,null,s,o,a,l,c,i,r,u,h),this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}function JNt(t,e,n,i,r,s,o,a,l){Q_t.call(this,t,e,n,i,r,s,o,a,l),this.needsUpdate=!0}function QNt(t,e,n,i,r,s,o,a,l,c){if((c=void 0!==c?c:TTt)!==TTt&&c!==_Tt)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&c===TTt&&(n=uTt),void 0===n&&c===_Tt&&(n=bTt),Q_t.call(this,null,i,r,s,o,a,c,n,l),this.image={width:t,height:e},this.magFilter=void 0!==o?o:eTt,this.minFilter=void 0!==a?a:eTt,this.flipY=!1,this.generateMipmaps=!1}XNt.prototype=Object.assign(Object.create(iMt.prototype),{constructor:XNt,isPoints:!0,copy:function(t){return iMt.prototype.copy.call(this,t),this.material=t.material,this.geometry=t.geometry,this},raycast:function(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),GNt.copy(n.boundingSphere),GNt.applyMatrix4(i),GNt.radius+=r,!1===t.ray.intersectsSphere(GNt))return;HNt.copy(i).invert(),jNt.copy(t.ray).applyMatrix4(HNt);const s=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s;if(n.isBufferGeometry){const r=n.index,s=n.attributes.position;if(null!==r){const n=r.array;for(let r=0,a=n.length;r<a;r++){const a=n[r];qNt.fromBufferAttribute(s,a),KNt(qNt,a,o,i,t,e,this)}}else for(let n=0,r=s.count;n<r;n++)qNt.fromBufferAttribute(s,n),KNt(qNt,n,o,i,t,e,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}),YNt.prototype=Object.assign(Object.create(Q_t.prototype),{constructor:YNt,clone:function(){return new this.constructor(this.image).copy(this)},isVideoTexture:!0,update:function(){const t=this.image;!1==="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}),ZNt.prototype=Object.create(Q_t.prototype),ZNt.prototype.constructor=ZNt,ZNt.prototype.isCompressedTexture=!0,JNt.prototype=Object.create(Q_t.prototype),JNt.prototype.constructor=JNt,JNt.prototype.isCanvasTexture=!0,QNt.prototype=Object.create(Q_t.prototype),QNt.prototype.constructor=QNt,QNt.prototype.isDepthTexture=!0;class tRt extends QMt{constructor(t=1,e=8,n=0,i=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:n,thetaLength:i},e=Math.max(3,e);const r=[],s=[],o=[],a=[],l=new rEt,c=new X_t;s.push(0,0,0),o.push(0,0,1),a.push(.5,.5);for(let r=0,u=3;r<=e;r++,u+=3){const h=n+r/e*i;l.x=t*Math.cos(h),l.y=t*Math.sin(h),s.push(l.x,l.y,l.z),o.push(0,0,1),c.x=(s[u]/t+1)/2,c.y=(s[u+1]/t+1)/2,a.push(c.x,c.y)}for(let t=1;t<=e;t++)r.push(t,t+1,0);this.setIndex(r),this.setAttribute("position",new UMt(s,3)),this.setAttribute("normal",new UMt(o,3)),this.setAttribute("uv",new UMt(a,2))}}class eRt extends QMt{constructor(t=1,e=1,n=1,i=8,r=1,s=!1,o=0,a=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:i,heightSegments:r,openEnded:s,thetaStart:o,thetaLength:a};const l=this;i=Math.floor(i),r=Math.floor(r);const c=[],u=[],h=[],d=[];let p=0;const f=[],m=n/2;let g=0;function y(n){const r=p,s=new X_t,f=new rEt;let y=0;const b=!0===n?t:e,v=!0===n?1:-1;for(let t=1;t<=i;t++)u.push(0,m*v,0),h.push(0,v,0),d.push(.5,.5),p++;const x=p;for(let t=0;t<=i;t++){const e=t/i*a+o,n=Math.cos(e),r=Math.sin(e);f.x=b*r,f.y=m*v,f.z=b*n,u.push(f.x,f.y,f.z),h.push(0,v,0),s.x=.5*n+.5,s.y=.5*r*v+.5,d.push(s.x,s.y),p++}for(let t=0;t<i;t++){const e=r+t,i=x+t;!0===n?c.push(i,i+1,e):c.push(i+1,i,e),y+=3}l.addGroup(g,y,!0===n?1:2),g+=y}!function(){const s=new rEt,y=new rEt;let b=0;const v=(e-t)/n;for(let l=0;l<=r;l++){const c=[],g=l/r,b=g*(e-t)+t;for(let t=0;t<=i;t++){const e=t/i,r=e*a+o,l=Math.sin(r),f=Math.cos(r);y.x=b*l,y.y=-g*n+m,y.z=b*f,u.push(y.x,y.y,y.z),s.set(l,v,f).normalize(),h.push(s.x,s.y,s.z),d.push(e,1-g),c.push(p++)}f.push(c)}for(let t=0;t<i;t++)for(let e=0;e<r;e++){const n=f[e][t],i=f[e+1][t],r=f[e+1][t+1],s=f[e][t+1];c.push(n,i,s),c.push(i,r,s),b+=6}l.addGroup(g,b,0),g+=b}(),!1===s&&(t>0&&y(!0),e>0&&y(!1)),this.setIndex(c),this.setAttribute("position",new UMt(u,3)),this.setAttribute("normal",new UMt(h,3)),this.setAttribute("uv",new UMt(d,2))}}class nRt extends eRt{constructor(t=1,e=1,n=8,i=1,r=!1,s=0,o=2*Math.PI){super(0,t,e,n,i,r,s,o),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:n,heightSegments:i,openEnded:r,thetaStart:s,thetaLength:o}}}class iRt extends QMt{constructor(t,e,n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:n,detail:i};const r=[],s=[];function o(t,e,n,i){const r=i+1,s=[];for(let i=0;i<=r;i++){s[i]=[];const o=t.clone().lerp(n,i/r),a=e.clone().lerp(n,i/r),l=r-i;for(let t=0;t<=l;t++)s[i][t]=0===t&&i===r?o:o.clone().lerp(a,t/l)}for(let t=0;t<r;t++)for(let e=0;e<2*(r-t)-1;e++){const n=Math.floor(e/2);e%2==0?(a(s[t][n+1]),a(s[t+1][n]),a(s[t][n])):(a(s[t][n+1]),a(s[t+1][n+1]),a(s[t+1][n]))}}function a(t){r.push(t.x,t.y,t.z)}function l(e,n){const i=3*e;n.x=t[i+0],n.y=t[i+1],n.z=t[i+2]}function c(t,e,n,i){i<0&&1===t.x&&(s[e]=t.x-1),0===n.x&&0===n.z&&(s[e]=i/2/Math.PI+.5)}function u(t){return Math.atan2(t.z,-t.x)}!function(t){const n=new rEt,i=new rEt,r=new rEt;for(let s=0;s<e.length;s+=3)l(e[s+0],n),l(e[s+1],i),l(e[s+2],r),o(n,i,r,t)}(i),function(t){const e=new rEt;for(let n=0;n<r.length;n+=3)e.x=r[n+0],e.y=r[n+1],e.z=r[n+2],e.normalize().multiplyScalar(t),r[n+0]=e.x,r[n+1]=e.y,r[n+2]=e.z}(n),function(){const t=new rEt;for(let n=0;n<r.length;n+=3){t.x=r[n+0],t.y=r[n+1],t.z=r[n+2];const i=u(t)/2/Math.PI+.5,o=(e=t,Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))/Math.PI+.5);s.push(i,1-o)}var e;(function(){const t=new rEt,e=new rEt,n=new rEt,i=new rEt,o=new X_t,a=new X_t,l=new X_t;for(let h=0,d=0;h<r.length;h+=9,d+=6){t.set(r[h+0],r[h+1],r[h+2]),e.set(r[h+3],r[h+4],r[h+5]),n.set(r[h+6],r[h+7],r[h+8]),o.set(s[d+0],s[d+1]),a.set(s[d+2],s[d+3]),l.set(s[d+4],s[d+5]),i.copy(t).add(e).add(n).divideScalar(3);const p=u(i);c(o,d+0,t,p),c(a,d+2,e,p),c(l,d+4,n,p)}})(),function(){for(let t=0;t<s.length;t+=6){const e=s[t+0],n=s[t+2],i=s[t+4],r=Math.max(e,n,i),o=Math.min(e,n,i);r>.9&&o<.1&&(e<.2&&(s[t+0]+=1),n<.2&&(s[t+2]+=1),i<.2&&(s[t+4]+=1))}}()}(),this.setAttribute("position",new UMt(r,3)),this.setAttribute("normal",new UMt(r.slice(),3)),this.setAttribute("uv",new UMt(s,2)),0===i?this.computeVertexNormals():this.normalizeNormals()}}class rRt extends iRt{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2,i=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}}const sRt=new rEt,oRt=new rEt,aRt=new rEt,lRt=new bMt;class cRt extends QMt{constructor(t,e){if(super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:e},e=void 0!==e?e:1,!0===t.isGeometry)return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");const n=Math.pow(10,4),i=Math.cos(q_t.DEG2RAD*e),r=t.getIndex(),s=t.getAttribute("position"),o=r?r.count:s.count,a=[0,0,0],l=["a","b","c"],c=new Array(3),u={},h=[];for(let t=0;t<o;t+=3){r?(a[0]=r.getX(t),a[1]=r.getX(t+1),a[2]=r.getX(t+2)):(a[0]=t,a[1]=t+1,a[2]=t+2);const{a:e,b:o,c:d}=lRt;if(e.fromBufferAttribute(s,a[0]),o.fromBufferAttribute(s,a[1]),d.fromBufferAttribute(s,a[2]),lRt.getNormal(aRt),c[0]=`${Math.round(e.x*n)},${Math.round(e.y*n)},${Math.round(e.z*n)}`,c[1]=`${Math.round(o.x*n)},${Math.round(o.y*n)},${Math.round(o.z*n)}`,c[2]=`${Math.round(d.x*n)},${Math.round(d.y*n)},${Math.round(d.z*n)}`,c[0]!==c[1]&&c[1]!==c[2]&&c[2]!==c[0])for(let t=0;t<3;t++){const e=(t+1)%3,n=c[t],r=c[e],s=lRt[l[t]],o=lRt[l[e]],d=`${n}_${r}`,p=`${r}_${n}`;p in u&&u[p]?(aRt.dot(u[p].normal)<=i&&(h.push(s.x,s.y,s.z),h.push(o.x,o.y,o.z)),u[p]=null):d in u||(u[d]={index0:a[t],index1:a[e],normal:aRt.clone()})}}for(const t in u)if(u[t]){const{index0:e,index1:n}=u[t];sRt.fromBufferAttribute(s,e),oRt.fromBufferAttribute(s,n),h.push(sRt.x,sRt.y,sRt.z),h.push(oRt.x,oRt.y,oRt.z)}this.setAttribute("position",new UMt(h,3))}}const uRt=function(t,e,n){n=n||2;const i=e&&e.length,r=i?e[0]*n:t.length;let s=hRt(t,0,r,n,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,c,u,h,d,p;if(i&&(s=function(t,e,n,i){const r=[];let s,o,a,l,c;for(s=0,o=e.length;s<o;s++)a=e[s]*i,l=s<o-1?e[s+1]*i:t.length,c=hRt(t,a,l,i,!1),c===c.next&&(c.steiner=!0),r.push(SRt(c));for(r.sort(bRt),s=0;s<r.length;s++)vRt(r[s],n),n=dRt(n,n.next);return n}(t,e,s,n)),t.length>80*n){a=c=t[0],l=u=t[1];for(let e=n;e<r;e+=n)h=t[e],d=t[e+1],h<a&&(a=h),d<l&&(l=d),h>c&&(c=h),d>u&&(u=d);p=Math.max(c-a,u-l),p=0!==p?1/p:0}return pRt(s,o,n,a,l,p),o};function hRt(t,e,n,i,r){let s,o;if(r===function(t,e,n,i){let r=0;for(let s=e,o=n-i;s<n;s+=i)r+=(t[o]-t[s])*(t[s+1]+t[o+1]),o=s;return r}(t,e,n,i)>0)for(s=e;s<n;s+=i)o=NRt(s,t[s],t[s+1],o);else for(s=n-i;s>=e;s-=i)o=NRt(s,t[s],t[s+1],o);return o&&_Rt(o,o.next)&&(RRt(o),o=o.next),o}function dRt(t,e){if(!t)return t;e||(e=t);let n,i=t;do{if(n=!1,i.steiner||!_Rt(i,i.next)&&0!==TRt(i.prev,i,i.next))i=i.next;else{if(RRt(i),i=e=i.prev,i===i.next)break;n=!0}}while(n||i!==e);return e}function pRt(t,e,n,i,r,s,o){if(!t)return;!o&&s&&function(t,e,n,i){let r=t;do{null===r.z&&(r.z=wRt(r.x,r.y,e,n,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==t);r.prevZ.nextZ=null,r.prevZ=null,function(t){let e,n,i,r,s,o,a,l,c=1;do{for(n=t,t=null,s=null,o=0;n;){for(o++,i=n,a=0,e=0;e<c&&(a++,i=i.nextZ,i);e++);for(l=c;a>0||l>0&&i;)0!==a&&(0===l||!i||n.z<=i.z)?(r=n,n=n.nextZ,a--):(r=i,i=i.nextZ,l--),s?s.nextZ=r:t=r,r.prevZ=s,s=r;n=i}s.nextZ=null,c*=2}while(o>1)}(r)}(t,i,r,s);let a,l,c=t;for(;t.prev!==t.next;)if(a=t.prev,l=t.next,s?mRt(t,i,r,s):fRt(t))e.push(a.i/n),e.push(t.i/n),e.push(l.i/n),RRt(t),t=l.next,c=l.next;else if((t=l)===c){o?1===o?pRt(t=gRt(dRt(t),e,n),e,n,i,r,s,2):2===o&&yRt(t,e,n,i,r,s):pRt(dRt(t),e,n,i,r,s,1);break}}function fRt(t){const e=t.prev,n=t,i=t.next;if(TRt(e,n,i)>=0)return!1;let r=t.next.next;for(;r!==t.prev;){if(kRt(e.x,e.y,n.x,n.y,i.x,i.y,r.x,r.y)&&TRt(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function mRt(t,e,n,i){const r=t.prev,s=t,o=t.next;if(TRt(r,s,o)>=0)return!1;const a=r.x<s.x?r.x<o.x?r.x:o.x:s.x<o.x?s.x:o.x,l=r.y<s.y?r.y<o.y?r.y:o.y:s.y<o.y?s.y:o.y,c=r.x>s.x?r.x>o.x?r.x:o.x:s.x>o.x?s.x:o.x,u=r.y>s.y?r.y>o.y?r.y:o.y:s.y>o.y?s.y:o.y,h=wRt(a,l,e,n,i),d=wRt(c,u,e,n,i);let p=t.prevZ,f=t.nextZ;for(;p&&p.z>=h&&f&&f.z<=d;){if(p!==t.prev&&p!==t.next&&kRt(r.x,r.y,s.x,s.y,o.x,o.y,p.x,p.y)&&TRt(p.prev,p,p.next)>=0)return!1;if(p=p.prevZ,f!==t.prev&&f!==t.next&&kRt(r.x,r.y,s.x,s.y,o.x,o.y,f.x,f.y)&&TRt(f.prev,f,f.next)>=0)return!1;f=f.nextZ}for(;p&&p.z>=h;){if(p!==t.prev&&p!==t.next&&kRt(r.x,r.y,s.x,s.y,o.x,o.y,p.x,p.y)&&TRt(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;f&&f.z<=d;){if(f!==t.prev&&f!==t.next&&kRt(r.x,r.y,s.x,s.y,o.x,o.y,f.x,f.y)&&TRt(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function gRt(t,e,n){let i=t;do{const r=i.prev,s=i.next.next;!_Rt(r,s)&&ERt(r,i,i.next,s)&&IRt(r,s)&&IRt(s,r)&&(e.push(r.i/n),e.push(i.i/n),e.push(s.i/n),RRt(i),RRt(i.next),i=t=s),i=i.next}while(i!==t);return dRt(i)}function yRt(t,e,n,i,r,s){let o=t;do{let t=o.next.next;for(;t!==o.prev;){if(o.i!==t.i&&CRt(o,t)){let a=ARt(o,t);return o=dRt(o,o.next),a=dRt(a,a.next),pRt(o,e,n,i,r,s),void pRt(a,e,n,i,r,s)}t=t.next}o=o.next}while(o!==t)}function bRt(t,e){return t.x-e.x}function vRt(t,e){if(e=function(t,e){let n=e;const i=t.x,r=t.y;let s,o=-1/0;do{if(r<=n.y&&r>=n.next.y&&n.next.y!==n.y){const t=n.x+(r-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=i&&t>o){if(o=t,t===i){if(r===n.y)return n;if(r===n.next.y)return n.next}s=n.x<n.next.x?n:n.next}}n=n.next}while(n!==e);if(!s)return null;if(i===o)return s;const a=s,l=s.x,c=s.y;let u,h=1/0;n=s;do{i>=n.x&&n.x>=l&&i!==n.x&&kRt(r<c?i:o,r,l,c,r<c?o:i,r,n.x,n.y)&&(u=Math.abs(r-n.y)/(i-n.x),IRt(n,t)&&(u<h||u===h&&(n.x>s.x||n.x===s.x&&xRt(s,n)))&&(s=n,h=u)),n=n.next}while(n!==a);return s}(t,e),e){const n=ARt(e,t);dRt(e,e.next),dRt(n,n.next)}}function xRt(t,e){return TRt(t.prev,t,e.prev)<0&&TRt(e.next,t,t.next)<0}function wRt(t,e,n,i,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-n)*r)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-i)*r)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function SRt(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function kRt(t,e,n,i,r,s,o,a){return(r-o)*(e-a)-(t-o)*(s-a)>=0&&(t-o)*(i-a)-(n-o)*(e-a)>=0&&(n-o)*(s-a)-(r-o)*(i-a)>=0}function CRt(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&ERt(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(IRt(t,e)&&IRt(e,t)&&function(t,e){let n=t,i=!1;const r=(t.x+e.x)/2,s=(t.y+e.y)/2;do{n.y>s!=n.next.y>s&&n.next.y!==n.y&&r<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==t);return i}(t,e)&&(TRt(t.prev,t,e.prev)||TRt(t,e.prev,e))||_Rt(t,e)&&TRt(t.prev,t,t.next)>0&&TRt(e.prev,e,e.next)>0)}function TRt(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function _Rt(t,e){return t.x===e.x&&t.y===e.y}function ERt(t,e,n,i){const r=$Rt(TRt(t,e,n)),s=$Rt(TRt(t,e,i)),o=$Rt(TRt(n,i,t)),a=$Rt(TRt(n,i,e));return r!==s&&o!==a||(!(0!==r||!MRt(t,n,e))||(!(0!==s||!MRt(t,i,e))||(!(0!==o||!MRt(n,t,i))||!(0!==a||!MRt(n,e,i)))))}function MRt(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function $Rt(t){return t>0?1:t<0?-1:0}function IRt(t,e){return TRt(t.prev,t,t.next)<0?TRt(t,e,t.next)>=0&&TRt(t,t.prev,e)>=0:TRt(t,e,t.prev)<0||TRt(t,t.next,e)<0}function ARt(t,e){const n=new PRt(t.i,t.x,t.y),i=new PRt(e.i,e.x,e.y),r=t.next,s=e.prev;return t.next=e,e.prev=t,n.next=r,r.prev=n,i.next=n,n.prev=i,s.next=i,i.prev=s,i}function NRt(t,e,n,i){const r=new PRt(t,e,n);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function RRt(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function PRt(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}const ORt={area:function(t){const e=t.length;let n=0;for(let i=e-1,r=0;r<e;i=r++)n+=t[i].x*t[r].y-t[r].x*t[i].y;return.5*n},isClockWise:function(t){return ORt.area(t)<0},triangulateShape:function(t,e){const n=[],i=[],r=[];LRt(t),DRt(n,t);let s=t.length;e.forEach(LRt);for(let t=0;t<e.length;t++)i.push(s),s+=e[t].length,DRt(n,e[t]);const o=uRt(n,i);for(let t=0;t<o.length;t+=3)r.push(o.slice(t,t+3));return r}};function LRt(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function DRt(t,e){for(let n=0;n<e.length;n++)t.push(e[n].x),t.push(e[n].y)}class FRt extends QMt{constructor(t,e){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,i=[],r=[];for(let e=0,n=t.length;e<n;e++){s(t[e])}function s(t){const s=[],o=void 0!==e.curveSegments?e.curveSegments:12,a=void 0!==e.steps?e.steps:1;let l=void 0!==e.depth?e.depth:100,c=void 0===e.bevelEnabled||e.bevelEnabled,u=void 0!==e.bevelThickness?e.bevelThickness:6,h=void 0!==e.bevelSize?e.bevelSize:u-2,d=void 0!==e.bevelOffset?e.bevelOffset:0,p=void 0!==e.bevelSegments?e.bevelSegments:3;const f=e.extrudePath,m=void 0!==e.UVGenerator?e.UVGenerator:zRt;void 0!==e.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),l=e.amount);let g,y,b,v,x,w=!1;f&&(g=f.getSpacedPoints(a),w=!0,c=!1,y=f.computeFrenetFrames(a,!1),b=new rEt,v=new rEt,x=new rEt),c||(p=0,u=0,h=0,d=0);const S=t.extractPoints(o);let k=S.shape;const C=S.holes;if(!ORt.isClockWise(k)){k=k.reverse();for(let t=0,e=C.length;t<e;t++){const e=C[t];ORt.isClockWise(e)&&(C[t]=e.reverse())}}const T=ORt.triangulateShape(k,C),_=k;for(let t=0,e=C.length;t<e;t++){const e=C[t];k=k.concat(e)}function E(t,e,n){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(n).add(t)}const M=k.length,$=T.length;function I(t,e,n){let i,r,s;const o=t.x-e.x,a=t.y-e.y,l=n.x-t.x,c=n.y-t.y,u=o*o+a*a,h=o*c-a*l;if(Math.abs(h)>Number.EPSILON){const h=Math.sqrt(u),d=Math.sqrt(l*l+c*c),p=e.x-a/h,f=e.y+o/h,m=((n.x-c/d-p)*c-(n.y+l/d-f)*l)/(o*c-a*l);i=p+o*m-t.x,r=f+a*m-t.y;const g=i*i+r*r;if(g<=2)return new X_t(i,r);s=Math.sqrt(g/2)}else{let t=!1;o>Number.EPSILON?l>Number.EPSILON&&(t=!0):o<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(a)===Math.sign(c)&&(t=!0),t?(i=-a,r=o,s=Math.sqrt(u)):(i=o,r=a,s=Math.sqrt(u/2))}return new X_t(i/s,r/s)}const A=[];for(let t=0,e=_.length,n=e-1,i=t+1;t<e;t++,n++,i++)n===e&&(n=0),i===e&&(i=0),A[t]=I(_[t],_[n],_[i]);const N=[];let R,P=A.concat();for(let t=0,e=C.length;t<e;t++){const e=C[t];R=[];for(let t=0,n=e.length,i=n-1,r=t+1;t<n;t++,i++,r++)i===n&&(i=0),r===n&&(r=0),R[t]=I(e[t],e[i],e[r]);N.push(R),P=P.concat(R)}for(let t=0;t<p;t++){const e=t/p,n=u*Math.cos(e*Math.PI/2),i=h*Math.sin(e*Math.PI/2)+d;for(let t=0,e=_.length;t<e;t++){const e=E(_[t],A[t],i);D(e.x,e.y,-n)}for(let t=0,e=C.length;t<e;t++){const e=C[t];R=N[t];for(let t=0,r=e.length;t<r;t++){const r=E(e[t],R[t],i);D(r.x,r.y,-n)}}}const O=h+d;for(let t=0;t<M;t++){const e=c?E(k[t],P[t],O):k[t];w?(v.copy(y.normals[0]).multiplyScalar(e.x),b.copy(y.binormals[0]).multiplyScalar(e.y),x.copy(g[0]).add(v).add(b),D(x.x,x.y,x.z)):D(e.x,e.y,0)}for(let t=1;t<=a;t++)for(let e=0;e<M;e++){const n=c?E(k[e],P[e],O):k[e];w?(v.copy(y.normals[t]).multiplyScalar(n.x),b.copy(y.binormals[t]).multiplyScalar(n.y),x.copy(g[t]).add(v).add(b),D(x.x,x.y,x.z)):D(n.x,n.y,l/a*t)}for(let t=p-1;t>=0;t--){const e=t/p,n=u*Math.cos(e*Math.PI/2),i=h*Math.sin(e*Math.PI/2)+d;for(let t=0,e=_.length;t<e;t++){const e=E(_[t],A[t],i);D(e.x,e.y,l+n)}for(let t=0,e=C.length;t<e;t++){const e=C[t];R=N[t];for(let t=0,r=e.length;t<r;t++){const r=E(e[t],R[t],i);w?D(r.x,r.y+g[a-1].y,g[a-1].x+n):D(r.x,r.y,l+n)}}}function L(t,e){let n=t.length;for(;--n>=0;){const i=n;let r=n-1;r<0&&(r=t.length-1);for(let t=0,n=a+2*p;t<n;t++){const n=M*t,s=M*(t+1);z(e+i+n,e+r+n,e+r+s,e+i+s)}}}function D(t,e,n){s.push(t),s.push(e),s.push(n)}function F(t,e,r){B(t),B(e),B(r);const s=i.length/3,o=m.generateTopUV(n,i,s-3,s-2,s-1);U(o[0]),U(o[1]),U(o[2])}function z(t,e,r,s){B(t),B(e),B(s),B(e),B(r),B(s);const o=i.length/3,a=m.generateSideWallUV(n,i,o-6,o-3,o-2,o-1);U(a[0]),U(a[1]),U(a[3]),U(a[1]),U(a[2]),U(a[3])}function B(t){i.push(s[3*t+0]),i.push(s[3*t+1]),i.push(s[3*t+2])}function U(t){r.push(t.x),r.push(t.y)}!function(){const t=i.length/3;if(c){let t=0,e=M*t;for(let t=0;t<$;t++){const n=T[t];F(n[2]+e,n[1]+e,n[0]+e)}t=a+2*p,e=M*t;for(let t=0;t<$;t++){const n=T[t];F(n[0]+e,n[1]+e,n[2]+e)}}else{for(let t=0;t<$;t++){const e=T[t];F(e[2],e[1],e[0])}for(let t=0;t<$;t++){const e=T[t];F(e[0]+M*a,e[1]+M*a,e[2]+M*a)}}n.addGroup(t,i.length/3-t,0)}(),function(){const t=i.length/3;let e=0;L(_,e),e+=_.length;for(let t=0,n=C.length;t<n;t++){const n=C[t];L(n,e),e+=n.length}n.addGroup(t,i.length/3-t,1)}()}this.setAttribute("position",new UMt(i,3)),this.setAttribute("uv",new UMt(r,2)),this.computeVertexNormals()}toJSON(){const t=QMt.prototype.toJSON.call(this);return function(t,e,n){if(n.shapes=[],Array.isArray(t))for(let e=0,i=t.length;e<i;e++){const i=t[e];n.shapes.push(i.uuid)}else n.shapes.push(t.uuid);void 0!==e.extrudePath&&(n.options.extrudePath=e.extrudePath.toJSON());return n}(this.parameters.shapes,this.parameters.options,t)}}const zRt={generateTopUV:function(t,e,n,i,r){const s=e[3*n],o=e[3*n+1],a=e[3*i],l=e[3*i+1],c=e[3*r],u=e[3*r+1];return[new X_t(s,o),new X_t(a,l),new X_t(c,u)]},generateSideWallUV:function(t,e,n,i,r,s){const o=e[3*n],a=e[3*n+1],l=e[3*n+2],c=e[3*i],u=e[3*i+1],h=e[3*i+2],d=e[3*r],p=e[3*r+1],f=e[3*r+2],m=e[3*s],g=e[3*s+1],y=e[3*s+2];return Math.abs(a-u)<.01?[new X_t(o,1-l),new X_t(c,1-h),new X_t(d,1-f),new X_t(m,1-y)]:[new X_t(a,1-l),new X_t(u,1-h),new X_t(p,1-f),new X_t(g,1-y)]}};class BRt extends iRt{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}}class URt extends QMt{constructor(t,e=12,n=0,i=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:n,phiLength:i},e=Math.floor(e),i=q_t.clamp(i,0,2*Math.PI);const r=[],s=[],o=[],a=1/e,l=new rEt,c=new X_t;for(let r=0;r<=e;r++){const u=n+r*a*i,h=Math.sin(u),d=Math.cos(u);for(let n=0;n<=t.length-1;n++)l.x=t[n].x*h,l.y=t[n].y,l.z=t[n].x*d,s.push(l.x,l.y,l.z),c.x=r/e,c.y=n/(t.length-1),o.push(c.x,c.y)}for(let n=0;n<e;n++)for(let e=0;e<t.length-1;e++){const i=e+n*t.length,s=i,o=i+t.length,a=i+t.length+1,l=i+1;r.push(s,o,l),r.push(o,a,l)}if(this.setIndex(r),this.setAttribute("position",new UMt(s,3)),this.setAttribute("uv",new UMt(o,2)),this.computeVertexNormals(),i===2*Math.PI){const n=this.attributes.normal.array,i=new rEt,r=new rEt,s=new rEt,o=e*t.length*3;for(let e=0,a=0;e<t.length;e++,a+=3)i.x=n[a+0],i.y=n[a+1],i.z=n[a+2],r.x=n[o+a+0],r.y=n[o+a+1],r.z=n[o+a+2],s.addVectors(i,r).normalize(),n[a+0]=n[o+a+0]=s.x,n[a+1]=n[o+a+1]=s.y,n[a+2]=n[o+a+2]=s.z}}}class VRt extends iRt{constructor(t=1,e=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}}function WRt(t,e,n){QMt.call(this),this.type="ParametricGeometry",this.parameters={func:t,slices:e,stacks:n};const i=[],r=[],s=[],o=[],a=1e-5,l=new rEt,c=new rEt,u=new rEt,h=new rEt,d=new rEt;t.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const p=e+1;for(let i=0;i<=n;i++){const p=i/n;for(let n=0;n<=e;n++){const i=n/e;t(i,p,c),r.push(c.x,c.y,c.z),i-a>=0?(t(i-a,p,u),h.subVectors(c,u)):(t(i+a,p,u),h.subVectors(u,c)),p-a>=0?(t(i,p-a,u),d.subVectors(c,u)):(t(i,p+a,u),d.subVectors(u,c)),l.crossVectors(h,d).normalize(),s.push(l.x,l.y,l.z),o.push(i,p)}}for(let t=0;t<n;t++)for(let n=0;n<e;n++){const e=t*p+n,r=t*p+n+1,s=(t+1)*p+n+1,o=(t+1)*p+n;i.push(e,r,o),i.push(r,s,o)}this.setIndex(i),this.setAttribute("position",new UMt(r,3)),this.setAttribute("normal",new UMt(s,3)),this.setAttribute("uv",new UMt(o,2))}WRt.prototype=Object.create(QMt.prototype),WRt.prototype.constructor=WRt;class HRt extends QMt{constructor(t=.5,e=1,n=8,i=1,r=0,s=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:n,phiSegments:i,thetaStart:r,thetaLength:s},n=Math.max(3,n);const o=[],a=[],l=[],c=[];let u=t;const h=(e-t)/(i=Math.max(1,i)),d=new rEt,p=new X_t;for(let t=0;t<=i;t++){for(let t=0;t<=n;t++){const i=r+t/n*s;d.x=u*Math.cos(i),d.y=u*Math.sin(i),a.push(d.x,d.y,d.z),l.push(0,0,1),p.x=(d.x/e+1)/2,p.y=(d.y/e+1)/2,c.push(p.x,p.y)}u+=h}for(let t=0;t<i;t++){const e=t*(n+1);for(let t=0;t<n;t++){const i=t+e,r=i,s=i+n+1,a=i+n+2,l=i+1;o.push(r,s,l),o.push(s,a,l)}}this.setIndex(o),this.setAttribute("position",new UMt(a,3)),this.setAttribute("normal",new UMt(l,3)),this.setAttribute("uv",new UMt(c,2))}}class jRt extends QMt{constructor(t,e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],i=[],r=[],s=[];let o=0,a=0;if(!1===Array.isArray(t))l(t);else for(let e=0;e<t.length;e++)l(t[e]),this.addGroup(o,a,e),o+=a,a=0;function l(t){const o=i.length/3,l=t.extractPoints(e);let c=l.shape;const u=l.holes;!1===ORt.isClockWise(c)&&(c=c.reverse());for(let t=0,e=u.length;t<e;t++){const e=u[t];!0===ORt.isClockWise(e)&&(u[t]=e.reverse())}const h=ORt.triangulateShape(c,u);for(let t=0,e=u.length;t<e;t++){const e=u[t];c=c.concat(e)}for(let t=0,e=c.length;t<e;t++){const e=c[t];i.push(e.x,e.y,0),r.push(0,0,1),s.push(e.x,e.y)}for(let t=0,e=h.length;t<e;t++){const e=h[t],i=e[0]+o,r=e[1]+o,s=e[2]+o;n.push(i,r,s),a+=3}}this.setIndex(n),this.setAttribute("position",new UMt(i,3)),this.setAttribute("normal",new UMt(r,3)),this.setAttribute("uv",new UMt(s,2))}toJSON(){const t=QMt.prototype.toJSON.call(this);return function(t,e){if(e.shapes=[],Array.isArray(t))for(let n=0,i=t.length;n<i;n++){const i=t[n];e.shapes.push(i.uuid)}else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}}class GRt extends QMt{constructor(t=1,e=8,n=6,i=0,r=2*Math.PI,s=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:i,phiLength:r,thetaStart:s,thetaLength:o},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const a=Math.min(s+o,Math.PI);let l=0;const c=[],u=new rEt,h=new rEt,d=[],p=[],f=[],m=[];for(let d=0;d<=n;d++){const g=[],y=d/n;let b=0;0==d&&0==s?b=.5/e:d==n&&a==Math.PI&&(b=-.5/e);for(let n=0;n<=e;n++){const a=n/e;u.x=-t*Math.cos(i+a*r)*Math.sin(s+y*o),u.y=t*Math.cos(s+y*o),u.z=t*Math.sin(i+a*r)*Math.sin(s+y*o),p.push(u.x,u.y,u.z),h.copy(u).normalize(),f.push(h.x,h.y,h.z),m.push(a+b,1-y),g.push(l++)}c.push(g)}for(let t=0;t<n;t++)for(let i=0;i<e;i++){const e=c[t][i+1],r=c[t][i],o=c[t+1][i],l=c[t+1][i+1];(0!==t||s>0)&&d.push(e,r,l),(t!==n-1||a<Math.PI)&&d.push(r,o,l)}this.setIndex(d),this.setAttribute("position",new UMt(p,3)),this.setAttribute("normal",new UMt(f,3)),this.setAttribute("uv",new UMt(m,2))}}class qRt extends iRt{constructor(t=1,e=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}}class XRt extends FRt{constructor(t,e={}){const n=e.font;if(!n||!n.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new QMt;const i=n.generateShapes(t,e.size);e.depth=void 0!==e.height?e.height:50,void 0===e.bevelThickness&&(e.bevelThickness=10),void 0===e.bevelSize&&(e.bevelSize=8),void 0===e.bevelEnabled&&(e.bevelEnabled=!1),super(i,e),this.type="TextGeometry"}}class KRt extends QMt{constructor(t=1,e=.4,n=8,i=6,r=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:n,tubularSegments:i,arc:r},n=Math.floor(n),i=Math.floor(i);const s=[],o=[],a=[],l=[],c=new rEt,u=new rEt,h=new rEt;for(let s=0;s<=n;s++)for(let d=0;d<=i;d++){const p=d/i*r,f=s/n*Math.PI*2;u.x=(t+e*Math.cos(f))*Math.cos(p),u.y=(t+e*Math.cos(f))*Math.sin(p),u.z=e*Math.sin(f),o.push(u.x,u.y,u.z),c.x=t*Math.cos(p),c.y=t*Math.sin(p),h.subVectors(u,c).normalize(),a.push(h.x,h.y,h.z),l.push(d/i),l.push(s/n)}for(let t=1;t<=n;t++)for(let e=1;e<=i;e++){const n=(i+1)*t+e-1,r=(i+1)*(t-1)+e-1,o=(i+1)*(t-1)+e,a=(i+1)*t+e;s.push(n,r,a),s.push(r,o,a)}this.setIndex(s),this.setAttribute("position",new UMt(o,3)),this.setAttribute("normal",new UMt(a,3)),this.setAttribute("uv",new UMt(l,2))}}class YRt extends QMt{constructor(t=1,e=.4,n=64,i=8,r=2,s=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:n,radialSegments:i,p:r,q:s},n=Math.floor(n),i=Math.floor(i);const o=[],a=[],l=[],c=[],u=new rEt,h=new rEt,d=new rEt,p=new rEt,f=new rEt,m=new rEt,g=new rEt;for(let o=0;o<=n;++o){const b=o/n*r*Math.PI*2;y(b,r,s,t,d),y(b+.01,r,s,t,p),m.subVectors(p,d),g.addVectors(p,d),f.crossVectors(m,g),g.crossVectors(f,m),f.normalize(),g.normalize();for(let t=0;t<=i;++t){const r=t/i*Math.PI*2,s=-e*Math.cos(r),p=e*Math.sin(r);u.x=d.x+(s*g.x+p*f.x),u.y=d.y+(s*g.y+p*f.y),u.z=d.z+(s*g.z+p*f.z),a.push(u.x,u.y,u.z),h.subVectors(u,d).normalize(),l.push(h.x,h.y,h.z),c.push(o/n),c.push(t/i)}}for(let t=1;t<=n;t++)for(let e=1;e<=i;e++){const n=(i+1)*(t-1)+(e-1),r=(i+1)*t+(e-1),s=(i+1)*t+e,a=(i+1)*(t-1)+e;o.push(n,r,a),o.push(r,s,a)}function y(t,e,n,i,r){const s=Math.cos(t),o=Math.sin(t),a=n/e*t,l=Math.cos(a);r.x=i*(2+l)*.5*s,r.y=i*(2+l)*o*.5,r.z=i*Math.sin(a)*.5}this.setIndex(o),this.setAttribute("position",new UMt(a,3)),this.setAttribute("normal",new UMt(l,3)),this.setAttribute("uv",new UMt(c,2))}}class ZRt extends QMt{constructor(t,e=64,n=1,i=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:n,radialSegments:i,closed:r};const s=t.computeFrenetFrames(e,r);this.tangents=s.tangents,this.normals=s.normals,this.binormals=s.binormals;const o=new rEt,a=new rEt,l=new X_t;let c=new rEt;const u=[],h=[],d=[],p=[];function f(r){c=t.getPointAt(r/e,c);const l=s.normals[r],d=s.binormals[r];for(let t=0;t<=i;t++){const e=t/i*Math.PI*2,r=Math.sin(e),s=-Math.cos(e);a.x=s*l.x+r*d.x,a.y=s*l.y+r*d.y,a.z=s*l.z+r*d.z,a.normalize(),h.push(a.x,a.y,a.z),o.x=c.x+n*a.x,o.y=c.y+n*a.y,o.z=c.z+n*a.z,u.push(o.x,o.y,o.z)}}!function(){for(let t=0;t<e;t++)f(t);f(!1===r?e:0),function(){for(let t=0;t<=e;t++)for(let n=0;n<=i;n++)l.x=t/e,l.y=n/i,d.push(l.x,l.y)}(),function(){for(let t=1;t<=e;t++)for(let e=1;e<=i;e++){const n=(i+1)*(t-1)+(e-1),r=(i+1)*t+(e-1),s=(i+1)*t+e,o=(i+1)*(t-1)+e;p.push(n,r,o),p.push(r,s,o)}}()}(),this.setIndex(p),this.setAttribute("position",new UMt(u,3)),this.setAttribute("normal",new UMt(h,3)),this.setAttribute("uv",new UMt(d,2))}toJSON(){const t=QMt.prototype.toJSON.call(this);return t.path=this.parameters.path.toJSON(),t}}class JRt extends QMt{constructor(t){if(super(),this.type="WireframeGeometry",!0===t.isGeometry)return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");const e=[],n=[0,0],i={},r=new rEt;if(null!==t.index){const s=t.attributes.position,o=t.index;let a=t.groups;0===a.length&&(a=[{start:0,count:o.count,materialIndex:0}]);for(let t=0,e=a.length;t<e;++t){const e=a[t],r=e.start;for(let t=r,s=r+e.count;t<s;t+=3)for(let e=0;e<3;e++){const r=o.getX(t+e),s=o.getX(t+(e+1)%3);n[0]=Math.min(r,s),n[1]=Math.max(r,s);const a=n[0]+","+n[1];void 0===i[a]&&(i[a]={index1:n[0],index2:n[1]})}}for(const t in i){const n=i[t];r.fromBufferAttribute(s,n.index1),e.push(r.x,r.y,r.z),r.fromBufferAttribute(s,n.index2),e.push(r.x,r.y,r.z)}}else{const n=t.attributes.position;for(let t=0,i=n.count/3;t<i;t++)for(let i=0;i<3;i++){const s=3*t+i;r.fromBufferAttribute(n,s),e.push(r.x,r.y,r.z);const o=3*t+(i+1)%3;r.fromBufferAttribute(n,o),e.push(r.x,r.y,r.z)}}this.setAttribute("position",new UMt(e,3))}}var QRt=Object.freeze({__proto__:null,BoxGeometry:v$t,BoxBufferGeometry:v$t,CircleGeometry:tRt,CircleBufferGeometry:tRt,ConeGeometry:nRt,ConeBufferGeometry:nRt,CylinderGeometry:eRt,CylinderBufferGeometry:eRt,DodecahedronGeometry:rRt,DodecahedronBufferGeometry:rRt,EdgesGeometry:cRt,ExtrudeGeometry:FRt,ExtrudeBufferGeometry:FRt,IcosahedronGeometry:BRt,IcosahedronBufferGeometry:BRt,LatheGeometry:URt,LatheBufferGeometry:URt,OctahedronGeometry:VRt,OctahedronBufferGeometry:VRt,ParametricGeometry:WRt,ParametricBufferGeometry:WRt,PlaneGeometry:F$t,PlaneBufferGeometry:F$t,PolyhedronGeometry:iRt,PolyhedronBufferGeometry:iRt,RingGeometry:HRt,RingBufferGeometry:HRt,ShapeGeometry:jRt,ShapeBufferGeometry:jRt,SphereGeometry:GRt,SphereBufferGeometry:GRt,TetrahedronGeometry:qRt,TetrahedronBufferGeometry:qRt,TextGeometry:XRt,TextBufferGeometry:XRt,TorusGeometry:KRt,TorusBufferGeometry:KRt,TorusKnotGeometry:YRt,TorusKnotBufferGeometry:YRt,TubeGeometry:ZRt,TubeBufferGeometry:ZRt,WireframeGeometry:JRt});function tPt(t){MMt.call(this),this.type="ShadowMaterial",this.color=new TMt(0),this.transparent=!0,this.setValues(t)}function ePt(t){T$t.call(this,t),this.type="RawShaderMaterial"}function nPt(t){MMt.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new TMt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new TMt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=D_t,this.normalScale=new X_t(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(t)}function iPt(t){nPt.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new X_t(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(t){this.reflectivity=q_t.clamp(2.5*(t-1)/(t+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(t)}function rPt(t){MMt.call(this),this.type="MeshPhongMaterial",this.color=new TMt(16777215),this.specular=new TMt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new TMt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=D_t,this.normalScale=new X_t(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=LCt,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function sPt(t){MMt.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new TMt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new TMt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=D_t,this.normalScale=new X_t(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function oPt(t){MMt.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=D_t,this.normalScale=new X_t(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function aPt(t){MMt.call(this),this.type="MeshLambertMaterial",this.color=new TMt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new TMt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=LCt,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function lPt(t){MMt.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new TMt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=D_t,this.normalScale=new X_t(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function cPt(t){NNt.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}tPt.prototype=Object.create(MMt.prototype),tPt.prototype.constructor=tPt,tPt.prototype.isShadowMaterial=!0,tPt.prototype.copy=function(t){return MMt.prototype.copy.call(this,t),this.color.copy(t.color),this},ePt.prototype=Object.create(T$t.prototype),ePt.prototype.constructor=ePt,ePt.prototype.isRawShaderMaterial=!0,nPt.prototype=Object.create(MMt.prototype),nPt.prototype.constructor=nPt,nPt.prototype.isMeshStandardMaterial=!0,nPt.prototype.copy=function(t){return MMt.prototype.copy.call(this,t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.vertexTangents=t.vertexTangents,this},iPt.prototype=Object.create(nPt.prototype),iPt.prototype.constructor=iPt,iPt.prototype.isMeshPhysicalMaterial=!0,iPt.prototype.copy=function(t){return nPt.prototype.copy.call(this,t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.reflectivity=t.reflectivity,t.sheen?this.sheen=(this.sheen||new TMt).copy(t.sheen):this.sheen=null,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this},rPt.prototype=Object.create(MMt.prototype),rPt.prototype.constructor=rPt,rPt.prototype.isMeshPhongMaterial=!0,rPt.prototype.copy=function(t){return MMt.prototype.copy.call(this,t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},sPt.prototype=Object.create(MMt.prototype),sPt.prototype.constructor=sPt,sPt.prototype.isMeshToonMaterial=!0,sPt.prototype.copy=function(t){return MMt.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},oPt.prototype=Object.create(MMt.prototype),oPt.prototype.constructor=oPt,oPt.prototype.isMeshNormalMaterial=!0,oPt.prototype.copy=function(t){return MMt.prototype.copy.call(this,t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},aPt.prototype=Object.create(MMt.prototype),aPt.prototype.constructor=aPt,aPt.prototype.isMeshLambertMaterial=!0,aPt.prototype.copy=function(t){return MMt.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},lPt.prototype=Object.create(MMt.prototype),lPt.prototype.constructor=lPt,lPt.prototype.isMeshMatcapMaterial=!0,lPt.prototype.copy=function(t){return MMt.prototype.copy.call(this,t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},cPt.prototype=Object.create(NNt.prototype),cPt.prototype.constructor=cPt,cPt.prototype.isLineDashedMaterial=!0,cPt.prototype.copy=function(t){return NNt.prototype.copy.call(this,t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this};var uPt=Object.freeze({__proto__:null,ShadowMaterial:tPt,SpriteMaterial:JAt,RawShaderMaterial:ePt,ShaderMaterial:T$t,PointsMaterial:WNt,MeshPhysicalMaterial:iPt,MeshStandardMaterial:nPt,MeshPhongMaterial:rPt,MeshToonMaterial:sPt,MeshNormalMaterial:oPt,MeshLambertMaterial:aPt,MeshDepthMaterial:AAt,MeshDistanceMaterial:NAt,MeshBasicMaterial:$Mt,MeshMatcapMaterial:lPt,LineDashedMaterial:cPt,LineBasicMaterial:NNt,Material:MMt});const hPt={arraySlice:function(t,e,n){return hPt.isTypedArray(t)?new t.constructor(t.subarray(e,void 0!==n?n:t.length)):t.slice(e,n)},convertArray:function(t,e,n){return!t||!n&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)},isTypedArray:function(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)},getKeyframeOrder:function(t){const e=t.length,n=new Array(e);for(let t=0;t!==e;++t)n[t]=t;return n.sort((function(e,n){return t[e]-t[n]})),n},sortedArray:function(t,e,n){const i=t.length,r=new t.constructor(i);for(let s=0,o=0;o!==i;++s){const i=n[s]*e;for(let n=0;n!==e;++n)r[o++]=t[i+n]}return r},flattenJSON:function(t,e,n,i){let r=1,s=t[0];for(;void 0!==s&&void 0===s[i];)s=t[r++];if(void 0===s)return;let o=s[i];if(void 0!==o)if(Array.isArray(o))do{o=s[i],void 0!==o&&(e.push(s.time),n.push.apply(n,o)),s=t[r++]}while(void 0!==s);else if(void 0!==o.toArray)do{o=s[i],void 0!==o&&(e.push(s.time),o.toArray(n,n.length)),s=t[r++]}while(void 0!==s);else do{o=s[i],void 0!==o&&(e.push(s.time),n.push(o)),s=t[r++]}while(void 0!==s)},subclip:function(t,e,n,i,r=30){const s=t.clone();s.name=e;const o=[];for(let t=0;t<s.tracks.length;++t){const e=s.tracks[t],a=e.getValueSize(),l=[],c=[];for(let t=0;t<e.times.length;++t){const s=e.times[t]*r;if(!(s<n||s>=i)){l.push(e.times[t]);for(let n=0;n<a;++n)c.push(e.values[t*a+n])}}0!==l.length&&(e.times=hPt.convertArray(l,e.times.constructor),e.values=hPt.convertArray(c,e.values.constructor),o.push(e))}s.tracks=o;let a=1/0;for(let t=0;t<s.tracks.length;++t)a>s.tracks[t].times[0]&&(a=s.tracks[t].times[0]);for(let t=0;t<s.tracks.length;++t)s.tracks[t].shift(-1*a);return s.resetDuration(),s},makeClipAdditive:function(t,e=0,n=t,i=30){i<=0&&(i=30);const r=n.tracks.length,s=e/i;for(let e=0;e<r;++e){const i=n.tracks[e],r=i.ValueTypeName;if("bool"===r||"string"===r)continue;const o=t.tracks.find((function(t){return t.name===i.name&&t.ValueTypeName===r}));if(void 0===o)continue;let a=0;const l=i.getValueSize();i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(a=l/3);let c=0;const u=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=u/3);const h=i.times.length-1;let d;if(s<=i.times[0]){const t=a,e=l-a;d=hPt.arraySlice(i.values,t,e)}else if(s>=i.times[h]){const t=h*l+a,e=t+l-a;d=hPt.arraySlice(i.values,t,e)}else{const t=i.createInterpolant(),e=a,n=l-a;t.evaluate(s),d=hPt.arraySlice(t.resultBuffer,e,n)}if("quaternion"===r){(new iEt).fromArray(d).normalize().conjugate().toArray(d)}const p=o.times.length;for(let t=0;t<p;++t){const e=t*u+c;if("quaternion"===r)iEt.multiplyQuaternionsFlat(o.values,e,d,0,o.values,e);else{const t=u-2*c;for(let n=0;n<t;++n)o.values[e+n]-=d[n]}}}return t.blendMode=__t,t}};function dPt(t,e,n,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==i?i:new e.constructor(n),this.sampleValues=e,this.valueSize=n}function pPt(t,e,n,i){dPt.call(this,t,e,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}function fPt(t,e,n,i){dPt.call(this,t,e,n,i)}function mPt(t,e,n,i){dPt.call(this,t,e,n,i)}function gPt(t,e,n,i){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=hPt.convertArray(e,this.TimeBufferType),this.values=hPt.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}function yPt(t,e,n){gPt.call(this,t,e,n)}function bPt(t,e,n,i){gPt.call(this,t,e,n,i)}function vPt(t,e,n,i){gPt.call(this,t,e,n,i)}function xPt(t,e,n,i){dPt.call(this,t,e,n,i)}function wPt(t,e,n,i){gPt.call(this,t,e,n,i)}function SPt(t,e,n,i){gPt.call(this,t,e,n,i)}function kPt(t,e,n,i){gPt.call(this,t,e,n,i)}function CPt(t,e=-1,n,i=2500){this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=q_t.generateUUID(),this.duration<0&&this.resetDuration()}function TPt(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return vPt;case"vector":case"vector2":case"vector3":case"vector4":return kPt;case"color":return bPt;case"quaternion":return wPt;case"bool":case"boolean":return yPt;case"string":return SPt}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],n=[];hPt.flattenJSON(t.keys,e,n,"value"),t.times=e,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}Object.assign(dPt.prototype,{evaluate:function(t){const e=this.parameterPositions;let n=this._cachedIndex,i=e[n],r=e[n-1];t:{e:{let s;n:{i:if(!(t<i)){for(let s=n+2;;){if(void 0===i){if(t<r)break i;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,r)}if(n===s)break;if(r=i,i=e[++n],t<i)break e}s=e.length;break n}if(t>=r)break t;{const o=e[1];t<o&&(n=2,r=o);for(let s=n-2;;){if(void 0===r)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(n===s)break;if(i=r,r=e[--n-1],t>=r)break e}s=n,n=0}}for(;n<s;){const i=n+s>>>1;t<e[i]?s=i:n=i+1}if(i=e[n],r=e[n-1],void 0===r)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(void 0===i)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,r,t)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,t,i)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=t*i;for(let t=0;t!==i;++t)e[t]=n[r+t];return e},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}}),Object.assign(dPt.prototype,{beforeStart_:dPt.prototype.copySampleValue_,afterEnd_:dPt.prototype.copySampleValue_}),pPt.prototype=Object.assign(Object.create(dPt.prototype),{constructor:pPt,DefaultSettings_:{endingStart:S_t,endingEnd:S_t},intervalChanged_:function(t,e,n){const i=this.parameterPositions;let r=t-2,s=t+1,o=i[r],a=i[s];if(void 0===o)switch(this.getSettings_().endingStart){case k_t:r=t,o=2*e-n;break;case C_t:r=i.length-2,o=e+i[r]-i[r+1];break;default:r=t,o=n}if(void 0===a)switch(this.getSettings_().endingEnd){case k_t:s=t,a=2*n-e;break;case C_t:s=1,a=n+i[1]-i[0];break;default:s=t-1,a=e}const l=.5*(n-e),c=this.valueSize;this._weightPrev=l/(e-o),this._weightNext=l/(a-n),this._offsetPrev=r*c,this._offsetNext=s*c},interpolate_:function(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=t*o,l=a-o,c=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,d=this._weightNext,p=(n-e)/(i-e),f=p*p,m=f*p,g=-h*m+2*h*f-h*p,y=(1+h)*m+(-1.5-2*h)*f+(-.5+h)*p+1,b=(-1-d)*m+(1.5+d)*f+.5*p,v=d*m-d*f;for(let t=0;t!==o;++t)r[t]=g*s[c+t]+y*s[l+t]+b*s[a+t]+v*s[u+t];return r}}),fPt.prototype=Object.assign(Object.create(dPt.prototype),{constructor:fPt,interpolate_:function(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=t*o,l=a-o,c=(n-e)/(i-e),u=1-c;for(let t=0;t!==o;++t)r[t]=s[l+t]*u+s[a+t]*c;return r}}),mPt.prototype=Object.assign(Object.create(dPt.prototype),{constructor:mPt,interpolate_:function(t){return this.copySampleValue_(t-1)}}),Object.assign(gPt,{toJSON:function(t){const e=t.constructor;let n;if(void 0!==e.toJSON)n=e.toJSON(t);else{n={name:t.name,times:hPt.convertArray(t.times,Array),values:hPt.convertArray(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(n.interpolation=e)}return n.type=t.ValueTypeName,n}}),Object.assign(gPt.prototype,{constructor:gPt,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:x_t,InterpolantFactoryMethodDiscrete:function(t){return new mPt(this.times,this.values,this.getValueSize(),t)},InterpolantFactoryMethodLinear:function(t){return new fPt(this.times,this.values,this.getValueSize(),t)},InterpolantFactoryMethodSmooth:function(t){return new pPt(this.times,this.values,this.getValueSize(),t)},setInterpolation:function(t){let e;switch(t){case v_t:e=this.InterpolantFactoryMethodDiscrete;break;case x_t:e=this.InterpolantFactoryMethodLinear;break;case w_t:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return v_t;case this.InterpolantFactoryMethodLinear:return x_t;case this.InterpolantFactoryMethodSmooth:return w_t}},getValueSize:function(){return this.values.length/this.times.length},shift:function(t){if(0!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]+=t}return this},scale:function(t){if(1!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]*=t}return this},trim:function(t,e){const n=this.times,i=n.length;let r=0,s=i-1;for(;r!==i&&n[r]<t;)++r;for(;-1!==s&&n[s]>e;)--s;if(++s,0!==r||s!==i){r>=s&&(s=Math.max(s,1),r=s-1);const t=this.getValueSize();this.times=hPt.arraySlice(n,r,s),this.values=hPt.arraySlice(this.values,r*t,s*t)}return this},validate:function(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,i=this.values,r=n.length;0===r&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let s=null;for(let e=0;e!==r;e++){const i=n[e];if("number"==typeof i&&isNaN(i)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,i),t=!1;break}if(null!==s&&s>i){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,i,s),t=!1;break}s=i}if(void 0!==i&&hPt.isTypedArray(i))for(let e=0,n=i.length;e!==n;++e){const n=i[e];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,n),t=!1;break}}return t},optimize:function(){const t=hPt.arraySlice(this.times),e=hPt.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===w_t,r=t.length-1;let s=1;for(let o=1;o<r;++o){let r=!1;const a=t[o];if(a!==t[o+1]&&(1!==o||a!==t[0]))if(i)r=!0;else{const t=o*n,i=t-n,s=t+n;for(let o=0;o!==n;++o){const n=e[t+o];if(n!==e[i+o]||n!==e[s+o]){r=!0;break}}}if(r){if(o!==s){t[s]=t[o];const i=o*n,r=s*n;for(let t=0;t!==n;++t)e[r+t]=e[i+t]}++s}}if(r>0){t[s]=t[r];for(let t=r*n,i=s*n,o=0;o!==n;++o)e[i+o]=e[t+o];++s}return s!==t.length?(this.times=hPt.arraySlice(t,0,s),this.values=hPt.arraySlice(e,0,s*n)):(this.times=t,this.values=e),this},clone:function(){const t=hPt.arraySlice(this.times,0),e=hPt.arraySlice(this.values,0),n=new(0,this.constructor)(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}),yPt.prototype=Object.assign(Object.create(gPt.prototype),{constructor:yPt,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:v_t,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),bPt.prototype=Object.assign(Object.create(gPt.prototype),{constructor:bPt,ValueTypeName:"color"}),vPt.prototype=Object.assign(Object.create(gPt.prototype),{constructor:vPt,ValueTypeName:"number"}),xPt.prototype=Object.assign(Object.create(dPt.prototype),{constructor:xPt,interpolate_:function(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=(n-e)/(i-e);let l=t*o;for(let t=l+o;l!==t;l+=4)iEt.slerpFlat(r,0,s,l-o,s,l,a);return r}}),wPt.prototype=Object.assign(Object.create(gPt.prototype),{constructor:wPt,ValueTypeName:"quaternion",DefaultInterpolation:x_t,InterpolantFactoryMethodLinear:function(t){return new xPt(this.times,this.values,this.getValueSize(),t)},InterpolantFactoryMethodSmooth:void 0}),SPt.prototype=Object.assign(Object.create(gPt.prototype),{constructor:SPt,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:v_t,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),kPt.prototype=Object.assign(Object.create(gPt.prototype),{constructor:kPt,ValueTypeName:"vector"}),Object.assign(CPt,{parse:function(t){const e=[],n=t.tracks,i=1/(t.fps||1);for(let t=0,r=n.length;t!==r;++t)e.push(TPt(n[t]).scale(i));const r=new CPt(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r},toJSON:function(t){const e=[],n=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let t=0,i=n.length;t!==i;++t)e.push(gPt.toJSON(n[t]));return i},CreateFromMorphTargetSequence:function(t,e,n,i){const r=e.length,s=[];for(let t=0;t<r;t++){let o=[],a=[];o.push((t+r-1)%r,t,(t+1)%r),a.push(0,1,0);const l=hPt.getKeyframeOrder(o);o=hPt.sortedArray(o,1,l),a=hPt.sortedArray(a,1,l),i||0!==o[0]||(o.push(r),a.push(a[0])),s.push(new vPt(".morphTargetInfluences["+e[t].name+"]",o,a).scale(1/n))}return new CPt(t,-1,s)},findByName:function(t,e){let n=t;if(!Array.isArray(t)){const e=t;n=e.geometry&&e.geometry.animations||e.animations}for(let t=0;t<n.length;t++)if(n[t].name===e)return n[t];return null},CreateClipsFromMorphTargetSequences:function(t,e,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let e=0,n=t.length;e<n;e++){const n=t[e],s=n.name.match(r);if(s&&s.length>1){const t=s[1];let e=i[t];e||(i[t]=e=[]),e.push(n)}}const s=[];for(const t in i)s.push(CPt.CreateFromMorphTargetSequence(t,i[t],e,n));return s},parseAnimation:function(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(t,e,n,i,r){if(0!==n.length){const s=[],o=[];hPt.flattenJSON(n,s,o,i),0!==s.length&&r.push(new t(e,s,o))}},i=[],r=t.name||"default",s=t.fps||30,o=t.blendMode;let a=t.length||-1;const l=t.hierarchy||[];for(let t=0;t<l.length;t++){const r=l[t].keys;if(r&&0!==r.length)if(r[0].morphTargets){const t={};let e;for(e=0;e<r.length;e++)if(r[e].morphTargets)for(let n=0;n<r[e].morphTargets.length;n++)t[r[e].morphTargets[n]]=-1;for(const n in t){const t=[],s=[];for(let i=0;i!==r[e].morphTargets.length;++i){const i=r[e];t.push(i.time),s.push(i.morphTarget===n?1:0)}i.push(new vPt(".morphTargetInfluence["+n+"]",t,s))}a=t.length*(s||1)}else{const s=".bones["+e[t].name+"]";n(kPt,s+".position",r,"pos",i),n(wPt,s+".quaternion",r,"rot",i),n(kPt,s+".scale",r,"scl",i)}}if(0===i.length)return null;return new CPt(r,a,i,o)}}),Object.assign(CPt.prototype,{resetDuration:function(){let t=0;for(let e=0,n=this.tracks.length;e!==n;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this},trim:function(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this},validate:function(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t},optimize:function(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this},clone:function(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new CPt(this.name,this.duration,t,this.blendMode)},toJSON:function(){return CPt.toJSON(this)}});const _Pt={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};function EPt(t,e,n){const i=this;let r,s=!1,o=0,a=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(t){a++,!1===s&&void 0!==i.onStart&&i.onStart(t,o,a),s=!0},this.itemEnd=function(t){o++,void 0!==i.onProgress&&i.onProgress(t,o,a),o===a&&(s=!1,void 0!==i.onLoad&&i.onLoad())},this.itemError=function(t){void 0!==i.onError&&i.onError(t)},this.resolveURL=function(t){return r?r(t):t},this.setURLModifier=function(t){return r=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],i=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return i}return null}}const MPt=new EPt;function $Pt(t){this.manager=void 0!==t?t:MPt,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign($Pt.prototype,{load:function(){},loadAsync:function(t,e){const n=this;return new Promise((function(i,r){n.load(t,i,e,r)}))},parse:function(){},setCrossOrigin:function(t){return this.crossOrigin=t,this},setWithCredentials:function(t){return this.withCredentials=t,this},setPath:function(t){return this.path=t,this},setResourcePath:function(t){return this.resourcePath=t,this},setRequestHeader:function(t){return this.requestHeader=t,this}});const IPt={};function APt(t){$Pt.call(this,t)}function NPt(t){$Pt.call(this,t)}function RPt(t){$Pt.call(this,t)}function PPt(t){$Pt.call(this,t)}function OPt(t){$Pt.call(this,t)}function LPt(t){$Pt.call(this,t)}function DPt(t){$Pt.call(this,t)}function FPt(){this.type="Curve",this.arcLengthDivisions=200}function zPt(t,e,n,i,r,s,o,a){FPt.call(this),this.type="EllipseCurve",this.aX=t||0,this.aY=e||0,this.xRadius=n||1,this.yRadius=i||1,this.aStartAngle=r||0,this.aEndAngle=s||2*Math.PI,this.aClockwise=o||!1,this.aRotation=a||0}function BPt(t,e,n,i,r,s){zPt.call(this,t,e,n,n,i,r,s),this.type="ArcCurve"}function UPt(){let t=0,e=0,n=0,i=0;function r(r,s,o,a){t=r,e=o,n=-3*r+3*s-2*o-a,i=2*r-2*s+o+a}return{initCatmullRom:function(t,e,n,i,s){r(e,n,s*(n-t),s*(i-e))},initNonuniformCatmullRom:function(t,e,n,i,s,o,a){let l=(e-t)/s-(n-t)/(s+o)+(n-e)/o,c=(n-e)/o-(i-e)/(o+a)+(i-n)/a;l*=o,c*=o,r(e,n,l,c)},calc:function(r){const s=r*r;return t+e*r+n*s+i*(s*r)}}}APt.prototype=Object.assign(Object.create($Pt.prototype),{constructor:APt,load:function(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=_Pt.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout((function(){e&&e(s),r.manager.itemEnd(t)}),0),s;if(void 0!==IPt[t])return void IPt[t].push({onLoad:e,onProgress:n,onError:i});const o=t.match(/^data:(.*?)(;base64)?,(.*)$/);let a;if(o){const n=o[1],s=!!o[2];let a=o[3];a=decodeURIComponent(a),s&&(a=atob(a));try{let i;const s=(this.responseType||"").toLowerCase();switch(s){case"arraybuffer":case"blob":const t=new Uint8Array(a.length);for(let e=0;e<a.length;e++)t[e]=a.charCodeAt(e);i="blob"===s?new Blob([t.buffer],{type:n}):t.buffer;break;case"document":const e=new DOMParser;i=e.parseFromString(a,n);break;case"json":i=JSON.parse(a);break;default:i=a}setTimeout((function(){e&&e(i),r.manager.itemEnd(t)}),0)}catch(e){setTimeout((function(){i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}),0)}}else{IPt[t]=[],IPt[t].push({onLoad:e,onProgress:n,onError:i}),a=new XMLHttpRequest,a.open("GET",t,!0),a.addEventListener("load",(function(e){const n=this.response,i=IPt[t];if(delete IPt[t],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),_Pt.add(t,n);for(let t=0,e=i.length;t<e;t++){const e=i[t];e.onLoad&&e.onLoad(n)}r.manager.itemEnd(t)}else{for(let t=0,n=i.length;t<n;t++){const n=i[t];n.onError&&n.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)}}),!1),a.addEventListener("progress",(function(e){const n=IPt[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onProgress&&i.onProgress(e)}}),!1),a.addEventListener("error",(function(e){const n=IPt[t];delete IPt[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onError&&i.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)}),!1),a.addEventListener("abort",(function(e){const n=IPt[t];delete IPt[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onError&&i.onError(e)}r.manager.itemError(t),r.manager.itemEnd(t)}),!1),void 0!==this.responseType&&(a.responseType=this.responseType),void 0!==this.withCredentials&&(a.withCredentials=this.withCredentials),a.overrideMimeType&&a.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(const t in this.requestHeader)a.setRequestHeader(t,this.requestHeader[t]);a.send(null)}return r.manager.itemStart(t),a},setResponseType:function(t){return this.responseType=t,this},setMimeType:function(t){return this.mimeType=t,this}}),NPt.prototype=Object.assign(Object.create($Pt.prototype),{constructor:NPt,load:function(t,e,n,i){const r=this,s=new APt(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,(function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}}),n,i)},parse:function(t){const e=[];for(let n=0;n<t.length;n++){const i=CPt.parse(t[n]);e.push(i)}return e}}),RPt.prototype=Object.assign(Object.create($Pt.prototype),{constructor:RPt,load:function(t,e,n,i){const r=this,s=[],o=new ZNt,a=new APt(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(r.withCredentials);let l=0;function c(c){a.load(t[c],(function(t){const n=r.parse(t,!0);s[c]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(o.minFilter=rTt),o.image=s,o.format=n.format,o.needsUpdate=!0,e&&e(o))}),n,i)}if(Array.isArray(t))for(let e=0,n=t.length;e<n;++e)c(e);else a.load(t,(function(t){const n=r.parse(t,!0);if(n.isCubemap){const t=n.mipmaps.length/n.mipmapCount;for(let e=0;e<t;e++){s[e]={mipmaps:[]};for(let t=0;t<n.mipmapCount;t++)s[e].mipmaps.push(n.mipmaps[e*n.mipmapCount+t]),s[e].format=n.format,s[e].width=n.width,s[e].height=n.height}o.image=s}else o.image.width=n.width,o.image.height=n.height,o.mipmaps=n.mipmaps;1===n.mipmapCount&&(o.minFilter=rTt),o.format=n.format,o.needsUpdate=!0,e&&e(o)}),n,i);return o}}),PPt.prototype=Object.assign(Object.create($Pt.prototype),{constructor:PPt,load:function(t,e,n,i){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=_Pt.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout((function(){e&&e(s),r.manager.itemEnd(t)}),0),s;const o=document.createElementNS("http://www.w3.org/1999/xhtml","img");function a(){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),_Pt.add(t,this),e&&e(this),r.manager.itemEnd(t)}function l(e){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}return o.addEventListener("load",a,!1),o.addEventListener("error",l,!1),"data:"!==t.substr(0,5)&&void 0!==this.crossOrigin&&(o.crossOrigin=this.crossOrigin),r.manager.itemStart(t),o.src=t,o}}),OPt.prototype=Object.assign(Object.create($Pt.prototype),{constructor:OPt,load:function(t,e,n,i){const r=new I$t,s=new PPt(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let o=0;function a(n){s.load(t[n],(function(t){r.images[n]=t,o++,6===o&&(r.needsUpdate=!0,e&&e(r))}),void 0,i)}for(let e=0;e<t.length;++e)a(e);return r}}),LPt.prototype=Object.assign(Object.create($Pt.prototype),{constructor:LPt,load:function(t,e,n,i){const r=this,s=new N$t,o=new APt(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(t,(function(t){const n=r.parse(t);n&&(void 0!==n.image?s.image=n.image:void 0!==n.data&&(s.image.width=n.width,s.image.height=n.height,s.image.data=n.data),s.wrapS=void 0!==n.wrapS?n.wrapS:QCt,s.wrapT=void 0!==n.wrapT?n.wrapT:QCt,s.magFilter=void 0!==n.magFilter?n.magFilter:rTt,s.minFilter=void 0!==n.minFilter?n.minFilter:rTt,s.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.encoding&&(s.encoding=n.encoding),void 0!==n.flipY&&(s.flipY=n.flipY),void 0!==n.format&&(s.format=n.format),void 0!==n.type&&(s.type=n.type),void 0!==n.mipmaps&&(s.mipmaps=n.mipmaps,s.minFilter=oTt),1===n.mipmapCount&&(s.minFilter=rTt),s.needsUpdate=!0,e&&e(s,n))}),n,i),s}}),DPt.prototype=Object.assign(Object.create($Pt.prototype),{constructor:DPt,load:function(t,e,n,i){const r=new Q_t,s=new PPt(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(t,(function(n){r.image=n;const i=t.search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/);r.format=i?xTt:wTt,r.needsUpdate=!0,void 0!==e&&e(r)}),n,i),r}}),Object.assign(FPt.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)},getPoints:function(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e},getSpacedPoints:function(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e},getLength:function(){const t=this.getLengths();return t[t.length-1]},getLengths:function(t){if(void 0===t&&(t=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,i=this.getPoint(0),r=0;e.push(0);for(let s=1;s<=t;s++)n=this.getPoint(s/t),r+=n.distanceTo(i),e.push(r),i=n;return this.cacheArcLengths=e,e},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(t,e){const n=this.getLengths();let i=0;const r=n.length;let s;s=e||t*n[r-1];let o,a=0,l=r-1;for(;a<=l;)if(i=Math.floor(a+(l-a)/2),o=n[i]-s,o<0)a=i+1;else{if(!(o>0)){l=i;break}l=i-1}if(i=l,n[i]===s)return i/(r-1);const c=n[i];return(i+(s-c)/(n[i+1]-c))/(r-1)},getTangent:function(t,e){const n=1e-4;let i=t-n,r=t+n;i<0&&(i=0),r>1&&(r=1);const s=this.getPoint(i),o=this.getPoint(r),a=e||(s.isVector2?new X_t:new rEt);return a.copy(o).sub(s).normalize(),a},getTangentAt:function(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)},computeFrenetFrames:function(t,e){const n=new rEt,i=[],r=[],s=[],o=new rEt,a=new NEt;for(let e=0;e<=t;e++){const n=e/t;i[e]=this.getTangentAt(n,new rEt),i[e].normalize()}r[0]=new rEt,s[0]=new rEt;let l=Number.MAX_VALUE;const c=Math.abs(i[0].x),u=Math.abs(i[0].y),h=Math.abs(i[0].z);c<=l&&(l=c,n.set(1,0,0)),u<=l&&(l=u,n.set(0,1,0)),h<=l&&n.set(0,0,1),o.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],o),s[0].crossVectors(i[0],r[0]);for(let e=1;e<=t;e++){if(r[e]=r[e-1].clone(),s[e]=s[e-1].clone(),o.crossVectors(i[e-1],i[e]),o.length()>Number.EPSILON){o.normalize();const t=Math.acos(q_t.clamp(i[e-1].dot(i[e]),-1,1));r[e].applyMatrix4(a.makeRotationAxis(o,t))}s[e].crossVectors(i[e],r[e])}if(!0===e){let e=Math.acos(q_t.clamp(r[0].dot(r[t]),-1,1));e/=t,i[0].dot(o.crossVectors(r[0],r[t]))>0&&(e=-e);for(let n=1;n<=t;n++)r[n].applyMatrix4(a.makeRotationAxis(i[n],e*n)),s[n].crossVectors(i[n],r[n])}return{tangents:i,normals:r,binormals:s}},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.arcLengthDivisions=t.arcLengthDivisions,this},toJSON:function(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t},fromJSON:function(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}),zPt.prototype=Object.create(FPt.prototype),zPt.prototype.constructor=zPt,zPt.prototype.isEllipseCurve=!0,zPt.prototype.getPoint=function(t,e){const n=e||new X_t,i=2*Math.PI;let r=this.aEndAngle-this.aStartAngle;const s=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(r=s?0:i),!0!==this.aClockwise||s||(r===i?r=-i:r-=i);const o=this.aStartAngle+t*r;let a=this.aX+this.xRadius*Math.cos(o),l=this.aY+this.yRadius*Math.sin(o);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),n=a-this.aX,i=l-this.aY;a=n*t-i*e+this.aX,l=n*e+i*t+this.aY}return n.set(a,l)},zPt.prototype.copy=function(t){return FPt.prototype.copy.call(this,t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this},zPt.prototype.toJSON=function(){const t=FPt.prototype.toJSON.call(this);return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t},zPt.prototype.fromJSON=function(t){return FPt.prototype.fromJSON.call(this,t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this},BPt.prototype=Object.create(zPt.prototype),BPt.prototype.constructor=BPt,BPt.prototype.isArcCurve=!0;const VPt=new rEt,WPt=new UPt,HPt=new UPt,jPt=new UPt;function GPt(t=[],e=!1,n="centripetal",i=.5){FPt.call(this),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=i}function qPt(t,e,n,i,r){const s=.5*(i-e),o=.5*(r-n),a=t*t;return(2*n-2*i+s+o)*(t*a)+(-3*n+3*i-2*s-o)*a+s*t+n}function XPt(t,e,n,i){return function(t,e){const n=1-t;return n*n*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,n)+function(t,e){return t*t*e}(t,i)}function KPt(t,e,n,i,r){return function(t,e){const n=1-t;return n*n*n*e}(t,e)+function(t,e){const n=1-t;return 3*n*n*t*e}(t,n)+function(t,e){return 3*(1-t)*t*t*e}(t,i)+function(t,e){return t*t*t*e}(t,r)}function YPt(t=new X_t,e=new X_t,n=new X_t,i=new X_t){FPt.call(this),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=i}function ZPt(t=new rEt,e=new rEt,n=new rEt,i=new rEt){FPt.call(this),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=i}function JPt(t=new X_t,e=new X_t){FPt.call(this),this.type="LineCurve",this.v1=t,this.v2=e}function QPt(t=new rEt,e=new rEt){FPt.call(this),this.type="LineCurve3",this.v1=t,this.v2=e}function tOt(t=new X_t,e=new X_t,n=new X_t){FPt.call(this),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}function eOt(t=new rEt,e=new rEt,n=new rEt){FPt.call(this),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}function nOt(t=[]){FPt.call(this),this.type="SplineCurve",this.points=t}GPt.prototype=Object.create(FPt.prototype),GPt.prototype.constructor=GPt,GPt.prototype.isCatmullRomCurve3=!0,GPt.prototype.getPoint=function(t,e=new rEt){const n=e,i=this.points,r=i.length,s=(r-(this.closed?0:1))*t;let o,a,l=Math.floor(s),c=s-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/r)+1)*r:0===c&&l===r-1&&(l=r-2,c=1),this.closed||l>0?o=i[(l-1)%r]:(VPt.subVectors(i[0],i[1]).add(i[0]),o=VPt);const u=i[l%r],h=i[(l+1)%r];if(this.closed||l+2<r?a=i[(l+2)%r]:(VPt.subVectors(i[r-1],i[r-2]).add(i[r-1]),a=VPt),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(o.distanceToSquared(u),t),n=Math.pow(u.distanceToSquared(h),t),i=Math.pow(h.distanceToSquared(a),t);n<1e-4&&(n=1),e<1e-4&&(e=n),i<1e-4&&(i=n),WPt.initNonuniformCatmullRom(o.x,u.x,h.x,a.x,e,n,i),HPt.initNonuniformCatmullRom(o.y,u.y,h.y,a.y,e,n,i),jPt.initNonuniformCatmullRom(o.z,u.z,h.z,a.z,e,n,i)}else"catmullrom"===this.curveType&&(WPt.initCatmullRom(o.x,u.x,h.x,a.x,this.tension),HPt.initCatmullRom(o.y,u.y,h.y,a.y,this.tension),jPt.initCatmullRom(o.z,u.z,h.z,a.z,this.tension));return n.set(WPt.calc(c),HPt.calc(c),jPt.calc(c)),n},GPt.prototype.copy=function(t){FPt.prototype.copy.call(this,t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this},GPt.prototype.toJSON=function(){const t=FPt.prototype.toJSON.call(this);t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t},GPt.prototype.fromJSON=function(t){FPt.prototype.fromJSON.call(this,t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new rEt).fromArray(n))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this},YPt.prototype=Object.create(FPt.prototype),YPt.prototype.constructor=YPt,YPt.prototype.isCubicBezierCurve=!0,YPt.prototype.getPoint=function(t,e=new X_t){const n=e,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return n.set(KPt(t,i.x,r.x,s.x,o.x),KPt(t,i.y,r.y,s.y,o.y)),n},YPt.prototype.copy=function(t){return FPt.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this},YPt.prototype.toJSON=function(){const t=FPt.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t},YPt.prototype.fromJSON=function(t){return FPt.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this},ZPt.prototype=Object.create(FPt.prototype),ZPt.prototype.constructor=ZPt,ZPt.prototype.isCubicBezierCurve3=!0,ZPt.prototype.getPoint=function(t,e=new rEt){const n=e,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return n.set(KPt(t,i.x,r.x,s.x,o.x),KPt(t,i.y,r.y,s.y,o.y),KPt(t,i.z,r.z,s.z,o.z)),n},ZPt.prototype.copy=function(t){return FPt.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this},ZPt.prototype.toJSON=function(){const t=FPt.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t},ZPt.prototype.fromJSON=function(t){return FPt.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this},JPt.prototype=Object.create(FPt.prototype),JPt.prototype.constructor=JPt,JPt.prototype.isLineCurve=!0,JPt.prototype.getPoint=function(t,e=new X_t){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n},JPt.prototype.getPointAt=function(t,e){return this.getPoint(t,e)},JPt.prototype.getTangent=function(t,e){const n=e||new X_t;return n.copy(this.v2).sub(this.v1).normalize(),n},JPt.prototype.copy=function(t){return FPt.prototype.copy.call(this,t),this.v1.copy(t.v1),this.v2.copy(t.v2),this},JPt.prototype.toJSON=function(){const t=FPt.prototype.toJSON.call(this);return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},JPt.prototype.fromJSON=function(t){return FPt.prototype.fromJSON.call(this,t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},QPt.prototype=Object.create(FPt.prototype),QPt.prototype.constructor=QPt,QPt.prototype.isLineCurve3=!0,QPt.prototype.getPoint=function(t,e=new rEt){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n},QPt.prototype.getPointAt=function(t,e){return this.getPoint(t,e)},QPt.prototype.copy=function(t){return FPt.prototype.copy.call(this,t),this.v1.copy(t.v1),this.v2.copy(t.v2),this},QPt.prototype.toJSON=function(){const t=FPt.prototype.toJSON.call(this);return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},QPt.prototype.fromJSON=function(t){return FPt.prototype.fromJSON.call(this,t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},tOt.prototype=Object.create(FPt.prototype),tOt.prototype.constructor=tOt,tOt.prototype.isQuadraticBezierCurve=!0,tOt.prototype.getPoint=function(t,e=new X_t){const n=e,i=this.v0,r=this.v1,s=this.v2;return n.set(XPt(t,i.x,r.x,s.x),XPt(t,i.y,r.y,s.y)),n},tOt.prototype.copy=function(t){return FPt.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this},tOt.prototype.toJSON=function(){const t=FPt.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},tOt.prototype.fromJSON=function(t){return FPt.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},eOt.prototype=Object.create(FPt.prototype),eOt.prototype.constructor=eOt,eOt.prototype.isQuadraticBezierCurve3=!0,eOt.prototype.getPoint=function(t,e=new rEt){const n=e,i=this.v0,r=this.v1,s=this.v2;return n.set(XPt(t,i.x,r.x,s.x),XPt(t,i.y,r.y,s.y),XPt(t,i.z,r.z,s.z)),n},eOt.prototype.copy=function(t){return FPt.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this},eOt.prototype.toJSON=function(){const t=FPt.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},eOt.prototype.fromJSON=function(t){return FPt.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},nOt.prototype=Object.create(FPt.prototype),nOt.prototype.constructor=nOt,nOt.prototype.isSplineCurve=!0,nOt.prototype.getPoint=function(t,e=new X_t){const n=e,i=this.points,r=(i.length-1)*t,s=Math.floor(r),o=r-s,a=i[0===s?s:s-1],l=i[s],c=i[s>i.length-2?i.length-1:s+1],u=i[s>i.length-3?i.length-1:s+2];return n.set(qPt(o,a.x,l.x,c.x,u.x),qPt(o,a.y,l.y,c.y,u.y)),n},nOt.prototype.copy=function(t){FPt.prototype.copy.call(this,t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this},nOt.prototype.toJSON=function(){const t=FPt.prototype.toJSON.call(this);t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t},nOt.prototype.fromJSON=function(t){FPt.prototype.fromJSON.call(this,t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new X_t).fromArray(n))}return this};var iOt=Object.freeze({__proto__:null,ArcCurve:BPt,CatmullRomCurve3:GPt,CubicBezierCurve:YPt,CubicBezierCurve3:ZPt,EllipseCurve:zPt,LineCurve:JPt,LineCurve3:QPt,QuadraticBezierCurve:tOt,QuadraticBezierCurve3:eOt,SplineCurve:nOt});function rOt(){FPt.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}function sOt(t){rOt.call(this),this.type="Path",this.currentPoint=new X_t,t&&this.setFromPoints(t)}function oOt(t){sOt.call(this,t),this.uuid=q_t.generateUUID(),this.type="Shape",this.holes=[]}function aOt(t,e=1){iMt.call(this),this.type="Light",this.color=new TMt(t),this.intensity=e}function lOt(t,e,n){aOt.call(this,t,n),this.type="HemisphereLight",this.position.copy(iMt.DefaultUp),this.updateMatrix(),this.groundColor=new TMt(e)}function cOt(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new X_t(512,512),this.map=null,this.mapPass=null,this.matrix=new NEt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new O$t,this._frameExtents=new X_t(1,1),this._viewportCount=1,this._viewports=[new eEt(0,0,1,1)]}function uOt(){cOt.call(this,new E$t(50,1,.5,500)),this.focus=1}function hOt(t,e,n,i,r,s){aOt.call(this,t,e),this.type="SpotLight",this.position.copy(iMt.DefaultUp),this.updateMatrix(),this.target=new iMt,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(t){this.intensity=t/Math.PI}}),this.distance=void 0!==n?n:0,this.angle=void 0!==i?i:Math.PI/3,this.penumbra=void 0!==r?r:0,this.decay=void 0!==s?s:1,this.shadow=new uOt}function dOt(){cOt.call(this,new E$t(90,1,.5,500)),this._frameExtents=new X_t(4,2),this._viewportCount=6,this._viewports=[new eEt(2,1,1,1),new eEt(0,1,1,1),new eEt(3,1,1,1),new eEt(1,1,1,1),new eEt(3,0,1,1),new eEt(1,0,1,1)],this._cubeDirections=[new rEt(1,0,0),new rEt(-1,0,0),new rEt(0,0,1),new rEt(0,0,-1),new rEt(0,1,0),new rEt(0,-1,0)],this._cubeUps=[new rEt(0,1,0),new rEt(0,1,0),new rEt(0,1,0),new rEt(0,1,0),new rEt(0,0,1),new rEt(0,0,-1)]}function pOt(t,e,n,i){aOt.call(this,t,e),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return 4*this.intensity*Math.PI},set:function(t){this.intensity=t/(4*Math.PI)}}),this.distance=void 0!==n?n:0,this.decay=void 0!==i?i:1,this.shadow=new dOt}function fOt(t=-1,e=1,n=1,i=-1,r=.1,s=2e3){_$t.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=r,this.far=s,this.updateProjectionMatrix()}function mOt(){cOt.call(this,new fOt(-5,5,5,-5,.5,500))}function gOt(t,e){aOt.call(this,t,e),this.type="DirectionalLight",this.position.copy(iMt.DefaultUp),this.updateMatrix(),this.target=new iMt,this.shadow=new mOt}function yOt(t,e){aOt.call(this,t,e),this.type="AmbientLight"}function bOt(t,e,n,i){aOt.call(this,t,e),this.type="RectAreaLight",this.width=void 0!==n?n:10,this.height=void 0!==i?i:10}rOt.prototype=Object.assign(Object.create(FPt.prototype),{constructor:rOt,add:function(t){this.curves.push(t)},closePath:function(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new JPt(e,t))},getPoint:function(t){const e=t*this.getLength(),n=this.getCurveLengths();let i=0;for(;i<n.length;){if(n[i]>=e){const t=n[i]-e,r=this.curves[i],s=r.getLength(),o=0===s?0:1-t/s;return r.getPointAt(o)}i++}return null},getLength:function(){const t=this.getCurveLengths();return t[t.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,i=this.curves.length;n<i;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t},getSpacedPoints:function(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e},getPoints:function(t=12){const e=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const s=r[i],o=s&&s.isEllipseCurve?2*t:s&&(s.isLineCurve||s.isLineCurve3)?1:s&&s.isSplineCurve?t*s.points.length:t,a=s.getPoints(o);for(let t=0;t<a.length;t++){const i=a[t];n&&n.equals(i)||(e.push(i),n=i)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e},copy:function(t){FPt.prototype.copy.call(this,t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push(n.clone())}return this.autoClose=t.autoClose,this},toJSON:function(){const t=FPt.prototype.toJSON.call(this);t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const n=this.curves[e];t.curves.push(n.toJSON())}return t},fromJSON:function(t){FPt.prototype.fromJSON.call(this,t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push((new iOt[n.type]).fromJSON(n))}return this}}),sOt.prototype=Object.assign(Object.create(rOt.prototype),{constructor:sOt,setFromPoints:function(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this},moveTo:function(t,e){return this.currentPoint.set(t,e),this},lineTo:function(t,e){const n=new JPt(this.currentPoint.clone(),new X_t(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this},quadraticCurveTo:function(t,e,n,i){const r=new tOt(this.currentPoint.clone(),new X_t(t,e),new X_t(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this},bezierCurveTo:function(t,e,n,i,r,s){const o=new YPt(this.currentPoint.clone(),new X_t(t,e),new X_t(n,i),new X_t(r,s));return this.curves.push(o),this.currentPoint.set(r,s),this},splineThru:function(t){const e=new nOt([this.currentPoint.clone()].concat(t));return this.curves.push(e),this.currentPoint.copy(t[t.length-1]),this},arc:function(t,e,n,i,r,s){const o=this.currentPoint.x,a=this.currentPoint.y;return this.absarc(t+o,e+a,n,i,r,s),this},absarc:function(t,e,n,i,r,s){return this.absellipse(t,e,n,n,i,r,s),this},ellipse:function(t,e,n,i,r,s,o,a){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(t+l,e+c,n,i,r,s,o,a),this},absellipse:function(t,e,n,i,r,s,o,a){const l=new zPt(t,e,n,i,r,s,o,a);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this},copy:function(t){return rOt.prototype.copy.call(this,t),this.currentPoint.copy(t.currentPoint),this},toJSON:function(){const t=rOt.prototype.toJSON.call(this);return t.currentPoint=this.currentPoint.toArray(),t},fromJSON:function(t){return rOt.prototype.fromJSON.call(this,t),this.currentPoint.fromArray(t.currentPoint),this}}),oOt.prototype=Object.assign(Object.create(sOt.prototype),{constructor:oOt,getPointsHoles:function(t){const e=[];for(let n=0,i=this.holes.length;n<i;n++)e[n]=this.holes[n].getPoints(t);return e},extractPoints:function(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}},copy:function(t){sOt.prototype.copy.call(this,t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push(n.clone())}return this},toJSON:function(){const t=sOt.prototype.toJSON.call(this);t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const n=this.holes[e];t.holes.push(n.toJSON())}return t},fromJSON:function(t){sOt.prototype.fromJSON.call(this,t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push((new sOt).fromJSON(n))}return this}}),aOt.prototype=Object.assign(Object.create(iMt.prototype),{constructor:aOt,isLight:!0,copy:function(t){return iMt.prototype.copy.call(this,t),this.color.copy(t.color),this.intensity=t.intensity,this},toJSON:function(t){const e=iMt.prototype.toJSON.call(this,t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}),lOt.prototype=Object.assign(Object.create(aOt.prototype),{constructor:lOt,isHemisphereLight:!0,copy:function(t){return aOt.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}),Object.assign(cOt.prototype,{_projScreenMatrix:new NEt,_lightPositionWorld:new rEt,_lookTarget:new rEt,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(t){const e=this.camera,n=this.matrix,i=this._projScreenMatrix,r=this._lookTarget,s=this._lightPositionWorld;s.setFromMatrixPosition(t.matrixWorld),e.position.copy(s),r.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(r),e.updateMatrixWorld(),i.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(i),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)},getViewport:function(t){return this._viewports[t]},getFrameExtents:function(){return this._frameExtents},copy:function(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}),uOt.prototype=Object.assign(Object.create(cOt.prototype),{constructor:uOt,isSpotLightShadow:!0,updateMatrices:function(t){const e=this.camera,n=2*q_t.RAD2DEG*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;n===e.fov&&i===e.aspect&&r===e.far||(e.fov=n,e.aspect=i,e.far=r,e.updateProjectionMatrix()),cOt.prototype.updateMatrices.call(this,t)}}),hOt.prototype=Object.assign(Object.create(aOt.prototype),{constructor:hOt,isSpotLight:!0,copy:function(t){return aOt.prototype.copy.call(this,t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}),dOt.prototype=Object.assign(Object.create(cOt.prototype),{constructor:dOt,isPointLightShadow:!0,updateMatrices:function(t,e=0){const n=this.camera,i=this.matrix,r=this._lightPositionWorld,s=this._lookTarget,o=this._projScreenMatrix;r.setFromMatrixPosition(t.matrixWorld),n.position.copy(r),s.copy(n.position),s.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(s),n.updateMatrixWorld(),i.makeTranslation(-r.x,-r.y,-r.z),o.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(o)}}),pOt.prototype=Object.assign(Object.create(aOt.prototype),{constructor:pOt,isPointLight:!0,copy:function(t){return aOt.prototype.copy.call(this,t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}),fOt.prototype=Object.assign(Object.create(_$t.prototype),{constructor:fOt,isOrthographicCamera:!0,copy:function(t,e){return _$t.prototype.copy.call(this,t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this},setViewOffset:function(t,e,n,i,r,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-t,s=n+t,o=i+e,a=i-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=t*this.view.offsetX,s=r+t*this.view.width,o-=e*this.view.offsetY,a=o-e*this.view.height}this.projectionMatrix.makeOrthographic(r,s,o,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(t){const e=iMt.prototype.toJSON.call(this,t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}),mOt.prototype=Object.assign(Object.create(cOt.prototype),{constructor:mOt,isDirectionalLightShadow:!0,updateMatrices:function(t){cOt.prototype.updateMatrices.call(this,t)}}),gOt.prototype=Object.assign(Object.create(aOt.prototype),{constructor:gOt,isDirectionalLight:!0,copy:function(t){return aOt.prototype.copy.call(this,t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}),yOt.prototype=Object.assign(Object.create(aOt.prototype),{constructor:yOt,isAmbientLight:!0}),bOt.prototype=Object.assign(Object.create(aOt.prototype),{constructor:bOt,isRectAreaLight:!0,copy:function(t){return aOt.prototype.copy.call(this,t),this.width=t.width,this.height=t.height,this},toJSON:function(t){const e=aOt.prototype.toJSON.call(this,t);return e.object.width=this.width,e.object.height=this.height,e}});class vOt{constructor(){Object.defineProperty(this,"isSphericalHarmonics3",{value:!0}),this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new rEt)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.282095),e.addScaledVector(s[1],.488603*i),e.addScaledVector(s[2],.488603*r),e.addScaledVector(s[3],.488603*n),e.addScaledVector(s[4],n*i*1.092548),e.addScaledVector(s[5],i*r*1.092548),e.addScaledVector(s[6],.315392*(3*r*r-1)),e.addScaledVector(s[7],n*r*1.092548),e.addScaledVector(s[8],.546274*(n*n-i*i)),e}getIrradianceAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.886227),e.addScaledVector(s[1],1.023328*i),e.addScaledVector(s[2],1.023328*r),e.addScaledVector(s[3],1.023328*n),e.addScaledVector(s[4],.858086*n*i),e.addScaledVector(s[5],.858086*i*r),e.addScaledVector(s[6],.743125*r*r-.247708),e.addScaledVector(s[7],.858086*n*r),e.addScaledVector(s[8],.429043*(n*n-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(t,e+3*i);return this}toArray(t=[],e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(t,e+3*i);return t}static getBasisAt(t,e){const n=t.x,i=t.y,r=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*r,e[3]=.488603*n,e[4]=1.092548*n*i,e[5]=1.092548*i*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*n*r,e[8]=.546274*(n*n-i*i)}}function xOt(t,e){aOt.call(this,void 0,e),this.type="LightProbe",this.sh=void 0!==t?t:new vOt}function wOt(t){$Pt.call(this,t),this.textures={}}xOt.prototype=Object.assign(Object.create(aOt.prototype),{constructor:xOt,isLightProbe:!0,copy:function(t){return aOt.prototype.copy.call(this,t),this.sh.copy(t.sh),this},fromJSON:function(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this},toJSON:function(t){const e=aOt.prototype.toJSON.call(this,t);return e.object.sh=this.sh.toArray(),e}}),wOt.prototype=Object.assign(Object.create($Pt.prototype),{constructor:wOt,load:function(t,e,n,i){const r=this,s=new APt(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,(function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}}),n,i)},parse:function(t){const e=this.textures;function n(t){return void 0===e[t]&&console.warn("THREE.MaterialLoader: Undefined texture",t),e[t]}const i=new uPt[t.type];if(void 0!==t.uuid&&(i.uuid=t.uuid),void 0!==t.name&&(i.name=t.name),void 0!==t.color&&void 0!==i.color&&i.color.setHex(t.color),void 0!==t.roughness&&(i.roughness=t.roughness),void 0!==t.metalness&&(i.metalness=t.metalness),void 0!==t.sheen&&(i.sheen=(new TMt).setHex(t.sheen)),void 0!==t.emissive&&void 0!==i.emissive&&i.emissive.setHex(t.emissive),void 0!==t.specular&&void 0!==i.specular&&i.specular.setHex(t.specular),void 0!==t.shininess&&(i.shininess=t.shininess),void 0!==t.clearcoat&&(i.clearcoat=t.clearcoat),void 0!==t.clearcoatRoughness&&(i.clearcoatRoughness=t.clearcoatRoughness),void 0!==t.fog&&(i.fog=t.fog),void 0!==t.flatShading&&(i.flatShading=t.flatShading),void 0!==t.blending&&(i.blending=t.blending),void 0!==t.combine&&(i.combine=t.combine),void 0!==t.side&&(i.side=t.side),void 0!==t.opacity&&(i.opacity=t.opacity),void 0!==t.transparent&&(i.transparent=t.transparent),void 0!==t.alphaTest&&(i.alphaTest=t.alphaTest),void 0!==t.depthTest&&(i.depthTest=t.depthTest),void 0!==t.depthWrite&&(i.depthWrite=t.depthWrite),void 0!==t.colorWrite&&(i.colorWrite=t.colorWrite),void 0!==t.stencilWrite&&(i.stencilWrite=t.stencilWrite),void 0!==t.stencilWriteMask&&(i.stencilWriteMask=t.stencilWriteMask),void 0!==t.stencilFunc&&(i.stencilFunc=t.stencilFunc),void 0!==t.stencilRef&&(i.stencilRef=t.stencilRef),void 0!==t.stencilFuncMask&&(i.stencilFuncMask=t.stencilFuncMask),void 0!==t.stencilFail&&(i.stencilFail=t.stencilFail),void 0!==t.stencilZFail&&(i.stencilZFail=t.stencilZFail),void 0!==t.stencilZPass&&(i.stencilZPass=t.stencilZPass),void 0!==t.wireframe&&(i.wireframe=t.wireframe),void 0!==t.wireframeLinewidth&&(i.wireframeLinewidth=t.wireframeLinewidth),void 0!==t.wireframeLinecap&&(i.wireframeLinecap=t.wireframeLinecap),void 0!==t.wireframeLinejoin&&(i.wireframeLinejoin=t.wireframeLinejoin),void 0!==t.rotation&&(i.rotation=t.rotation),1!==t.linewidth&&(i.linewidth=t.linewidth),void 0!==t.dashSize&&(i.dashSize=t.dashSize),void 0!==t.gapSize&&(i.gapSize=t.gapSize),void 0!==t.scale&&(i.scale=t.scale),void 0!==t.polygonOffset&&(i.polygonOffset=t.polygonOffset),void 0!==t.polygonOffsetFactor&&(i.polygonOffsetFactor=t.polygonOffsetFactor),void 0!==t.polygonOffsetUnits&&(i.polygonOffsetUnits=t.polygonOffsetUnits),void 0!==t.skinning&&(i.skinning=t.skinning),void 0!==t.morphTargets&&(i.morphTargets=t.morphTargets),void 0!==t.morphNormals&&(i.morphNormals=t.morphNormals),void 0!==t.dithering&&(i.dithering=t.dithering),void 0!==t.vertexTangents&&(i.vertexTangents=t.vertexTangents),void 0!==t.visible&&(i.visible=t.visible),void 0!==t.toneMapped&&(i.toneMapped=t.toneMapped),void 0!==t.userData&&(i.userData=t.userData),void 0!==t.vertexColors&&("number"==typeof t.vertexColors?i.vertexColors=t.vertexColors>0:i.vertexColors=t.vertexColors),void 0!==t.uniforms)for(const e in t.uniforms){const r=t.uniforms[e];switch(i.uniforms[e]={},r.type){case"t":i.uniforms[e].value=n(r.value);break;case"c":i.uniforms[e].value=(new TMt).setHex(r.value);break;case"v2":i.uniforms[e].value=(new X_t).fromArray(r.value);break;case"v3":i.uniforms[e].value=(new rEt).fromArray(r.value);break;case"v4":i.uniforms[e].value=(new eEt).fromArray(r.value);break;case"m3":i.uniforms[e].value=(new K_t).fromArray(r.value);break;case"m4":i.uniforms[e].value=(new NEt).fromArray(r.value);break;default:i.uniforms[e].value=r.value}}if(void 0!==t.defines&&(i.defines=t.defines),void 0!==t.vertexShader&&(i.vertexShader=t.vertexShader),void 0!==t.fragmentShader&&(i.fragmentShader=t.fragmentShader),void 0!==t.extensions)for(const e in t.extensions)i.extensions[e]=t.extensions[e];if(void 0!==t.shading&&(i.flatShading=1===t.shading),void 0!==t.size&&(i.size=t.size),void 0!==t.sizeAttenuation&&(i.sizeAttenuation=t.sizeAttenuation),void 0!==t.map&&(i.map=n(t.map)),void 0!==t.matcap&&(i.matcap=n(t.matcap)),void 0!==t.alphaMap&&(i.alphaMap=n(t.alphaMap)),void 0!==t.bumpMap&&(i.bumpMap=n(t.bumpMap)),void 0!==t.bumpScale&&(i.bumpScale=t.bumpScale),void 0!==t.normalMap&&(i.normalMap=n(t.normalMap)),void 0!==t.normalMapType&&(i.normalMapType=t.normalMapType),void 0!==t.normalScale){let e=t.normalScale;!1===Array.isArray(e)&&(e=[e,e]),i.normalScale=(new X_t).fromArray(e)}return void 0!==t.displacementMap&&(i.displacementMap=n(t.displacementMap)),void 0!==t.displacementScale&&(i.displacementScale=t.displacementScale),void 0!==t.displacementBias&&(i.displacementBias=t.displacementBias),void 0!==t.roughnessMap&&(i.roughnessMap=n(t.roughnessMap)),void 0!==t.metalnessMap&&(i.metalnessMap=n(t.metalnessMap)),void 0!==t.emissiveMap&&(i.emissiveMap=n(t.emissiveMap)),void 0!==t.emissiveIntensity&&(i.emissiveIntensity=t.emissiveIntensity),void 0!==t.specularMap&&(i.specularMap=n(t.specularMap)),void 0!==t.envMap&&(i.envMap=n(t.envMap)),void 0!==t.envMapIntensity&&(i.envMapIntensity=t.envMapIntensity),void 0!==t.reflectivity&&(i.reflectivity=t.reflectivity),void 0!==t.refractionRatio&&(i.refractionRatio=t.refractionRatio),void 0!==t.lightMap&&(i.lightMap=n(t.lightMap)),void 0!==t.lightMapIntensity&&(i.lightMapIntensity=t.lightMapIntensity),void 0!==t.aoMap&&(i.aoMap=n(t.aoMap)),void 0!==t.aoMapIntensity&&(i.aoMapIntensity=t.aoMapIntensity),void 0!==t.gradientMap&&(i.gradientMap=n(t.gradientMap)),void 0!==t.clearcoatMap&&(i.clearcoatMap=n(t.clearcoatMap)),void 0!==t.clearcoatRoughnessMap&&(i.clearcoatRoughnessMap=n(t.clearcoatRoughnessMap)),void 0!==t.clearcoatNormalMap&&(i.clearcoatNormalMap=n(t.clearcoatNormalMap)),void 0!==t.clearcoatNormalScale&&(i.clearcoatNormalScale=(new X_t).fromArray(t.clearcoatNormalScale)),void 0!==t.transmission&&(i.transmission=t.transmission),void 0!==t.transmissionMap&&(i.transmissionMap=n(t.transmissionMap)),i},setTextures:function(t){return this.textures=t,this}});const SOt={decodeText:function(t){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);let e="";for(let n=0,i=t.length;n<i;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch(t){return e}},extractUrlBase:function(t){const e=t.lastIndexOf("/");return-1===e?"./":t.substr(0,e+1)}};function kOt(){QMt.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}function COt(t,e,n,i){"number"==typeof n&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),NMt.call(this,t,e,n),this.meshPerAttribute=i||1}function TOt(t){$Pt.call(this,t)}kOt.prototype=Object.assign(Object.create(QMt.prototype),{constructor:kOt,isInstancedBufferGeometry:!0,copy:function(t){return QMt.prototype.copy.call(this,t),this.instanceCount=t.instanceCount,this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const t=QMt.prototype.toJSON.call(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}),COt.prototype=Object.assign(Object.create(NMt.prototype),{constructor:COt,isInstancedBufferAttribute:!0,copy:function(t){return NMt.prototype.copy.call(this,t),this.meshPerAttribute=t.meshPerAttribute,this},toJSON:function(){const t=NMt.prototype.toJSON.call(this);return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}),TOt.prototype=Object.assign(Object.create($Pt.prototype),{constructor:TOt,load:function(t,e,n,i){const r=this,s=new APt(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,(function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}}),n,i)},parse:function(t){const e={},n={};function i(t,i){if(void 0!==e[i])return e[i];const r=t.interleavedBuffers[i],s=function(t,e){if(void 0!==n[e])return n[e];const i=t.arrayBuffers,r=i[e],s=new Uint32Array(r).buffer;return n[e]=s,s}(t,r.buffer),o=new KAt(jMt(r.type,s),r.stride);return o.uuid=r.uuid,e[i]=o,o}const r=t.isInstancedBufferGeometry?new kOt:new QMt,s=t.data.index;if(void 0!==s){const t=jMt(s.type,s.array);r.setIndex(new NMt(t,1))}const o=t.data.attributes;for(const e in o){const n=o[e];let s;if(n.isInterleavedBufferAttribute){s=new ZAt(i(t.data,n.data),n.itemSize,n.offset,n.normalized)}else{const t=jMt(n.type,n.array);s=new(n.isInstancedBufferAttribute?COt:NMt)(t,n.itemSize,n.normalized)}void 0!==n.name&&(s.name=n.name),r.setAttribute(e,s)}const a=t.data.morphAttributes;if(a)for(const e in a){const n=a[e],s=[];for(let e=0,r=n.length;e<r;e++){const r=n[e];let o;if(r.isInterleavedBufferAttribute){o=new ZAt(i(t.data,r.data),r.itemSize,r.offset,r.normalized)}else{o=new NMt(jMt(r.type,r.array),r.itemSize,r.normalized)}void 0!==r.name&&(o.name=r.name),s.push(o)}r.morphAttributes[e]=s}t.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);const l=t.data.groups||t.data.drawcalls||t.data.offsets;if(void 0!==l)for(let t=0,e=l.length;t!==e;++t){const e=l[t];r.addGroup(e.start,e.count,e.materialIndex)}const c=t.data.boundingSphere;if(void 0!==c){const t=new rEt;void 0!==c.center&&t.fromArray(c.center),r.boundingSphere=new kEt(t,c.radius)}return t.name&&(r.name=t.name),t.userData&&(r.userData=t.userData),r}});const _Ot={UVMapping:jCt,CubeReflectionMapping:GCt,CubeRefractionMapping:qCt,EquirectangularReflectionMapping:XCt,EquirectangularRefractionMapping:KCt,CubeUVReflectionMapping:YCt,CubeUVRefractionMapping:ZCt},EOt={RepeatWrapping:JCt,ClampToEdgeWrapping:QCt,MirroredRepeatWrapping:tTt},MOt={NearestFilter:eTt,NearestMipmapNearestFilter:nTt,NearestMipmapLinearFilter:iTt,LinearFilter:rTt,LinearMipmapNearestFilter:sTt,LinearMipmapLinearFilter:oTt};function $Ot(t){"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),$Pt.call(this,t),this.options={premultiplyAlpha:"none"}}function IOt(){this.type="ShapePath",this.color=new TMt,this.subPaths=[],this.currentPath=null}$Ot.prototype=Object.assign(Object.create($Pt.prototype),{constructor:$Ot,isImageBitmapLoader:!0,setOptions:function(t){return this.options=t,this},load:function(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=_Pt.get(t);if(void 0!==s)return r.manager.itemStart(t),setTimeout((function(){e&&e(s),r.manager.itemEnd(t)}),0),s;const o={};o.credentials="anonymous"===this.crossOrigin?"same-origin":"include",fetch(t,o).then((function(t){return t.blob()})).then((function(t){return createImageBitmap(t,r.options)})).then((function(n){_Pt.add(t,n),e&&e(n),r.manager.itemEnd(t)})).catch((function(e){i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)})),r.manager.itemStart(t)}}),Object.assign(IOt.prototype,{moveTo:function(t,e){return this.currentPath=new sOt,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this},lineTo:function(t,e){return this.currentPath.lineTo(t,e),this},quadraticCurveTo:function(t,e,n,i){return this.currentPath.quadraticCurveTo(t,e,n,i),this},bezierCurveTo:function(t,e,n,i,r,s){return this.currentPath.bezierCurveTo(t,e,n,i,r,s),this},splineThru:function(t){return this.currentPath.splineThru(t),this},toShapes:function(t,e){function n(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n],r=new oOt;r.curves=i.curves,e.push(r)}return e}function i(t,e){const n=e.length;let i=!1;for(let r=n-1,s=0;s<n;r=s++){let n=e[r],o=e[s],a=o.x-n.x,l=o.y-n.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(n=e[s],a=-a,o=e[r],l=-l),t.y<n.y||t.y>o.y)continue;if(t.y===n.y){if(t.x===n.x)return!0}else{const e=l*(t.x-n.x)-a*(t.y-n.y);if(0===e)return!0;if(e<0)continue;i=!i}}else{if(t.y!==n.y)continue;if(o.x<=t.x&&t.x<=n.x||n.x<=t.x&&t.x<=o.x)return!0}}return i}const r=ORt.isClockWise,s=this.subPaths;if(0===s.length)return[];if(!0===e)return n(s);let o,a,l;const c=[];if(1===s.length)return a=s[0],l=new oOt,l.curves=a.curves,c.push(l),c;let u=!r(s[0].getPoints());u=t?!u:u;const h=[],d=[];let p,f,m=[],g=0;d[g]=void 0,m[g]=[];for(let e=0,n=s.length;e<n;e++)a=s[e],p=a.getPoints(),o=r(p),o=t?!o:o,o?(!u&&d[g]&&g++,d[g]={s:new oOt,p:p},d[g].s.curves=a.curves,u&&g++,m[g]=[]):m[g].push({h:a,p:p[0]});if(!d[0])return n(s);if(d.length>1){let t=!1;const e=[];for(let t=0,e=d.length;t<e;t++)h[t]=[];for(let n=0,r=d.length;n<r;n++){const r=m[n];for(let s=0;s<r.length;s++){const o=r[s];let a=!0;for(let r=0;r<d.length;r++)i(o.p,d[r].p)&&(n!==r&&e.push({froms:n,tos:r,hole:s}),a?(a=!1,h[r].push(o)):t=!0);a&&h[n].push(o)}}e.length>0&&(t||(m=h))}for(let t=0,e=d.length;t<e;t++){l=d[t].s,c.push(l),f=m[t];for(let t=0,e=f.length;t<e;t++)l.holes.push(f[t].h)}return c}});class AOt{constructor(t){Object.defineProperty(this,"isFont",{value:!0}),this.type="Font",this.data=t}generateShapes(t,e=100){const n=[],i=function(t,e,n){const i=Array.from?Array.from(t):String(t).split(""),r=e/n.resolution,s=(n.boundingBox.yMax-n.boundingBox.yMin+n.underlineThickness)*r,o=[];let a=0,l=0;for(let t=0;t<i.length;t++){const e=i[t];if("\n"===e)a=0,l-=s;else{const t=NOt(e,r,a,l,n);a+=t.offsetX,o.push(t.path)}}return o}(t,e,this.data);for(let t=0,e=i.length;t<e;t++)Array.prototype.push.apply(n,i[t].toShapes());return n}}function NOt(t,e,n,i,r){const s=r.glyphs[t]||r.glyphs["?"];if(!s)return void console.error('THREE.Font: character "'+t+'" does not exists in font family '+r.familyName+".");const o=new IOt;let a,l,c,u,h,d,p,f;if(s.o){const t=s._cachedOutline||(s._cachedOutline=s.o.split(" "));for(let r=0,s=t.length;r<s;){switch(t[r++]){case"m":a=t[r++]*e+n,l=t[r++]*e+i,o.moveTo(a,l);break;case"l":a=t[r++]*e+n,l=t[r++]*e+i,o.lineTo(a,l);break;case"q":c=t[r++]*e+n,u=t[r++]*e+i,h=t[r++]*e+n,d=t[r++]*e+i,o.quadraticCurveTo(h,d,c,u);break;case"b":c=t[r++]*e+n,u=t[r++]*e+i,h=t[r++]*e+n,d=t[r++]*e+i,p=t[r++]*e+n,f=t[r++]*e+i,o.bezierCurveTo(h,d,p,f,c,u)}}}return{offsetX:s.ha*e,path:o}}function ROt(t){$Pt.call(this,t)}let POt;ROt.prototype=Object.assign(Object.create($Pt.prototype),{constructor:ROt,load:function(t,e,n,i){const r=this,s=new APt(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,(function(t){let n;try{n=JSON.parse(t)}catch(e){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),n=JSON.parse(t.substring(65,t.length-2))}const i=r.parse(n);e&&e(i)}),n,i)},parse:function(t){return new AOt(t)}});const OOt={getContext:function(){return void 0===POt&&(POt=new(window.AudioContext||window.webkitAudioContext)),POt},setContext:function(t){POt=t}};function LOt(t){$Pt.call(this,t)}function DOt(t,e,n){xOt.call(this,void 0,n);const i=(new TMt).set(t),r=(new TMt).set(e),s=new rEt(i.r,i.g,i.b),o=new rEt(r.r,r.g,r.b),a=Math.sqrt(Math.PI),l=a*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)}function FOt(t,e){xOt.call(this,void 0,e);const n=(new TMt).set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}LOt.prototype=Object.assign(Object.create($Pt.prototype),{constructor:LOt,load:function(t,e,n,i){const r=this,s=new APt(r.manager);s.setResponseType("arraybuffer"),s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(t,(function(n){try{const t=n.slice(0);OOt.getContext().decodeAudioData(t,(function(t){e(t)}))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}}),n,i)}}),DOt.prototype=Object.assign(Object.create(xOt.prototype),{constructor:DOt,isHemisphereLightProbe:!0,copy:function(t){return xOt.prototype.copy.call(this,t),this},toJSON:function(t){return xOt.prototype.toJSON.call(this,t)}}),FOt.prototype=Object.assign(Object.create(xOt.prototype),{constructor:FOt,isAmbientLightProbe:!0,copy:function(t){return xOt.prototype.copy.call(this,t),this},toJSON:function(t){return xOt.prototype.toJSON.call(this,t)}});const zOt=new NEt,BOt=new NEt;function UOt(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new E$t,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new E$t,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}Object.assign(UOt.prototype,{update:function(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep;const n=t.projectionMatrix.clone(),i=e.eyeSep/2,r=i*e.near/e.focus,s=e.near*Math.tan(q_t.DEG2RAD*e.fov*.5)/e.zoom;let o,a;BOt.elements[12]=-i,zOt.elements[12]=i,o=-s*e.aspect+r,a=s*e.aspect+r,n.elements[0]=2*e.near/(a-o),n.elements[8]=(a+o)/(a-o),this.cameraL.projectionMatrix.copy(n),o=-s*e.aspect-r,a=s*e.aspect-r,n.elements[0]=2*e.near/(a-o),n.elements[8]=(a+o)/(a-o),this.cameraR.projectionMatrix.copy(n)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(BOt),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(zOt)}});class VOt{constructor(t){this.autoStart=void 0===t||t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=WOt(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=WOt();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}function WOt(){return("undefined"==typeof performance?Date:performance).now()}const HOt=new rEt,jOt=new iEt,GOt=new rEt,qOt=new rEt;class XOt extends iMt{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}const KOt=new rEt,YOt=new iEt,ZOt=new rEt,JOt=new rEt;class QOt{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const e=this.getFrequencyData();for(let n=0;n<e.length;n++)t+=e[n];return t/e.length}}function tLt(t,e,n){let i,r,s;switch(this.binding=t,this.valueSize=n,e){case"quaternion":i=this._slerp,r=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:i=this._lerp,r=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign(tLt.prototype,{accumulate:function(t,e){const n=this.buffer,i=this.valueSize,r=t*i+i;let s=this.cumulativeWeight;if(0===s){for(let t=0;t!==i;++t)n[r+t]=n[t];s=e}else{s+=e;const t=e/s;this._mixBufferRegion(n,r,0,t,i)}this.cumulativeWeight=s},accumulateAdditive:function(t){const e=this.buffer,n=this.valueSize,i=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t},apply:function(t){const e=this.valueSize,n=this.buffer,i=t*e+e,r=this.cumulativeWeight,s=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const t=e*this._origIndex;this._mixBufferRegion(n,i,t,1-r,e)}s>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*e,1,e);for(let t=e,r=e+e;t!==r;++t)if(n[t]!==n[t+e]){o.setValue(n,i);break}},saveOriginalState:function(){const t=this.binding,e=this.buffer,n=this.valueSize,i=n*this._origIndex;t.getValue(e,i);for(let t=n,r=i;t!==r;++t)e[t]=e[i+t%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)},_setAdditiveIdentityNumeric:function(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1},_setAdditiveIdentityOther:function(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]},_select:function(t,e,n,i,r){if(i>=.5)for(let i=0;i!==r;++i)t[e+i]=t[n+i]},_slerp:function(t,e,n,i){iEt.slerpFlat(t,e,t,e,t,n,i)},_slerpAdditive:function(t,e,n,i,r){const s=this._workIndex*r;iEt.multiplyQuaternionsFlat(t,s,t,e,t,n),iEt.slerpFlat(t,e,t,e,t,s,i)},_lerp:function(t,e,n,i,r){const s=1-i;for(let o=0;o!==r;++o){const r=e+o;t[r]=t[r]*s+t[n+o]*i}},_lerpAdditive:function(t,e,n,i,r){for(let s=0;s!==r;++s){const r=e+s;t[r]=t[r]+t[n+s]*i}}});const eLt="\\[\\]\\.:\\/",nLt=new RegExp("["+eLt+"]","g"),iLt="[^"+eLt+"]",rLt="[^"+eLt.replace("\\.","")+"]",sLt=/((?:WC+[\/:])*)/.source.replace("WC",iLt),oLt=/(WCOD+)?/.source.replace("WCOD",rLt),aLt=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",iLt),lLt=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",iLt),cLt=new RegExp("^"+sLt+oLt+aLt+lLt+"$"),uLt=["material","materials","bones"];function hLt(t,e,n){const i=n||dLt.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}function dLt(t,e,n){this.path=e,this.parsedPath=n||dLt.parseTrackName(e),this.node=dLt.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t}function pLt(){this.uuid=q_t.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let e=0,n=arguments.length;e!==n;++e)t[arguments[e].uuid]=e;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}Object.assign(hLt.prototype,{getValue:function(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];void 0!==i&&i.getValue(t,e)},setValue:function(t,e){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(t,e)},bind:function(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()},unbind:function(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}}),Object.assign(dLt,{Composite:hLt,create:function(t,e,n){return t&&t.isAnimationObjectGroup?new dLt.Composite(t,e,n):new dLt(t,e,n)},sanitizeNodeName:function(t){return t.replace(/\s/g,"_").replace(nLt,"")},parseTrackName:function(t){const e=cLt.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==i&&-1!==i){const t=n.nodeName.substring(i+1);-1!==uLt.indexOf(t)&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=t)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n},findNode:function(t,e){if(!e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(void 0!==n)return n}if(t.children){const n=function(t){for(let i=0;i<t.length;i++){const r=t[i];if(r.name===e||r.uuid===e)return r;const s=n(r.children);if(s)return s}return null},i=n(t.children);if(i)return i}return null}}),Object.assign(dLt.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(t,e){t[e]=this.node[this.propertyName]},function(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)t[e++]=n[i]},function(t,e){t[e]=this.resolvedProperty[this.propertyIndex]},function(t,e){this.resolvedProperty.toArray(t,e)}],SetterByBindingTypeAndVersioning:[[function(t,e){this.targetObject[this.propertyName]=t[e]},function(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0},function(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++]},function(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0},function(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){this.resolvedProperty[this.propertyIndex]=t[e]},function(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0},function(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){this.resolvedProperty.fromArray(t,e)},function(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0},function(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(t,e){this.bind(),this.getValue(t,e)},setValue:function(t,e){this.bind(),this.setValue(t,e)},bind:function(){let t=this.node;const e=this.parsedPath,n=e.objectName,i=e.propertyName;let r=e.propertyIndex;if(t||(t=dLt.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let i=e.objectIndex;switch(n){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===i){i=e;break}break;default:if(void 0===t[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[n]}if(void 0!==i){if(void 0===t[i])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[i]}}const s=t[i];if(void 0===s){const n=e.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+i+" but it wasn't found.",t)}let o=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?o=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(void 0!==r){if("morphTargetInfluences"===i){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[r]&&(r=t.morphTargetDictionary[r])}a=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else void 0!==s.fromArray&&void 0!==s.toArray?(a=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(a=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=i;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}),Object.assign(dLt.prototype,{_getValue_unbound:dLt.prototype.getValue,_setValue_unbound:dLt.prototype.setValue}),Object.assign(pLt.prototype,{isAnimationObjectGroup:!0,add:function(){const t=this._objects,e=this._indicesByUUID,n=this._paths,i=this._parsedPaths,r=this._bindings,s=r.length;let o,a=t.length,l=this.nCachedObjects_;for(let c=0,u=arguments.length;c!==u;++c){const u=arguments[c],h=u.uuid;let d=e[h];if(void 0===d){d=a++,e[h]=d,t.push(u);for(let t=0,e=s;t!==e;++t)r[t].push(new dLt(u,n[t],i[t]))}else if(d<l){o=t[d];const a=--l,c=t[a];e[c.uuid]=d,t[d]=c,e[h]=a,t[a]=u;for(let t=0,e=s;t!==e;++t){const e=r[t],s=e[a];let o=e[d];e[d]=s,void 0===o&&(o=new dLt(u,n[t],i[t])),e[a]=o}}else t[d]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l},remove:function(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_;for(let s=0,o=arguments.length;s!==o;++s){const o=arguments[s],a=o.uuid,l=e[a];if(void 0!==l&&l>=r){const s=r++,c=t[s];e[c.uuid]=l,t[l]=c,e[a]=s,t[s]=o;for(let t=0,e=i;t!==e;++t){const e=n[t],i=e[s],r=e[l];e[l]=i,e[s]=r}}}this.nCachedObjects_=r},uncache:function(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_,s=t.length;for(let o=0,a=arguments.length;o!==a;++o){const a=arguments[o].uuid,l=e[a];if(void 0!==l)if(delete e[a],l<r){const o=--r,a=t[o],c=--s,u=t[c];e[a.uuid]=l,t[l]=a,e[u.uuid]=o,t[o]=u,t.pop();for(let t=0,e=i;t!==e;++t){const e=n[t],i=e[o],r=e[c];e[l]=i,e[o]=r,e.pop()}}else{const r=--s,o=t[r];r>0&&(e[o.uuid]=l),t[l]=o,t.pop();for(let t=0,e=i;t!==e;++t){const e=n[t];e[l]=e[r],e.pop()}}}this.nCachedObjects_=r},subscribe_:function(t,e){const n=this._bindingsIndicesByPath;let i=n[t];const r=this._bindings;if(void 0!==i)return r[i];const s=this._paths,o=this._parsedPaths,a=this._objects,l=a.length,c=this.nCachedObjects_,u=new Array(l);i=r.length,n[t]=i,s.push(t),o.push(e),r.push(u);for(let n=c,i=a.length;n!==i;++n){const i=a[n];u[n]=new dLt(i,t,e)}return u},unsubscribe_:function(t){const e=this._bindingsIndicesByPath,n=e[t];if(void 0!==n){const i=this._paths,r=this._parsedPaths,s=this._bindings,o=s.length-1,a=s[o];e[t[o]]=n,s[n]=a,s.pop(),r[n]=r[o],r.pop(),i[n]=i[o],i.pop()}}});class fLt{constructor(t,e,n=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;const r=e.tracks,s=r.length,o=new Array(s),a={endingStart:S_t,endingEnd:S_t};for(let t=0;t!==s;++t){const e=r[t].createInterpolant(null);o[t]=e,e.settings=a}this._interpolantSettings=a,this._interpolants=o,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const n=this._clip.duration,i=t._clip.duration,r=i/n,s=n/i;t.warp(1,r,e),this.warp(s,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const i=this._mixer,r=i.time,s=this.timeScale;let o=this._timeScaleInterpolant;null===o&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=r,a[1]=r+n,l[0]=t/s,l[1]=e/s,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,i){if(!this.enabled)return void this._updateWeight(t);const r=this._startTime;if(null!==r){const i=(t-r)*n;if(i<0||0===n)return;this._startTime=null,e=n*i}e*=this._updateTimeScale(t);const s=this._updateTime(e),o=this._updateWeight(t);if(o>0){const t=this._interpolants,e=this._propertyBindings;if(this.blendMode===__t)for(let n=0,i=t.length;n!==i;++n)t[n].evaluate(s),e[n].accumulateAdditive(o);else for(let n=0,r=t.length;n!==r;++n)t[n].evaluate(s),e[n].accumulate(i,o)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(null!==n){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopFading(),0===i&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;if(null!==n){e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e)}}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let i=this.time+t,r=this._loopCount;const s=2202===n;if(0===t)return-1===r?i:s&&1==(1&r)?e-i:i;if(2200===n){-1===r&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else{if(!(i<0)){this.time=i;break t}i=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===r&&(t>=0?(r=0,this._setEndings(!0,0===this.repetitions,s)):this._setEndings(0===this.repetitions,!0,s)),i>=e||i<0){const n=Math.floor(i/e);i-=e*n,r+=Math.abs(n);const o=this.repetitions-r;if(o<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===o){const e=t<0;this._setEndings(e,!e,s)}else this._setEndings(!1,!1,s);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=i;if(s&&1==(1&r))return e-i}return i}_setEndings(t,e,n){const i=this._interpolantSettings;n?(i.endingStart=k_t,i.endingEnd=k_t):(i.endingStart=t?this.zeroSlopeAtStart?k_t:S_t:C_t,i.endingEnd=e?this.zeroSlopeAtEnd?k_t:S_t:C_t)}_scheduleFading(t,e,n){const i=this._mixer,r=i.time;let s=this._weightInterpolant;null===s&&(s=i._lendControlInterpolant(),this._weightInterpolant=s);const o=s.parameterPositions,a=s.sampleValues;return o[0]=r,a[0]=e,o[1]=r+t,a[1]=n,this}}function mLt(t){this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}mLt.prototype=Object.assign(Object.create(H_t.prototype),{constructor:mLt,_bindAction:function(t,e){const n=t._localRoot||this._root,i=t._clip.tracks,r=i.length,s=t._propertyBindings,o=t._interpolants,a=n.uuid,l=this._bindingsByRootAndName;let c=l[a];void 0===c&&(c={},l[a]=c);for(let t=0;t!==r;++t){const r=i[t],l=r.name;let u=c[l];if(void 0!==u)s[t]=u;else{if(u=s[t],void 0!==u){null===u._cacheIndex&&(++u.referenceCount,this._addInactiveBinding(u,a,l));continue}const i=e&&e._propertyBindings[t].binding.parsedPath;u=new tLt(dLt.create(n,l,i),r.ValueTypeName,r.getValueSize()),++u.referenceCount,this._addInactiveBinding(u,a,l),s[t]=u}o[t].resultBuffer=u.buffer}},_activateAction:function(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,n=t._clip.uuid,i=this._actionsByClip[n];this._bindAction(t,i&&i.knownActions[0]),this._addInactiveAction(t,n,e)}const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(t)}},_deactivateAction:function(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(t)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}},_isActiveAction:function(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions},_addInactiveAction:function(t,e,n){const i=this._actions,r=this._actionsByClip;let s=r[e];if(void 0===s)s={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=s;else{const e=s.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=i.length,i.push(t),s.actionByRoot[n]=t},_removeInactiveAction:function(t){const e=this._actions,n=e[e.length-1],i=t._cacheIndex;n._cacheIndex=i,e[i]=n,e.pop(),t._cacheIndex=null;const r=t._clip.uuid,s=this._actionsByClip,o=s[r],a=o.knownActions,l=a[a.length-1],c=t._byClipCacheIndex;l._byClipCacheIndex=c,a[c]=l,a.pop(),t._byClipCacheIndex=null;delete o.actionByRoot[(t._localRoot||this._root).uuid],0===a.length&&delete s[r],this._removeInactiveBindingsForAction(t)},_removeInactiveBindingsForAction:function(t){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.referenceCount&&this._removeInactiveBinding(n)}},_lendAction:function(t){const e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r},_takeBackAction:function(t){const e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r},_addInactiveBinding:function(t,e,n){const i=this._bindingsByRootAndName,r=this._bindings;let s=i[e];void 0===s&&(s={},i[e]=s),s[n]=t,t._cacheIndex=r.length,r.push(t)},_removeInactiveBinding:function(t){const e=this._bindings,n=t.binding,i=n.rootNode.uuid,r=n.path,s=this._bindingsByRootAndName,o=s[i],a=e[e.length-1],l=t._cacheIndex;a._cacheIndex=l,e[l]=a,e.pop(),delete o[r],0===Object.keys(o).length&&delete s[i]},_lendBinding:function(t){const e=this._bindings,n=t._cacheIndex,i=this._nActiveBindings++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r},_takeBackBinding:function(t){const e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r},_lendControlInterpolant:function(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return void 0===n&&(n=new fPt(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n},_takeBackControlInterpolant:function(t){const e=this._controlInterpolants,n=t.__cacheIndex,i=--this._nActiveControlInterpolants,r=e[i];t.__cacheIndex=i,e[i]=t,r.__cacheIndex=n,e[n]=r},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(t,e,n){const i=e||this._root,r=i.uuid;let s="string"==typeof t?CPt.findByName(i,t):t;const o=null!==s?s.uuid:t,a=this._actionsByClip[o];let l=null;if(void 0===n&&(n=null!==s?s.blendMode:T_t),void 0!==a){const t=a.actionByRoot[r];if(void 0!==t&&t.blendMode===n)return t;l=a.knownActions[0],null===s&&(s=l._clip)}if(null===s)return null;const c=new fLt(this,s,e,n);return this._bindAction(c,l),this._addInactiveAction(c,o,r),c},existingAction:function(t,e){const n=e||this._root,i=n.uuid,r="string"==typeof t?CPt.findByName(n,t):t,s=r?r.uuid:t,o=this._actionsByClip[s];return void 0!==o&&o.actionByRoot[i]||null},stopAllAction:function(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this},update:function(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,i=this.time+=t,r=Math.sign(t),s=this._accuIndex^=1;for(let o=0;o!==n;++o){e[o]._update(i,t,r,s)}const o=this._bindings,a=this._nActiveBindings;for(let t=0;t!==a;++t)o[t].apply(s);return this},setTime:function(t){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(t)},getRoot:function(){return this._root},uncacheClip:function(t){const e=this._actions,n=t.uuid,i=this._actionsByClip,r=i[n];if(void 0!==r){const t=r.knownActions;for(let n=0,i=t.length;n!==i;++n){const i=t[n];this._deactivateAction(i);const r=i._cacheIndex,s=e[e.length-1];i._cacheIndex=null,i._byClipCacheIndex=null,s._cacheIndex=r,e[r]=s,e.pop(),this._removeInactiveBindingsForAction(i)}delete i[n]}},uncacheRoot:function(t){const e=t.uuid,n=this._actionsByClip;for(const t in n){const i=n[t].actionByRoot[e];void 0!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}const i=this._bindingsByRootAndName[e];if(void 0!==i)for(const t in i){const e=i[t];e.restoreOriginalState(),this._removeInactiveBinding(e)}},uncacheAction:function(t,e){const n=this.existingAction(t,e);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}});class gLt{constructor(t){"string"==typeof t&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),t=arguments[1]),this.value=t}clone(){return new gLt(void 0===this.value.clone?this.value:this.value.clone())}}function yLt(t,e,n){KAt.call(this,t,e),this.meshPerAttribute=n||1}function bLt(t,e,n,i,r){this.buffer=t,this.type=e,this.itemSize=n,this.elementSize=i,this.count=r,this.version=0}function vLt(t,e,n,i){this.ray=new AEt(t,e),this.near=n||0,this.far=i||1/0,this.camera=null,this.layers=new WEt,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function xLt(t,e){return t.distance-e.distance}function wLt(t,e,n,i){if(t.layers.test(e.layers)&&t.raycast(e,n),!0===i){const i=t.children;for(let t=0,r=i.length;t<r;t++)wLt(i[t],e,n,!0)}}yLt.prototype=Object.assign(Object.create(KAt.prototype),{constructor:yLt,isInstancedInterleavedBuffer:!0,copy:function(t){return KAt.prototype.copy.call(this,t),this.meshPerAttribute=t.meshPerAttribute,this},clone:function(t){const e=KAt.prototype.clone.call(this,t);return e.meshPerAttribute=this.meshPerAttribute,e},toJSON:function(t){const e=KAt.prototype.toJSON.call(this,t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}),Object.defineProperty(bLt.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),Object.assign(bLt.prototype,{isGLBufferAttribute:!0,setBuffer:function(t){return this.buffer=t,this},setType:function(t,e){return this.type=t,this.elementSize=e,this},setItemSize:function(t){return this.itemSize=t,this},setCount:function(t){return this.count=t,this}}),Object.assign(vLt.prototype,{set:function(t,e){this.ray.set(t,e)},setFromCamera:function(t,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)},intersectObject:function(t,e,n){const i=n||[];return wLt(t,this,i,e),i.sort(xLt),i},intersectObjects:function(t,e,n){const i=n||[];if(!1===Array.isArray(t))return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),i;for(let n=0,r=t.length;n<r;n++)wLt(t[n],this,i,e);return i.sort(xLt),i}});class SLt{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}clone(){return(new this.constructor).copy(this)}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Math.max(t,Math.min(Math.PI-t,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(q_t.clamp(e/this.radius,-1,1))),this}}const kLt=new X_t;class CLt{constructor(t,e){Object.defineProperty(this,"isBox2",{value:!0}),this.min=void 0!==t?t:new X_t(1/0,1/0),this.max=void 0!==e?e:new X_t(-1/0,-1/0)}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=kLt.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return void 0===t&&(console.warn("THREE.Box2: .getCenter() target is now required"),t=new X_t),this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return void 0===t&&(console.warn("THREE.Box2: .getSize() target is now required"),t=new X_t),this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return void 0===e&&(console.warn("THREE.Box2: .getParameter() target is now required"),e=new X_t),e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return void 0===e&&(console.warn("THREE.Box2: .clampPoint() target is now required"),e=new X_t),e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return kLt.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const TLt=new rEt,_Lt=new rEt;class ELt{constructor(t,e){this.start=void 0!==t?t:new rEt,this.end=void 0!==e?e:new rEt}set(t,e){return this.start.copy(t),this.end.copy(e),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return void 0===t&&(console.warn("THREE.Line3: .getCenter() target is now required"),t=new rEt),t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return void 0===t&&(console.warn("THREE.Line3: .delta() target is now required"),t=new rEt),t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return void 0===e&&(console.warn("THREE.Line3: .at() target is now required"),e=new rEt),this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){TLt.subVectors(t,this.start),_Lt.subVectors(this.end,this.start);const n=_Lt.dot(_Lt);let i=_Lt.dot(TLt)/n;return e&&(i=q_t.clamp(i,0,1)),i}closestPointToPoint(t,e,n){const i=this.closestPointToPointParameter(t,e);return void 0===n&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),n=new rEt),this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}}function MLt(t){iMt.call(this),this.material=t,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}MLt.prototype=Object.create(iMt.prototype),MLt.prototype.constructor=MLt,MLt.prototype.isImmediateRenderObject=!0;const $Lt=new rEt;const ILt=new rEt,ALt=new NEt,NLt=new NEt;class RLt extends UNt{constructor(t){const e=PLt(t),n=new QMt,i=[],r=[],s=new TMt(0,0,1),o=new TMt(0,1,0);for(let t=0;t<e.length;t++){const n=e[t];n.parent&&n.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(s.r,s.g,s.b),r.push(o.r,o.g,o.b))}n.setAttribute("position",new UMt(i,3)),n.setAttribute("color",new UMt(r,3));super(n,new NNt({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,i=n.getAttribute("position");NLt.copy(this.root.matrixWorld).invert();for(let t=0,n=0;t<e.length;t++){const r=e[t];r.parent&&r.parent.isBone&&(ALt.multiplyMatrices(NLt,r.matrixWorld),ILt.setFromMatrixPosition(ALt),i.setXYZ(n,ILt.x,ILt.y,ILt.z),ALt.multiplyMatrices(NLt,r.parent.matrixWorld),ILt.setFromMatrixPosition(ALt),i.setXYZ(n+1,ILt.x,ILt.y,ILt.z),n+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function PLt(t){const e=[];t&&t.isBone&&e.push(t);for(let n=0;n<t.children.length;n++)e.push.apply(e,PLt(t.children[n]));return e}const OLt=new rEt,LLt=new TMt,DLt=new TMt;class FLt extends UNt{constructor(t=10,e=10,n=4473924,i=8947848){n=new TMt(n),i=new TMt(i);const r=e/2,s=t/e,o=t/2,a=[],l=[];for(let t=0,c=0,u=-o;t<=e;t++,u+=s){a.push(-o,0,u,o,0,u),a.push(u,0,-o,u,0,o);const e=t===r?n:i;e.toArray(l,c),c+=3,e.toArray(l,c),c+=3,e.toArray(l,c),c+=3,e.toArray(l,c),c+=3}const c=new QMt;c.setAttribute("position",new UMt(a,3)),c.setAttribute("color",new UMt(l,3));super(c,new NNt({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}const zLt=new rEt,BLt=new rEt,ULt=new rEt;const VLt=new rEt,WLt=new _$t;function HLt(t,e,n,i,r,s,o){VLt.set(r,s,o).unproject(i);const a=e[t];if(void 0!==a){const t=n.getAttribute("position");for(let e=0,n=a.length;e<n;e++)t.setXYZ(a[e],VLt.x,VLt.y,VLt.z)}}const jLt=new aEt;class GLt extends UNt{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),r=new QMt;r.setIndex(new NMt(n,1)),r.setAttribute("position",new NMt(i,3)),super(r,new NNt({color:e,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(t){if(void 0!==t&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&jLt.setFromObject(this.object),jLt.isEmpty())return;const e=jLt.min,n=jLt.max,i=this.geometry.attributes.position,r=i.array;r[0]=n.x,r[1]=n.y,r[2]=n.z,r[3]=e.x,r[4]=n.y,r[5]=n.z,r[6]=e.x,r[7]=e.y,r[8]=n.z,r[9]=n.x,r[10]=e.y,r[11]=n.z,r[12]=n.x,r[13]=n.y,r[14]=e.z,r[15]=e.x,r[16]=n.y,r[17]=e.z,r[18]=e.x,r[19]=e.y,r[20]=e.z,r[21]=n.x,r[22]=e.y,r[23]=e.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t){return UNt.prototype.copy.call(this,t),this.object=t.object,this}}const qLt=new rEt;let XLt,KLt;class YLt extends UNt{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],n=new QMt;n.setAttribute("position",new UMt(e,3)),n.setAttribute("color",new UMt([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3));super(n,new NNt({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}}const ZLt=new Float32Array(1),JLt=new Int32Array(ZLt.buffer),QLt={toHalfFloat:function(t){ZLt[0]=t;const e=JLt[0];let n=e>>16&32768,i=e>>12&2047;const r=e>>23&255;return r<103?n:r>142?(n|=31744,n|=(255==r?0:1)&&8388607&e,n):r<113?(i|=2048,n|=(i>>114-r)+(i>>113-r&1),n):(n|=r-112<<10|i>>1,n+=1&i,n)}},tDt=Math.pow(2,8),eDt=[.125,.215,.35,.446,.526,.582],nDt=5+eDt.length,iDt=20,rDt={[E_t]:0,[M_t]:1,[I_t]:2,[N_t]:3,[R_t]:4,[P_t]:5,[$_t]:6},sDt=new $Mt({side:rCt,depthWrite:!1,depthTest:!1}),oDt=new y$t(new v$t,sDt),aDt=new fOt,{_lodPlanes:lDt,_sizeLods:cDt,_sigmas:uDt}=bDt(),hDt=new TMt;let dDt=null;const pDt=(1+Math.sqrt(5))/2,fDt=1/pDt,mDt=[new rEt(1,1,1),new rEt(-1,1,1),new rEt(1,1,-1),new rEt(-1,1,-1),new rEt(0,pDt,fDt),new rEt(0,pDt,-fDt),new rEt(fDt,0,pDt),new rEt(-fDt,0,pDt),new rEt(pDt,fDt,0),new rEt(-pDt,fDt,0)];function gDt(t){const e=Math.max(t.r,t.g,t.b),n=Math.min(Math.max(Math.ceil(Math.log2(e)),-128),127);t.multiplyScalar(Math.pow(2,-n));return(n+128)/255}function yDt(t){return void 0!==t&&t.type===aTt&&(t.encoding===E_t||t.encoding===M_t||t.encoding===$_t)}function bDt(){const t=[],e=[],n=[];let i=8;for(let r=0;r<nDt;r++){const s=Math.pow(2,i);e.push(s);let o=1/s;r>4?o=eDt[r-8+4-1]:0==r&&(o=0),n.push(o);const a=1/(s-1),l=-a/2,c=1+a/2,u=[l,l,c,l,c,c,l,l,c,c,l,c],h=6,d=6,p=3,f=2,m=1,g=new Float32Array(p*d*h),y=new Float32Array(f*d*h),b=new Float32Array(m*d*h);for(let t=0;t<h;t++){const e=t%3*2/3-1,n=t>2?0:-1,i=[e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0];g.set(i,p*d*t),y.set(u,f*d*t);const r=[t,t,t,t,t,t];b.set(r,m*d*t)}const v=new QMt;v.setAttribute("position",new NMt(g,p)),v.setAttribute("uv",new NMt(y,f)),v.setAttribute("faceIndex",new NMt(b,m)),t.push(v),i>4&&i--}return{_lodPlanes:t,_sizeLods:e,_sigmas:n}}function vDt(t){const e=new nEt(3*tDt,3*tDt,t);return e.texture.mapping=YCt,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function xDt(t,e,n,i,r){t.viewport.set(e,n,i,r),t.scissor.set(e,n,i,r)}function wDt(){return new ePt({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:new X_t(1,1)},inputEncoding:{value:rDt[E_t]},outputEncoding:{value:rDt[E_t]}},vertexShader:kDt(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${CDt()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:oCt,depthTest:!1,depthWrite:!1})}function SDt(){return new ePt({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:rDt[E_t]},outputEncoding:{value:rDt[E_t]}},vertexShader:kDt(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${CDt()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:oCt,depthTest:!1,depthWrite:!1})}function kDt(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"}function CDt(){return"\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"}function TDt(t){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),GPt.call(this,t),this.type="catmullrom",this.closed=!0}function _Dt(t){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),GPt.call(this,t),this.type="catmullrom"}function EDt(t){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),GPt.call(this,t),this.type="catmullrom"}FPt.create=function(t,e){return console.log("THREE.Curve.create() has been deprecated"),t.prototype=Object.create(FPt.prototype),t.prototype.constructor=t,t.prototype.getPoint=e,t},Object.assign(sOt.prototype,{fromPoints:function(t){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(t)}}),TDt.prototype=Object.create(GPt.prototype),_Dt.prototype=Object.create(GPt.prototype),EDt.prototype=Object.create(GPt.prototype),Object.assign(EDt.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}}),FLt.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},RLt.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Object.assign($Pt.prototype,{extractUrlBase:function(t){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),SOt.extractUrlBase(t)}}),$Pt.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Object.assign(CLt.prototype,{center:function(t){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(t)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(t){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},size:function(t){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(t)}}),Object.assign(aEt.prototype,{center:function(t){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(t)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(t){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},isIntersectionSphere:function(t){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},size:function(t){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(t)}}),Object.assign(kEt.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}}),O$t.prototype.setFromMatrix=function(t){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(t)},ELt.prototype.center=function(t){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(t)},Object.assign(q_t,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(t){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),q_t.floorPowerOfTwo(t)},nextPowerOfTwo:function(t){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),q_t.ceilPowerOfTwo(t)}}),Object.assign(K_t.prototype,{flattenToArrayOffset:function(t,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},multiplyVector3:function(t){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(t){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},getInverse:function(t){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()}}),Object.assign(NEt.prototype,{extractPosition:function(t){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(t)},flattenToArrayOffset:function(t,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new rEt).setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(t){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(t)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(t){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},multiplyVector4:function(t){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(t){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),t.transformDirection(this)},crossVector:function(t){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(t){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(t,e,n,i,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(t,e,i,n,r,s)},getInverse:function(t){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()}}),aMt.prototype.isIntersectionLine=function(t){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(t)},Object.assign(iEt.prototype,{multiplyVector3:function(t){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),t.applyQuaternion(this)},inverse:function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()}}),Object.assign(AEt.prototype,{isIntersectionBox:function(t){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},isIntersectionPlane:function(t){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(t)},isIntersectionSphere:function(t){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)}}),Object.assign(bMt.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(t,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(t,e)},midpoint:function(t){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(t)},normal:function(t){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(t)},plane:function(t){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(t)}}),Object.assign(bMt,{barycoordFromPoint:function(t,e,n,i,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),bMt.getBarycoord(t,e,n,i,r)},normal:function(t,e,n,i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),bMt.getNormal(t,e,n,i)}}),Object.assign(oOt.prototype,{extractAllPoints:function(t){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(t)},extrude:function(t){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new FRt(this,t)},makeGeometry:function(t){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new jRt(this,t)}}),Object.assign(X_t.prototype,{fromAttribute:function(t,e,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},distanceToManhattan:function(t){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(rEt.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(t){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(t)},getScaleFromMatrix:function(t){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(t)},getColumnFromMatrix:function(t,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,t)},applyProjection:function(t){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(t)},fromAttribute:function(t,e,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},distanceToManhattan:function(t){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(eEt.prototype,{fromAttribute:function(t,e,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(iMt.prototype,{getChildByName:function(t){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(t)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(t,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,t)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(t){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)}}),Object.defineProperties(iMt.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(t){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=t}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Object.assign(y$t.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}),Object.defineProperties(y$t.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Object.defineProperties(gNt.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}}),Object.defineProperty(_Nt.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}}),SNt.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Object.defineProperty(FPt.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(t){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=t}}),E$t.prototype.setLens=function(t,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==e&&(this.filmGauge=e),this.setFocalLength(t)},Object.defineProperties(aOt.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(t){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=t}},shadowCameraLeft:{set:function(t){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=t}},shadowCameraRight:{set:function(t){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=t}},shadowCameraTop:{set:function(t){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=t}},shadowCameraBottom:{set:function(t){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=t}},shadowCameraNear:{set:function(t){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=t}},shadowCameraFar:{set:function(t){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=t}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(t){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=t}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(t){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=t}},shadowMapHeight:{set:function(t){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=t}}}),Object.defineProperties(NMt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===V_t},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(V_t)}}}),Object.assign(NMt.prototype,{setDynamic:function(t){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?V_t:U_t),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(QMt.prototype,{addIndex:function(t){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(t)},addAttribute:function(t,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),e&&e.isBufferAttribute||e&&e.isInterleavedBufferAttribute?"index"===t?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(t,e):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(t,new NMt(arguments[1],arguments[2])))},addDrawCall:function(t,e,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(t,e)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(t){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(t)},applyMatrix:function(t){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)}}),Object.defineProperties(QMt.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Object.defineProperties(kOt.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(t){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=t}}}),Object.defineProperties(vLt.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(t){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=t}}}),Object.defineProperties(KAt.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===V_t},set:function(t){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(t)}}}),Object.assign(KAt.prototype,{setDynamic:function(t){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?V_t:U_t),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(FRt.prototype,{getArrays:function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")}}),Object.assign(XAt.prototype,{dispose:function(){console.error("THREE.Scene: .dispose() has been removed.")}}),Object.defineProperties(gLt.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}}),Object.defineProperties(MMt.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new TMt}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===t}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(t){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=t}}}),Object.defineProperties(rPt.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}}),Object.defineProperties(iPt.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(t){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=t}}}),Object.defineProperties(T$t.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(t){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=t}}}),Object.assign(HAt.prototype,{clearTarget:function(t,e,n,i){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(t),this.clear(e,n,i)},animate:function(t){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(t)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(t){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(t)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}}),Object.defineProperties(HAt.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=t}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=t}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(t){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===t?M_t:E_t}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(OAt.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(nEt.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=t}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=t}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=t}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=t}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(t){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=t}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(t){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=t}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(t){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=t}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(t){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=t}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(t){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=t}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(t){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=t}}}),Object.defineProperties(XOt.prototype,{load:{value:function(t){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return(new LOt).load(t,(function(t){e.setBuffer(t)})),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}}),QOt.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},$$t.prototype.updateCubeMap=function(t,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(t,e)},$$t.prototype.clear=function(t,e,n,i){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(t,e,n,i)};const MDt={merge:function(t,e,n){let i;console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),e.isMesh&&(e.matrixAutoUpdate&&e.updateMatrix(),i=e.matrix,e=e.geometry),t.merge(e,i,n)},center:function(t){return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),t.center()}};Z_t.crossOrigin=void 0,Z_t.loadTexture=function(t,e,n,i){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new DPt;r.setCrossOrigin(this.crossOrigin);const s=r.load(t,n,void 0,i);return e&&(s.mapping=e),s},Z_t.loadTextureCube=function(t,e,n,i){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new OPt;r.setCrossOrigin(this.crossOrigin);const s=r.load(t,n,void 0,i);return e&&(s.mapping=e),s},Z_t.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},Z_t.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};const $Dt={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Xkt}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Xkt);var IDt=Object.freeze({__proto__:null,ACESFilmicToneMapping:WCt,AddEquation:dCt,AddOperation:FCt,AdditiveAnimationBlendMode:__t,AdditiveBlending:lCt,AlphaFormat:vTt,AlwaysDepth:$Ct,AlwaysStencilFunc:B_t,AmbientLight:yOt,AmbientLightProbe:FOt,AnimationClip:CPt,AnimationLoader:NPt,AnimationMixer:mLt,AnimationObjectGroup:pLt,AnimationUtils:hPt,ArcCurve:BPt,ArrayCamera:zAt,ArrowHelper:class extends iMt{constructor(t,e,n,i,r,s){super(),this.type="ArrowHelper",void 0===t&&(t=new rEt(0,0,1)),void 0===e&&(e=new rEt(0,0,0)),void 0===n&&(n=1),void 0===i&&(i=16776960),void 0===r&&(r=.2*n),void 0===s&&(s=.2*r),void 0===XLt&&(XLt=new QMt,XLt.setAttribute("position",new UMt([0,0,0,0,1,0],3)),KLt=new eRt(0,.5,1,5,1),KLt.translate(0,-.5,0)),this.position.copy(e),this.line=new FNt(XLt,new NNt({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new y$t(KLt,new $Mt({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(n,r,s)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{qLt.set(t.z,0,-t.x).normalize();const e=Math.acos(t.y);this.quaternion.setFromAxisAngle(qLt,e)}}setLength(t,e,n){void 0===e&&(e=.2*t),void 0===n&&(n=.2*e),this.line.scale.set(1,Math.max(1e-4,t-e),1),this.line.updateMatrix(),this.cone.scale.set(n,e,n),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}},Audio:XOt,AudioAnalyser:QOt,AudioContext:OOt,AudioListener:class extends iMt{constructor(){super(),this.type="AudioListener",this.context=OOt.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new VOt}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const e=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(HOt,jOt,GOt),qOt.set(0,0,-1).applyQuaternion(jOt),e.positionX){const t=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(HOt.x,t),e.positionY.linearRampToValueAtTime(HOt.y,t),e.positionZ.linearRampToValueAtTime(HOt.z,t),e.forwardX.linearRampToValueAtTime(qOt.x,t),e.forwardY.linearRampToValueAtTime(qOt.y,t),e.forwardZ.linearRampToValueAtTime(qOt.z,t),e.upX.linearRampToValueAtTime(n.x,t),e.upY.linearRampToValueAtTime(n.y,t),e.upZ.linearRampToValueAtTime(n.z,t)}else e.setPosition(HOt.x,HOt.y,HOt.z),e.setOrientation(qOt.x,qOt.y,qOt.z,n.x,n.y,n.z)}},AudioLoader:LOt,AxesHelper:YLt,AxisHelper:function(t){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new YLt(t)},BackSide:rCt,BasicDepthPacking:O_t,BasicShadowMap:0,BinaryTextureLoader:function(t){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new LPt(t)},Bone:kNt,BooleanKeyframeTrack:yPt,BoundingBoxHelper:function(t,e){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new GLt(t,e)},Box2:CLt,Box3:aEt,Box3Helper:class extends UNt{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new QMt;i.setIndex(new NMt(n,1)),i.setAttribute("position",new UMt([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(i,new NNt({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}},BoxBufferGeometry:v$t,BoxGeometry:v$t,BoxHelper:GLt,BufferAttribute:NMt,BufferGeometry:QMt,BufferGeometryLoader:TOt,ByteType:lTt,Cache:_Pt,Camera:_$t,CameraHelper:class extends UNt{constructor(t){const e=new QMt,n=new NNt({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],r=[],s={},o=new TMt(16755200),a=new TMt(16711680),l=new TMt(43775),c=new TMt(16777215),u=new TMt(3355443);function h(t,e,n){d(t,n),d(e,n)}function d(t,e){i.push(0,0,0),r.push(e.r,e.g,e.b),void 0===s[t]&&(s[t]=[]),s[t].push(i.length/3-1)}h("n1","n2",o),h("n2","n4",o),h("n4","n3",o),h("n3","n1",o),h("f1","f2",o),h("f2","f4",o),h("f4","f3",o),h("f3","f1",o),h("n1","f1",o),h("n2","f2",o),h("n3","f3",o),h("n4","f4",o),h("p","n1",a),h("p","n2",a),h("p","n3",a),h("p","n4",a),h("u1","u2",l),h("u2","u3",l),h("u3","u1",l),h("c","t",c),h("p","c",u),h("cn1","cn2",u),h("cn3","cn4",u),h("cf1","cf2",u),h("cf3","cf4",u),e.setAttribute("position",new UMt(i,3)),e.setAttribute("color",new UMt(r,3)),super(e,n),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=s,this.update()}update(){const t=this.geometry,e=this.pointMap;WLt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),HLt("c",e,t,WLt,0,0,-1),HLt("t",e,t,WLt,0,0,1),HLt("n1",e,t,WLt,-1,-1,-1),HLt("n2",e,t,WLt,1,-1,-1),HLt("n3",e,t,WLt,-1,1,-1),HLt("n4",e,t,WLt,1,1,-1),HLt("f1",e,t,WLt,-1,-1,1),HLt("f2",e,t,WLt,1,-1,1),HLt("f3",e,t,WLt,-1,1,1),HLt("f4",e,t,WLt,1,1,1),HLt("u1",e,t,WLt,.7,1.1,-1),HLt("u2",e,t,WLt,-.7,1.1,-1),HLt("u3",e,t,WLt,0,2,-1),HLt("cf1",e,t,WLt,-1,0,1),HLt("cf2",e,t,WLt,1,0,1),HLt("cf3",e,t,WLt,0,-1,1),HLt("cf4",e,t,WLt,0,1,1),HLt("cn1",e,t,WLt,-1,0,-1),HLt("cn2",e,t,WLt,1,0,-1),HLt("cn3",e,t,WLt,0,-1,-1),HLt("cn4",e,t,WLt,0,1,-1),t.getAttribute("position").needsUpdate=!0}},CanvasRenderer:function(){console.error("THREE.CanvasRenderer has been removed")},CanvasTexture:JNt,CatmullRomCurve3:GPt,CineonToneMapping:VCt,CircleBufferGeometry:tRt,CircleGeometry:tRt,ClampToEdgeWrapping:QCt,Clock:VOt,ClosedSplineCurve3:TDt,Color:TMt,ColorKeyframeTrack:bPt,CompressedTexture:ZNt,CompressedTextureLoader:RPt,ConeBufferGeometry:nRt,ConeGeometry:nRt,CubeCamera:$$t,CubeReflectionMapping:GCt,CubeRefractionMapping:qCt,CubeTexture:I$t,CubeTextureLoader:OPt,CubeUVReflectionMapping:YCt,CubeUVRefractionMapping:ZCt,CubicBezierCurve:YPt,CubicBezierCurve3:ZPt,CubicInterpolant:pPt,CullFaceBack:Jkt,CullFaceFront:Qkt,CullFaceFrontBack:3,CullFaceNone:Zkt,Curve:FPt,CurvePath:rOt,CustomBlending:hCt,CustomToneMapping:HCt,CylinderBufferGeometry:eRt,CylinderGeometry:eRt,Cylindrical:class{constructor(t,e,n){return this.radius=void 0!==t?t:1,this.theta=void 0!==e?e:0,this.y=void 0!==n?n:0,this}set(t,e,n){return this.radius=t,this.theta=e,this.y=n,this}clone(){return(new this.constructor).copy(this)}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+n*n),this.theta=Math.atan2(t,n),this.y=e,this}},DataTexture:N$t,DataTexture2DArray:nIt,DataTexture3D:iIt,DataTextureLoader:LPt,DataUtils:QLt,DecrementStencilOp:7683,DecrementWrapStencilOp:34056,DefaultLoadingManager:MPt,DepthFormat:TTt,DepthStencilFormat:_Tt,DepthTexture:QNt,DirectionalLight:gOt,DirectionalLightHelper:class extends iMt{constructor(t,e,n){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,void 0===e&&(e=1);let i=new QMt;i.setAttribute("position",new UMt([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const r=new NNt({fog:!1,toneMapped:!1});this.lightPlane=new FNt(i,r),this.add(this.lightPlane),i=new QMt,i.setAttribute("position",new UMt([0,0,0,0,0,1],3)),this.targetLine=new FNt(i,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){zLt.setFromMatrixPosition(this.light.matrixWorld),BLt.setFromMatrixPosition(this.light.target.matrixWorld),ULt.subVectors(BLt,zLt),this.lightPlane.lookAt(BLt),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(BLt),this.targetLine.scale.z=ULt.length()}},DiscreteInterpolant:mPt,DodecahedronBufferGeometry:rRt,DodecahedronGeometry:rRt,DoubleSide:sCt,DstAlphaFactor:kCt,DstColorFactor:TCt,DynamicBufferAttribute:function(t,e){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new NMt(t,e).setUsage(V_t)},DynamicCopyUsage:35050,DynamicDrawUsage:V_t,DynamicReadUsage:35049,EdgesGeometry:cRt,EdgesHelper:function(t,e){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new UNt(new cRt(t.geometry),new NNt({color:void 0!==e?e:16777215}))},EllipseCurve:zPt,EqualDepth:NCt,EqualStencilFunc:514,EquirectangularReflectionMapping:XCt,EquirectangularRefractionMapping:KCt,Euler:BEt,EventDispatcher:H_t,ExtrudeBufferGeometry:FRt,ExtrudeGeometry:FRt,Face3:_Mt,Face4:function(t,e,n,i,r,s,o){return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),new _Mt(t,e,n,r,s,o)},FaceColors:1,FileLoader:APt,FlatShading:1,Float16BufferAttribute:BMt,Float32Attribute:function(t,e){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new UMt(t,e)},Float32BufferAttribute:UMt,Float64Attribute:function(t,e){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new VMt(t,e)},Float64BufferAttribute:VMt,FloatType:pTt,Fog:qAt,FogExp2:GAt,Font:AOt,FontLoader:ROt,FrontSide:iCt,Frustum:O$t,GLBufferAttribute:bLt,GLSL1:"100",GLSL3:W_t,GammaEncoding:$_t,GeometryUtils:MDt,GreaterDepth:PCt,GreaterEqualDepth:RCt,GreaterEqualStencilFunc:518,GreaterStencilFunc:516,GridHelper:FLt,Group:BAt,HalfFloatType:fTt,HemisphereLight:lOt,HemisphereLightHelper:class extends iMt{constructor(t,e,n){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const i=new VRt(e);i.rotateY(.5*Math.PI),this.material=new $Mt({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const r=i.getAttribute("position"),s=new Float32Array(3*r.count);i.setAttribute("color",new NMt(s,3)),this.add(new y$t(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const e=t.geometry.getAttribute("color");LLt.copy(this.light.color),DLt.copy(this.light.groundColor);for(let t=0,n=e.count;t<n;t++){const i=t<n/2?LLt:DLt;e.setXYZ(t,i.r,i.g,i.b)}e.needsUpdate=!0}t.lookAt(OLt.setFromMatrixPosition(this.light.matrixWorld).negate())}},HemisphereLightProbe:DOt,IcosahedronBufferGeometry:BRt,IcosahedronGeometry:BRt,ImageBitmapLoader:$Ot,ImageLoader:PPt,ImageUtils:Z_t,ImmediateRenderObject:MLt,IncrementStencilOp:7682,IncrementWrapStencilOp:34055,InstancedBufferAttribute:COt,InstancedBufferGeometry:kOt,InstancedInterleavedBuffer:yLt,InstancedMesh:ANt,Int16Attribute:function(t,e){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new LMt(t,e)},Int16BufferAttribute:LMt,Int32Attribute:function(t,e){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new FMt(t,e)},Int32BufferAttribute:FMt,Int8Attribute:function(t,e){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new RMt(t,e)},Int8BufferAttribute:RMt,IntType:hTt,InterleavedBuffer:KAt,InterleavedBufferAttribute:ZAt,Interpolant:dPt,InterpolateDiscrete:v_t,InterpolateLinear:x_t,InterpolateSmooth:w_t,InvertStencilOp:5386,JSONLoader:function(){console.error("THREE.JSONLoader has been removed.")},KeepStencilOp:z_t,KeyframeTrack:gPt,LOD:gNt,LatheBufferGeometry:URt,LatheGeometry:URt,Layers:WEt,LensFlare:function(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")},LessDepth:ICt,LessEqualDepth:ACt,LessEqualStencilFunc:515,LessStencilFunc:513,Light:aOt,LightProbe:xOt,Line:FNt,Line3:ELt,LineBasicMaterial:NNt,LineCurve:JPt,LineCurve3:QPt,LineDashedMaterial:cPt,LineLoop:VNt,LinePieces:1,LineSegments:UNt,LineStrip:0,LinearEncoding:E_t,LinearFilter:rTt,LinearInterpolant:fPt,LinearMipMapLinearFilter:1008,LinearMipMapNearestFilter:1007,LinearMipmapLinearFilter:oTt,LinearMipmapNearestFilter:sTt,LinearToneMapping:BCt,Loader:$Pt,LoaderUtils:SOt,LoadingManager:EPt,LogLuvEncoding:A_t,LoopOnce:2200,LoopPingPong:2202,LoopRepeat:2201,LuminanceAlphaFormat:kTt,LuminanceFormat:STt,MOUSE:Kkt,Material:MMt,MaterialLoader:wOt,Math:q_t,MathUtils:q_t,Matrix3:K_t,Matrix4:NEt,MaxEquation:gCt,Mesh:y$t,MeshBasicMaterial:$Mt,MeshDepthMaterial:AAt,MeshDistanceMaterial:NAt,MeshFaceMaterial:function(t){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),t},MeshLambertMaterial:aPt,MeshMatcapMaterial:lPt,MeshNormalMaterial:oPt,MeshPhongMaterial:rPt,MeshPhysicalMaterial:iPt,MeshStandardMaterial:nPt,MeshToonMaterial:sPt,MinEquation:mCt,MirroredRepeatWrapping:tTt,MixOperation:DCt,MultiMaterial:function(t=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),t.isMultiMaterial=!0,t.materials=t,t.clone=function(){return t.slice()},t},MultiplyBlending:uCt,MultiplyOperation:LCt,NearestFilter:eTt,NearestMipMapLinearFilter:1005,NearestMipMapNearestFilter:1004,NearestMipmapLinearFilter:iTt,NearestMipmapNearestFilter:nTt,NeverDepth:MCt,NeverStencilFunc:512,NoBlending:oCt,NoColors:0,NoToneMapping:zCt,NormalAnimationBlendMode:T_t,NormalBlending:aCt,NotEqualDepth:OCt,NotEqualStencilFunc:517,NumberKeyframeTrack:vPt,Object3D:iMt,ObjectLoader:class extends $Pt{constructor(t){super(t)}load(t,e,n,i){const r=this,s=""===this.path?SOt.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||s;const o=new APt(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,(function(n){let s=null;try{s=JSON.parse(n)}catch(e){return void 0!==i&&i(e),void console.error("THREE:ObjectLoader: Can't parse "+t+".",e.message)}const o=s.metadata;void 0!==o&&void 0!==o.type&&"geometry"!==o.type.toLowerCase()?r.parse(s,e):console.error("THREE.ObjectLoader: Can't load "+t)}),n,i)}parse(t,e){const n=this.parseAnimations(t.animations),i=this.parseShapes(t.shapes),r=this.parseGeometries(t.geometries,i),s=this.parseImages(t.images,(function(){void 0!==e&&e(l)})),o=this.parseTextures(t.textures,s),a=this.parseMaterials(t.materials,o),l=this.parseObject(t.object,r,a,n),c=this.parseSkeletons(t.skeletons,l);if(this.bindSkeletons(l,c),void 0!==e){let t=!1;for(const e in s)if(s[e]instanceof HTMLImageElement){t=!0;break}!1===t&&e(l)}return l}parseShapes(t){const e={};if(void 0!==t)for(let n=0,i=t.length;n<i;n++){const i=(new oOt).fromJSON(t[n]);e[i.uuid]=i}return e}parseSkeletons(t,e){const n={},i={};if(e.traverse((function(t){t.isBone&&(i[t.uuid]=t)})),void 0!==t)for(let e=0,r=t.length;e<r;e++){const r=(new _Nt).fromJSON(t[e],i);n[r.uuid]=r}return n}parseGeometries(t,e){const n={};let i;if(void 0!==t){const r=new TOt;for(let s=0,o=t.length;s<o;s++){let o;const a=t[s];switch(a.type){case"PlaneGeometry":case"PlaneBufferGeometry":o=new QRt[a.type](a.width,a.height,a.widthSegments,a.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":o=new QRt[a.type](a.width,a.height,a.depth,a.widthSegments,a.heightSegments,a.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":o=new QRt[a.type](a.radius,a.segments,a.thetaStart,a.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":o=new QRt[a.type](a.radiusTop,a.radiusBottom,a.height,a.radialSegments,a.heightSegments,a.openEnded,a.thetaStart,a.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":o=new QRt[a.type](a.radius,a.height,a.radialSegments,a.heightSegments,a.openEnded,a.thetaStart,a.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":o=new QRt[a.type](a.radius,a.widthSegments,a.heightSegments,a.phiStart,a.phiLength,a.thetaStart,a.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":o=new QRt[a.type](a.radius,a.detail);break;case"RingGeometry":case"RingBufferGeometry":o=new QRt[a.type](a.innerRadius,a.outerRadius,a.thetaSegments,a.phiSegments,a.thetaStart,a.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":o=new QRt[a.type](a.radius,a.tube,a.radialSegments,a.tubularSegments,a.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":o=new QRt[a.type](a.radius,a.tube,a.tubularSegments,a.radialSegments,a.p,a.q);break;case"TubeGeometry":case"TubeBufferGeometry":o=new QRt[a.type]((new iOt[a.path.type]).fromJSON(a.path),a.tubularSegments,a.radius,a.radialSegments,a.closed);break;case"LatheGeometry":case"LatheBufferGeometry":o=new QRt[a.type](a.points,a.segments,a.phiStart,a.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":o=new QRt[a.type](a.vertices,a.indices,a.radius,a.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":i=[];for(let t=0,n=a.shapes.length;t<n;t++){const n=e[a.shapes[t]];i.push(n)}o=new QRt[a.type](i,a.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":i=[];for(let t=0,n=a.shapes.length;t<n;t++){const n=e[a.shapes[t]];i.push(n)}const t=a.options.extrudePath;void 0!==t&&(a.options.extrudePath=(new iOt[t.type]).fromJSON(t)),o=new QRt[a.type](i,a.options);break;case"BufferGeometry":case"InstancedBufferGeometry":o=r.parse(a);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+a.type+'"');continue}o.uuid=a.uuid,void 0!==a.name&&(o.name=a.name),!0===o.isBufferGeometry&&void 0!==a.userData&&(o.userData=a.userData),n[a.uuid]=o}}return n}parseMaterials(t,e){const n={},i={};if(void 0!==t){const r=new wOt;r.setTextures(e);for(let e=0,s=t.length;e<s;e++){const s=t[e];if("MultiMaterial"===s.type){const t=[];for(let e=0;e<s.materials.length;e++){const i=s.materials[e];void 0===n[i.uuid]&&(n[i.uuid]=r.parse(i)),t.push(n[i.uuid])}i[s.uuid]=t}else void 0===n[s.uuid]&&(n[s.uuid]=r.parse(s)),i[s.uuid]=n[s.uuid]}}return i}parseAnimations(t){const e={};if(void 0!==t)for(let n=0;n<t.length;n++){const i=t[n],r=CPt.parse(i);e[r.uuid]=r}return e}parseImages(t,e){const n=this,i={};let r;function s(t){if("string"==typeof t){const e=t;return function(t){return n.manager.itemStart(t),r.load(t,(function(){n.manager.itemEnd(t)}),void 0,(function(){n.manager.itemError(t),n.manager.itemEnd(t)}))}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)?e:n.resourcePath+e)}return t.data?{data:jMt(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){const n=new EPt(e);r=new PPt(n),r.setCrossOrigin(this.crossOrigin);for(let e=0,n=t.length;e<n;e++){const n=t[e],r=n.url;if(Array.isArray(r)){i[n.uuid]=[];for(let t=0,e=r.length;t<e;t++){const e=s(r[t]);null!==e&&(e instanceof HTMLImageElement?i[n.uuid].push(e):i[n.uuid].push(new N$t(e.data,e.width,e.height)))}}else{const t=s(n.url);null!==t&&(i[n.uuid]=t)}}}return i}parseTextures(t,e){function n(t,e){return"number"==typeof t?t:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",t),e[t])}const i={};if(void 0!==t)for(let r=0,s=t.length;r<s;r++){const s=t[r];let o;void 0===s.image&&console.warn('THREE.ObjectLoader: No "image" specified for',s.uuid),void 0===e[s.image]&&console.warn("THREE.ObjectLoader: Undefined image",s.image);const a=e[s.image];Array.isArray(a)?(o=new I$t(a),6===a.length&&(o.needsUpdate=!0)):(o=a&&a.data?new N$t(a.data,a.width,a.height):new Q_t(a),a&&(o.needsUpdate=!0)),o.uuid=s.uuid,void 0!==s.name&&(o.name=s.name),void 0!==s.mapping&&(o.mapping=n(s.mapping,_Ot)),void 0!==s.offset&&o.offset.fromArray(s.offset),void 0!==s.repeat&&o.repeat.fromArray(s.repeat),void 0!==s.center&&o.center.fromArray(s.center),void 0!==s.rotation&&(o.rotation=s.rotation),void 0!==s.wrap&&(o.wrapS=n(s.wrap[0],EOt),o.wrapT=n(s.wrap[1],EOt)),void 0!==s.format&&(o.format=s.format),void 0!==s.type&&(o.type=s.type),void 0!==s.encoding&&(o.encoding=s.encoding),void 0!==s.minFilter&&(o.minFilter=n(s.minFilter,MOt)),void 0!==s.magFilter&&(o.magFilter=n(s.magFilter,MOt)),void 0!==s.anisotropy&&(o.anisotropy=s.anisotropy),void 0!==s.flipY&&(o.flipY=s.flipY),void 0!==s.premultiplyAlpha&&(o.premultiplyAlpha=s.premultiplyAlpha),void 0!==s.unpackAlignment&&(o.unpackAlignment=s.unpackAlignment),i[s.uuid]=o}return i}parseObject(t,e,n,i){let r,s,o;function a(t){return void 0===e[t]&&console.warn("THREE.ObjectLoader: Undefined geometry",t),e[t]}function l(t){if(void 0!==t){if(Array.isArray(t)){const e=[];for(let i=0,r=t.length;i<r;i++){const r=t[i];void 0===n[r]&&console.warn("THREE.ObjectLoader: Undefined material",r),e.push(n[r])}return e}return void 0===n[t]&&console.warn("THREE.ObjectLoader: Undefined material",t),n[t]}}switch(t.type){case"Scene":r=new XAt,void 0!==t.background&&Number.isInteger(t.background)&&(r.background=new TMt(t.background)),void 0!==t.fog&&("Fog"===t.fog.type?r.fog=new qAt(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(r.fog=new GAt(t.fog.color,t.fog.density)));break;case"PerspectiveCamera":r=new E$t(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(r.focus=t.focus),void 0!==t.zoom&&(r.zoom=t.zoom),void 0!==t.filmGauge&&(r.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(r.filmOffset=t.filmOffset),void 0!==t.view&&(r.view=Object.assign({},t.view));break;case"OrthographicCamera":r=new fOt(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(r.zoom=t.zoom),void 0!==t.view&&(r.view=Object.assign({},t.view));break;case"AmbientLight":r=new yOt(t.color,t.intensity);break;case"DirectionalLight":r=new gOt(t.color,t.intensity);break;case"PointLight":r=new pOt(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":r=new bOt(t.color,t.intensity,t.width,t.height);break;case"SpotLight":r=new hOt(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);break;case"HemisphereLight":r=new lOt(t.color,t.groundColor,t.intensity);break;case"LightProbe":r=(new xOt).fromJSON(t);break;case"SkinnedMesh":s=a(t.geometry),o=l(t.material),r=new SNt(s,o),void 0!==t.bindMode&&(r.bindMode=t.bindMode),void 0!==t.bindMatrix&&r.bindMatrix.fromArray(t.bindMatrix),void 0!==t.skeleton&&(r.skeleton=t.skeleton);break;case"Mesh":s=a(t.geometry),o=l(t.material),r=new y$t(s,o);break;case"InstancedMesh":s=a(t.geometry),o=l(t.material);const e=t.count,n=t.instanceMatrix;r=new ANt(s,o,e),r.instanceMatrix=new NMt(new Float32Array(n.array),16);break;case"LOD":r=new gNt;break;case"Line":r=new FNt(a(t.geometry),l(t.material));break;case"LineLoop":r=new VNt(a(t.geometry),l(t.material));break;case"LineSegments":r=new UNt(a(t.geometry),l(t.material));break;case"PointCloud":case"Points":r=new XNt(a(t.geometry),l(t.material));break;case"Sprite":r=new dNt(l(t.material));break;case"Group":r=new BAt;break;case"Bone":r=new kNt;break;default:r=new iMt}if(r.uuid=t.uuid,void 0!==t.name&&(r.name=t.name),void 0!==t.matrix?(r.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(r.matrixAutoUpdate=t.matrixAutoUpdate),r.matrixAutoUpdate&&r.matrix.decompose(r.position,r.quaternion,r.scale)):(void 0!==t.position&&r.position.fromArray(t.position),void 0!==t.rotation&&r.rotation.fromArray(t.rotation),void 0!==t.quaternion&&r.quaternion.fromArray(t.quaternion),void 0!==t.scale&&r.scale.fromArray(t.scale)),void 0!==t.castShadow&&(r.castShadow=t.castShadow),void 0!==t.receiveShadow&&(r.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.bias&&(r.shadow.bias=t.shadow.bias),void 0!==t.shadow.normalBias&&(r.shadow.normalBias=t.shadow.normalBias),void 0!==t.shadow.radius&&(r.shadow.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&r.shadow.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(r.shadow.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(r.visible=t.visible),void 0!==t.frustumCulled&&(r.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(r.renderOrder=t.renderOrder),void 0!==t.userData&&(r.userData=t.userData),void 0!==t.layers&&(r.layers.mask=t.layers),void 0!==t.children){const s=t.children;for(let t=0;t<s.length;t++)r.add(this.parseObject(s[t],e,n,i))}if(void 0!==t.animations){const e=t.animations;for(let t=0;t<e.length;t++){const n=e[t];r.animations.push(i[n])}}if("LOD"===t.type){void 0!==t.autoUpdate&&(r.autoUpdate=t.autoUpdate);const e=t.levels;for(let t=0;t<e.length;t++){const n=e[t],i=r.getObjectByProperty("uuid",n.object);void 0!==i&&r.addLevel(i,n.distance)}}return r}bindSkeletons(t,e){0!==Object.keys(e).length&&t.traverse((function(t){if(!0===t.isSkinnedMesh&&void 0!==t.skeleton){const n=e[t.skeleton];void 0===n?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",t.skeleton):t.bind(n,t.bindMatrix)}}))}setTexturePath(t){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(t)}},ObjectSpaceNormalMap:F_t,OctahedronBufferGeometry:VRt,OctahedronGeometry:VRt,OneFactor:bCt,OneMinusDstAlphaFactor:CCt,OneMinusDstColorFactor:_Ct,OneMinusSrcAlphaFactor:SCt,OneMinusSrcColorFactor:xCt,OrthographicCamera:fOt,PCFShadowMap:tCt,PCFSoftShadowMap:eCt,PMREMGenerator:class{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=function(t){const e=new Float32Array(t),n=new rEt(0,1,0);return new ePt({name:"SphericalGaussianBlur",defines:{n:t},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n},inputEncoding:{value:rDt[E_t]},outputEncoding:{value:rDt[E_t]}},vertexShader:kDt(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${CDt()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:oCt,depthTest:!1,depthWrite:!1})}(iDt),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){dDt=this._renderer.getRenderTarget();const r=this._allocateTargets();return this._sceneToCubeUV(t,n,i,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(t){return this._fromTexture(t)}fromCubemap(t){return this._fromTexture(t)}compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=SDt(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=wDt(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let t=0;t<lDt.length;t++)lDt[t].dispose()}_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(dDt),t.scissorTest=!1,xDt(t,0,0,t.width,t.height)}_fromTexture(t){dDt=this._renderer.getRenderTarget();const e=this._allocateTargets(t);return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(t){const e={magFilter:eTt,minFilter:eTt,generateMipmaps:!1,type:aTt,format:CTt,encoding:yDt(t)?t.encoding:I_t,depthBuffer:!1},n=vDt(e);return n.depthBuffer=!t,this._pingPongRenderTarget=vDt(e),n}_compileMaterial(t){const e=new y$t(lDt[0],t);this._renderer.compile(e,aDt)}_sceneToCubeUV(t,e,n,i){const r=new E$t(90,1,e,n),s=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],a=this._renderer,l=a.autoClear,c=a.outputEncoding,u=a.toneMapping;a.getClearColor(hDt),a.toneMapping=zCt,a.outputEncoding=E_t,a.autoClear=!1;let h=!1;const d=t.background;if(d){if(d.isColor){sDt.color.copy(d).convertSRGBToLinear(),t.background=null;const e=gDt(sDt.color);sDt.opacity=e,h=!0}}else{sDt.color.copy(hDt).convertSRGBToLinear();const t=gDt(sDt.color);sDt.opacity=t,h=!0}for(let e=0;e<6;e++){const n=e%3;0==n?(r.up.set(0,s[e],0),r.lookAt(o[e],0,0)):1==n?(r.up.set(0,0,s[e]),r.lookAt(0,o[e],0)):(r.up.set(0,s[e],0),r.lookAt(0,0,o[e])),xDt(i,n*tDt,e>2?tDt:0,tDt,tDt),a.setRenderTarget(i),h&&a.render(oDt,r),a.render(t,r)}a.toneMapping=u,a.outputEncoding=c,a.autoClear=l}_textureToCubeUV(t,e){const n=this._renderer;t.isCubeTexture?null==this._cubemapShader&&(this._cubemapShader=SDt()):null==this._equirectShader&&(this._equirectShader=wDt());const i=t.isCubeTexture?this._cubemapShader:this._equirectShader,r=new y$t(lDt[0],i),s=i.uniforms;s.envMap.value=t,t.isCubeTexture||s.texelSize.value.set(1/t.image.width,1/t.image.height),s.inputEncoding.value=rDt[t.encoding],s.outputEncoding.value=rDt[e.texture.encoding],xDt(e,0,0,3*tDt,2*tDt),n.setRenderTarget(e),n.render(r,aDt)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let e=1;e<nDt;e++){const n=Math.sqrt(uDt[e]*uDt[e]-uDt[e-1]*uDt[e-1]),i=mDt[(e-1)%mDt.length];this._blur(t,e-1,e,n,i)}e.autoClear=n}_blur(t,e,n,i,r){const s=this._pingPongRenderTarget;this._halfBlur(t,s,e,n,i,"latitudinal",r),this._halfBlur(s,t,n,n,i,"longitudinal",r)}_halfBlur(t,e,n,i,r,s,o){const a=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new y$t(lDt[i],l),u=l.uniforms,h=cDt[n]-1,d=isFinite(r)?Math.PI/(2*h):2*Math.PI/39,p=r/d,f=isFinite(r)?1+Math.floor(3*p):iDt;f>iDt&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);const m=[];let g=0;for(let t=0;t<iDt;++t){const e=t/p,n=Math.exp(-e*e/2);m.push(n),0==t?g+=n:t<f&&(g+=2*n)}for(let t=0;t<m.length;t++)m[t]=m[t]/g;u.envMap.value=t.texture,u.samples.value=f,u.weights.value=m,u.latitudinal.value="latitudinal"===s,o&&(u.poleAxis.value=o),u.dTheta.value=d,u.mipInt.value=8-n,u.inputEncoding.value=rDt[t.texture.encoding],u.outputEncoding.value=rDt[t.texture.encoding];const y=cDt[i];xDt(e,3*Math.max(0,tDt-2*y),(0===i?0:2*tDt)+2*y*(i>4?i-8+4:0),3*y,2*y),a.setRenderTarget(e),a.render(c,aDt)}},ParametricBufferGeometry:WRt,ParametricGeometry:WRt,Particle:function(t){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new dNt(t)},ParticleBasicMaterial:function(t){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new WNt(t)},ParticleSystem:function(t,e){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new XNt(t,e)},ParticleSystemMaterial:function(t){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new WNt(t)},Path:sOt,PerspectiveCamera:E$t,Plane:aMt,PlaneBufferGeometry:F$t,PlaneGeometry:F$t,PlaneHelper:class extends FNt{constructor(t,e=1,n=16776960){const i=n,r=new QMt;r.setAttribute("position",new UMt([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),r.computeBoundingSphere(),super(r,new NNt({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=e;const s=new QMt;s.setAttribute("position",new UMt([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),s.computeBoundingSphere(),this.add(new y$t(s,new $Mt({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){let e=-this.plane.constant;Math.abs(e)<1e-8&&(e=1e-8),this.scale.set(.5*this.size,.5*this.size,e),this.children[0].material.side=e<0?rCt:iCt,this.lookAt(this.plane.normal),super.updateMatrixWorld(t)}},PointCloud:function(t,e){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new XNt(t,e)},PointCloudMaterial:function(t){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new WNt(t)},PointLight:pOt,PointLightHelper:class extends y$t{constructor(t,e,n){super(new GRt(e,4,2),new $Mt({wireframe:!0,fog:!1,toneMapped:!1})),this.light=t,this.light.updateMatrixWorld(),this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}},Points:XNt,PointsMaterial:WNt,PolarGridHelper:class extends UNt{constructor(t=10,e=16,n=8,i=64,r=4473924,s=8947848){r=new TMt(r),s=new TMt(s);const o=[],a=[];for(let n=0;n<=e;n++){const i=n/e*(2*Math.PI),l=Math.sin(i)*t,c=Math.cos(i)*t;o.push(0,0,0),o.push(l,0,c);const u=1&n?r:s;a.push(u.r,u.g,u.b),a.push(u.r,u.g,u.b)}for(let e=0;e<=n;e++){const l=1&e?r:s,c=t-t/n*e;for(let t=0;t<i;t++){let e=t/i*(2*Math.PI),n=Math.sin(e)*c,r=Math.cos(e)*c;o.push(n,0,r),a.push(l.r,l.g,l.b),e=(t+1)/i*(2*Math.PI),n=Math.sin(e)*c,r=Math.cos(e)*c,o.push(n,0,r),a.push(l.r,l.g,l.b)}}const l=new QMt;l.setAttribute("position",new UMt(o,3)),l.setAttribute("color",new UMt(a,3));super(l,new NNt({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}},PolyhedronBufferGeometry:iRt,PolyhedronGeometry:iRt,PositionalAudio:class extends XOt{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,e,n){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=n,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(KOt,YOt,ZOt),JOt.set(0,0,1).applyQuaternion(YOt);const e=this.panner;if(e.positionX){const t=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(KOt.x,t),e.positionY.linearRampToValueAtTime(KOt.y,t),e.positionZ.linearRampToValueAtTime(KOt.z,t),e.orientationX.linearRampToValueAtTime(JOt.x,t),e.orientationY.linearRampToValueAtTime(JOt.y,t),e.orientationZ.linearRampToValueAtTime(JOt.z,t)}else e.setPosition(KOt.x,KOt.y,KOt.z),e.setOrientation(JOt.x,JOt.y,JOt.z)}},PropertyBinding:dLt,PropertyMixer:tLt,QuadraticBezierCurve:tOt,QuadraticBezierCurve3:eOt,Quaternion:iEt,QuaternionKeyframeTrack:wPt,QuaternionLinearInterpolant:xPt,REVISION:Xkt,RGBADepthPacking:L_t,RGBAFormat:wTt,RGBAIntegerFormat:NTt,RGBA_ASTC_10x10_Format:e_t,RGBA_ASTC_10x5_Format:JTt,RGBA_ASTC_10x6_Format:QTt,RGBA_ASTC_10x8_Format:t_t,RGBA_ASTC_12x10_Format:n_t,RGBA_ASTC_12x12_Format:i_t,RGBA_ASTC_4x4_Format:HTt,RGBA_ASTC_5x4_Format:jTt,RGBA_ASTC_5x5_Format:GTt,RGBA_ASTC_6x5_Format:qTt,RGBA_ASTC_6x6_Format:XTt,RGBA_ASTC_8x5_Format:KTt,RGBA_ASTC_8x6_Format:YTt,RGBA_ASTC_8x8_Format:ZTt,RGBA_BPTC_Format:r_t,RGBA_ETC2_EAC_Format:WTt,RGBA_PVRTC_2BPPV1_Format:BTt,RGBA_PVRTC_4BPPV1_Format:zTt,RGBA_S3TC_DXT1_Format:PTt,RGBA_S3TC_DXT3_Format:OTt,RGBA_S3TC_DXT5_Format:LTt,RGBDEncoding:P_t,RGBEEncoding:I_t,RGBEFormat:CTt,RGBFormat:xTt,RGBIntegerFormat:ATt,RGBM16Encoding:R_t,RGBM7Encoding:N_t,RGB_ETC1_Format:UTt,RGB_ETC2_Format:VTt,RGB_PVRTC_2BPPV1_Format:FTt,RGB_PVRTC_4BPPV1_Format:DTt,RGB_S3TC_DXT1_Format:RTt,RGFormat:$Tt,RGIntegerFormat:ITt,RawShaderMaterial:ePt,Ray:AEt,Raycaster:vLt,RectAreaLight:bOt,RedFormat:ETt,RedIntegerFormat:MTt,ReinhardToneMapping:UCt,RepeatWrapping:JCt,ReplaceStencilOp:7681,ReverseSubtractEquation:fCt,RingBufferGeometry:HRt,RingGeometry:HRt,SRGB8_ALPHA8_ASTC_10x10_Format:g_t,SRGB8_ALPHA8_ASTC_10x5_Format:p_t,SRGB8_ALPHA8_ASTC_10x6_Format:f_t,SRGB8_ALPHA8_ASTC_10x8_Format:m_t,SRGB8_ALPHA8_ASTC_12x10_Format:y_t,SRGB8_ALPHA8_ASTC_12x12_Format:b_t,SRGB8_ALPHA8_ASTC_4x4_Format:s_t,SRGB8_ALPHA8_ASTC_5x4_Format:o_t,SRGB8_ALPHA8_ASTC_5x5_Format:a_t,SRGB8_ALPHA8_ASTC_6x5_Format:l_t,SRGB8_ALPHA8_ASTC_6x6_Format:c_t,SRGB8_ALPHA8_ASTC_8x5_Format:u_t,SRGB8_ALPHA8_ASTC_8x6_Format:h_t,SRGB8_ALPHA8_ASTC_8x8_Format:d_t,Scene:XAt,SceneUtils:$Dt,ShaderChunk:z$t,ShaderLib:U$t,ShaderMaterial:T$t,ShadowMaterial:tPt,Shape:oOt,ShapeBufferGeometry:jRt,ShapeGeometry:jRt,ShapePath:IOt,ShapeUtils:ORt,ShortType:cTt,Skeleton:_Nt,SkeletonHelper:RLt,SkinnedMesh:SNt,SmoothShading:2,Sphere:kEt,SphereBufferGeometry:GRt,SphereGeometry:GRt,Spherical:SLt,SphericalHarmonics3:vOt,Spline:EDt,SplineCurve:nOt,SplineCurve3:_Dt,SpotLight:hOt,SpotLightHelper:class extends iMt{constructor(t,e){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=e;const n=new QMt,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let t=0,e=1,n=32;t<n;t++,e++){const r=t/n*Math.PI*2,s=e/n*Math.PI*2;i.push(Math.cos(r),Math.sin(r),1,Math.cos(s),Math.sin(s),1)}n.setAttribute("position",new UMt(i,3));const r=new NNt({fog:!1,toneMapped:!1});this.cone=new UNt(n,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const t=this.light.distance?this.light.distance:1e3,e=t*Math.tan(this.light.angle);this.cone.scale.set(e,e,t),$Lt.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt($Lt),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}},Sprite:dNt,SpriteMaterial:JAt,SrcAlphaFactor:wCt,SrcAlphaSaturateFactor:ECt,SrcColorFactor:vCt,StaticCopyUsage:35046,StaticDrawUsage:U_t,StaticReadUsage:35045,StereoCamera:UOt,StreamCopyUsage:35042,StreamDrawUsage:35040,StreamReadUsage:35041,StringKeyframeTrack:SPt,SubtractEquation:pCt,SubtractiveBlending:cCt,TOUCH:Ykt,TangentSpaceNormalMap:D_t,TetrahedronBufferGeometry:qRt,TetrahedronGeometry:qRt,TextBufferGeometry:XRt,TextGeometry:XRt,Texture:Q_t,TextureLoader:DPt,TorusBufferGeometry:KRt,TorusGeometry:KRt,TorusKnotBufferGeometry:YRt,TorusKnotGeometry:YRt,Triangle:bMt,TriangleFanDrawMode:2,TriangleStripDrawMode:1,TrianglesDrawMode:0,TubeBufferGeometry:ZRt,TubeGeometry:ZRt,UVMapping:jCt,Uint16Attribute:function(t,e){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new DMt(t,e)},Uint16BufferAttribute:DMt,Uint32Attribute:function(t,e){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new zMt(t,e)},Uint32BufferAttribute:zMt,Uint8Attribute:function(t,e){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new PMt(t,e)},Uint8BufferAttribute:PMt,Uint8ClampedAttribute:function(t,e){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new OMt(t,e)},Uint8ClampedBufferAttribute:OMt,Uniform:gLt,UniformsLib:B$t,UniformsUtils:S$t,UnsignedByteType:aTt,UnsignedInt248Type:bTt,UnsignedIntType:dTt,UnsignedShort4444Type:mTt,UnsignedShort5551Type:gTt,UnsignedShort565Type:yTt,UnsignedShortType:uTt,VSMShadowMap:nCt,Vector2:X_t,Vector3:rEt,Vector4:eEt,VectorKeyframeTrack:kPt,Vertex:function(t,e,n){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new rEt(t,e,n)},VertexColors:2,VideoTexture:YNt,WebGL1Renderer:jAt,WebGLCubeRenderTarget:A$t,WebGLMultisampleRenderTarget:class extends nEt{constructor(t,e,n){super(t,e,n),Object.defineProperty(this,"isWebGLMultisampleRenderTarget",{value:!0}),this.samples=4}copy(t){return super.copy.call(this,t),this.samples=t.samples,this}},WebGLRenderTarget:nEt,WebGLRenderTargetCube:function(t,e,n){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new A$t(t,n)},WebGLRenderer:HAt,WebGLUtils:FAt,WireframeGeometry:JRt,WireframeHelper:function(t,e){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new UNt(new JRt(t.geometry),new NNt({color:void 0!==e?e:16777215}))},WrapAroundEnding:C_t,XHRLoader:function(t){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new APt(t)},ZeroCurvatureEnding:S_t,ZeroFactor:yCt,ZeroSlopeEnding:k_t,ZeroStencilOp:0,sRGBEncoding:M_t}),ADt=Ei(IDt),NDt=function(t,e){void 0===e&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),e===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=t,this.domElement=e,this.enabled=!0,this.target=new rEt,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={LEFT:Kkt.ROTATE,MIDDLE:Kkt.DOLLY,RIGHT:Kkt.PAN},this.touches={ONE:Ykt.ROTATE,TWO:Ykt.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return c.phi},this.getAzimuthalAngle=function(){return c.theta},this.listenToKeyEvents=function(t){t.addEventListener("keydown",W),this._domElementKeyEvents=t},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(i),n.update(),a=o.NONE},this.update=function(){var e=new rEt,r=(new iEt).setFromUnitVectors(t.up,new rEt(0,1,0)),s=r.clone().invert(),f=new rEt,m=new iEt,g=2*Math.PI;return function(){var t=n.object.position;e.copy(t).sub(n.target),e.applyQuaternion(r),c.setFromVector3(e),n.autoRotate&&a===o.NONE&&C(2*Math.PI/60/60*n.autoRotateSpeed),n.enableDamping?(c.theta+=u.theta*n.dampingFactor,c.phi+=u.phi*n.dampingFactor):(c.theta+=u.theta,c.phi+=u.phi);var y=n.minAzimuthAngle,b=n.maxAzimuthAngle;return isFinite(y)&&isFinite(b)&&(y<-Math.PI?y+=g:y>Math.PI&&(y-=g),b<-Math.PI?b+=g:b>Math.PI&&(b-=g),c.theta=y<=b?Math.max(y,Math.min(b,c.theta)):c.theta>(y+b)/2?Math.max(y,c.theta):Math.min(b,c.theta)),c.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,c.phi)),c.makeSafe(),c.radius*=h,c.radius=Math.max(n.minDistance,Math.min(n.maxDistance,c.radius)),!0===n.enableDamping?n.target.addScaledVector(d,n.dampingFactor):n.target.add(d),e.setFromSpherical(c),e.applyQuaternion(s),t.copy(n.target).add(e),n.object.lookAt(n.target),!0===n.enableDamping?(u.theta*=1-n.dampingFactor,u.phi*=1-n.dampingFactor,d.multiplyScalar(1-n.dampingFactor)):(u.set(0,0,0),d.set(0,0,0)),h=1,!!(p||f.distanceToSquared(n.object.position)>l||8*(1-m.dot(n.object.quaternion))>l)&&(n.dispatchEvent(i),f.copy(n.object.position),m.copy(n.object.quaternion),p=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",q),n.domElement.removeEventListener("pointerdown",z),n.domElement.removeEventListener("wheel",V),n.domElement.removeEventListener("touchstart",H),n.domElement.removeEventListener("touchend",G),n.domElement.removeEventListener("touchmove",j),n.domElement.ownerDocument.removeEventListener("pointermove",B),n.domElement.ownerDocument.removeEventListener("pointerup",U),null!==n._domElementKeyEvents&&n._domElementKeyEvents.removeEventListener("keydown",W)};var n=this,i={type:"change"},r={type:"start"},s={type:"end"},o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},a=o.NONE,l=1e-6,c=new SLt,u=new SLt,h=1,d=new rEt,p=!1,f=new X_t,m=new X_t,g=new X_t,y=new X_t,b=new X_t,v=new X_t,x=new X_t,w=new X_t,S=new X_t;function k(){return Math.pow(.95,n.zoomSpeed)}function C(t){u.theta-=t}function T(t){u.phi-=t}var _=function(){var t=new rEt;return function(e,n){t.setFromMatrixColumn(n,0),t.multiplyScalar(-e),d.add(t)}}(),E=function(){var t=new rEt;return function(e,i){!0===n.screenSpacePanning?t.setFromMatrixColumn(i,1):(t.setFromMatrixColumn(i,0),t.crossVectors(n.object.up,t)),t.multiplyScalar(e),d.add(t)}}(),M=function(){var t=new rEt;return function(e,i){var r=n.domElement;if(n.object.isPerspectiveCamera){var s=n.object.position;t.copy(s).sub(n.target);var o=t.length();o*=Math.tan(n.object.fov/2*Math.PI/180),_(2*e*o/r.clientHeight,n.object.matrix),E(2*i*o/r.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(_(e*(n.object.right-n.object.left)/n.object.zoom/r.clientWidth,n.object.matrix),E(i*(n.object.top-n.object.bottom)/n.object.zoom/r.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function $(t){n.object.isPerspectiveCamera?h/=t:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*t)),n.object.updateProjectionMatrix(),p=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function I(t){n.object.isPerspectiveCamera?h*=t:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/t)),n.object.updateProjectionMatrix(),p=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function A(t){f.set(t.clientX,t.clientY)}function N(t){y.set(t.clientX,t.clientY)}function R(t){if(1==t.touches.length)f.set(t.touches[0].pageX,t.touches[0].pageY);else{var e=.5*(t.touches[0].pageX+t.touches[1].pageX),n=.5*(t.touches[0].pageY+t.touches[1].pageY);f.set(e,n)}}function P(t){if(1==t.touches.length)y.set(t.touches[0].pageX,t.touches[0].pageY);else{var e=.5*(t.touches[0].pageX+t.touches[1].pageX),n=.5*(t.touches[0].pageY+t.touches[1].pageY);y.set(e,n)}}function O(t){var e=t.touches[0].pageX-t.touches[1].pageX,n=t.touches[0].pageY-t.touches[1].pageY,i=Math.sqrt(e*e+n*n);x.set(0,i)}function L(t){if(1==t.touches.length)m.set(t.touches[0].pageX,t.touches[0].pageY);else{var e=.5*(t.touches[0].pageX+t.touches[1].pageX),i=.5*(t.touches[0].pageY+t.touches[1].pageY);m.set(e,i)}g.subVectors(m,f).multiplyScalar(n.rotateSpeed);var r=n.domElement;C(2*Math.PI*g.x/r.clientHeight),T(2*Math.PI*g.y/r.clientHeight),f.copy(m)}function D(t){if(1==t.touches.length)b.set(t.touches[0].pageX,t.touches[0].pageY);else{var e=.5*(t.touches[0].pageX+t.touches[1].pageX),i=.5*(t.touches[0].pageY+t.touches[1].pageY);b.set(e,i)}v.subVectors(b,y).multiplyScalar(n.panSpeed),M(v.x,v.y),y.copy(b)}function F(t){var e=t.touches[0].pageX-t.touches[1].pageX,i=t.touches[0].pageY-t.touches[1].pageY,r=Math.sqrt(e*e+i*i);w.set(0,r),S.set(0,Math.pow(w.y/x.y,n.zoomSpeed)),$(S.y),x.copy(w)}function z(t){if(!1!==n.enabled)switch(t.pointerType){case"mouse":case"pen":!function(t){var e;switch(t.preventDefault(),n.domElement.focus?n.domElement.focus():window.focus(),t.button){case 0:e=n.mouseButtons.LEFT;break;case 1:e=n.mouseButtons.MIDDLE;break;case 2:e=n.mouseButtons.RIGHT;break;default:e=-1}switch(e){case Kkt.DOLLY:if(!1===n.enableZoom)return;!function(t){x.set(t.clientX,t.clientY)}(t),a=o.DOLLY;break;case Kkt.ROTATE:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enablePan)return;N(t),a=o.PAN}else{if(!1===n.enableRotate)return;A(t),a=o.ROTATE}break;case Kkt.PAN:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enableRotate)return;A(t),a=o.ROTATE}else{if(!1===n.enablePan)return;N(t),a=o.PAN}break;default:a=o.NONE}a!==o.NONE&&(n.domElement.ownerDocument.addEventListener("pointermove",B),n.domElement.ownerDocument.addEventListener("pointerup",U),n.dispatchEvent(r))}(t)}}function B(t){if(!1!==n.enabled)switch(t.pointerType){case"mouse":case"pen":!function(t){if(!1===n.enabled)return;switch(t.preventDefault(),a){case o.ROTATE:if(!1===n.enableRotate)return;!function(t){m.set(t.clientX,t.clientY),g.subVectors(m,f).multiplyScalar(n.rotateSpeed);var e=n.domElement;C(2*Math.PI*g.x/e.clientHeight),T(2*Math.PI*g.y/e.clientHeight),f.copy(m),n.update()}(t);break;case o.DOLLY:if(!1===n.enableZoom)return;!function(t){w.set(t.clientX,t.clientY),S.subVectors(w,x),S.y>0?$(k()):S.y<0&&I(k()),x.copy(w),n.update()}(t);break;case o.PAN:if(!1===n.enablePan)return;!function(t){b.set(t.clientX,t.clientY),v.subVectors(b,y).multiplyScalar(n.panSpeed),M(v.x,v.y),y.copy(b),n.update()}(t)}}(t)}}function U(t){switch(t.pointerType){case"mouse":case"pen":!function(t){if(n.domElement.ownerDocument.removeEventListener("pointermove",B),n.domElement.ownerDocument.removeEventListener("pointerup",U),!1===n.enabled)return;n.dispatchEvent(s),a=o.NONE}()}}function V(t){!1===n.enabled||!1===n.enableZoom||a!==o.NONE&&a!==o.ROTATE||(t.preventDefault(),t.stopPropagation(),n.dispatchEvent(r),function(t){t.deltaY<0?I(k()):t.deltaY>0&&$(k()),n.update()}(t),n.dispatchEvent(s))}function W(t){!1!==n.enabled&&!1!==n.enablePan&&function(t){var e=!1;switch(t.keyCode){case n.keys.UP:M(0,n.keyPanSpeed),e=!0;break;case n.keys.BOTTOM:M(0,-n.keyPanSpeed),e=!0;break;case n.keys.LEFT:M(n.keyPanSpeed,0),e=!0;break;case n.keys.RIGHT:M(-n.keyPanSpeed,0),e=!0}e&&(t.preventDefault(),n.update())}(t)}function H(t){if(!1!==n.enabled){switch(t.preventDefault(),t.touches.length){case 1:switch(n.touches.ONE){case Ykt.ROTATE:if(!1===n.enableRotate)return;R(t),a=o.TOUCH_ROTATE;break;case Ykt.PAN:if(!1===n.enablePan)return;P(t),a=o.TOUCH_PAN;break;default:a=o.NONE}break;case 2:switch(n.touches.TWO){case Ykt.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(t){n.enableZoom&&O(t),n.enablePan&&P(t)}(t),a=o.TOUCH_DOLLY_PAN;break;case Ykt.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(t){n.enableZoom&&O(t),n.enableRotate&&R(t)}(t),a=o.TOUCH_DOLLY_ROTATE;break;default:a=o.NONE}break;default:a=o.NONE}a!==o.NONE&&n.dispatchEvent(r)}}function j(t){if(!1!==n.enabled)switch(t.preventDefault(),t.stopPropagation(),a){case o.TOUCH_ROTATE:if(!1===n.enableRotate)return;L(t),n.update();break;case o.TOUCH_PAN:if(!1===n.enablePan)return;D(t),n.update();break;case o.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(t){n.enableZoom&&F(t),n.enablePan&&D(t)}(t),n.update();break;case o.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(t){n.enableZoom&&F(t),n.enableRotate&&L(t)}(t),n.update();break;default:a=o.NONE}}function G(t){!1!==n.enabled&&(n.dispatchEvent(s),a=o.NONE)}function q(t){!1!==n.enabled&&t.preventDefault()}n.domElement.addEventListener("contextmenu",q),n.domElement.addEventListener("pointerdown",z),n.domElement.addEventListener("wheel",V),n.domElement.addEventListener("touchstart",H),n.domElement.addEventListener("touchend",G),n.domElement.addEventListener("touchmove",j),this.update()};(NDt.prototype=Object.create(H_t.prototype)).constructor=NDt;var RDt=function(t,e){NDt.call(this,t,e),this.screenSpacePanning=!1,this.mouseButtons.LEFT=Kkt.PAN,this.mouseButtons.RIGHT=Kkt.ROTATE,this.touches.ONE=Ykt.PAN,this.touches.TWO=Ykt.DOLLY_ROTATE};(RDt.prototype=Object.create(H_t.prototype)).constructor=RDt;var PDt=Ei(Object.freeze({__proto__:null,MapControls:RDt,OrbitControls:NDt})),ODt={};!function(t){Object.defineProperty(t,"__esModule",{value:!0});var e,n=function(t,e,n,i,r,s,o){this.pointIndices=t,this.labelStrings=e,this.scaleFactors=n,this.useSceneOpacityFlags=i,this.defaultFontSize=r,this.fillColors=s,this.strokeColors=o};t.LabelRenderParams=n,(e=t.CameraType||(t.CameraType={}))[e.Perspective=0]="Perspective",e[e.Orthographic=1]="Orthographic";var i=function(t,e,n,i,r,s,o,a,l,c,u,h,d,p){this.camera=t,this.cameraType=e,this.cameraTarget=n,this.screenWidth=i,this.screenHeight=r,this.nearestCameraSpacePointZ=s,this.farthestCameraSpacePointZ=o,this.backgroundColor=a,this.pointColors=l,this.pointScaleFactors=c,this.labels=u,this.polylineColors=h,this.polylineOpacities=d,this.polylineWidths=p};t.RenderContext=i}(ODt);var LDt={};Object.defineProperty(LDt,"__esModule",{value:!0});var DDt=ADt;function FDt(t,e){return void 0===e&&(e=!0),t.needsUpdate=e,t.minFilter=DDt.LinearFilter,t.generateMipmaps=!1,t.flipY=!1,t}LDt.vector3DToScreenCoords=function(t,e,n,i){var r=window.devicePixelRatio,s=(new DDt.Vector3).copy(i).project(t);return[(s.x+1)/2*e*r,-(s.y-1)/2*n*r]},LDt.vector3FromPackedArray=function(t,e){var n=3*e;return new DDt.Vector3(t[n],t[n+1],t[n+2])},LDt.getNearFarPoints=function(t,e,n){for(var i=1/0,r=0,s=(new DDt.Vector3).copy(n).sub(e),o=(new DDt.Vector3).copy(s).normalize(),a=t.length/3,l=0,c=new DDt.Vector3,u=new DDt.Vector3,h=0;h<a;h++){c.x=t[l],c.y=t[l+1],c.z=t[l+2],l+=3,u.copy(c).sub(e);var d=o.dot(u);d<0||(r=d>r?d:r,i=d<i?d:i)}return[i,r]},LDt.createTextureFromCanvas=function(t){return FDt(new DDt.Texture(t))},LDt.createTextureFromImage=function(t,e){var n=new DDt.Texture(t);return t.complete?(n.needsUpdate=!0,e()):t.onload=function(){n.needsUpdate=!0,e()},FDt(n,!1)},LDt.hasWebGLSupport=function(){try{var t=document.createElement("canvas");return null!=(t.getContext("webgl")||t.getContext("experimental-webgl"))}catch(t){return!1}},LDt.extent=function(t){for(var e=1/0,n=-1/0,i=0;i<t.length;i++){var r=t[i];r<e&&(e=r),r>n&&(n=r)}return[e,n]},LDt.scaleLinear=function(t,e,n){var i=e[1]-e[0],r=n[1]-n[0];return(t-e[0])/i*r+n[0]},LDt.scaleExponential=function(t,e,n){var i=Math.pow(e[1],Math.E)-Math.pow(e[0],Math.E),r=n[1]-n[0];return(Math.pow(t,Math.E)-e[0])/i*r+n[0]},LDt.packRgbIntoUint8Array=function(t,e,n,i,r){t[3*e]=n,t[3*e+1]=i,t[3*e+2]=r},LDt.styleRgbFromHexColor=function(t){var e=new DDt.Color(t);return[255*e.r|0,255*e.g|0,255*e.b|0]};var zDt=function(t){return 100*t+"%"};LDt.getDefaultPointInPolylineColor=function(t,e,n,i,r,s){var o="hsl("+(n+(i-n)*t/e)+", "+zDt(r)+", "+zDt(s)+")";return new DDt.Color(o)};var BDt={};Object.defineProperty(BDt,"__esModule",{value:!0});var UDt=function(){function t(t,e,n){this.startCoordinates=[0,0],this.svgElement=document.createElementNS("http://www.w3.org/2000/svg","svg"),this.svgElement.style.display="none",this.svgElement.style.height="100%",this.svgElement.style.width="100%",this.svgElement.style.position="absolute",t.insertAdjacentElement("afterbegin",this.svgElement),this.rectElement=document.createElementNS("http://www.w3.org/2000/svg","rect"),this.rectElement.style.stroke=n.select.stroke,this.rectElement.style.strokeDasharray=n.select.strokeDashArray,this.rectElement.style.strokeWidth=""+n.select.strokeWidth,this.rectElement.style.fill=n.select.fill,this.rectElement.style.fillOpacity=""+n.select.fillOpacity,this.svgElement.appendChild(this.rectElement),this.selectionCallback=e,this.isMouseDown=!1}return t.prototype.onMouseDown=function(t,e){this.isMouseDown=!0,this.rectElement.style.display="block",this.svgElement.style.display="block",this.startCoordinates=[t,e],this.lastBoundingBox={x:this.startCoordinates[0],y:this.startCoordinates[1],width:1,height:1}},t.prototype.onMouseMove=function(t,e){this.isMouseDown&&(this.lastBoundingBox.x=Math.min(t,this.startCoordinates[0]),this.lastBoundingBox.y=Math.max(e,this.startCoordinates[1]),this.lastBoundingBox.width=Math.max(t,this.startCoordinates[0])-this.lastBoundingBox.x,this.lastBoundingBox.height=this.lastBoundingBox.y-Math.min(e,this.startCoordinates[1]),this.rectElement.setAttribute("x",""+this.lastBoundingBox.x),this.rectElement.setAttribute("y",""+(this.lastBoundingBox.y-this.lastBoundingBox.height)),this.rectElement.setAttribute("width",""+this.lastBoundingBox.width),this.rectElement.setAttribute("height",""+this.lastBoundingBox.height))},t.prototype.onMouseUp=function(){this.isMouseDown=!1,this.svgElement.style.display="none",this.rectElement.style.display="none",this.rectElement.setAttribute("width","0"),this.rectElement.setAttribute("height","0"),this.selectionCallback(this.lastBoundingBox)},t}();BDt.ScatterPlotRectangleSelector=UDt;var VDt=Ti&&Ti.__assign||function(){return VDt=Object.assign||function(t){for(var e,n=1,i=arguments.length;n<i;n++)for(var r in e=arguments[n])Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t},VDt.apply(this,arguments)},WDt=Ti&&Ti.__read||function(t,e){var n="function"==typeof Symbol&&t[Symbol.iterator];if(!n)return t;var i,r,s=n.call(t),o=[];try{for(;(void 0===e||e-- >0)&&!(i=s.next()).done;)o.push(i.value)}catch(t){r={error:t}}finally{try{i&&!i.done&&(n=s.return)&&n.call(s)}finally{if(r)throw r.error}}return o},HDt=Ti&&Ti.__values||function(t){var e="function"==typeof Symbol&&Symbol.iterator,n=e&&t[e],i=0;if(n)return n.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&i>=t.length&&(t=void 0),{value:t&&t[i++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(qkt,"__esModule",{value:!0});var jDt=ADt,GDt=PDt,qDt=ODt,XDt=LDt,KDt=BDt,YDt=1.2,ZDt="Shift",JDt="Control",QDt=new jDt.Vector3(.45,.9,1.6),tFt=new jDt.Vector3(0,0,0),eFt=new jDt.Vector3(0,0,4),nFt=new jDt.Vector3(0,0,0),iFt={mouseRotateSpeed:1,autoRotateSpeed:2,zoomSpeed:.125},rFt=function(){function t(t,e){var n=this;this.clickCallback=function(){},this.hoverCallback=function(){},this.selectCallback=function(){},this.selectEnabled=!0,this.visualizers=new Map,this.onCameraMoveListeners=[],this.height=0,this.width=0,this.dimensions=3,this.interactionMode="PAN",this.pickingTexture=new jDt.WebGLRenderTarget(0,0),this.orbitAnimationOnNextCameraCreation=!1,this.orbitAnimationId=null,this.worldSpacePointPositions=new Float32Array(0),this.pointColors=new Float32Array(0),this.pointScaleFactors=new Float32Array(0),this.polylineColors={},this.polylineOpacities=new Float32Array(0),this.polylineWidths=new Float32Array(0),this.selecting=!1,this.nearestPoint=null,this.mouseIsDown=!1,this.isDragSequence=!1,this.lastHovered=null,this.container=t,this.styles=e.styles,this.setParameters(e),this.computeLayoutValues(),this.scene=new jDt.Scene,this.renderer=new jDt.WebGLRenderer({alpha:!0,premultipliedAlpha:!1,antialias:!1}),this.renderer.setClearColor(this.styles.backgroundColor,1),this.container.appendChild(this.renderer.domElement),this.light=new jDt.PointLight(16772287,1,0),this.scene.add(this.light),this.orbitControlParams=VDt(VDt({},iFt),e.orbitControlParams),this.rectangleSelector=new KDt.ScatterPlotRectangleSelector(this.container,(function(t){n.selectBoundingBox(t)}),this.styles),this.addInteractionListeners(),this.setDimensions(3),this.makeCamera(e.camera),this.resize()}return t.prototype.setParameters=function(t){void 0!==t.onClick&&(this.clickCallback=t.onClick),void 0!==t.onHover&&(this.hoverCallback=t.onHover),void 0!==t.onSelect&&(this.selectCallback=t.onSelect),void 0!==t.selectEnabled&&(this.selectEnabled=t.selectEnabled)},t.prototype.addInteractionListeners=function(){this.container.addEventListener("pointermove",this.onMouseMove.bind(this)),this.container.addEventListener("pointerdown",this.onMouseDown.bind(this)),this.container.addEventListener("pointerup",this.onMouseUp.bind(this)),this.container.addEventListener("click",this.onClick.bind(this)),window.addEventListener("keydown",this.onKeyDown.bind(this),!1),window.addEventListener("keyup",this.onKeyUp.bind(this),!1)},t.prototype.addCameraControlsEventListeners=function(t){var e=this;t.addEventListener("start",(function(){e.stopOrbitAnimation(),e.onCameraMoveListeners.forEach((function(n){return n(e.camera.position,t.target)}))})),t.addEventListener("change",(function(){e.render()})),t.addEventListener("end",(function(){}))},t.prototype.makeOrbitControls=function(t,e){null!=this.orbitCameraControls&&this.orbitCameraControls.dispose();var n=new GDt.OrbitControls(t,this.renderer.domElement);n.zoomSpeed=this.orbitControlParams.zoomSpeed,n.enableRotate=e,n.autoRotate=!1,n.enableKeys=!1,n.rotateSpeed=this.orbitControlParams.mouseRotateSpeed,e?(n.mouseButtons.LEFT=jDt.MOUSE.LEFT,n.mouseButtons.RIGHT=jDt.MOUSE.RIGHT):(n.mouseButtons.LEFT=jDt.MOUSE.RIGHT,n.mouseButtons.RIGHT=jDt.MOUSE.LEFT),n.reset(),this.camera=t,this.orbitCameraControls=n,this.addCameraControlsEventListeners(this.orbitCameraControls)},t.prototype.makeCamera=function(t){void 0===t&&(t={});var e=this.makeDefaultCameraDef(this.dimensions,t);this.recreateCamera(e),3===this.dimensions&&this.styles.axesVisible?this.add3dAxes():this.remove3dAxesFromScene()},t.prototype.makeCamera3D=function(t,e,n){var i,r=e/n;(i=new jDt.PerspectiveCamera(70,r,.01,100)).position.set(t.position[0],t.position[1],t.position[2]);var s=new jDt.Vector3(t.target[0],t.target[1],t.target[2]);i.lookAt(s),i.zoom=t.zoom,i.updateProjectionMatrix(),this.camera=i,this.makeOrbitControls(i,!0)},t.prototype.makeCamera2D=function(t,e,n){var i,r=new jDt.Vector3(t.target[0],t.target[1],t.target[2]),s=e/n,o=-1.2,a=YDt,l=-1.2,c=YDt;s>1?(o*=s,a*=s):(c/=s,l/=s),(i=new jDt.OrthographicCamera(o,a,c,l,-1e3,1e3)).position.set(t.position[0],t.position[1],t.position[2]),i.up=new jDt.Vector3(0,0,1),i.lookAt(r),i.zoom=t.zoom,i.updateProjectionMatrix(),this.camera=i,this.makeOrbitControls(i,!1)},t.prototype.makeDefaultCameraDef=function(t,e){void 0===e&&(e={});var n=2===t,i=n?eFt:QDt,r=n?nFt:tFt,s={orthographic:n,zoom:1,position:[i.x,i.y,i.z],target:[r.x,r.y,r.z]};return e.zoom&&(s.zoom=e.zoom),e.position&&(s.position=e.position),e.target&&(s.target=e.target),s},t.prototype.recreateCamera=function(t){t.orthographic?this.makeCamera2D(t,this.width,this.height):this.makeCamera3D(t,this.width,this.height),this.orbitCameraControls.minDistance=.05,this.orbitCameraControls.maxDistance=10,this.orbitCameraControls.update(),this.orbitAnimationOnNextCameraCreation&&this.startOrbitAnimation()},t.prototype.setInteractionMode=function(t){this.interactionMode=t,"SELECT"===t?(this.selecting=!0,this.container.style.cursor="crosshair",this.orbitCameraControls.enabled=!1):(this.selecting=!1,this.container.style.cursor="default",this.orbitCameraControls.enabled=!0)},t.prototype.onClick=function(t,e){if(void 0===e&&(e=!0),!t||!this.selecting){if(!this.isDragSequence&&e){if(this.selectEnabled){var n=null!=this.nearestPoint?[this.nearestPoint]:[];this.selectCallback(n)}this.clickCallback(this.nearestPoint)}this.isDragSequence=!1,this.render()}},t.prototype.onMouseDown=function(t){this.isDragSequence=!1,this.mouseIsDown=!0,this.selecting?(this.rectangleSelector.onMouseDown(t.offsetX,t.offsetY),this.setNearestPointToMouse(t)):!t.ctrlKey&&this.sceneIs3D()&&this.orbitCameraControls.mouseButtons.ORBIT===jDt.MOUSE.RIGHT?(this.orbitCameraControls.mouseButtons.ORBIT=jDt.MOUSE.LEFT,this.orbitCameraControls.mouseButtons.PAN=jDt.MOUSE.RIGHT):t.ctrlKey&&this.sceneIs3D()&&this.orbitCameraControls.mouseButtons.ORBIT===jDt.MOUSE.LEFT&&(this.orbitCameraControls.mouseButtons.ORBIT=jDt.MOUSE.RIGHT,this.orbitCameraControls.mouseButtons.PAN=jDt.MOUSE.LEFT)},t.prototype.onMouseUp=function(t){this.selecting&&(this.rectangleSelector.onMouseUp(),this.render()),this.mouseIsDown=!1},t.prototype.onMouseMove=function(t){this.isDragSequence=this.mouseIsDown,this.selecting&&this.mouseIsDown?(this.rectangleSelector.onMouseMove(t.offsetX,t.offsetY),this.render()):this.mouseIsDown||(this.setNearestPointToMouse(t),this.nearestPoint!=this.lastHovered&&(this.lastHovered=this.nearestPoint,this.hoverCallback(this.nearestPoint)))},t.prototype.onKeyDown=function(t){t.key===JDt&&this.sceneIs3D()&&(this.orbitCameraControls.mouseButtons.ORBIT=jDt.MOUSE.RIGHT,this.orbitCameraControls.mouseButtons.PAN=jDt.MOUSE.LEFT),t.key===ZDt&&this.selectEnabled&&(this.selecting=!0,this.orbitCameraControls.enabled=!1,this.container.style.cursor="crosshair")},t.prototype.onKeyUp=function(t){t.key===JDt&&this.sceneIs3D()&&(this.orbitCameraControls.mouseButtons.ORBIT=jDt.MOUSE.LEFT,this.orbitCameraControls.mouseButtons.PAN=jDt.MOUSE.RIGHT),t.key===ZDt&&this.selectEnabled&&(this.selecting=!1,this.orbitCameraControls.enabled=!0,this.container.style.cursor="default",this.render())},t.prototype.getPointIndicesFromBoundingBox=function(t){if(null==this.worldSpacePointPositions)return[];this.camera.updateMatrixWorld();var e=window.devicePixelRatio||1,n=Math.floor(t.x*e),i=Math.floor(t.y*e),r=Math.max(Math.floor(t.width*e),1),s=Math.max(Math.floor(t.height*e),1);if(r<=2&&s<=2)return this.getPointIndicesFromBoundingBoxPickingTexture(t);for(var o=this.renderer.domElement,a=o.width,l=o.height,c=[],u=new jDt.Vector3,h=0;h<this.worldSpacePointPositions.length;h++){var d=3*h,p=WDt(this.worldSpacePointPositions.slice(d,d+3),3),f=p[0],m=p[1],g=p[2];u.x=f,u.y=m,u.z=g;var y=u.project(this.camera),b=(y.x+1)*a/2,v=-(y.y-1)*l/2;b>=n&&b<=n+r&&v<=i&&v>=i-s&&c.push(h)}return c},t.prototype.getPointIndicesFromBoundingBoxPickingTexture=function(t){if(null==this.worldSpacePointPositions)return[];var e=this.worldSpacePointPositions.length/3,n=window.devicePixelRatio||1,i=Math.floor(t.x*n),r=Math.floor(t.y*n),s=Math.max(Math.floor(t.width*n),1),o=Math.max(Math.floor(t.height*n),1),a=new Uint8Array(s*o*4);this.renderer.readRenderTargetPixels(this.pickingTexture,i,this.pickingTexture.height-r,s,o,a);for(var l=new Uint8Array(this.worldSpacePointPositions.length),c=0;c<s*o;c++){var u=a[4*c]<<16|a[4*c+1]<<8|a[4*c+2];16777215!==u&&u<e&&(l[u]=1)}var h=[];for(c=0;c<l.length;c++)1===l[c]&&h.push(c);return h},t.prototype.selectBoundingBox=function(t){var e=this.getPointIndicesFromBoundingBox(t);this.selectCallback(e)},t.prototype.setNearestPointToMouse=function(t){if(null!=this.pickingTexture){var e={x:t.offsetX,y:t.offsetY,width:1,height:1},n=this.getPointIndicesFromBoundingBoxPickingTexture(e);this.nearestPoint=n.length?n[0]:null}else this.nearestPoint=null},t.prototype.computeLayoutValues=function(){return this.width=this.container.offsetWidth,this.height=Math.max(1,this.container.offsetHeight),[this.width,this.height]},t.prototype.sceneIs3D=function(){return 3===this.dimensions},t.prototype.remove3dAxesFromScene=function(){var t=this.scene.getObjectByName("axes");return null!=t&&this.scene.remove(t),t},t.prototype.add3dAxes=function(){var t=new jDt.AxesHelper;t.name="axes",this.scene.add(t)},t.prototype.setDimensions=function(t){if(2!==t&&3!==t)throw new RangeError("dimensions must be 2 or 3");this.dimensions!==t&&(this.dimensions=t,this.makeCamera())},t.prototype.getCameraPosition=function(){var t=this.camera.position;return[t.x,t.y,t.z]},t.prototype.getCameraTarget=function(){var t=this.orbitCameraControls.target;return[t.x,t.y,t.z]},t.prototype.setCameraPositionAndTarget=function(t,e){this.stopOrbitAnimation(),this.camera.position.set(t[0],t[1],t[2]),this.orbitCameraControls.target.set(e[0],e[1],e[2]),this.orbitCameraControls.update(),this.render()},t.prototype.startOrbitAnimation=function(){this.sceneIs3D()&&(null!=this.orbitAnimationId&&this.stopOrbitAnimation(),this.orbitCameraControls.autoRotate=!0,this.orbitCameraControls.autoRotateSpeed=this.orbitControlParams.autoRotateSpeed,this.updateOrbitAnimation())},t.prototype.orbitIsAnimating=function(){return null!=this.orbitAnimationId},t.prototype.updateOrbitAnimation=function(){var t=this;this.orbitCameraControls.update(),this.orbitAnimationId=requestAnimationFrame((function(){return t.updateOrbitAnimation()}))},t.prototype.stopOrbitAnimation=function(){this.orbitCameraControls.autoRotate=!1,this.orbitCameraControls.rotateSpeed=this.orbitControlParams.mouseRotateSpeed,null!=this.orbitAnimationId&&(cancelAnimationFrame(this.orbitAnimationId),this.orbitAnimationId=null)},t.prototype.setActiveVisualizers=function(t){var e,n,i,r,s=new Set(t.map((function(t){return t.id})));try{for(var o=HDt(this.visualizers.values()),a=o.next();!a.done;a=o.next()){var l=a.value;s.has(l.id)||(l.dispose(),this.visualizers.delete(l.id))}}catch(t){e={error:t}}finally{try{a&&!a.done&&(n=o.return)&&n.call(o)}finally{if(e)throw e.error}}try{for(var c=HDt(t),u=c.next();!u.done;u=c.next()){l=u.value;this.visualizers.set(l.id,l),l.setScene(this.scene),l.onResize(this.width,this.height),this.worldSpacePointPositions&&l.onPointPositionsChanged(this.worldSpacePointPositions)}}catch(t){i={error:t}}finally{try{u&&!u.done&&(r=c.return)&&r.call(c)}finally{if(i)throw i.error}}},t.prototype.disposeAllVisualizers=function(){this.visualizers.forEach((function(t){return t.dispose()})),this.visualizers.clear()},t.prototype.setPointPositions=function(t){this.worldSpacePointPositions=t,this.visualizers.forEach((function(e){return e.onPointPositionsChanged(t)}))},t.prototype.render=function(){var t=this.camera.position.clone();t.x+=1,t.y+=1,this.light.position.set(t.x,t.y,t.z);var e=this.camera instanceof jDt.PerspectiveCamera?qDt.CameraType.Perspective:qDt.CameraType.Orthographic,n=[0,0];null!=this.worldSpacePointPositions&&(n=XDt.getNearFarPoints(this.worldSpacePointPositions,this.camera.position,this.orbitCameraControls.target));var i=new qDt.RenderContext(this.camera,e,this.orbitCameraControls.target,this.width,this.height,n[0],n[1],this.styles.backgroundColor,this.pointColors,this.pointScaleFactors,this.labels,this.polylineColors,this.polylineOpacities,this.polylineWidths);this.visualizers.forEach((function(t){return t.onPickingRender(i)}));var r=this.remove3dAxesFromScene();this.renderer.setRenderTarget(this.pickingTexture),this.renderer.render(this.scene,this.camera),null!=r&&this.scene.add(r),this.visualizers.forEach((function(t){return t.onRender(i)})),this.renderer.setRenderTarget(null),this.renderer.render(this.scene,this.camera)},t.prototype.setPointColors=function(t){this.pointColors=t},t.prototype.setPointScaleFactors=function(t){this.pointScaleFactors=t},t.prototype.setLabels=function(t){this.labels=t},t.prototype.setPolylineColors=function(t){this.polylineColors=t},t.prototype.setPolylineOpacities=function(t){this.polylineOpacities=t},t.prototype.setPolylineWidths=function(t){this.polylineWidths=t},t.prototype.resetZoom=function(){this.recreateCamera(this.makeDefaultCameraDef(this.dimensions)),this.render()},t.prototype.setDayNightMode=function(t){for(var e=this.container.querySelectorAll("canvas"),n=t?"invert(100%)":"",i=0;i<e.length;i++)e[i].style.filter=n},t.prototype.resize=function(t){void 0===t&&(t=!0);var e=WDt([this.width,this.height],2),n=e[0],i=e[1],r=WDt(this.computeLayoutValues(),2),s=r[0],o=r[1];if(3===this.dimensions){(a=this.camera).aspect=s/o,a.updateProjectionMatrix()}else{var a=this.camera,l=s/n,c=o/i,u=(a.right-a.left)*l/2,h=(a.top-a.bottom)*c/2;a.top=h,a.bottom=-h,a.left=-u,a.right=u,a.updateProjectionMatrix()}var d=window.devicePixelRatio||1;this.renderer.setPixelRatio(d),this.renderer.setSize(s,o);var p=new jDt.Vector2;this.renderer.getSize(p);var f=this.renderer.getPixelRatio();this.pickingTexture=new jDt.WebGLRenderTarget(p.width*f,p.height*f),this.pickingTexture.texture.minFilter=jDt.LinearFilter,this.visualizers.forEach((function(t){return t.onResize(s,o)})),t&&this.render()},t.prototype.onCameraMove=function(t){this.onCameraMoveListeners.push(t)},t.prototype.clickOnPoint=function(t){this.nearestPoint=t,this.onClick(null,!1)},t}();qkt.ScatterPlot=rFt;var sFt={},oFt=Ti&&Ti.__read||function(t,e){var n="function"==typeof Symbol&&t[Symbol.iterator];if(!n)return t;var i,r,s=n.call(t),o=[];try{for(;(void 0===e||e-- >0)&&!(i=s.next()).done;)o.push(i.value)}catch(t){r={error:t}}finally{try{i&&!i.done&&(n=s.return)&&n.call(s)}finally{if(r)throw r.error}}return o};Object.defineProperty(sFt,"__esModule",{value:!0});var aFt=ADt,lFt=new Map,cFt=/^(rgba|hsla)\((\d+),\s*(\d+%?),\s*(\d+%?)(?:,\s*(\d+(?:\.\d+)?))?\)$/;sFt.parseColor=function(t){if(lFt.has(t))return lFt.get(t);var e=function(t){var e=cFt.exec(t);if(e){var n=oFt(e,6);n[0];var i=n[1],r=n[2],s=n[3],o=n[4],a=n[5];return{colorString:i.replace("a","")+"("+r+","+s+","+o+")",opacity:parseFloat(a)}}return{colorString:t,opacity:1}}(t),n=e.colorString,i=e.opacity,r=new aFt.Color(n),s={r:r.r,g:r.g,b:r.b,opacity:i};return lFt.set(t,s),s};var uFt={},hFt=Ti&&Ti.__values||function(t){var e="function"==typeof Symbol&&Symbol.iterator,n=e&&t[e],i=0;if(n)return n.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&i>=t.length&&(t=void 0),{value:t&&t[i++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(uFt,"__esModule",{value:!0});var dFt="Points must be an array of either 2 or 3 dimensional number arrays",pFt=function(){function t(t,e){var n,i;void 0===e&&(e=[]),this.points=t,this.metadata=e;var r=t[0].length;if(2!==r&&3!==r)throw new Error(dFt);try{for(var s=hFt(t),o=s.next();!o.done;o=s.next()){if(r!==o.value.length)throw new Error(dFt)}}catch(t){n={error:t}}finally{try{o&&!o.done&&(i=s.return)&&i.call(s)}finally{if(n)throw n.error}}this.dimensions=r}return t.prototype.setSpriteMetadata=function(t){this.spriteMetadata=t},t}();uFt.Dataset=pFt;var fFt={};Object.defineProperty(fFt,"__esModule",{value:!0});fFt.makeStyles=function(t){var e={backgroundColor:"#ffffff",axesVisible:!0,fog:{color:"#ffffff",enabled:!0,threshold:5e3},label:{fontSize:10,scaleDefault:1,scaleLarge:2,fillColorSelected:"#000000",fillColorHover:"#000000",strokeColorSelected:"#ffffff",strokeColorHover:"#ffffff",strokeWidth:3,fillWidth:6},label3D:{fontSize:80,scale:2.2,color:"black",backgroundColor:"#ffffff",colorUnselected:"#ffffff",colorNoSelection:"#ffffff"},point:{colorUnselected:"rgba(227, 227, 227, 0.7)",colorNoSelection:"rgba(117, 117, 217, 0.7)",colorSelected:"rgba(250, 102, 102, 0.7)",colorHover:"rgba(118, 11, 79, 0.7)",scaleDefault:1,scaleSelected:1.2,scaleHover:1.2},polyline:{startHue:60,endHue:360,saturation:1,lightness:.3,defaultOpacity:.2,defaultLineWidth:2,selectedOpacity:.9,selectedLineWidth:3,deselectedOpacity:.05},select:{fill:"#dddddd",fillOpacity:.2,stroke:"#aaaaaa",strokeWidth:2,strokeDashArray:"10 5"},sprites:{minPointSize:5,imageSize:30,colorUnselected:"#ffffff",colorNoSelection:"#ffffff"}};if(void 0===t)return e;for(var n in e){var i=n;"object"==typeof e[i]&&"object"==typeof t[i]?e[i]=Object.assign(e[i],t[i]):void 0!==t[i]&&(e[i]=t[i])}return e};var mFt={};Object.defineProperty(mFt,"__esModule",{value:!0}),mFt.RGB_NUM_ELEMENTS=3,mFt.RGBA_NUM_ELEMENTS=4,mFt.XYZ_NUM_ELEMENTS=3,mFt.UV_NUM_ELEMENTS=2,mFt.INDEX_NUM_ELEMENTS=1,mFt.SCATTER_PLOT_CUBE_LENGTH=2;var gFt={};Object.defineProperty(gFt,"__esModule",{value:!0});var yFt=ADt,bFt=LDt,vFt=mFt,xFt=8192,wFt=function(t,e){return"\n      attribute vec2 posObj;\n      attribute vec4 color;\n      varying vec2 vUv;\n      varying vec4 vColor;\n\n      void main() {\n        vUv = uv;\n        vColor = color;\n\n        // Rotate label to face camera.\n\n        vec4 vRight = vec4(\n          modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0], 0);\n\n        vec4 vUp = vec4(\n          modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1], 0);\n\n        vec4 vAt = -vec4(\n          modelViewMatrix[0][2], modelViewMatrix[1][2], modelViewMatrix[2][2], 0);\n\n        mat4 pointToCamera = mat4(vRight, vUp, vAt, vec4(0, 0, 0, 1));\n\n        vec2 scaledPos = posObj * "+1/t+" * "+e+";\n\n        vec4 posRotated = pointToCamera * vec4(scaledPos, 0, 1);\n        vec4 mvPosition = modelViewMatrix * (vec4(position, 0) + posRotated);\n        gl_Position = projectionMatrix * mvPosition;\n      }"},SFt=function(){function t(t){this.styles=t,this.id="3D_LABELS",this.labelStrings=[],this.worldSpacePointPositions=new Float32Array(0),this.pickingColors=new Float32Array(0),this.renderColors=new Float32Array(0),this.uniforms={},this.totalVertexCount=0,this.labelVertexMap=[]}return t.prototype.createGlyphTexture=function(){var t=this.styles.label3D,e=t.fontSize,n=t.backgroundColor,i=t.color,r=document.createElement("canvas");r.width=xFt,r.height=e;var s=r.getContext("2d");s.font="bold "+e+"px roboto",s.textBaseline="top",s.fillStyle=n,s.rect(0,0,r.width,r.height),s.fill(),s.fillStyle=i;for(var o=s.measureText(" ").width,a=new Float32Array(256),l=new Float32Array(256),c=0,u=0;u<256;u++){var h=" "+String.fromCharCode(u),d=s.measureText(h).width;a[u]=d-o,l[u]=c,s.fillText(h,c-o,0),c+=d}return{texture:bFt.createTextureFromCanvas(r),lengths:a,offsets:l}},t.prototype.processLabelVerts=function(t){var e=0;this.labelVertexMap=[];for(var n=0;n<t;n++){for(var i=this.labelStrings[n],r=[],s=0;s<i.length;s++){for(var o=0;o<6;o++)r.push(6*e+o);e++}this.labelVertexMap.push(r)}this.totalVertexCount=6*e},t.prototype.createColorBuffers=function(t){var e=this;this.pickingColors=new Float32Array(this.totalVertexCount*vFt.RGB_NUM_ELEMENTS),this.renderColors=new Float32Array(this.totalVertexCount*vFt.RGB_NUM_ELEMENTS);for(var n=function(t){var n=new yFt.Color(t);i.labelVertexMap[t].forEach((function(t){e.pickingColors[vFt.RGB_NUM_ELEMENTS*t]=n.r,e.pickingColors[vFt.RGB_NUM_ELEMENTS*t+1]=n.g,e.pickingColors[vFt.RGB_NUM_ELEMENTS*t+2]=n.b,e.renderColors[vFt.RGB_NUM_ELEMENTS*t]=1,e.renderColors[vFt.RGB_NUM_ELEMENTS*t+1]=1,e.renderColors[vFt.RGB_NUM_ELEMENTS*t+2]=1}))},i=this,r=0;r<t;r++)n(r)},t.prototype.createLabels=function(){var t=this,e=this.styles.label3D,n=e.fontSize,i=e.scale;if(null!=this.labelStrings&&null!=this.worldSpacePointPositions){var r=this.worldSpacePointPositions.length/vFt.XYZ_NUM_ELEMENTS;if(r===this.labelStrings.length){this.glyphTexture=this.createGlyphTexture(),this.uniforms={glyphTexture:{value:null},picking:{value:!1}},this.material=new yFt.ShaderMaterial({uniforms:this.uniforms,transparent:!0,vertexShader:wFt(n,i),fragmentShader:"\n      uniform sampler2D glyphTexture;\n      uniform bool picking;\n      varying vec2 vUv;\n      varying vec4 vColor;\n\n      void main() {\n        if (picking) {\n          gl_FragColor = vColor;\n        } else {\n          vec4 fromTexture = texture(glyphTexture, vUv);\n          gl_FragColor = vColor * fromTexture;\n        }\n      }"}),this.processLabelVerts(r),this.createColorBuffers(r);var s=new Float32Array(this.totalVertexCount*vFt.XYZ_NUM_ELEMENTS);this.positions=new yFt.BufferAttribute(s,vFt.XYZ_NUM_ELEMENTS);var o=new Float32Array(this.totalVertexCount*vFt.XYZ_NUM_ELEMENTS),a=new Float32Array(this.totalVertexCount*vFt.UV_NUM_ELEMENTS),l=new Float32Array(this.totalVertexCount*vFt.RGB_NUM_ELEMENTS),c=new yFt.BufferAttribute(o,2),u=new yFt.BufferAttribute(a,vFt.UV_NUM_ELEMENTS),h=new yFt.BufferAttribute(l,vFt.RGB_NUM_ELEMENTS);this.geometry=new yFt.BufferGeometry,this.geometry.setAttribute("posObj",c),this.geometry.setAttribute("position",this.positions),this.geometry.setAttribute("uv",u),this.geometry.setAttribute("color",h);for(var d=0,p=0;p<r;p++){for(var f=this.labelStrings[p],m=0,g=0;g<f.length;g++){var y=f.charCodeAt(g);m+=this.glyphTexture.lengths[y]}m/=-2;for(g=0;g<f.length;g++){y=f.charCodeAt(g);var b=this.glyphTexture.lengths[y],v=(m+b)/n,x=m/n,w=n/n;c.setXY(6*d+0,x,0),c.setXY(6*d+1,v,0),c.setXY(6*d+2,x,w),c.setXY(6*d+3,x,w),c.setXY(6*d+4,v,0),c.setXY(6*d+5,v,w);var S=this.glyphTexture.offsets[y],k=this.glyphTexture.offsets[y]+b;S/=xFt,k/=xFt;u.setXY(6*d+0,S,1),u.setXY(6*d+1,k,1),u.setXY(6*d+2,S,0),u.setXY(6*d+3,S,0),u.setXY(6*d+4,k,1),u.setXY(6*d+5,k,0),d++,m+=b}}var C=function(e){var n=bFt.vector3FromPackedArray(T.worldSpacePointPositions,e);T.labelVertexMap[e].forEach((function(e){t.positions.setXYZ(e,n.x,n.y,n.z)}))},T=this;for(p=0;p<r;p++)C(p);this.labelsMesh=new yFt.Mesh(this.geometry,this.material),this.labelsMesh.frustumCulled=!1,this.scene.add(this.labelsMesh)}}},t.prototype.colorLabels=function(t){if(null!=this.labelStrings&&null!=this.geometry&&null!=t){var e=this.geometry.getAttribute("color");e.array=this.renderColors;for(var n=t.length/vFt.RGBA_NUM_ELEMENTS,i=0,r=0;r<n;++r){for(var s=new yFt.Color(t[i],t[i+1],t[i+2]),o=this.labelVertexMap[r].length,a=0;a<o;++a)e.setXYZ(this.labelVertexMap[r][a],s.r,s.g,s.b);i+=vFt.RGBA_NUM_ELEMENTS}e.needsUpdate=!0}},t.prototype.setScene=function(t){this.scene=t},t.prototype.dispose=function(){this.labelsMesh&&(this.scene&&this.scene.remove(this.labelsMesh),this.labelsMesh=null),this.geometry&&(this.geometry.dispose(),this.geometry=null),null!=this.glyphTexture&&null!=this.glyphTexture.texture&&(this.glyphTexture.texture.dispose(),this.glyphTexture.texture=null)},t.prototype.onPickingRender=function(t){if(null!=this.geometry){this.material.uniforms.glyphTexture.value=this.glyphTexture.texture,this.material.uniforms.picking.value=!0;var e=this.geometry.getAttribute("color");e.array=this.pickingColors,e.needsUpdate=!0}else this.createLabels()},t.prototype.onRender=function(t){if(null!=this.geometry){this.colorLabels(t.pointColors),this.material.uniforms.glyphTexture.value=this.glyphTexture.texture,this.material.uniforms.picking.value=!1;var e=this.geometry.getAttribute("color");e.array=this.renderColors,e.needsUpdate=!0}else this.createLabels()},t.prototype.onPointPositionsChanged=function(t){this.worldSpacePointPositions=t,this.dispose()},t.prototype.setLabelStrings=function(t){this.labelStrings=t,this.dispose()},t.prototype.onResize=function(t,e){},t}();gFt.ScatterPlotVisualizer3DLabels=SFt;var kFt={};Object.defineProperty(kFt,"__esModule",{value:!0});var CFt=ADt,TFt=ODt,_Ft=LDt,EFt=mFt,MFt=function(t){return"\n    // Index of the specific vertex (passed in as bufferAttribute), and the\n    // variable that will be used to pass it to the fragment shader.\n    attribute float spriteIndex;\n    attribute vec4 color;\n    attribute float scaleFactor;\n\n    varying vec2 xyIndex;\n    varying vec4 vColor;\n\n    uniform bool sizeAttenuation;\n    uniform float pointSize;\n    uniform float spritesPerRow;\n    uniform float spritesPerColumn;\n\n    varying float fogDepth;\n\n    void main() {\n      // Pass index and color values to fragment shader.\n      vColor = color;\n      xyIndex = vec2(mod(spriteIndex, spritesPerRow),\n                floor(spriteIndex / spritesPerColumn));\n\n      // Transform current vertex by modelViewMatrix (model world position and\n      // camera world position matrix).\n      vec4 cameraSpacePos = modelViewMatrix * vec4(position, 1.0);\n\n      // Project vertex in camera-space to screen coordinates using the camera's\n      // projection matrix.\n      gl_Position = projectionMatrix * cameraSpacePos;\n\n      // Create size attenuation (if we're in 3D mode) by making the size of\n      // each point inversly proportional to its distance to the camera.\n      float outputPointSize = pointSize;\n      if (sizeAttenuation) {\n        outputPointSize = -pointSize / cameraSpacePos.z;\n        fogDepth = pointSize / outputPointSize * 1.2;\n      } else {  // Create size attenuation (if we're in 2D mode)\n        const float PI = 3.1415926535897932384626433832795;\n        const float minScale = 0.1;  // minimum scaling factor\n        const float outSpeed = 2.0;  // shrink speed when zooming out\n        const float outNorm = (1. - minScale) / atan(outSpeed);\n        const float maxScale = 15.0;  // maximum scaling factor\n        const float inSpeed = 0.02;  // enlarge speed when zooming in\n        const float zoomOffset = 0.3;  // offset zoom pivot\n        float zoom = projectionMatrix[0][0] + zoomOffset;  // zoom pivot\n        float scale = zoom < 1. ? 1. + outNorm * atan(outSpeed * (zoom - 1.)) :\n                      1. + 2. / PI * (maxScale - 1.) * atan(inSpeed * (zoom - 1.));\n        outputPointSize = pointSize * scale;\n      }\n\n      gl_PointSize =\n        max(outputPointSize * scaleFactor, "+t.toFixed(1)+");\n    }"},$Ft="\n    bool point_in_unit_circle(vec2 spriteCoord) {\n      vec2 centerToP = spriteCoord - vec2(0.5, 0.5);\n      return dot(centerToP, centerToP) < (0.5 * 0.5);\n    }\n\n    bool point_in_unit_equilateral_triangle(vec2 spriteCoord) {\n      vec3 v0 = vec3(0, 1, 0);\n      vec3 v1 = vec3(0.5, 0, 0);\n      vec3 v2 = vec3(1, 1, 0);\n      vec3 p = vec3(spriteCoord, 0);\n      float p_in_v0_v1 = cross(v1 - v0, p - v0).z;\n      float p_in_v1_v2 = cross(v2 - v1, p - v1).z;\n      return (p_in_v0_v1 > 0.0) && (p_in_v1_v2 > 0.0);\n    }\n\n    bool point_in_unit_square(vec2 spriteCoord) {\n      return true;\n    }\n  ",IFt="\n    varying vec2 xyIndex;\n    varying vec4 vColor;\n\n    uniform sampler2D spriteTexture;\n    uniform float spritesPerRow;\n    uniform float spritesPerColumn;\n    uniform bool isImage;\n\n    "+CFt.ShaderChunk.common+"\n    "+$Ft+"\n    uniform vec3 fogColor;\n    varying float fogDepth;\n\t\tuniform float fogNear;\n    uniform float fogFar;\n\n    void main() {\n      if (isImage) {\n        // Coordinates of the vertex within the entire sprite image.\n        vec2 coords =\n          (gl_PointCoord + xyIndex) / vec2(spritesPerRow, spritesPerColumn);\n        gl_FragColor = vColor * texture(spriteTexture, coords);\n      } else {\n        bool inside = point_in_unit_circle(gl_PointCoord);\n        if (!inside) {\n          discard;\n        }\n        gl_FragColor = vColor;\n      }\n      float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n      gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n    }",AFt="\n    varying vec2 xyIndex;\n    varying vec4 vColor;\n    uniform bool isImage;\n\n    "+$Ft+"\n\n    varying float fogDepth;\n\n    void main() {\n      xyIndex; // Silence 'unused variable' warning.\n      fogDepth; // Silence 'unused variable' warning.\n      if (isImage) {\n        gl_FragColor = vColor;\n      } else {\n        bool inside = point_in_unit_circle(gl_PointCoord);\n        if (!inside) {\n          discard;\n        }\n        gl_FragColor = vColor;\n      }\n    }",NFt=function(){function t(t,e){this.styles=t,this.id="SPRITES",this.isSpriteSheetMode=!1,this.spritesPerRow=0,this.spritesPerColumn=0,this.spriteDimensions=[0,0],this.worldSpacePointPositions=new Float32Array(0),this.pickingColors=new Float32Array(0),this.renderColors=new Float32Array(0),this.standinTextureForPoints=_Ft.createTextureFromCanvas(document.createElement("canvas")),e&&(this.spriteSheetParams=e,this.setSpriteSheet(e),this.isSpriteSheetMode=!0),this.renderMaterial=this.createRenderMaterial(),this.pickingMaterial=this.createPickingMaterial()}return t.prototype.createUniforms=function(){return{spriteTexture:{type:"t"},spritesPerRow:{type:"f"},spritesPerColumn:{type:"f"},fogColor:{type:"c"},fogNear:{type:"f"},fogFar:{type:"f"},isImage:{type:"bool"},sizeAttenuation:{type:"bool"},pointSize:{type:"f"}}},t.prototype.createRenderMaterial=function(){this.isSpriteSheetMode;var t=this.createUniforms();return new CFt.ShaderMaterial({uniforms:t,vertexShader:MFt(this.styles.sprites.minPointSize),fragmentShader:IFt,transparent:!0,depthFunc:CFt.LessDepth,fog:this.styles.fog.enabled,blending:CFt.NormalBlending})},t.prototype.createPickingMaterial=function(){var t=this.createUniforms();return new CFt.ShaderMaterial({uniforms:t,vertexShader:MFt(this.styles.sprites.minPointSize),fragmentShader:AFt,transparent:!0,depthTest:!0,depthWrite:!0,fog:!1,blending:CFt.NormalBlending})},t.prototype.createPointSprites=function(t,e){var n=null!=e?e.length/EFt.XYZ_NUM_ELEMENTS:0,i=this.createGeometry(n);this.fog=new CFt.Fog(16777215),this.points=new CFt.Points(i,this.renderMaterial),this.points.frustumCulled=!1,null!=this.spriteIndexBufferAttribute&&this.points.geometry.setAttribute("spriteIndex",this.spriteIndexBufferAttribute),t.add(this.points)},t.prototype.calculatePointSize=function(t){var e=this.styles.sprites.imageSize;if(this.texture)return t?e:this.spriteDimensions[0];var n=null!=this.worldSpacePointPositions?this.worldSpacePointPositions.length/EFt.XYZ_NUM_ELEMENTS:1,i=200/Math.log(n)/Math.log(8);return t?i:i/1.5},t.prototype.createGeometry=function(t){var e=t;this.pickingColors=new Float32Array(e*EFt.RGBA_NUM_ELEMENTS);for(var n=0,i=0;i<e;i++){var r=new CFt.Color(i);this.pickingColors[n++]=r.r,this.pickingColors[n++]=r.g,this.pickingColors[n++]=r.b,this.pickingColors[n++]=1}var s=new CFt.BufferGeometry;return s.setAttribute("position",new CFt.BufferAttribute(new Float32Array([]),EFt.XYZ_NUM_ELEMENTS)),s.setAttribute("color",new CFt.BufferAttribute(new Float32Array([]),EFt.RGBA_NUM_ELEMENTS)),s.setAttribute("scaleFactor",new CFt.BufferAttribute(new Float32Array([]),EFt.INDEX_NUM_ELEMENTS)),s.computeVertexNormals(),s},t.prototype.setFogDistances=function(t,e,n){var i=this.styles.fog,r=i.threshold,s=i.enabled;if(t&&s){this.fog.near=e;var o=e-n;this.fog.far=e-r*o}else this.fog.near=1/0,this.fog.far=1/0},t.prototype.dispose=function(){this.disposeGeometry(),this.disposeSpriteSheet()},t.prototype.disposeGeometry=function(){null!=this.points&&(this.scene.remove(this.points),this.points.geometry.dispose(),this.points=null,this.worldSpacePointPositions=null)},t.prototype.disposeSpriteSheet=function(){this.texture&&this.texture.dispose(),this.texture=null,this.renderMaterial=null,this.pickingMaterial=null,this.spriteSheetImage=null},t.prototype.setScene=function(t){this.scene=t},t.prototype.setSpriteSheet=function(t){var e=this,n=t.spriteDimensions,i=t.onImageLoad,r=t.spritesheetImage;if("string"==typeof r){var s=r;(r=new Image).src=s}this.spriteSheetImage=r,this.texture=_Ft.createTextureFromImage(this.spriteSheetImage,(function(){e.spritesPerRow=e.spriteSheetImage.width/n[0],e.spritesPerColumn=e.spriteSheetImage.height/n[1],i()})),this.spriteDimensions=n,this.setSpriteIndexBuffer()},t.prototype.setSpriteIndexBuffer=function(){var t=this.spriteSheetParams.spriteIndices;this.spriteIndexBufferAttribute=new CFt.BufferAttribute(t,EFt.INDEX_NUM_ELEMENTS),null!=this.points&&this.points.geometry.setAttribute("spriteIndex",this.spriteIndexBufferAttribute)},t.prototype.onPointPositionsChanged=function(t){null!=this.points&&this.worldSpacePointPositions.length!==t.length&&this.disposeGeometry(),this.worldSpacePointPositions=t,null==this.points&&this.createPointSprites(this.scene,t),this.spriteSheetParams&&this.setSpriteIndexBuffer(),this.renderMaterial=this.createRenderMaterial(),this.pickingMaterial=this.createPickingMaterial();var e=this.points.geometry.getAttribute("position");e.array=t,e.count=t.length/EFt.XYZ_NUM_ELEMENTS,e.needsUpdate=!0},t.prototype.onPickingRender=function(t){var e=t.cameraType===TFt.CameraType.Perspective;this.pickingMaterial.uniforms.spritesPerRow.value=this.spritesPerRow,this.pickingMaterial.uniforms.spritesPerRow.value=this.spritesPerColumn,this.pickingMaterial.uniforms.sizeAttenuation.value=e,this.pickingMaterial.uniforms.pointSize.value=this.calculatePointSize(e),this.points.material=this.pickingMaterial;var n=this.points.geometry.getAttribute("color");n.array=this.pickingColors,n.count=this.pickingColors.length/EFt.RGBA_NUM_ELEMENTS,n.needsUpdate=!0;var i=this.points.geometry.getAttribute("scaleFactor");i.array=t.pointScaleFactors,i.count=t.pointScaleFactors.length,i.count=t.pointScaleFactors.length/EFt.INDEX_NUM_ELEMENTS,i.needsUpdate=!0},t.prototype.onRender=function(t){var e=t.camera instanceof CFt.PerspectiveCamera;this.setFogDistances(e,t.nearestCameraSpacePointZ,t.farthestCameraSpacePointZ),this.scene.fog=this.fog,this.scene.fog.color=new CFt.Color(t.backgroundColor),this.renderMaterial.uniforms.fogColor.value=this.scene.fog.color,this.renderMaterial.uniforms.fogNear.value=this.fog.near,this.renderMaterial.uniforms.fogFar.value=this.fog.far,this.renderMaterial.uniforms.spritesPerRow.value=this.spritesPerRow,this.renderMaterial.uniforms.spritesPerColumn.value=this.spritesPerColumn,this.renderMaterial.uniforms.isImage.value=null!=this.texture,this.renderMaterial.uniforms.spriteTexture.value=null!=this.texture?this.texture:this.standinTextureForPoints,this.renderMaterial.uniforms.sizeAttenuation.value=e,this.renderMaterial.uniforms.pointSize.value=this.calculatePointSize(e),this.points.material=this.renderMaterial;var n=this.points.geometry.getAttribute("color");this.renderColors=t.pointColors,n.array=this.renderColors,n.count=this.renderColors.length/EFt.RGBA_NUM_ELEMENTS,n.needsUpdate=!0;var i=this.points.geometry.getAttribute("scaleFactor");i.array=t.pointScaleFactors,i.count=t.pointScaleFactors.length/EFt.INDEX_NUM_ELEMENTS,i.needsUpdate=!0},t.prototype.onResize=function(t,e){},t}();kFt.ScatterPlotVisualizerSprites=NFt;var RFt={},PFt={};Object.defineProperty(PFt,"__esModule",{value:!0});var OFt=function(){function t(t,e,n){this.bound=t,this.cellWidth=e,this.cellHeight=n,this.numHorizCells=Math.ceil(this.boundWidth(t)/e),this.numVertCells=Math.ceil(this.boundHeight(t)/n),this.grid=new Array(this.numHorizCells*this.numVertCells)}return t.prototype.boundWidth=function(t){return t.hiX-t.loX},t.prototype.boundHeight=function(t){return t.hiY-t.loY},t.prototype.boundsIntersect=function(t,e){return!(t.loX>e.hiX||t.loY>e.hiY||t.hiX<e.loX||t.hiY<e.loY)},t.prototype.insert=function(t,e){if(void 0===e&&(e=!1),t.hiX<this.bound.loX||t.loX>this.bound.hiX||t.hiY<this.bound.loY||t.loY>this.bound.hiY)return!1;for(var n=this.getCellX(t.loX),i=this.getCellX(t.hiX),r=this.getCellY(t.loY),s=this.getCellY(t.hiY),o=r*this.numHorizCells+n,a=o,l=r;l<=s;l++){for(var c=n;c<=i;c++){var u=this.grid[a++];if(u)for(var h=0;h<u.length;h++)if(this.boundsIntersect(t,u[h]))return!1}a+=this.numHorizCells-(i-n+1)}if(e)return!0;a=o;for(l=r;l<=s;l++){for(c=n;c<=i;c++)this.grid[a]?this.grid[a].push(t):this.grid[a]=[t],a++;a+=this.numHorizCells-(i-n+1)}return!0},t.prototype.getCellX=function(t){return Math.floor((t-this.bound.loX)/this.cellWidth)},t.prototype.getCellY=function(t){return Math.floor((t-this.bound.loY)/this.cellHeight)},t}();PFt.CollisionGrid=OFt;var LFt=Ti&&Ti.__read||function(t,e){var n="function"==typeof Symbol&&t[Symbol.iterator];if(!n)return t;var i,r,s=n.call(t),o=[];try{for(;(void 0===e||e-- >0)&&!(i=s.next()).done;)o.push(i.value)}catch(t){r={error:t}}finally{try{i&&!i.done&&(n=s.return)&&n.call(s)}finally{if(r)throw r.error}}return o};Object.defineProperty(RFt,"__esModule",{value:!0});var DFt=ADt,FFt=ODt,zFt=PFt,BFt=LDt,UFt=function(){function t(t,e){this.styles=e,this.id="CANVAS_LABELS",this.worldSpacePointPositions=new Float32Array(0),this.labelsActive=!0,this.canvas=document.createElement("canvas"),t.appendChild(this.canvas),this.gc=this.canvas.getContext("2d"),this.canvas.style.position="absolute",this.canvas.style.left="0",this.canvas.style.top="0",this.canvas.style.pointerEvents="none"}return t.prototype.removeAllLabels=function(){var t=this.canvas.width*window.devicePixelRatio,e=this.canvas.height*window.devicePixelRatio;this.gc.clearRect(0,0,t,e)},t.prototype.makeLabels=function(t){if(null!=t.labels&&0!==t.labels.pointIndices.length&&null!=this.worldSpacePointPositions){var e,n=t.labels,i=t.cameraType===FFt.CameraType.Perspective,r=parseInt(this.gc.font,10),s=window.devicePixelRatio,o=this.canvas.width*s,a=this.canvas.height*s,l={loX:0,hiX:o,loY:0,hiY:a};e=new zFt.CollisionGrid(l,o/25,a/50);var c=[t.farthestCameraSpacePointZ,t.nearestCameraSpacePointZ],u=function(t){return BFt.scaleExponential(t,c,[.1,1])},h=t.camera.position,d=h.clone().sub(t.cameraTarget),p=new DFt.Vector3;this.gc.textBaseline="middle",this.gc.miterLimit=2;for(var f=Math.min(1e4,n.pointIndices.length),m=0;m<f;++m){var g,y=n.pointIndices[m];if(g=BFt.vector3FromPackedArray(this.worldSpacePointPositions,y),p.copy(h).sub(g),!(d.dot(p)<0)){var b=LFt(BFt.vector3DToScreenCoords(t.camera,t.screenWidth,t.screenHeight,g),2),v=b[0],x=b[1],w={loX:(v+=4)-2,hiX:v+1+2,loY:x-r/2-2,hiY:x+r/2+2};if(e.insert(w,!0)){var S=n.labelStrings[m],k=n.defaultFontSize*n.scaleFactors[m]*s;if(this.gc.font=k+"px roboto",w.hiX+=this.gc.measureText(S).width-1,e.insert(w)){var C=1;i&&1===n.useSceneOpacityFlags[m]&&(C=u(p.length())),this.gc.fillStyle=this.styleStringFromPackedRgba(n.fillColors,m,C),this.gc.strokeStyle=this.styleStringFromPackedRgba(n.strokeColors,m,C),this.gc.lineWidth=this.styles.label.strokeWidth,this.gc.strokeText(S,v,x),this.gc.lineWidth=this.styles.label.fillWidth,this.gc.fillText(S,v,x)}}}}}},t.prototype.styleStringFromPackedRgba=function(t,e,n){var i=3*e;return"rgba("+t[i]+","+t[i+1]+","+t[i+2]+","+n+")"},t.prototype.onResize=function(t,e){var n=window.devicePixelRatio;this.canvas.width=t*n,this.canvas.height=e*n,this.canvas.style.width=t+"px",this.canvas.style.height=e+"px"},t.prototype.dispose=function(){this.removeAllLabels()},t.prototype.onPointPositionsChanged=function(t){this.worldSpacePointPositions=t,this.removeAllLabels()},t.prototype.onRender=function(t){this.labelsActive&&(this.removeAllLabels(),this.makeLabels(t))},t.prototype.setScene=function(t){},t.prototype.onPickingRender=function(t){},t}();RFt.ScatterPlotVisualizerCanvasLabels=UFt;var VFt={},WFt=Ti&&Ti.__values||function(t){var e="function"==typeof Symbol&&Symbol.iterator,n=e&&t[e],i=0;if(n)return n.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&i>=t.length&&(t=void 0),{value:t&&t[i++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(VFt,"__esModule",{value:!0});var HFt=ADt,jFt=LDt,GFt=mFt,qFt=function(){function t(){this.id="POLYLINES",this.sequences=[],this.polylines=[],this.polylinePositionBuffer={},this.polylineColorBuffer={},this.pointSequenceIndices=new Map}return t.prototype.getPointSequenceIndex=function(t){return this.pointSequenceIndices.get(t)},t.prototype.updateSequenceIndices=function(){for(var t=0;t<this.sequences.length;t++)for(var e=this.sequences[t],n=0;n<e.indices.length-1;n++){var i=e.indices[n];this.pointSequenceIndices.set(i,t),this.pointSequenceIndices.set(i+1,t)}},t.prototype.createPolylines=function(){var t,e;this.updateSequenceIndices();try{for(var n=WFt(this.polylines),i=n.next();!i.done;i=n.next()){var r=i.value;this.scene.remove(r),r.geometry.dispose()}}catch(e){t={error:e}}finally{try{i&&!i.done&&(e=n.return)&&e.call(n)}finally{if(t)throw t.error}}this.polylines=[];for(var s=0;s<this.sequences.length;s++){var o=new HFt.BufferGeometry;o.addAttribute("position",this.polylinePositionBuffer[s]),o.addAttribute("color",this.polylineColorBuffer[s]);var a=new HFt.LineBasicMaterial({linewidth:1,opacity:1,transparent:!0,vertexColors:!0});(r=new HFt.LineSegments(o,a)).frustumCulled=!1,this.polylines.push(r),this.scene.add(r)}},t.prototype.dispose=function(){var t,e;try{for(var n=WFt(this.polylines),i=n.next();!i.done;i=n.next()){var r=i.value;this.scene.remove(r),r.geometry.dispose()}}catch(e){t={error:e}}finally{try{i&&!i.done&&(e=n.return)&&e.call(n)}finally{if(t)throw t.error}}this.polylines=[],this.polylinePositionBuffer={},this.polylineColorBuffer={}},t.prototype.setScene=function(t){this.scene=t},t.prototype.setSequences=function(t){this.sequences=t},t.prototype.onPointPositionsChanged=function(t){if(null==t&&this.dispose(),null!=t&&0!==this.sequences.length){for(var e=0;e<this.sequences.length;e++){var n=2*((s=this.sequences[e]).indices.length-1),i=new Float32Array(n*GFt.XYZ_NUM_ELEMENTS);this.polylinePositionBuffer[e]=new HFt.BufferAttribute(i,GFt.XYZ_NUM_ELEMENTS);var r=new Float32Array(n*GFt.RGBA_NUM_ELEMENTS);this.polylineColorBuffer[e]=new HFt.BufferAttribute(r,GFt.RGBA_NUM_ELEMENTS)}for(e=0;e<this.sequences.length;e++){for(var s=this.sequences[e],o=0,a=0;a<s.indices.length-1;a++){var l=s.indices[a],c=s.indices[a+1],u=jFt.vector3FromPackedArray(t,l),h=jFt.vector3FromPackedArray(t,c);this.polylinePositionBuffer[e].setXYZ(o,u.x,u.y,u.z),this.polylinePositionBuffer[e].setXYZ(o+1,h.x,h.y,h.z),o+=2}this.polylinePositionBuffer[e].needsUpdate=!0}this.createPolylines()}},t.prototype.onRender=function(t){for(var e=0;e<this.polylines.length;e++){var n=this.polylines[e].material;n.opacity=t.polylineOpacities[e],n.linewidth=t.polylineWidths[e],this.polylineColorBuffer[e].array=t.polylineColors[e],this.polylineColorBuffer[e].needsUpdate=!0}},t.prototype.onPickingRender=function(t){},t.prototype.onResize=function(t,e){},t}();VFt.ScatterPlotVisualizerPolylines=qFt;var XFt=Ti&&Ti.__read||function(t,e){var n="function"==typeof Symbol&&t[Symbol.iterator];if(!n)return t;var i,r,s=n.call(t),o=[];try{for(;(void 0===e||e-- >0)&&!(i=s.next()).done;)o.push(i.value)}catch(t){r={error:t}}finally{try{i&&!i.done&&(n=s.return)&&n.call(s)}finally{if(r)throw r.error}}return o},KFt=Ti&&Ti.__spread||function(){for(var t=[],e=0;e<arguments.length;e++)t=t.concat(XFt(arguments[e]));return t},YFt=Ti&&Ti.__values||function(t){var e="function"==typeof Symbol&&Symbol.iterator,n=e&&t[e],i=0;if(n)return n.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&i>=t.length&&(t=void 0),{value:t&&t[i++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(Gkt,"__esModule",{value:!0});var ZFt=qkt,JFt=sFt,QFt=uFt,tzt=ODt,ezt=fFt,nzt=LDt,izt=mFt,rzt=gFt,szt=kFt,ozt=RFt,azt=VFt,lzt=function(){function t(t,e){var n=this;void 0===e&&(e={}),this.pointColorer=null,this.sequences=[],this.renderMode="POINT",this.rotateOnStart=!0,this.selectEnabled=!0,this.showLabelsOnHover=!0,this.hoverPointIndex=null,this.selectedPointIndices=new Set,this.clickCallback=function(){},this.hoverCallback=function(){},this.selectCallback=function(){},this.cameraMoveCallback=function(){},this.onHover=function(t){n.hoverCallback(t),n.hoverPointIndex=t,n.updateScatterPlotAttributes(),n.renderScatterPlot()},this.onClick=function(t){n.clickCallback(t)},this.select=function(t){n.selectEnabled&&(n.selectedPointIndices=new Set(t),n.updateScatterPlotAttributes(),n.renderScatterPlot())},this.onSelect=function(t){n.selectEnabled&&(n.selectCallback(t),n.select(t))},this.containerElement=t,this.styles=ezt.makeStyles(e.styles),this.setParameters(e),this.scatterPlot=new ZFt.ScatterPlot(t,{camera:e.camera,onClick:this.onClick,onHover:this.onHover,onSelect:this.onSelect,selectEnabled:this.selectEnabled,styles:this.styles,orbitControlParams:e.orbitControls}),this.scatterPlot.onCameraMove(this.cameraMoveCallback)}return t.prototype.setParameters=function(t){void 0!==t.onClick&&(this.clickCallback=t.onClick),void 0!==t.onHover&&(this.hoverCallback=t.onHover),void 0!==t.onSelect&&(this.selectCallback=t.onSelect),void 0!==t.onCameraMove&&(this.cameraMoveCallback=t.onCameraMove),void 0!==t.pointColorer&&(this.pointColorer=t.pointColorer),void 0!==t.renderMode&&(this.renderMode=t.renderMode),void 0!==t.rotateOnStart&&(this.rotateOnStart=t.rotateOnStart),void 0!==t.selectEnabled&&(this.selectEnabled=t.selectEnabled),void 0!==t.showLabelsOnHover&&(this.showLabelsOnHover=t.showLabelsOnHover)},t.prototype.render=function(t){this.updateDataset(t),this.clearVisualizers(),this.setVisualizers(),this.rotateOnStart&&this.scatterPlot.startOrbitAnimation()},t.prototype.clearVisualizers=function(){this.canvasLabelsVisualizer=void 0,this.labels3DVisualizer=void 0,this.pointVisualizer=void 0,this.polylineVisualizer=void 0,this.spritesheetVisualizer=void 0,this.scatterPlot.disposeAllVisualizers()},t.prototype.renderScatterPlot=function(){this.dataset&&this.scatterPlot.render()},t.prototype.resetZoom=function(){this.scatterPlot.resetZoom()},t.prototype.setRenderMode=function(t){this.renderMode=t,this.setVisualizers(),this.updateScatterPlotAttributes(),this.updateScatterPlotPositions()},t.prototype.setTextRenderMode=function(){this.setRenderMode("TEXT"),this.renderScatterPlot()},t.prototype.setPointRenderMode=function(){this.setRenderMode("POINT"),this.renderScatterPlot()},t.prototype.setSpriteRenderMode=function(){this.dataset&&this.dataset.spriteMetadata&&(this.setRenderMode("SPRITE"),this.renderScatterPlot())},t.prototype.setSequences=function(t){this.sequences=t,this.updatePolylineAttributes(),this.setVisualizers(),this.renderScatterPlot()},t.prototype.setPanMode=function(){this.scatterPlot.setInteractionMode("PAN")},t.prototype.setSelectMode=function(){this.scatterPlot.setInteractionMode("SELECT")},t.prototype.setDimensions=function(t){var e=t<2||t>3,n=this.dataset&&t>this.dataset.dimensions;if(e||n)throw new RangeError("Setting invalid dimensionality");this.scatterPlot.setDimensions(t),this.renderScatterPlot()},t.prototype.setPointColorer=function(t){this.pointColorer=t,this.updateScatterPlotAttributes(),this.renderScatterPlot()},t.prototype.callPointColorer=function(t,e){return t(e,this.selectedPointIndices,this.hoverPointIndex)},t.prototype.setHoverPointIndex=function(t){this.hoverPointIndex=t,this.updateScatterPlotAttributes(),this.scatterPlot.orbitIsAnimating()||this.renderScatterPlot()},t.prototype.resize=function(){this.scatterPlot.resize()},t.prototype.updateDataset=function(t){this.setDataset(t),this.scatterPlot.setDimensions(t.dimensions),this.updateScatterPlotAttributes(),this.updateScatterPlotPositions(),this.renderScatterPlot()},t.prototype.isOrbiting=function(){return this.scatterPlot.orbitIsAnimating()},t.prototype.startOrbitAnimation=function(){this.scatterPlot.startOrbitAnimation()},t.prototype.stopOrbitAnimation=function(){this.scatterPlot.stopOrbitAnimation()},t.prototype.setDataset=function(t){this.dataset=t,this.labels3DVisualizer&&this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray())},t.prototype.updateScatterPlotPositions=function(){var t=this.dataset;if(t){var e=this.generatePointPositionArray(t);this.scatterPlot.setPointPositions(e)}},t.prototype.updateScatterPlotAttributes=function(){var t=this.dataset;if(t){var e=this.generatePointColorArray(t),n=this.generatePointScaleFactorArray(t),i=this.generateVisibleLabelRenderParams();this.scatterPlot.setPointColors(e),this.scatterPlot.setPointScaleFactors(n),this.scatterPlot.setLabels(i)}},t.prototype.updatePolylineAttributes=function(){var t=this.dataset;if(t){var e=this.generateLineSegmentColorMap(t),n=this.generateLineSegmentOpacityArray(t),i=this.generateLineSegmentWidthArray(t);this.scatterPlot.setPolylineColors(e),this.scatterPlot.setPolylineOpacities(n),this.scatterPlot.setPolylineWidths(i)}},t.prototype.generatePointPositionArray=function(t){var e,n,i=[0,0];e=nzt.extent(t.points.map((function(t){return t[0]}))),n=nzt.extent(t.points.map((function(t){return t[1]}))),3===t.dimensions&&(i=nzt.extent(t.points.map((function(t){return t[2]}))));var r=function(t){return Math.abs(t[1]-t[0])},s=r(e),o=r(n),a=r(i),l=Math.max(s,o,a),c=izt.SCATTER_PLOT_CUBE_LENGTH/2,u=function(t,e){return[t/l*-e,e*(t/l)]},h=u(s,c),d=u(o,c),p=u(a,c),f=new Float32Array(3*t.points.length),m=0;return t.points.forEach((function(r,s){var o=t.points[s];f[m++]=nzt.scaleLinear(o[0],e,h),f[m++]=nzt.scaleLinear(o[1],n,d),3===t.dimensions?f[m++]=nzt.scaleLinear(o[2],i,p):f[m++]=0})),f},t.prototype.generateVisibleLabelRenderParams=function(){var t=this,e=t.hoverPointIndex,n=t.selectedPointIndices,i=t.styles,r=null!==e?1:0,s=new Uint32Array(r),o=new Float32Array(r),a=new Int8Array(r),l=new Uint8Array(3*r),c=new Uint8Array(3*r),u=[];o.fill(i.label.scaleDefault),a.fill(1);var h=0;if(null!==e){u.push(this.getLabelText(e)),s[h]=e,o[h]=i.label.scaleLarge,a[h]=0;var d=nzt.styleRgbFromHexColor(i.label.fillColorHover);nzt.packRgbIntoUint8Array(l,h,d[0],d[1],d[2]);var p=nzt.styleRgbFromHexColor(i.label.strokeColorHover);nzt.packRgbIntoUint8Array(c,h,p[0],p[1],p[1]),++h}d=nzt.styleRgbFromHexColor(i.label.fillColorSelected),p=nzt.styleRgbFromHexColor(i.label.strokeColorSelected);if(1===n.size){var f=KFt(n)[0];u.push(this.getLabelText(f)),s[h]=f,o[h]=i.label.scaleLarge,a[h]=0,nzt.packRgbIntoUint8Array(l,h,d[0],d[1],d[2]),nzt.packRgbIntoUint8Array(c,h,p[0],p[1],p[2])}return new tzt.LabelRenderParams(new Float32Array(s),u,o,a,i.label.fontSize,l,c)},t.prototype.generatePointScaleFactorArray=function(t){var e,n,i=this,r=i.hoverPointIndex,s=i.selectedPointIndices,o=i.styles.point,a=o.scaleDefault,l=o.scaleSelected,c=o.scaleHover,u=new Float32Array(t.points.length);u.fill(a),s.size;try{for(var h=YFt(s.values()),d=h.next();!d.done;d=h.next()){u[d.value]=l}}catch(t){e={error:t}}finally{try{d&&!d.done&&(n=h.return)&&n.call(h)}finally{if(e)throw e.error}}return null!=r&&(u[r]=c),u},t.prototype.generatePointColorArray=function(t){var e,n,i=this,r=i.hoverPointIndex,s=i.pointColorer,o=i.selectedPointIndices,a=i.styles.point,l=a.colorHover,c=a.colorNoSelection,u=a.colorSelected,h=a.colorUnselected,d=new Float32Array(t.points.length*izt.RGBA_NUM_ELEMENTS),p=h,f=c;"TEXT"===this.renderMode&&(p=this.styles.label3D.colorUnselected,f=this.styles.label3D.colorNoSelection),"SPRITE"===this.renderMode&&(p=this.styles.sprites.colorUnselected,f=this.styles.sprites.colorNoSelection);var m=t.points.length,g=this.selectedPointIndices.size;if(s)for(var y=0,b=0;b<m;++b){var v=JFt.parseColor(this.callPointColorer(s,b)||f);d[y++]=v.r,d[y++]=v.g,d[y++]=v.b,d[y++]=v.opacity}else{for(y=0,v=g>0?JFt.parseColor(p):JFt.parseColor(f),b=0;b<m;++b)d[y++]=v.r,d[y++]=v.g,d[y++]=v.b,d[y++]=v.opacity;v=JFt.parseColor(u);try{for(var x=YFt(o.values()),w=x.next();!w.done;w=x.next()){var S=w.value*izt.RGBA_NUM_ELEMENTS;d[S++]=v.r,d[S++]=v.g,d[S++]=v.b,d[S++]=v.opacity}}catch(t){e={error:t}}finally{try{w&&!w.done&&(n=x.return)&&n.call(x)}finally{if(e)throw e.error}}if(null!=r){var k=JFt.parseColor(l),C=r*izt.RGBA_NUM_ELEMENTS;d[C++]=k.r,d[C++]=k.g,d[C++]=k.b,d[C++]=k.opacity}}return d},t.prototype.generate3DLabelsArray=function(){var t=this.dataset;if(!t)return[];for(var e=[],n=t.points.length,i=0;i<n;++i)e.push(this.getLabelText(i));return e},t.prototype.generateLineSegmentColorMap=function(t){for(var e=this.pointColorer,n=this.styles,i={},r=0;r<this.sequences.length;r++){var s=this.sequences[r],o=new Float32Array(2*(s.indices.length-1)*3),a=0;if(e)for(var l=0;l<s.indices.length-1;l++){var c=JFt.parseColor(this.callPointColorer(e,s.indices[l])),u=JFt.parseColor(this.callPointColorer(e,s.indices[l+1]));o[a++]=c.r,o[a++]=c.g,o[a++]=c.b,o[a++]=u.r,o[a++]=u.g,o[a++]=u.b}else for(l=0;l<s.indices.length-1;l++){c=nzt.getDefaultPointInPolylineColor(l,s.indices.length,n.polyline.startHue,n.polyline.endHue,n.polyline.saturation,n.polyline.lightness),u=nzt.getDefaultPointInPolylineColor(l+1,s.indices.length,n.polyline.startHue,n.polyline.endHue,n.polyline.saturation,n.polyline.lightness);o[a++]=c.r,o[a++]=c.g,o[a++]=c.b,o[a++]=u.r,o[a++]=u.g,o[a++]=u.b}i[r]=o}return i},t.prototype.generateLineSegmentOpacityArray=function(t){var e=this.selectedPointIndices,n=this.styles,i=new Float32Array(this.sequences.length);if(e.size>0){i.fill(n.polyline.deselectedOpacity);var r=this.polylineVisualizer.getPointSequenceIndex(KFt(e)[0]);void 0!==r&&(i[r]=n.polyline.selectedOpacity)}else i.fill(n.polyline.defaultOpacity);return i},t.prototype.generateLineSegmentWidthArray=function(t){var e=this.selectedPointIndices,n=this.styles,i=new Float32Array(this.sequences.length);if(i.fill(n.polyline.defaultLineWidth),e.size>0){var r=this.polylineVisualizer.getPointSequenceIndex(KFt(e)[0]);void 0!==r&&(i[r]=n.polyline.selectedLineWidth)}return i},t.prototype.getLabelText=function(t){var e=this.dataset;if(!e)return"";var n=e.metadata[t];return n&&null!=n.label?""+n.label:""},t.prototype.initializeCanvasLabelsVisualizer=function(){return this.canvasLabelsVisualizer||(this.canvasLabelsVisualizer=new ozt.ScatterPlotVisualizerCanvasLabels(this.containerElement,this.styles)),this.canvasLabelsVisualizer},t.prototype.initialize3DLabelsVisualizer=function(){return this.labels3DVisualizer||(this.labels3DVisualizer=new rzt.ScatterPlotVisualizer3DLabels(this.styles)),this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray()),this.labels3DVisualizer},t.prototype.initializePointVisualizer=function(){return this.pointVisualizer||(this.pointVisualizer=new szt.ScatterPlotVisualizerSprites(this.styles)),this.pointVisualizer},t.prototype.initializeSpritesheetVisualizer=function(){var t=this,e=this.styles,n=this.dataset,i=n.spriteMetadata;if(!this.spritesheetVisualizer&&i){if(!i.spriteImage||!i.singleSpriteSize)return;var r=n.points.length,s=void 0;if(i.spriteIndices)s=new Float32Array(i.spriteIndices);else{s=new Float32Array(r);for(var o=0;o<r;++o)s[o]=o}var a=new szt.ScatterPlotVisualizerSprites(e,{spritesheetImage:i.spriteImage,spriteDimensions:i.singleSpriteSize,spriteIndices:s,onImageLoad:function(){return t.renderScatterPlot()}});a.id="SPRITE_SHEET_VISUALIZER",this.spritesheetVisualizer=a}return this.spritesheetVisualizer},t.prototype.initializePolylineVisualizer=function(){return this.polylineVisualizer||(this.polylineVisualizer=new azt.ScatterPlotVisualizerPolylines),this.polylineVisualizer.setSequences(this.sequences),this.polylineVisualizer},t.prototype.setVisualizers=function(){var t=this.dataset,e=this.renderMode,n=[];if("TEXT"===e){var i=this.initialize3DLabelsVisualizer();n.push(i)}else if("POINT"===e){i=this.initializePointVisualizer();n.push(i)}else if("SPRITE"===e&&t.spriteMetadata){(i=this.initializeSpritesheetVisualizer())&&n.push(i)}if(this.sequences.length>0){i=this.initializePolylineVisualizer();n.push(i)}if(("POINT"===e||"SPRITE"===e)&&this.showLabelsOnHover){i=this.initializeCanvasLabelsVisualizer();n.push(i)}this.scatterPlot.setActiveVisualizers(n)},t.Dataset=QFt.Dataset,t}();Gkt.ScatterGL=lzt,Object.defineProperty(jkt,"__esModule",{value:!0});var czt=Gkt,uzt=jkt.ScatterGL=czt.ScatterGL,hzt=uFt;function dzt(t){let e;return{c(){e=MB("div"),OB(e,"id","scatter-container"),OB(e,"class","svelte-f0tf1i")},m(n,i){TB(n,e,i),t[4](e)},p:Jz,d(n){n&&_B(e),t[4](null)}}}function pzt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[dzt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),66&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function fzt(t,e,n){let i,r,{title:s}=e,{embedding:o}=e,{labels:a}=e;return tU((()=>{const t=document.getElementById("scatter-container");r=new uzt(t,{styles:{point:{scaleDefault:1.6,scaleSelected:2,scaleHover:2}}}),o.subscribe((t=>{if(t.length>0){let e=[];e=void 0===a||0===a.get().length?new Array(t.length).fill(0):a.get();const n=new uzt.Dataset(t);r.render(n);const i=Array.from(new Set(e)),s=[...new Array(i.length)].map(((t,e)=>Math.floor(255/i.length*e))),o=s.map((t=>`hsla(${t}, 100%, 50%, 0.1)`)),l=s.map((t=>`hsla(${t}, 100%, 50%, 0.75)`)),c=s.map((t=>`hsla(${t}, 100%, 50%, 1)`));r.setPointColorer(((t,n,r)=>n.size>0?n.has(t)?c[i.indexOf(e[t])]:o[i.indexOf(e[t])]:t===r?c[i.indexOf(e[t])]:l[i.indexOf(e[t])]))}})),a.subscribe((t=>{const e=Array.from(new Set(t)),n=[...new Array(e.length)].map(((t,n)=>Math.floor(255/e.length*n))),i=n.map((t=>`hsla(${t}, 100%, 50%, 0.1)`)),s=n.map((t=>`hsla(${t}, 100%, 50%, 0.75)`)),o=n.map((t=>`hsla(${t}, 100%, 50%, 1)`));r.setPointColorer(((n,r,a)=>r.size>0?r.has(n)?o[e.indexOf(t[n])]:i[e.indexOf(t[n])]:n===a?o[e.indexOf(t[n])]:s[e.indexOf(t[n])]))}))})),t.$$set=t=>{"title"in t&&n(0,s=t.title),"embedding"in t&&n(2,o=t.embedding),"labels"in t&&n(3,a=t.labels)},[s,i,o,a,function(t){aU[t?"unshift":"push"]((()=>{i=t,n(1,i)}))}]}jkt.Dataset=hzt.Dataset;class mzt extends UU{constructor(t){super(),BU(this,t,fzt,pzt,rB,{title:0,embedding:2,labels:3})}get title(){return this.$$.ctx[0]}set title(t){this.$$set({title:t}),vU()}get embedding(){return this.$$.ctx[2]}set embedding(t){this.$$set({embedding:t}),vU()}get labels(){return this.$$.ctx[3]}set labels(t){this.$$set({labels:t}),vU()}}class gzt extends xK{constructor(t,e){super(),this.title="Scatter plot",this.$data=t.hold(),this.$labels=e.hold(),this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new mzt({target:e,props:{title:this.title,embedding:this.$data,labels:this.$labels}}))}}function yzt(...t){return new gzt(...t)}function bzt(t){let e,n;return e=new PV({props:{options:t[3],value:t[4]}}),e.$on("change",t[5]),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};8&n&&(i.options=t[3]),16&n&&(i.value=t[4]),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function vzt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[bzt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),88&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function xzt(t,e,n){let i,r,s=Jz,o=()=>(s(),s=aB(u,(t=>n(3,i=t))),u),a=Jz,l=()=>(a(),a=aB(h,(t=>n(4,r=t))),h);t.$$.on_destroy.push((()=>s())),t.$$.on_destroy.push((()=>a()));let{title:c}=e,{options:u}=e;o();let{value:h}=e;return l(),t.$$set=t=>{"title"in t&&n(0,c=t.title),"options"in t&&o(n(1,u=t.options)),"value"in t&&l(n(2,h=t.value))},[c,u,h,i,r,function({detail:t}){h.set(t)}]}class wzt extends UU{constructor(t){super(),BU(this,t,xzt,vzt,rB,{title:0,options:1,value:2})}}class Szt extends xK{constructor(t,e){super(),this.title="select",this.$options=new eK(t,!0),this.$value=new eK(void 0!==e?e:t[0],!0),this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new wzt({target:e,props:{title:this.title,options:this.$options,value:this.$value}}))}}function kzt(...t){return new Szt(...t)}const{document:Czt}=wB;function Tzt(t){let e;return{c(){e=IB("Clear")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function _zt(t){let e,n,i,r,s,o,a,l;return s=new HU({props:{size:"small",type:"danger",$$slots:{default:[Tzt]},$$scope:{ctx:t}}}),s.$on("click",t[2]),{c(){e=MB("div"),n=MB("canvas"),i=AB(),r=MB("div"),DU(s.$$.fragment),OB(n,"id","fxid"),OB(n,"class","sketchpad-container svelte-1trukpy"),OB(n,"width","300"),OB(n,"height","300"),OB(r,"class","m-1"),OB(e,"class","w-full flex flex-col items-center box-border")},m(c,u){TB(c,e,u),SB(e,n),t[8](n),SB(e,i),SB(e,r),FU(s,r,null),o=!0,a||(l=[RB(n,"mousemove",t[3]),RB(n,"mousedown",t[4])],a=!0)},p(t,e){const n={};16384&e&&(n.$$scope={dirty:e,ctx:t}),s.$set(n)},i(t){o||(EU(s.$$.fragment,t),o=!0)},o(t){MU(s.$$.fragment,t),o=!1},d(n){n&&_B(e),t[8](null),zU(s),a=!1,nB(l)}}}function Ezt(t){let e,n,i,r,s;return n=new DH({props:{title:t[0],$$slots:{default:[_zt]},$$scope:{ctx:t}}}),{c(){e=AB(),DU(n.$$.fragment)},m(o,a){TB(o,e,a),FU(n,o,a),i=!0,r||(s=RB(Czt.body,"mouseup",t[5]),r=!0)},p(t,[e]){const i={};1&e&&(i.title=t[0]),16386&e&&(i.$$scope={dirty:e,ctx:t}),n.$set(i)},i(t){i||(EU(n.$$.fragment,t),i=!0)},o(t){MU(n.$$.fragment,t),i=!1},d(t){t&&_B(e),zU(n,t),r=!1,s()}}}function Mzt(t,e,n){let i,r,{title:s}=e,{strokeStart:o}=e,{strokeEnd:a}=e,l=!1,c={left:0,top:0},u={x:0,y:0};const h=iU();function d(){r.clearRect(0,0,i.width,i.height),r.fillStyle="white",r.fillRect(0,0,i.width,i.height),l=!1}function p(t){const e=t.clientX-c.left,n=t.clientY-c.top;l&&(r.beginPath(),r.strokeStyle="black",r.lineWidth=10,r.lineJoin="round",r.moveTo(u.x,u.y),r.lineTo(e,n),r.closePath(),r.stroke()),u.x=e,u.y=n}return tU((async()=>{await pU(),await pU(),r=i.getContext("2d"),d(),h("canvasElement",i)})),t.$$set=t=>{"title"in t&&n(0,s=t.title),"strokeStart"in t&&n(6,o=t.strokeStart),"strokeEnd"in t&&n(7,a=t.strokeEnd)},[s,i,d,p,function(t){const e=i.getBoundingClientRect();c={top:e.top+document.body.scrollTop,left:e.left+document.body.scrollLeft},p(t),o.set(),l=!0},function(){l&&a.set(),l=!1},o,a,function(t){aU[t?"unshift":"push"]((()=>{i=t,n(1,i)}))}]}class $zt extends UU{constructor(t){super(),BU(this,t,Mzt,Ezt,rB,{title:0,strokeStart:6,strokeEnd:7})}}var Izt,Azt,Nzt,Rzt;class Pzt extends xK{constructor(){super(),this.title="sketchPad",this.$images=new eK(Yj()),this.$thumbnails=new eK(Yj()),this.$strokeStart=new eK(Yj()),this.$strokeEnd=new eK(Yj()),Izt.set(this,60),Azt.set(this,void 0),Nzt.set(this,void 0),Rzt.set(this,void 0),this.setupCapture(),this.$strokeEnd.subscribe((()=>{this.capture()})),this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new $zt({target:e,props:{title:this.title,strokeStart:this.$strokeStart,strokeEnd:this.$strokeEnd}}),this.$$.app.$on("canvasElement",(t=>{this.sketchElement=t.detail,WX(this,Rzt,this.sketchElement.getContext("2d"),"f")})))}setupCapture(){WX(this,Azt,document.createElement("canvas"),"f"),VX(this,Azt,"f").width=VX(this,Izt,"f"),VX(this,Azt,"f").height=VX(this,Izt,"f"),WX(this,Nzt,VX(this,Azt,"f").getContext("2d"),"f")}capture(){const t=this.captureThumbnail();this.$thumbnails.set(t),this.$images.set(this.captureImage())}captureThumbnail(){return VX(this,Nzt,"f").drawImage(this.sketchElement,0,0,VX(this,Azt,"f").width,VX(this,Azt,"f").height),VX(this,Azt,"f").toDataURL("image/jpeg")}captureImage(){return VX(this,Rzt,"f").getImageData(0,0,this.sketchElement.width,this.sketchElement.height)}}function Ozt(...t){return new Pzt(...t)}function Lzt(t){return"[object Date]"===Object.prototype.toString.call(t)}function Dzt(t,e,n,i){if("number"==typeof n||Lzt(n)){const r=i-n,s=(n-e)/(t.dt||1/60),o=(s+(t.opts.stiffness*r-t.opts.damping*s)*t.inv_mass)*t.dt;return Math.abs(o)<t.opts.precision&&Math.abs(r)<t.opts.precision?i:(t.settled=!1,Lzt(n)?new Date(n.getTime()+o):n+o)}if(Array.isArray(n))return n.map(((r,s)=>Dzt(t,e[s],n[s],i[s])));if("object"==typeof n){const r={};for(const s in n)r[s]=Dzt(t,e[s],n[s],i[s]);return r}throw new Error(`Cannot spring ${typeof n} values`)}function Fzt(t,e={}){const n=UV(t),{stiffness:i=.15,damping:r=.8,precision:s=.01}=e;let o,a,l,c=t,u=t,h=1,d=0,p=!1;function f(e,i={}){u=e;const r=l={};if(null==t||i.hard||m.stiffness>=1&&m.damping>=1)return p=!0,o=gB(),c=e,n.set(t=u),Promise.resolve();if(i.soft){const t=!0===i.soft?.5:+i.soft;d=1/(60*t),h=0}return a||(o=gB(),p=!1,a=xB((e=>{if(p)return p=!1,a=null,!1;h=Math.min(h+d,1);const i={inv_mass:h,opts:m,settled:!0,dt:60*(e-o)/1e3},r=Dzt(i,c,t,u);return o=e,c=t,n.set(t=r),i.settled&&(a=null),!i.settled}))),new Promise((t=>{a.promise.then((()=>{r===l&&t()}))}))}const m={set:f,update:(e,n)=>f(e(u,t),n),subscribe:n.subscribe,stiffness:i,damping:r,precision:s};return m}function zzt(t,e,n){const i=t.slice();return i[28]=e[n],i[30]=n,i}function Bzt(t){let e,n,i,r,s=("label"===t[6]||"label"===t[7])&&Uzt(t);return{c(){e=MB("span"),s&&s.c(),OB(e,"class","pip first"),OB(e,"style",n=t[14]+": 0%;"),WB(e,"selected",t[18](t[0])),WB(e,"in-range",t[17](t[0]))},m(n,o){TB(n,e,o),s&&s.m(e,null),i||(r=[RB(e,"click",(function(){iB(t[21](t[0]))&&t[21](t[0]).apply(this,arguments)})),RB(e,"touchend",PB((function(){iB(t[21](t[0]))&&t[21](t[0]).apply(this,arguments)})))],i=!0)},p(i,r){"label"===(t=i)[6]||"label"===t[7]?s?s.p(t,r):(s=Uzt(t),s.c(),s.m(e,null)):s&&(s.d(1),s=null),16384&r&&n!==(n=t[14]+": 0%;")&&OB(e,"style",n),262145&r&&WB(e,"selected",t[18](t[0])),131073&r&&WB(e,"in-range",t[17](t[0]))},d(t){t&&_B(e),s&&s.d(),i=!1,nB(r)}}}function Uzt(t){let e,n,i=t[12](t[16](t[0]),0,0)+"",r=t[10]&&Vzt(t),s=t[11]&&Wzt(t);return{c(){e=MB("span"),r&&r.c(),n=IB(i),s&&s.c(),OB(e,"class","pipVal")},m(t,i){TB(t,e,i),r&&r.m(e,null),SB(e,n),s&&s.m(e,null)},p(t,o){t[10]?r?r.p(t,o):(r=Vzt(t),r.c(),r.m(e,n)):r&&(r.d(1),r=null),69633&o&&i!==(i=t[12](t[16](t[0]),0,0)+"")&&DB(n,i),t[11]?s?s.p(t,o):(s=Wzt(t),s.c(),s.m(e,null)):s&&(s.d(1),s=null)},d(t){t&&_B(e),r&&r.d(),s&&s.d()}}}function Vzt(t){let e,n;return{c(){e=MB("span"),n=IB(t[10]),OB(e,"class","pipVal-prefix")},m(t,i){TB(t,e,i),SB(e,n)},p(t,e){1024&e&&DB(n,t[10])},d(t){t&&_B(e)}}}function Wzt(t){let e,n;return{c(){e=MB("span"),n=IB(t[11]),OB(e,"class","pipVal-suffix")},m(t,i){TB(t,e,i),SB(e,n)},p(t,e){2048&e&&DB(n,t[11])},d(t){t&&_B(e)}}}function Hzt(t){let e,n=Array(t[20]+1),i=[];for(let e=0;e<n.length;e+=1)i[e]=Kzt(zzt(t,n,e));return{c(){for(let t=0;t<i.length;t+=1)i[t].c();e=NB()},m(t,n){for(let e=0;e<i.length;e+=1)i[e]&&i[e].m(t,n);TB(t,e,n)},p(t,r){if(4120131&r){let s;for(n=Array(t[20]+1),s=0;s<n.length;s+=1){const o=zzt(t,n,s);i[s]?i[s].p(o,r):(i[s]=Kzt(o),i[s].c(),i[s].m(e.parentNode,e))}for(;s<i.length;s+=1)i[s].d(1);i.length=n.length}},d(t){EB(i,t),t&&_B(e)}}}function jzt(t){let e,n,i,r,s,o=("label"===t[6]||"label"===t[9])&&Gzt(t);return{c(){e=MB("span"),o&&o.c(),n=AB(),OB(e,"class","pip"),OB(e,"style",i=t[14]+": "+t[15](t[19](t[30]))+"%;"),WB(e,"selected",t[18](t[19](t[30]))),WB(e,"in-range",t[17](t[19](t[30])))},m(i,a){TB(i,e,a),o&&o.m(e,null),SB(e,n),r||(s=[RB(e,"click",(function(){iB(t[21](t[19](t[30])))&&t[21](t[19](t[30])).apply(this,arguments)})),RB(e,"touchend",PB((function(){iB(t[21](t[19](t[30])))&&t[21](t[19](t[30])).apply(this,arguments)})))],r=!0)},p(r,s){"label"===(t=r)[6]||"label"===t[9]?o?o.p(t,s):(o=Gzt(t),o.c(),o.m(e,n)):o&&(o.d(1),o=null),573440&s&&i!==(i=t[14]+": "+t[15](t[19](t[30]))+"%;")&&OB(e,"style",i),786432&s&&WB(e,"selected",t[18](t[19](t[30]))),655360&s&&WB(e,"in-range",t[17](t[19](t[30])))},d(t){t&&_B(e),o&&o.d(),r=!1,nB(s)}}}function Gzt(t){let e,n,i=t[12](t[19](t[30]),t[30],t[15](t[19](t[30])))+"",r=t[10]&&qzt(t),s=t[11]&&Xzt(t);return{c(){e=MB("span"),r&&r.c(),n=IB(i),s&&s.c(),OB(e,"class","pipVal")},m(t,i){TB(t,e,i),r&&r.m(e,null),SB(e,n),s&&s.m(e,null)},p(t,o){t[10]?r?r.p(t,o):(r=qzt(t),r.c(),r.m(e,n)):r&&(r.d(1),r=null),561152&o&&i!==(i=t[12](t[19](t[30]),t[30],t[15](t[19](t[30])))+"")&&DB(n,i),t[11]?s?s.p(t,o):(s=Xzt(t),s.c(),s.m(e,null)):s&&(s.d(1),s=null)},d(t){t&&_B(e),r&&r.d(),s&&s.d()}}}function qzt(t){let e,n;return{c(){e=MB("span"),n=IB(t[10]),OB(e,"class","pipVal-prefix")},m(t,i){TB(t,e,i),SB(e,n)},p(t,e){1024&e&&DB(n,t[10])},d(t){t&&_B(e)}}}function Xzt(t){let e,n;return{c(){e=MB("span"),n=IB(t[11]),OB(e,"class","pipVal-suffix")},m(t,i){TB(t,e,i),SB(e,n)},p(t,e){2048&e&&DB(n,t[11])},d(t){t&&_B(e)}}}function Kzt(t){let e,n=t[19](t[30])!==t[0]&&t[19](t[30])!==t[1],i=n&&jzt(t);return{c(){i&&i.c(),e=NB()},m(t,n){i&&i.m(t,n),TB(t,e,n)},p(t,r){524291&r&&(n=t[19](t[30])!==t[0]&&t[19](t[30])!==t[1]),n?i?i.p(t,r):(i=jzt(t),i.c(),i.m(e.parentNode,e)):i&&(i.d(1),i=null)},d(t){i&&i.d(t),t&&_B(e)}}}function Yzt(t){let e,n,i,r,s=("label"===t[6]||"label"===t[8])&&Zzt(t);return{c(){e=MB("span"),s&&s.c(),OB(e,"class","pip last"),OB(e,"style",n=t[14]+": 100%;"),WB(e,"selected",t[18](t[1])),WB(e,"in-range",t[17](t[1]))},m(n,o){TB(n,e,o),s&&s.m(e,null),i||(r=[RB(e,"click",(function(){iB(t[21](t[1]))&&t[21](t[1]).apply(this,arguments)})),RB(e,"touchend",PB((function(){iB(t[21](t[1]))&&t[21](t[1]).apply(this,arguments)})))],i=!0)},p(i,r){"label"===(t=i)[6]||"label"===t[8]?s?s.p(t,r):(s=Zzt(t),s.c(),s.m(e,null)):s&&(s.d(1),s=null),16384&r&&n!==(n=t[14]+": 100%;")&&OB(e,"style",n),262146&r&&WB(e,"selected",t[18](t[1])),131074&r&&WB(e,"in-range",t[17](t[1]))},d(t){t&&_B(e),s&&s.d(),i=!1,nB(r)}}}function Zzt(t){let e,n,i=t[12](t[16](t[1]),t[20],100)+"",r=t[10]&&Jzt(t),s=t[11]&&Qzt(t);return{c(){e=MB("span"),r&&r.c(),n=IB(i),s&&s.c(),OB(e,"class","pipVal")},m(t,i){TB(t,e,i),r&&r.m(e,null),SB(e,n),s&&s.m(e,null)},p(t,o){t[10]?r?r.p(t,o):(r=Jzt(t),r.c(),r.m(e,n)):r&&(r.d(1),r=null),1118210&o&&i!==(i=t[12](t[16](t[1]),t[20],100)+"")&&DB(n,i),t[11]?s?s.p(t,o):(s=Qzt(t),s.c(),s.m(e,null)):s&&(s.d(1),s=null)},d(t){t&&_B(e),r&&r.d(),s&&s.d()}}}function Jzt(t){let e,n;return{c(){e=MB("span"),n=IB(t[10]),OB(e,"class","pipVal-prefix")},m(t,i){TB(t,e,i),SB(e,n)},p(t,e){1024&e&&DB(n,t[10])},d(t){t&&_B(e)}}}function Qzt(t){let e,n;return{c(){e=MB("span"),n=IB(t[11]),OB(e,"class","pipVal-suffix")},m(t,i){TB(t,e,i),SB(e,n)},p(t,e){2048&e&&DB(n,t[11])},d(t){t&&_B(e)}}}function tBt(t){let e,n,i,r=(t[6]&&!1!==t[7]||t[7])&&Bzt(t),s=(t[6]&&!1!==t[9]||t[9])&&Hzt(t),o=(t[6]&&!1!==t[8]||t[8])&&Yzt(t);return{c(){e=MB("div"),r&&r.c(),n=AB(),s&&s.c(),i=AB(),o&&o.c(),OB(e,"class","rangePips"),WB(e,"disabled",t[5]),WB(e,"hoverable",t[4]),WB(e,"vertical",t[2]),WB(e,"reversed",t[3]),WB(e,"focus",t[13])},m(t,a){TB(t,e,a),r&&r.m(e,null),SB(e,n),s&&s.m(e,null),SB(e,i),o&&o.m(e,null)},p(t,[a]){t[6]&&!1!==t[7]||t[7]?r?r.p(t,a):(r=Bzt(t),r.c(),r.m(e,n)):r&&(r.d(1),r=null),t[6]&&!1!==t[9]||t[9]?s?s.p(t,a):(s=Hzt(t),s.c(),s.m(e,i)):s&&(s.d(1),s=null),t[6]&&!1!==t[8]||t[8]?o?o.p(t,a):(o=Yzt(t),o.c(),o.m(e,null)):o&&(o.d(1),o=null),32&a&&WB(e,"disabled",t[5]),16&a&&WB(e,"hoverable",t[4]),4&a&&WB(e,"vertical",t[2]),8&a&&WB(e,"reversed",t[3]),8192&a&&WB(e,"focus",t[13])},i:Jz,o:Jz,d(t){t&&_B(e),r&&r.d(),s&&s.d(),o&&o.d()}}}function eBt(t,e,n){let i,r,s,o,a,{range:l=!1}=e,{min:c=0}=e,{max:u=100}=e,{step:h=1}=e,{values:d=[(u+c)/2]}=e,{vertical:p=!1}=e,{reversed:f=!1}=e,{hoverable:m=!0}=e,{disabled:g=!1}=e,{pipstep:y}=e,{all:b=!0}=e,{first:v}=e,{last:x}=e,{rest:w}=e,{prefix:S=""}=e,{suffix:k=""}=e,{formatter:C=((t,e)=>t)}=e,{focus:T}=e,{orientationStart:_}=e,{percentOf:E}=e,{moveHandle:M}=e,{fixFloat:$}=e;return t.$$set=t=>{"range"in t&&n(22,l=t.range),"min"in t&&n(0,c=t.min),"max"in t&&n(1,u=t.max),"step"in t&&n(23,h=t.step),"values"in t&&n(24,d=t.values),"vertical"in t&&n(2,p=t.vertical),"reversed"in t&&n(3,f=t.reversed),"hoverable"in t&&n(4,m=t.hoverable),"disabled"in t&&n(5,g=t.disabled),"pipstep"in t&&n(25,y=t.pipstep),"all"in t&&n(6,b=t.all),"first"in t&&n(7,v=t.first),"last"in t&&n(8,x=t.last),"rest"in t&&n(9,w=t.rest),"prefix"in t&&n(10,S=t.prefix),"suffix"in t&&n(11,k=t.suffix),"formatter"in t&&n(12,C=t.formatter),"focus"in t&&n(13,T=t.focus),"orientationStart"in t&&n(14,_=t.orientationStart),"percentOf"in t&&n(15,E=t.percentOf),"moveHandle"in t&&n(26,M=t.moveHandle),"fixFloat"in t&&n(16,$=t.fixFloat)},t.$$.update=()=>{41943047&t.$$.dirty&&n(27,i=y||((u-c)/h>=(p?50:100)?(u-c)/(p?10:20):1)),142606339&t.$$.dirty&&n(20,r=parseInt((u-c)/(h*i),10)),142671873&t.$$.dirty&&n(19,s=function(t){return $(c+t*h*i)}),16842752&t.$$.dirty&&n(18,o=function(t){return d.some((e=>$(e)===$(t)))}),20971520&t.$$.dirty&&n(17,a=function(t){return"min"===l?d[0]>t:"max"===l?d[0]<t:l?d[0]<t&&d[1]>t:void 0})},[c,u,p,f,m,g,b,v,x,w,S,k,C,T,_,E,$,a,o,s,r,function(t){g||M(void 0,t)},l,h,d,y,M,i]}Izt=new WeakMap,Azt=new WeakMap,Nzt=new WeakMap,Rzt=new WeakMap;class nBt extends UU{constructor(t){super(),BU(this,t,eBt,tBt,rB,{range:22,min:0,max:1,step:23,values:24,vertical:2,reversed:3,hoverable:4,disabled:5,pipstep:25,all:6,first:7,last:8,rest:9,prefix:10,suffix:11,formatter:12,focus:13,orientationStart:14,percentOf:15,moveHandle:26,fixFloat:16})}}function iBt(t,e,n){const i=t.slice();return i[64]=e[n],i[66]=n,i}function rBt(t){let e,n,i=t[21](t[64],t[66],t[23](t[64]))+"",r=t[18]&&sBt(t),s=t[19]&&oBt(t);return{c(){e=MB("span"),r&&r.c(),n=IB(i),s&&s.c(),OB(e,"class","rangeFloat")},m(t,i){TB(t,e,i),r&&r.m(e,null),SB(e,n),s&&s.m(e,null)},p(t,o){t[18]?r?r.p(t,o):(r=sBt(t),r.c(),r.m(e,n)):r&&(r.d(1),r=null),10485761&o[0]&&i!==(i=t[21](t[64],t[66],t[23](t[64]))+"")&&DB(n,i),t[19]?s?s.p(t,o):(s=oBt(t),s.c(),s.m(e,null)):s&&(s.d(1),s=null)},d(t){t&&_B(e),r&&r.d(),s&&s.d()}}}function sBt(t){let e,n;return{c(){e=MB("span"),n=IB(t[18]),OB(e,"class","rangeFloat-prefix")},m(t,i){TB(t,e,i),SB(e,n)},p(t,e){262144&e[0]&&DB(n,t[18])},d(t){t&&_B(e)}}}function oBt(t){let e,n;return{c(){e=MB("span"),n=IB(t[19]),OB(e,"class","rangeFloat-suffix")},m(t,i){TB(t,e,i),SB(e,n)},p(t,e){524288&e[0]&&DB(n,t[19])},d(t){t&&_B(e)}}}function aBt(t){let e,n,i,r,s,o,a,l,c,u,h,d,p=t[7]&&rBt(t);return{c(){e=MB("span"),n=MB("span"),i=AB(),p&&p.c(),OB(n,"class","rangeNub"),OB(e,"role","slider"),OB(e,"class","rangeHandle"),OB(e,"data-handle",t[66]),OB(e,"style",r=t[28]+": "+t[29][t[66]]+"%; z-index: "+(t[26]===t[66]?3:2)+";"),OB(e,"aria-valuemin",s=!0===t[2]&&1===t[66]?t[0][0]:t[3]),OB(e,"aria-valuemax",o=!0===t[2]&&0===t[66]?t[0][1]:t[4]),OB(e,"aria-valuenow",a=t[64]),OB(e,"aria-valuetext",l=""+(t[18]+t[21](t[64],t[66],t[23](t[64]))+t[19])),OB(e,"aria-orientation",c=t[6]?"vertical":"horizontal"),OB(e,"aria-disabled",t[10]),OB(e,"disabled",t[10]),OB(e,"tabindex",u=t[10]?-1:0),WB(e,"active",t[24]&&t[26]===t[66]),WB(e,"press",t[25]&&t[26]===t[66])},m(r,s){TB(r,e,s),SB(e,n),SB(e,i),p&&p.m(e,null),h||(d=[RB(e,"blur",t[34]),RB(e,"focus",t[35]),RB(e,"keydown",t[36])],h=!0)},p(t,n){t[7]?p?p.p(t,n):(p=rBt(t),p.c(),p.m(e,null)):p&&(p.d(1),p=null),872415232&n[0]&&r!==(r=t[28]+": "+t[29][t[66]]+"%; z-index: "+(t[26]===t[66]?3:2)+";")&&OB(e,"style",r),13&n[0]&&s!==(s=!0===t[2]&&1===t[66]?t[0][0]:t[3])&&OB(e,"aria-valuemin",s),21&n[0]&&o!==(o=!0===t[2]&&0===t[66]?t[0][1]:t[4])&&OB(e,"aria-valuemax",o),1&n[0]&&a!==(a=t[64])&&OB(e,"aria-valuenow",a),11272193&n[0]&&l!==(l=""+(t[18]+t[21](t[64],t[66],t[23](t[64]))+t[19]))&&OB(e,"aria-valuetext",l),64&n[0]&&c!==(c=t[6]?"vertical":"horizontal")&&OB(e,"aria-orientation",c),1024&n[0]&&OB(e,"aria-disabled",t[10]),1024&n[0]&&OB(e,"disabled",t[10]),1024&n[0]&&u!==(u=t[10]?-1:0)&&OB(e,"tabindex",u),83886080&n[0]&&WB(e,"active",t[24]&&t[26]===t[66]),100663296&n[0]&&WB(e,"press",t[25]&&t[26]===t[66])},d(t){t&&_B(e),p&&p.d(),h=!1,nB(d)}}}function lBt(t){let e,n;return{c(){e=MB("span"),OB(e,"class","rangeBar"),OB(e,"style",n=t[28]+": "+t[32](t[29])+"%; "+t[27]+": "+t[33](t[29])+"%;")},m(t,n){TB(t,e,n)},p(t,i){939524096&i[0]&&n!==(n=t[28]+": "+t[32](t[29])+"%; "+t[27]+": "+t[33](t[29])+"%;")&&OB(e,"style",n)},d(t){t&&_B(e)}}}function cBt(t){let e,n;return e=new nBt({props:{values:t[0],min:t[3],max:t[4],step:t[5],range:t[2],vertical:t[6],reversed:t[8],orientationStart:t[28],hoverable:t[9],disabled:t[10],all:t[13],first:t[14],last:t[15],rest:t[16],pipstep:t[12],prefix:t[18],suffix:t[19],formatter:t[20],focus:t[24],percentOf:t[23],moveHandle:t[31],fixFloat:t[30]}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};1&n[0]&&(i.values=t[0]),8&n[0]&&(i.min=t[3]),16&n[0]&&(i.max=t[4]),32&n[0]&&(i.step=t[5]),4&n[0]&&(i.range=t[2]),64&n[0]&&(i.vertical=t[6]),256&n[0]&&(i.reversed=t[8]),268435456&n[0]&&(i.orientationStart=t[28]),512&n[0]&&(i.hoverable=t[9]),1024&n[0]&&(i.disabled=t[10]),8192&n[0]&&(i.all=t[13]),16384&n[0]&&(i.first=t[14]),32768&n[0]&&(i.last=t[15]),65536&n[0]&&(i.rest=t[16]),4096&n[0]&&(i.pipstep=t[12]),262144&n[0]&&(i.prefix=t[18]),524288&n[0]&&(i.suffix=t[19]),1048576&n[0]&&(i.formatter=t[20]),16777216&n[0]&&(i.focus=t[24]),8388608&n[0]&&(i.percentOf=t[23]),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function uBt(t){let e,n,i,r,s,o,a=t[0],l=[];for(let e=0;e<a.length;e+=1)l[e]=aBt(iBt(t,a,e));let c=t[2]&&lBt(t),u=t[11]&&cBt(t);return{c(){e=MB("div");for(let t=0;t<l.length;t+=1)l[t].c();n=AB(),c&&c.c(),i=AB(),u&&u.c(),OB(e,"id",t[17]),OB(e,"class","rangeSlider"),WB(e,"range",t[2]),WB(e,"disabled",t[10]),WB(e,"hoverable",t[9]),WB(e,"vertical",t[6]),WB(e,"reversed",t[8]),WB(e,"focus",t[24]),WB(e,"min","min"===t[2]),WB(e,"max","max"===t[2]),WB(e,"pips",t[11]),WB(e,"pip-labels","label"===t[13]||"label"===t[14]||"label"===t[15]||"label"===t[16])},m(a,h){TB(a,e,h);for(let t=0;t<l.length;t+=1)l[t]&&l[t].m(e,null);SB(e,n),c&&c.m(e,null),SB(e,i),u&&u.m(e,null),t[50](e),r=!0,s||(o=[RB(window,"mousedown",t[39]),RB(window,"touchstart",t[39]),RB(window,"mousemove",t[40]),RB(window,"touchmove",t[40]),RB(window,"mouseup",t[41]),RB(window,"touchend",t[42]),RB(window,"keydown",t[43]),RB(e,"mousedown",t[37]),RB(e,"mouseup",t[38]),RB(e,"touchstart",PB(t[37])),RB(e,"touchend",PB(t[38]))],s=!0)},p(t,s){if(934020317&s[0]|56&s[1]){let i;for(a=t[0],i=0;i<a.length;i+=1){const r=iBt(t,a,i);l[i]?l[i].p(r,s):(l[i]=aBt(r),l[i].c(),l[i].m(e,n))}for(;i<l.length;i+=1)l[i].d(1);l.length=a.length}t[2]?c?c.p(t,s):(c=lBt(t),c.c(),c.m(e,i)):c&&(c.d(1),c=null),t[11]?u?(u.p(t,s),2048&s[0]&&EU(u,1)):(u=cBt(t),u.c(),EU(u,1),u.m(e,null)):u&&(TU(),MU(u,1,1,(()=>{u=null})),_U()),(!r||131072&s[0])&&OB(e,"id",t[17]),(!r||4&s[0])&&WB(e,"range",t[2]),(!r||1024&s[0])&&WB(e,"disabled",t[10]),(!r||512&s[0])&&WB(e,"hoverable",t[9]),(!r||64&s[0])&&WB(e,"vertical",t[6]),(!r||256&s[0])&&WB(e,"reversed",t[8]),(!r||16777216&s[0])&&WB(e,"focus",t[24]),(!r||4&s[0])&&WB(e,"min","min"===t[2]),(!r||4&s[0])&&WB(e,"max","max"===t[2]),(!r||2048&s[0])&&WB(e,"pips",t[11]),(!r||122880&s[0])&&WB(e,"pip-labels","label"===t[13]||"label"===t[14]||"label"===t[15]||"label"===t[16])},i(t){r||(EU(u),r=!0)},o(t){MU(u),r=!1},d(n){n&&_B(e),EB(l,n),c&&c.d(),u&&u.d(),t[50](null),s=!1,nB(o)}}}function hBt(t){if(!t)return-1;for(var e=0;t=t.previousElementSibling;)e++;return e}function dBt(t){return t.type.includes("touch")?t.touches[0]:t}function pBt(t,e,n){let i,r,s,o,a,l,c=Jz;t.$$.on_destroy.push((()=>c()));let{slider:u}=e,{range:h=!1}=e,{pushy:d=!1}=e,{min:p=0}=e,{max:f=100}=e,{step:m=1}=e,{values:g=[(f+p)/2]}=e,{vertical:y=!1}=e,{float:b=!1}=e,{reversed:v=!1}=e,{hoverable:x=!0}=e,{disabled:w=!1}=e,{pips:S=!1}=e,{pipstep:k}=e,{all:C}=e,{first:T}=e,{last:_}=e,{rest:E}=e,{id:M}=e,{prefix:$=""}=e,{suffix:I=""}=e,{formatter:A=((t,e,n)=>t)}=e,{handleFormatter:N=A}=e,{precision:R=2}=e,{springValues:P={stiffness:.15,damping:.4}}=e;const O=iU();let L,D,F,z=0,B=!1,U=!1,V=!1,W=!1,H=g.length-1;const j=t=>parseFloat(t.toFixed(R));function G(){return u.getBoundingClientRect()}function q(t){const e=G();let n=0,i=0,r=0;y?(n=t.clientY-e.top,i=n/e.height*100,i=v?i:100-i):(n=t.clientX-e.left,i=n/e.width*100,i=v?100-i:i),r=(f-p)/100*i+p,X(H,r)}function X(t,e){return e=s(e),void 0===t&&(t=H),h&&(0===t&&e>g[1]?d?n(0,g[1]=e,g):e=g[1]:1===t&&e<g[0]&&(d?n(0,g[0]=e,g):e=g[0])),g[t]!==e&&n(0,g[t]=e,g),D!==e&&(!w&&O("change",{activeHandle:H,startValue:L,previousValue:void 0===D?L:D,value:g[H],values:g.map((t=>s(t)))}),D=e),e}function K(){!w&&O("stop",{activeHandle:H,startValue:L,value:g[H],values:g.map((t=>s(t)))})}return t.$$set=t=>{"slider"in t&&n(1,u=t.slider),"range"in t&&n(2,h=t.range),"pushy"in t&&n(44,d=t.pushy),"min"in t&&n(3,p=t.min),"max"in t&&n(4,f=t.max),"step"in t&&n(5,m=t.step),"values"in t&&n(0,g=t.values),"vertical"in t&&n(6,y=t.vertical),"float"in t&&n(7,b=t.float),"reversed"in t&&n(8,v=t.reversed),"hoverable"in t&&n(9,x=t.hoverable),"disabled"in t&&n(10,w=t.disabled),"pips"in t&&n(11,S=t.pips),"pipstep"in t&&n(12,k=t.pipstep),"all"in t&&n(13,C=t.all),"first"in t&&n(14,T=t.first),"last"in t&&n(15,_=t.last),"rest"in t&&n(16,E=t.rest),"id"in t&&n(17,M=t.id),"prefix"in t&&n(18,$=t.prefix),"suffix"in t&&n(19,I=t.suffix),"formatter"in t&&n(20,A=t.formatter),"handleFormatter"in t&&n(21,N=t.handleFormatter),"precision"in t&&n(45,R=t.precision),"springValues"in t&&n(46,P=t.springValues)},t.$$.update=()=>{24&t.$$.dirty[0]&&n(49,r=function(t){return t<=p?p:t>=f?f:t}),56&t.$$.dirty[0]|262144&t.$$.dirty[1]&&n(48,s=function(t){if(t<=p)return j(p);if(t>=f)return j(f);let e=(t-p)%m,n=t-e;return 2*Math.abs(e)>=m&&(n+=e>0?m:-m),n=r(n),j(n)}),24&t.$$.dirty[0]&&n(23,i=function(t){let e=(t-p)/(f-p)*100;return isNaN(e)||e<=0?0:e>=100?100:j(e)}),12582937&t.$$.dirty[0]|229376&t.$$.dirty[1]&&(Array.isArray(g)||(n(0,g=[(f+p)/2]),console.error("'values' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)")),n(0,g=function(t){return"min"===h||"max"===h?t.slice(0,1):h?t.slice(0,2):t}(g.map((t=>s(t))))),z!==g.length?(n(22,F=Fzt(g.map((t=>i(t))),P)),c(),c=aB(F,(t=>n(29,l=t)))):F.set(g.map((t=>i(t)))),n(47,z=g.length)),320&t.$$.dirty[0]&&n(28,o=y?v?"top":"bottom":v?"right":"left"),320&t.$$.dirty[0]&&n(27,a=y?v?"bottom":"top":v?"left":"right")},[g,u,h,p,f,m,y,b,v,x,w,S,k,C,T,_,E,M,$,I,A,N,F,i,B,V,H,a,o,l,j,X,function(t){return"min"===h?0:t[0]},function(t){return"max"===h?0:"min"===h?100-t[0]:100-t[1]},function(t){W&&(n(24,B=!1),U=!1,n(25,V=!1))},function(t){w||(n(26,H=hBt(t.target)),n(24,B=!0))},function(t){if(!w){const e=hBt(t.target);let n=t.ctrlKey||t.metaKey||t.shiftKey?10*m:m,i=!1;switch(t.key){case"PageDown":n*=10;case"ArrowRight":case"ArrowUp":X(e,g[e]+n),i=!0;break;case"PageUp":n*=10;case"ArrowLeft":case"ArrowDown":X(e,g[e]-n),i=!0;break;case"Home":X(e,p),i=!0;break;case"End":X(e,f),i=!0}i&&(t.preventDefault(),t.stopPropagation())}},function(t){if(!w){const e=t.target,i=dBt(t);n(24,B=!0),U=!0,n(25,V=!0),n(26,H=function(t){const e=G();let n,i=0,r=0,s=0;return y?(i=t.clientY-e.top,r=i/e.height*100,r=v?r:100-r):(i=t.clientX-e.left,r=i/e.width*100,r=v?100-r:r),s=(f-p)/100*r+p,!0===h&&g[0]===g[1]?s>g[1]?1:0:(n=g.indexOf([...g].sort(((t,e)=>Math.abs(s-t)-Math.abs(s-e)))[0]),n)}(i)),L=D=s(g[H]),!w&&O("start",{activeHandle:H,value:L,values:g.map((t=>s(t)))}),"touchstart"!==t.type||e.matches(".pipVal")||q(i)}},function(t){"touchend"===t.type&&K(),n(25,V=!1)},function(t){W=!1,B&&t.target!==u&&!u.contains(t.target)&&n(24,B=!1)},function(t){w||U&&q(dBt(t))},function(t){if(!w){const e=t.target;U&&((e===u||u.contains(e))&&(n(24,B=!0),function(t){const e=u.querySelectorAll(".handle"),n=Array.prototype.includes.call(e,t),i=Array.prototype.some.call(e,(e=>e.contains(t)));return n||i}(e)||e.matches(".pipVal")||q(dBt(t))),K())}U=!1,n(25,V=!1)},function(t){U=!1,n(25,V=!1)},function(t){w||(t.target===u||u.contains(t.target))&&(W=!0)},d,R,P,z,s,r,function(t){aU[t?"unshift":"push"]((()=>{u=t,n(1,u)}))}]}class fBt extends UU{constructor(t){super(),BU(this,t,pBt,uBt,rB,{slider:1,range:2,pushy:44,min:3,max:4,step:5,values:0,vertical:6,float:7,reversed:8,hoverable:9,disabled:10,pips:11,pipstep:12,all:13,first:14,last:15,rest:16,id:17,prefix:18,suffix:19,formatter:20,handleFormatter:21,precision:45,springValues:46},null,[-1,-1,-1])}}function mBt(t){let e,n;return e=new fBt({props:{values:t[12],min:t[13],max:t[14],step:t[15],range:t[5],float:t[6],vertical:t[7],pips:t[8],pipstep:t[9],formatter:t[10],all:"label",springValues:{stiffness:.2,damping:.8}}}),e.$on("stop",t[16]),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};4096&n&&(i.values=t[12]),8192&n&&(i.min=t[13]),16384&n&&(i.max=t[14]),32768&n&&(i.step=t[15]),32&n&&(i.range=t[5]),64&n&&(i.float=t[6]),128&n&&(i.vertical=t[7]),256&n&&(i.pips=t[8]),512&n&&(i.pipstep=t[9]),1024&n&&(i.formatter=t[10]),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function gBt(t){let e,n,i;function r(e){t[17](e)}let s={min:t[13],max:t[14],step:t[15],range:t[5],float:t[6],vertical:t[7],pips:t[8],pipstep:t[9],formatter:t[10],all:"label",springValues:{stiffness:.2,damping:.8}};return void 0!==t[12]&&(s.values=t[12]),e=new fBt({props:s}),aU.push((()=>LU(e,"values",r))),{c(){DU(e.$$.fragment)},m(t,n){FU(e,t,n),i=!0},p(t,i){const r={};8192&i&&(r.min=t[13]),16384&i&&(r.max=t[14]),32768&i&&(r.step=t[15]),32&i&&(r.range=t[5]),64&i&&(r.float=t[6]),128&i&&(r.vertical=t[7]),256&i&&(r.pips=t[8]),512&i&&(r.pipstep=t[9]),1024&i&&(r.formatter=t[10]),!n&&4096&i&&(n=!0,r.values=t[12],mU((()=>n=!1))),e.$set(r)},i(t){i||(EU(e.$$.fragment,t),i=!0)},o(t){MU(e.$$.fragment,t),i=!1},d(t){zU(e,t)}}}function yBt(t){let e,n,i,r;const s=[gBt,mBt],o=[];function a(t,e){return t[11]?0:1}return e=a(t),n=o[e]=s[e](t),{c(){n.c(),i=NB()},m(t,n){o[e].m(t,n),TB(t,i,n),r=!0},p(t,r){let l=e;e=a(t),e===l?o[e].p(t,r):(TU(),MU(o[l],1,1,(()=>{o[l]=null})),_U(),n=o[e],n?n.p(t,r):(n=o[e]=s[e](t),n.c()),EU(n,1),n.m(i.parentNode,i))},i(t){r||(EU(n),r=!0)},o(t){MU(n),r=!1},d(t){o[e].d(t),t&&_B(i)}}}function bBt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[yBt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),327648&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function vBt(t,e,n){let i,r,s,o,a=Jz,l=()=>(a(),a=aB(g,(t=>n(12,i=t))),g),c=Jz,u=()=>(c(),c=aB(y,(t=>n(13,r=t))),y),h=Jz,d=()=>(h(),h=aB(b,(t=>n(14,s=t))),b),p=Jz,f=()=>(p(),p=aB(v,(t=>n(15,o=t))),v);t.$$.on_destroy.push((()=>a())),t.$$.on_destroy.push((()=>c())),t.$$.on_destroy.push((()=>h())),t.$$.on_destroy.push((()=>p()));let{title:m}=e,{values:g}=e;l();let{min:y}=e;u();let{max:b}=e;d();let{step:v}=e;f();let{range:x}=e,{float:w}=e,{vertical:S}=e,{pips:k}=e,{pipstep:C}=e,{formatter:T}=e,{continuous:_}=e;return t.$$set=t=>{"title"in t&&n(0,m=t.title),"values"in t&&l(n(1,g=t.values)),"min"in t&&u(n(2,y=t.min)),"max"in t&&d(n(3,b=t.max)),"step"in t&&f(n(4,v=t.step)),"range"in t&&n(5,x=t.range),"float"in t&&n(6,w=t.float),"vertical"in t&&n(7,S=t.vertical),"pips"in t&&n(8,k=t.pips),"pipstep"in t&&n(9,C=t.pipstep),"formatter"in t&&n(10,T=t.formatter),"continuous"in t&&n(11,_=t.continuous)},[m,g,y,b,v,x,w,S,k,C,T,_,i,r,s,o,function({detail:t}){g.set(t.values)},function(t){i=t,g.set(i)}]}class xBt extends UU{constructor(t){super(),BU(this,t,vBt,bBt,rB,{title:0,values:1,min:2,max:3,step:4,range:5,float:6,vertical:7,pips:8,pipstep:9,formatter:10,continuous:11})}}let wBt=class extends xK{constructor({values:t=[.2],min:e=0,max:n=1,step:i=.01,range:r="min",float:s=!0,vertical:o=!1,pips:a=!1,pipstep:l,formatter:c=(t=>function(t,e){if(void 0===e||0==+e)return Math.round(t);let n=+t;const i=+e;if(isNaN(n)||"number"!=typeof i||i%1!=0)return NaN;let r=n.toString().split("e");return n=Math.round(+(r[0]+"e"+(r[1]?+r[1]+i:i))),r=n.toString().split("e"),+(r[0]+"e"+(r[1]?+r[1]-i:-i))}(t,3)),continuous:u=!0}={}){super(),this.title="slider",this.$values=new eK(t,!0),this.$min=new eK(e,!0),this.$max=new eK(n,!0),this.$step=new eK(i,!0),this.range=r,this.float=s,this.vertical=o,this.pips=a,this.pipstep=void 0!==l?l:Math.floor((n-e)/(10*i)),this.formatter=c,this.continuous=u,this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new xBt({target:e,props:{title:this.title,values:this.$values,min:this.$min,max:this.$max,step:this.$step,range:this.range,float:this.float,vertical:this.vertical,pips:this.pips,pipstep:this.pipstep,formatter:this.formatter,continuous:this.continuous}}))}};function SBt(...t){return new wBt(...t)}function kBt(t){let e,n,i,r;return{c(){e=MB("div"),n=MB("textarea"),OB(n,"class","w-full px-3 py-1.5 text-base font-normal text-gray-700 bg-white bg-clip-padding border border-solid border-gray-300 rounded transition ease-in-out m-0 focus:text-gray-700 focus:bg-white focus:border-blue-600 focus:outline-none svelte-1nngj94"),OB(n,"placeholder",t[2]),n.disabled=t[4],OB(e,"class","w-full svelte-1nngj94")},m(s,o){TB(s,e,o),SB(e,n),FB(n,t[5]),i||(r=RB(n,"input",t[6]),i=!0)},p(t,e){4&e&&OB(n,"placeholder",t[2]),16&e&&(n.disabled=t[4]),32&e&&FB(n,t[5])},d(t){t&&_B(e),i=!1,r()}}}function CBt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[kBt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),180&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function TBt(t,e,n){let i,r,s=Jz,o=()=>(s(),s=aB(d,(t=>n(4,i=t))),d),a=Jz,l=()=>(a(),a=aB(u,(t=>n(5,r=t))),u);t.$$.on_destroy.push((()=>s())),t.$$.on_destroy.push((()=>a()));let{title:c}=e,{value:u}=e;l();let{placeholder:h}=e,{disabled:d}=e;return o(),t.$$set=t=>{"title"in t&&n(0,c=t.title),"value"in t&&l(n(1,u=t.value)),"placeholder"in t&&n(2,h=t.placeholder),"disabled"in t&&o(n(3,d=t.disabled))},[c,u,h,d,i,r,function(){r=this.value,u.set(r)}]}class _Bt extends UU{constructor(t){super(),BU(this,t,TBt,CBt,rB,{title:0,value:1,placeholder:2,disabled:3})}}class EBt extends xK{constructor(t="",e=""){super(),this.title="text area",this.$disabled=new eK(!1,!0),this.$value=new eK(t,!0),this.placeholder=e,this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new _Bt({target:e,props:{title:this.title,value:this.$value,placeholder:this.placeholder,disabled:this.$disabled}}))}}function MBt(...t){return new EBt(...t)}function $Bt(t){let e,n,i,r,s;function o(e){t[5](e)}let a={type:"text",placeholder:"Enter a label..",disabled:t[4]};return void 0!==t[3]&&(a.value=t[3]),i=new qU({props:a}),aU.push((()=>LU(i,"value",o))),{c(){e=MB("div"),n=MB("div"),DU(i.$$.fragment),OB(n,"class","md:flex md:items-center mb-2"),OB(e,"class","w-full max-w-sm")},m(t,r){TB(t,e,r),SB(e,n),FU(i,n,null),s=!0},p(t,e){const n={};16&e&&(n.disabled=t[4]),!r&&8&e&&(r=!0,n.value=t[3],mU((()=>r=!1))),i.$set(n)},i(t){s||(EU(i.$$.fragment,t),s=!0)},o(t){MU(i.$$.fragment,t),s=!1},d(t){t&&_B(e),zU(i)}}}function IBt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[$Bt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),88&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function ABt(t,e,n){let i,r,s=Jz,o=()=>(s(),s=aB(u,(t=>n(3,i=t))),u),a=Jz,l=()=>(a(),a=aB(h,(t=>n(4,r=t))),h);t.$$.on_destroy.push((()=>s())),t.$$.on_destroy.push((()=>a()));let{title:c}=e,{value:u}=e;o();let{disabled:h}=e;return l(),t.$$set=t=>{"title"in t&&n(0,c=t.title),"value"in t&&o(n(1,u=t.value)),"disabled"in t&&l(n(2,h=t.disabled))},[c,u,h,i,r,function(t){i=t,u.set(i)}]}class NBt extends UU{constructor(t){super(),BU(this,t,ABt,IBt,rB,{title:0,value:1,disabled:2})}}class RBt extends xK{constructor(t){super(),this.title="text input",this.$value=new eK("",!0),this.$disabled=new eK(!1,!0),void 0!==t&&this.$value.set(t),this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new NBt({target:e,props:{title:this.title,value:this.$value,disabled:this.$disabled}}))}}function PBt(...t){return new RBt(...t)}function OBt(){const t=new Error("textField has been renamed to textInput");return t.name="Deprecation Notice",cK(t),PBt()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LBt(t){let e;return{c(){e=MB("p"),e.textContent="No model loaded"},m(t,n){TB(t,e,n)},p:Jz,d(t){t&&_B(e)}}}function DBt(t){let e,n,i,r;return{c(){e=MB("p"),n=IB("Model Loaded from "),i=IB(t[2]),r=IB(".")},m(t,s){TB(t,e,s),SB(e,n),SB(e,i),SB(e,r)},p(t,e){4&e&&DB(i,t[2])},d(t){t&&_B(e)}}}function FBt(t){let e;return{c(){e=MB("p"),e.textContent="Loading Model..."},m(t,n){TB(t,e,n)},p:Jz,d(t){t&&_B(e)}}}function zBt(t){let e;function n(t,e){return"loading"===t[3]?FBt:"loaded"===t[3]?DBt:LBt}let i=n(t),r=i(t);return{c(){e=MB("div"),r.c(),OB(e,"class","p-2 text-sm text-gray-600")},m(t,n){TB(t,e,n),r.m(e,null)},p(t,s){i===(i=n(t))&&r?r.p(t,s):(r.d(1),r=i(t),r&&(r.c(),r.m(e,null)))},d(t){t&&_B(e),r.d()}}}function BBt(t){let e,n;return e=new DH({props:{title:t[0],loading:"loading"===t[3],$$slots:{default:[zBt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),8&n&&(i.loading="loading"===t[3]),268&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function UBt(t,e,n){let i,r,s,o=Jz,a=()=>(o(),o=aB(d,(t=>n(7,s=t))),d);var l,c,u;t.$$.on_destroy.push((()=>o()));let{title:h}=e,{training:d}=e;return a(),t.$$set=t=>{"title"in t&&n(0,h=t.title),"training"in t&&a(n(1,d=t.training))},t.$$.update=()=>{128&t.$$.dirty&&n(3,i=s.status),240&t.$$.dirty&&n(2,r=(null===n(4,l=s.data)||void 0===l?void 0:l.source)?"datastore"===s.data.source?`datastore at ${null===n(5,c=s.data)||void 0===c?void 0:c.url}`:"url"===s.data.source?`url ${null===n(6,u=s.data)||void 0===u?void 0:u.url}`:"files":"unknown source")},[h,d,r,i,l,c,u,s]}Lr().prototype.mul=function(t){return this.throwIfDisposed(),Po(this,t)};class VBt extends UU{constructor(t){super(),BU(this,t,UBt,BBt,rB,{title:0,training:1})}}function WBt(t,e){return t===e}function HBt(t,e){return t===e}class jBt extends hnt{constructor({inputType:t,taskType:e,segmentationOptions:n={applyArgmax:!1,output:"image"}}){super(),this.title="tfjs model",this.parameters={},this.segmentationOptions={applyArgmax:!1,output:"image",...n},this.inputType=t,this.taskType=e,this.$training.subscribe((({status:t})=>{"loaded"===t&&(this.inputShape=this.model.inputs[0].shape.map((t=>t&&t>0?t:1)))}))}train(){throw new lK("Model `TfModel` cannot be trained")}async predict(t){if(!this.model||"loaded"!==this.$training.get().status)throw new Error("Model is not loaded");const e=Co((()=>{const e=this.preprocess(t);return this.model.predict(e.expandDims(0)).gather(0)})),n=await this.postprocess(e);return e.dispose(),n}preprocess(t){if(WBt(this.inputType,"image"))return this.preprocessImage(t);if(WBt(this.inputType,"generic"))return xs(t);throw new Error("Invalid input data type")}preprocessImage(t){return Bd.resizeBilinear(Np(t),[this.inputShape[1],this.inputShape[2]])}async postprocess(t){if(HBt(this.taskType,"classification")){const e=this.labels?t=>this.labels[t]:t=>t.toString(),n=Co((()=>t.argMax().dataSync()[0])),i=t.arraySync().reduce(((t,n,i)=>({...t,[e(i)]:n})),{});return{label:e(n),confidences:i}}if(HBt(this.taskType,"segmentation")){const[e,n]=t.shape,i=this.segmentationOptions.applyArgmax?Co((()=>t.argMax(-1).mul(.5))):t,r="image"===this.segmentationOptions.output?new ImageData(await Ap(i),e,n):await i.array();return this.segmentationOptions.applyArgmax&&i.dispose(),r}if(HBt(this.taskType,"generic"))return t.array();throw new Error("Invalid output data type")}async loadFromFiles(t){this.$training.set({status:"loading"}),await Eo();try{const e=t.filter((t=>t.name.includes(".json"))),n=t.filter((t=>t.name.includes(".bin")));if(1!==e.length){const t=new Error("The provided files are not compatible with this model");throw t.name="File upload error",t}if(this.$training.set({status:"loading"}),t.length){const t=await o2(e[0]);this.loadFn="graph-model"===t.format?C4:U7,this.model=await this.loadFn(unt([e[0],...n])),await this.warmup(),this.$training.set({status:"loaded",data:{source:"file"}})}}catch(t){throw this.$training.set({status:"error"}),t}}async loadFromUrl(t){this.$training.set({status:"loading"}),await Eo();try{const e=await fetch(t).then((t=>t.json()));this.loadFn="graph-model"===e.format?C4:U7,this.model=await this.loadFn(cnt(t)),await this.warmup(),this.$training.set({status:"loaded",data:{source:"url",url:t}})}catch(t){throw console.log("[tf-model] Loading error",t),this.$training.set({status:"error"}),t}}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new VBt({target:e,props:{title:this.title,training:this.$training}}))}}function GBt(t){return new jBt(t)}function qBt(t){let e,n,i;function r(e){t[7](e)}let s={disabled:t[5],text:t[6]};return void 0!==t[4]&&(s.checked=t[4]),e=new zV({props:s}),aU.push((()=>LU(e,"checked",r))),{c(){DU(e.$$.fragment)},m(t,n){FU(e,t,n),i=!0},p(t,i){const r={};32&i&&(r.disabled=t[5]),64&i&&(r.text=t[6]),!n&&16&i&&(n=!0,r.checked=t[4],mU((()=>n=!1))),e.$set(r)},i(t){i||(EU(e.$$.fragment,t),i=!0)},o(t){MU(e.$$.fragment,t),i=!1},d(t){zU(e,t)}}}function XBt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[qBt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),368&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function KBt(t,e,n){let i,r,s,o=Jz,a=()=>(o(),o=aB(f,(t=>n(4,i=t))),f),l=Jz,c=()=>(l(),l=aB(m,(t=>n(5,r=t))),m),u=Jz,h=()=>(u(),u=aB(p,(t=>n(6,s=t))),p);t.$$.on_destroy.push((()=>o())),t.$$.on_destroy.push((()=>l())),t.$$.on_destroy.push((()=>u()));let{title:d}=e,{text:p}=e;h();let{checked:f}=e;a();let{disabled:m}=e;return c(),t.$$set=t=>{"title"in t&&n(0,d=t.title),"text"in t&&h(n(1,p=t.text)),"checked"in t&&a(n(2,f=t.checked)),"disabled"in t&&c(n(3,m=t.disabled))},[d,p,f,m,i,r,s,function(t){i=t,f.set(i)}]}UX([aK],jBt.prototype,"train",null),UX([aK],jBt.prototype,"predict",null),UX([aK],jBt.prototype,"preprocess",null),UX([aK],jBt.prototype,"preprocessImage",null),UX([aK],jBt.prototype,"postprocess",null),UX([aK],jBt.prototype,"loadFromFiles",null),UX([aK],jBt.prototype,"loadFromUrl",null);class YBt extends UU{constructor(t){super(),BU(this,t,KBt,XBt,rB,{title:0,text:1,checked:2,disabled:3})}}class ZBt extends xK{constructor(t="toggle me"){super(),this.title="toggle",this.$checked=new eK(!1,!0),this.$disabled=new eK(!1,!0),this.$text=new eK(t,!0),this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new YBt({target:e,props:{title:this.title,text:this.$text,checked:this.$checked,disabled:this.$disabled}}))}}function JBt(...t){return new ZBt(...t)}function QBt(t){let e;return{c(){e=MB("div"),e.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v18"></path></svg> \n    <p>Select one or several runs to display information</p>',OB(e,"class","empty svelte-yj1ygt")},m(t,n){TB(t,e,n)},p:Jz,i:Jz,o:Jz,d(t){t&&_B(e)}}}function tUt(t){let e,n;return e=new TH({props:{columns:[{name:"field"},...t[2]],provider:t[1],selectable:!1}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};4&n&&(i.columns=[{name:"field"},...t[2]]),2&n&&(i.provider=t[1]),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function eUt(t){let e,n,i,r;const s=[tUt,QBt],o=[];function a(t,e){return t[0].length>0?0:1}return e=a(t),n=o[e]=s[e](t),{c(){n.c(),i=NB()},m(t,n){o[e].m(t,n),TB(t,i,n),r=!0},p(t,[r]){let l=e;e=a(t),e===l?o[e].p(t,r):(TU(),MU(o[l],1,1,(()=>{o[l]=null})),_U(),n=o[e],n?n.p(t,r):(n=o[e]=s[e](t),n.c()),EU(n,1),n.m(i.parentNode,i))},i(t){r||(EU(n),r=!0)},o(t){MU(n),r=!1},d(t){o[e].d(t),t&&_B(i)}}}function nUt(t,e,n){let i,r,s,o,{runs:a}=e;return t.$$set=t=>{"runs"in t&&n(0,a=t.runs)},t.$$.update=()=>{1&t.$$.dirty&&n(2,i=a.map(((t,e)=>({name:`Run ${e+1}`})))),1&t.$$.dirty&&n(4,r=a.length>0?Object.keys(a[0]).filter((t=>"logs"!==t)):[]),17&t.$$.dirty&&n(3,s=r.map((t=>a.map(((e,n)=>({[`Run ${n+1}`]:e[t]}))).reduce(((t,e)=>({...t,...e})),{field:t})))),8&t.$$.dirty&&n(1,o=new AH({data:s}))},[a,o,i,s,r]}class iUt extends UU{constructor(t){super(),BU(this,t,nUt,eUt,rB,{runs:0})}}function rUt(t,e,n){const i=t.slice();return i[5]=e[n],i[6]=e,i[7]=n,i}function sUt(t){let e,n=t[7];const i=()=>t[3](e,n),r=()=>t[3](null,n);return{c(){e=MB("div"),OB(e,"class","card inner-card xl:flex-1 svelte-1o4ebpu")},m(t,n){TB(t,e,n),i()},p(e,s){n!==(t=e)[7]&&(r(),n=t[7],i())},d(t){t&&_B(e),r()}}}function oUt(t){let e,n=Object.values(t[0]),i=[];for(let e=0;e<n.length;e+=1)i[e]=sUt(rUt(t,n,e));return{c(){e=MB("div");for(let t=0;t<i.length;t+=1)i[t].c();OB(e,"class","grid grid-cols-1 gap-1")},m(n,r){TB(n,e,r);for(let t=0;t<i.length;t+=1)i[t]&&i[t].m(e,null);t[4](e)},p(t,[r]){if(5&r){let s;for(n=Object.values(t[0]),s=0;s<n.length;s+=1){const o=rUt(t,n,s);i[s]?i[s].p(o,r):(i[s]=sUt(o),i[s].c(),i[s].m(e,null))}for(;s<i.length;s+=1)i[s].d(1);i.length=n.length}},i:Jz,o:Jz,d(n){n&&_B(e),EB(i,n),t[4](null)}}}function aUt(t,e,n){let i,{charts:r}=e,s=[];return tU((async()=>{await pU(),await pU(),Object.keys(r).length>1&&i.clientWidth>700&&n(1,i.style.gridTemplateColumns="repeat(2, minmax(0, 1fr))",i);for(const[t,e]of Object.values(r).entries())e.mount(s[t])})),nU((()=>{for(const t of Object.values(r))t.destroy()})),t.$$set=t=>{"charts"in t&&n(0,r=t.charts)},[r,i,s,function(t,e){aU[t?"unshift":"push"]((()=>{s[e]=t,n(2,s)}))},function(t){aU[t?"unshift":"push"]((()=>{i=t,n(1,i)}))}]}class lUt extends UU{constructor(t){super(),BU(this,t,aUt,oUt,rB,{charts:0})}}class cUt extends xK{constructor(t,e={loss:["loss","lossVal"],accuracy:["acc","accVal"]}){if(super(),this.model=t,this.title="training plot",this.charts={},!t){const t=new Error("[training plot] No model was provided");t.name="Component Compatibility Error",cK(t)}if(!t.$training){const t=new Error("[training plot] The provided model is incompatible with the training plot component, missing `$training` stream");t.name="Component Compatibility Error",cK(t)}let n=e;"string"==typeof e&&(n=[e]),Array.isArray(n)&&(n=n.reduce(((t,e)=>({...t,[e]:e})),{}));const i={};for(const[t,e]of Object.entries(n)){const n=Array.isArray(e)?e:[e];this.charts[t]=umt({preset:"line-fast",options:{xlabel:"Epoch",ylabel:t}});for(const e of n)Object.keys(i).includes(e)||(i[e]=new eK([],!0)),this.charts[t].addSeries(i[e],e);this.charts[t].title=t}t.$training.subscribe((t=>{if("start"===t.status)!function(){for(const t of Object.values(i))t.set([])}();else if(t.data)for(const[e,n]of Object.entries(t.data)){if(!Object.keys(i).includes(e))return;Array.isArray(n)?i[e].set(n.map(((t,e)=>({x:e+1,y:t})))):i[e].set(i[e].get().concat([{x:i[e].get().length+1,y:n}]))}})),this.start()}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new lUt({target:e,props:{charts:this.charts}}))}}function uUt(...t){return new cUt(...t)}function hUt(t){let e;return{c(){e=MB("div"),e.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v18"></path></svg> \n    <p>Select one or several runs to display information</p>',OB(e,"class","empty svelte-yj1ygt")},m(t,n){TB(t,e,n)},p:Jz,d(t){t&&_B(e)}}}function dUt(t){let e;return{c(){e=MB("div")},m(n,i){TB(n,e,i),t[7](e)},p:Jz,d(n){n&&_B(e),t[7](null)}}}function pUt(t){let e;function n(t,e){return t[0].length>0?dUt:hUt}let i=n(t),r=i(t);return{c(){r.c(),e=NB()},m(t,n){r.m(t,n),TB(t,e,n)},p(t,[s]){i===(i=n(t))&&r?r.p(t,s):(r.d(1),r=i(t),r&&(r.c(),r.m(e.parentNode,e)))},i:Jz,o:Jz,d(t){r.d(t),t&&_B(e)}}}function fUt(t,e,n){let i,r,s,o,a,{names:l}=e,{logs:c}=e;return nU((()=>{a&&a.destroy()})),t.$$set=t=>{"names"in t&&n(2,l=t.names),"logs"in t&&n(0,c=t.logs)},t.$$.update=()=>{9&t.$$.dirty&&(n(3,o=Array.from(new Set(c.map(Object.keys).flat()))),o.sort()),5&t.$$.dirty&&n(6,i=c.map(((t,e)=>Object.entries(t).reduce(((t,[n,i])=>({...t,[`${n} (${l[e]})`]:i})),{}))).reduce(((t,e)=>({...t,...e})),{})),72&t.$$.dirty&&n(5,r=o.reduce(((t,e)=>({...t,[e]:Object.keys(i).filter((t=>t.startsWith(`${e} (`)))})),{})),114&t.$$.dirty&&(a&&a.destroy(),n(4,a=uUt({$training:new eK({status:"success",data:i},!0)},r)),a.mount(s))},[c,s,l,o,a,r,i,function(t){aU[t?"unshift":"push"]((()=>{s=t,n(1,s)}))}]}class mUt extends UU{constructor(t){super(),BU(this,t,fUt,pUt,rB,{names:2,logs:0})}}function gUt(t,e,n){const i=t.slice();return i[13]=e[n],i[15]=n,i}function yUt(t){let e;return{c(){e=IB("Graphs")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function bUt(t){let e;return{c(){e=IB("Metadata")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function vUt(t){let e;return{c(){e=IB("Parameters")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function xUt(t){let e;return{c(){e=IB("Model Summary")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function wUt(t){let e,n,i,r,s,o,a,l;return e=new XV({props:{$$slots:{default:[yUt]},$$scope:{ctx:t}}}),i=new XV({props:{$$slots:{default:[bUt]},$$scope:{ctx:t}}}),s=new XV({props:{$$slots:{default:[vUt]},$$scope:{ctx:t}}}),a=new XV({props:{$$slots:{default:[xUt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment),n=AB(),DU(i.$$.fragment),r=AB(),DU(s.$$.fragment),o=AB(),DU(a.$$.fragment)},m(t,c){FU(e,t,c),TB(t,n,c),FU(i,t,c),TB(t,r,c),FU(s,t,c),TB(t,o,c),FU(a,t,c),l=!0},p(t,n){const r={};65536&n&&(r.$$scope={dirty:n,ctx:t}),e.$set(r);const o={};65536&n&&(o.$$scope={dirty:n,ctx:t}),i.$set(o);const l={};65536&n&&(l.$$scope={dirty:n,ctx:t}),s.$set(l);const c={};65536&n&&(c.$$scope={dirty:n,ctx:t}),a.$set(c)},i(t){l||(EU(e.$$.fragment,t),EU(i.$$.fragment,t),EU(s.$$.fragment,t),EU(a.$$.fragment,t),l=!0)},o(t){MU(e.$$.fragment,t),MU(i.$$.fragment,t),MU(s.$$.fragment,t),MU(a.$$.fragment,t),l=!1},d(t){zU(e,t),t&&_B(n),zU(i,t),t&&_B(r),zU(s,t),t&&_B(o),zU(a,t)}}}function SUt(t){let e,n;return e=new mUt({props:{logs:t[4].map(AUt),names:t[4].map(NUt)}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};16&n&&(i.logs=t[4].map(AUt)),16&n&&(i.names=t[4].map(NUt)),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function kUt(t){let e,n;return e=new iUt({props:{runs:t[4]}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};16&n&&(i.runs=t[4]),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function CUt(t){let e,n;return e=new iUt({props:{runs:t[4].map(RUt)}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};16&n&&(i.runs=t[4].map(RUt)),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function TUt(t){let e,n,i,r,s,o,a,l,c,u,h=t[15]+1+"",d=t[13]+"";return{c(){e=MB("div"),n=MB("h2"),i=IB("Model "),r=IB(h),s=AB(),o=MB("div"),a=MB("pre"),l=IB(d),c=MB("br"),u=AB(),OB(o,"class","summary svelte-y4izzs")},m(t,h){TB(t,e,h),SB(e,n),SB(n,i),SB(n,r),SB(e,s),SB(e,o),SB(o,a),SB(a,l),SB(a,c),SB(e,u)},p(t,e){16&e&&d!==(d=t[13]+"")&&DB(l,d)},d(t){t&&_B(e)}}}function _Ut(t){let e,n=t[4].map(PUt),i=[];for(let e=0;e<n.length;e+=1)i[e]=TUt(gUt(t,n,e));return{c(){e=MB("div");for(let t=0;t<i.length;t+=1)i[t].c();OB(e,"class","summaries svelte-y4izzs")},m(t,n){TB(t,e,n);for(let t=0;t<i.length;t+=1)i[t]&&i[t].m(e,null)},p(t,r){if(16&r){let s;for(n=t[4].map(PUt),s=0;s<n.length;s+=1){const o=gUt(t,n,s);i[s]?i[s].p(o,r):(i[s]=TUt(o),i[s].c(),i[s].m(e,null))}for(;s<i.length;s+=1)i[s].d(1);i.length=n.length}},d(t){t&&_B(e),EB(i,t)}}}function EUt(t){let e,n,i,r,s,o,a,l,c,u;return e=new MH({props:{$$slots:{default:[wUt]},$$scope:{ctx:t}}}),i=new JV({props:{$$slots:{default:[SUt]},$$scope:{ctx:t}}}),s=new JV({props:{$$slots:{default:[kUt]},$$scope:{ctx:t}}}),a=new JV({props:{$$slots:{default:[CUt]},$$scope:{ctx:t}}}),c=new JV({props:{$$slots:{default:[_Ut]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment),n=AB(),DU(i.$$.fragment),r=AB(),DU(s.$$.fragment),o=AB(),DU(a.$$.fragment),l=AB(),DU(c.$$.fragment)},m(t,h){FU(e,t,h),TB(t,n,h),FU(i,t,h),TB(t,r,h),FU(s,t,h),TB(t,o,h),FU(a,t,h),TB(t,l,h),FU(c,t,h),u=!0},p(t,n){const r={};65536&n&&(r.$$scope={dirty:n,ctx:t}),e.$set(r);const o={};65552&n&&(o.$$scope={dirty:n,ctx:t}),i.$set(o);const l={};65552&n&&(l.$$scope={dirty:n,ctx:t}),s.$set(l);const u={};65552&n&&(u.$$scope={dirty:n,ctx:t}),a.$set(u);const h={};65552&n&&(h.$$scope={dirty:n,ctx:t}),c.$set(h)},i(t){u||(EU(e.$$.fragment,t),EU(i.$$.fragment,t),EU(s.$$.fragment,t),EU(a.$$.fragment,t),EU(c.$$.fragment,t),u=!0)},o(t){MU(e.$$.fragment,t),MU(i.$$.fragment,t),MU(s.$$.fragment,t),MU(a.$$.fragment,t),MU(c.$$.fragment,t),u=!1},d(t){zU(e,t),t&&_B(n),zU(i,t),t&&_B(r),zU(s,t),t&&_B(o),zU(a,t),t&&_B(l),zU(c,t)}}}function MUt(t){let e,n,i,r,s,o,a;function l(e){t[10](e)}let c={columns:t[7],provider:t[6],actions:[...t[1].map(IUt),{name:"delete",confirm:!0}]};return void 0!==t[4]&&(c.selection=t[4]),e=new TH({props:c}),aU.push((()=>LU(e,"selection",l))),t[11](e),e.$on("select",t[12]),o=new jV({props:{$$slots:{default:[EUt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment),i=AB(),r=MB("br"),s=AB(),DU(o.$$.fragment)},m(t,n){FU(e,t,n),TB(t,i,n),TB(t,r,n),TB(t,s,n),FU(o,t,n),a=!0},p(t,i){const r={};2&i&&(r.actions=[...t[1].map(IUt),{name:"delete",confirm:!0}]),!n&&16&i&&(n=!0,r.selection=t[4],mU((()=>n=!1))),e.$set(r);const s={};65552&i&&(s.$$scope={dirty:i,ctx:t}),o.$set(s)},i(t){a||(EU(e.$$.fragment,t),EU(o.$$.fragment,t),a=!0)},o(t){MU(e.$$.fragment,t),MU(o.$$.fragment,t),a=!1},d(n){t[11](null),zU(e,n),n&&_B(i),n&&_B(r),n&&_B(s),zU(o,n)}}}function $Ut(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[MUt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),65562&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}const IUt=t=>"string"==typeof t?{name:t}:t,AUt=t=>t.logs,NUt=t=>t.name,RUt=t=>t.params,PUt=t=>t.model?.summary||"No summary available";function OUt(t,e,n){let i,r=Jz,s=()=>(r(),r=aB(u,(t=>n(4,i=t))),u);t.$$.on_destroy.push((()=>r()));let{title:o}=e,{service:a}=e,{metrics:l}=e,{actions:c}=e,{selection:u}=e;s();const h=iU(),d=new NH({service:a,transform:{...l.reduce(((t,e)=>({...t,[e]:t=>e in t.logs?t.logs[e][t.logs[e].length-1]:"metrics not found"})),{}),...c.reduce(((t,e)=>({...t,["string"==typeof e?e:e.name]:()=>"string"==typeof e?e:e.name})),{})}});d.data.subscribe((()=>{u.set([])}));const p=[{name:"name",sortable:!0},{name:"start",sortable:!0,type:"date"},...l.map((t=>({name:t}))),{name:"epochs"},{name:"status"},...c.map((t=>({name:"string"==typeof t?t:t.name,type:"action"})))];let f;tU((async()=>{await pU(),await pU();for(const t of c){const e="string"==typeof t?t:t.name;f.$on(e,(({detail:t})=>{h(e,t)}))}}));return t.$$set=t=>{"title"in t&&n(0,o=t.title),"service"in t&&n(8,a=t.service),"metrics"in t&&n(9,l=t.metrics),"actions"in t&&n(1,c=t.actions),"selection"in t&&s(n(2,u=t.selection))},[o,c,u,f,i,h,d,p,a,l,function(t){i=t,u.set(i)},function(t){aU[t?"unshift":"push"]((()=>{f=t,n(3,f)}))},({detail:t})=>h("load",t)]}class LUt extends UU{constructor(t){super(),BU(this,t,OUt,$Ut,rB,{title:0,service:8,metrics:9,actions:1,selection:2})}}function DUt(t,e){const n={...t};for(const[t,i]of Object.entries(e))n[t]=(n[t]||[]).concat([i]);return n}const FUt={metrics:["accuracy","accuracyVal","loss","lossVal"],actions:[]};class zUt extends xK{constructor(t,e={}){super(),this.dataStore=t,this.title="Training History",this.$selection=new eK([],!0),this.$actions=new eK(null).skip(1),this.ready=Promise.resolve(),this.stopTracking=ZX,this.lock=Promise.resolve(),this.options={...FUt,...e},this.lock=this.lock.then(ZX),this.start(),this.ready=this.ready.then((()=>this.dataStore.connect())).then((()=>{this.runService=this.dataStore.service("runs")})).catch((()=>{sK.log("[dataset] dataStore connection failed")}))}track(t,e="anonymous"){return this.ready.then((()=>(this.stopTracking(),this.model=t,this.modelName=e,this.runService.find({query:{basename:e,$sort:{createdAt:-1},$select:["name"],$limit:1}})))).then((({data:t})=>t.length>0?parseInt(t[0].name.split(`${e}-`)[1])+1:1)).then((t=>{this.nextIndex=t,this.crtRun=null,this.stopTracking=this.model?this.model.$training.subscribe(this.trackTrainingStream):ZX})),this}async trackTrainingStream(t){if("start"===t.status)this.crtRun=await this.runService.create({name:`${this.modelName}-${this.nextIndex++}`,basename:this.modelName,start:new Date(Date.now()).toISOString(),source:"js",status:t.status,epochs:t.epochs,params:Object.entries(this.model.parameters).map((([t,e])=>({[t]:e.get()}))).reduce(((t,e)=>({...t,...e})),{}),logs:{}});else if("epoch"===t.status)this.runService.patch(this.crtRun.id,{status:t.status,epoch:t.epoch,logs:DUt(this.crtRun.logs,t.data)});else if("success"===t.status){const e=await this.model.save(this.dataStore,this.modelName,{});this.runService.patch(this.crtRun.id,{status:t.status,epoch:t.epoch,logs:t.data,checkpoints:(this.crtRun.checkpoints||[]).concat([{id:e,name:`${this.crtRun.name}@final`,service:this.model.serviceName}])})}else"error"===t.status&&this.runService.patch(this.crtRun.id,{status:t.status})}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.ready.then((()=>{this.$$.app=new LUt({target:e,props:{title:this.title,service:this.runService,metrics:this.options.metrics,actions:this.options.actions,selection:this.$selection}});for(const t of this.options.actions){const e="string"==typeof t?t:t.name;this.$$.app.$on(e,(({detail:t})=>{this.$actions.set({name:e,data:t})}))}})))}}var BUt;function UUt(...t){return new zUt(...t)}UX([(BUt="lock",function(t,e,n){const i=n.value;return n.value=function(...t){const e=this[BUt].then((()=>i.apply(this,t)));return this[BUt]=e,e},n})],zUt.prototype,"trackTrainingStream",null);var VUt={},WUt={},HUt={},jUt={},GUt=Ti&&Ti.__values||function(t){var e="function"==typeof Symbol&&t[Symbol.iterator],n=0;return e?e.call(t):{next:function(){return t&&n>=t.length&&(t=void 0),{value:t&&t[n++],done:!t}}}};function qUt(t,e){return Math.floor(e()*t)}function XUt(t){for(var e=[],n=0;n<t;n++)e.push(void 0);return e}function KUt(t,e){return XUt(t).map((function(){return e}))}function YUt(t){return KUt(t,0)}function ZUt(t){return t.reduce((function(t,e){return t+e}))}Object.defineProperty(jUt,"__esModule",{value:!0}),jUt.tauRandInt=qUt,jUt.tauRand=function(t){return t()},jUt.norm=function(t){var e,n,i=0;try{for(var r=GUt(t),s=r.next();!s.done;s=r.next()){var o=s.value;i+=Math.pow(o,2)}}catch(t){e={error:t}}finally{try{s&&!s.done&&(n=r.return)&&n.call(r)}finally{if(e)throw e.error}}return Math.sqrt(i)},jUt.empty=XUt,jUt.range=function(t){return XUt(t).map((function(t,e){return e}))},jUt.filled=KUt,jUt.zeros=YUt,jUt.ones=function(t){return KUt(t,1)},jUt.linear=function(t,e,n){return XUt(n).map((function(i,r){return t+r*((e-t)/(n-1))}))},jUt.sum=ZUt,jUt.mean=function(t){return ZUt(t)/t.length},jUt.max=function(t){for(var e=0,n=0;n<t.length;n++)e=t[n]>e?t[n]:e;return e},jUt.max2d=function(t){for(var e=0,n=0;n<t.length;n++)for(var i=0;i<t[n].length;i++)e=t[n][i]>e?t[n][i]:e;return e},jUt.rejectionSample=function(t,e,n){for(var i=YUt(t),r=0;r<t;r++)for(var s=!0;s;){for(var o=qUt(e,n),a=!1,l=0;l<r;l++)if(o===i[l]){a=!0;break}a||(s=!1),i[r]=o}return i},jUt.reshape2d=function(t,e,n){var i=[],r=0;if(t.length!==e*n)throw new Error("Array dimensions must match input length.");for(var s=0;s<e;s++){for(var o=[],a=0;a<n;a++)o.push(t[r]),r+=1;i.push(o)}return i};var JUt=Ti&&Ti.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e};Object.defineProperty(HUt,"__esModule",{value:!0});var QUt=JUt(jUt);function tVt(t,e){var n=function(n){return QUt.empty(t).map((function(){return QUt.filled(e,n)}))},i=[];return i.push(n(-1)),i.push(n(1/0)),i.push(n(0)),i}function eVt(t,e,n,i,r){e=Math.floor(e);var s=t[0][e],o=t[1][e];if(t[2][e],n>=o[0])return 0;for(var a=0;a<s.length;a++)if(i===s[a])return 0;return nVt(t,e,n,i,r)}function nVt(t,e,n,i,r){var s=t[0][e],o=t[1][e],a=t[2][e];if(n>=o[0])return 0;o[0]=n,s[0]=i,a[0]=r;for(var l=0,c=0;;){var u=2*l+1,h=u+1,d=t[0][0].length;if(u>=d)break;if(h>=d){if(!(o[u]>n))break;c=u}else if(o[u]>=o[h]){if(!(n<o[u]))break;c=u}else{if(!(n<o[h]))break;c=h}o[l]=o[c],s[l]=s[c],a[l]=a[c],l=c}return o[l]=n,s[l]=i,a[l]=r,1}function iVt(t,e,n,i){for(;2*i+1<n;){var r=2*i+1,s=r+1,o=i;if(t[o]<t[r]&&(o=r),s<n&&t[o]<t[s]&&(o=s),o===i)break;var a=t[i];t[i]=t[o],t[o]=a;var l=e[i];e[i]=e[o],e[o]=l,i=o}}HUt.makeHeap=tVt,HUt.rejectionSample=function(t,e,n){for(var i=QUt.zeros(t),r=0;r<t;r++){for(var s=!0,o=0;s;){o=QUt.tauRandInt(e,n);for(var a=!1,l=0;l<r;l++)if(o===i[l]){a=!0;break}a||(s=!1)}i[r]=o}return i},HUt.heapPush=eVt,HUt.uncheckedHeapPush=nVt,HUt.buildCandidates=function(t,e,n,i,r){for(var s=tVt(e,i),o=0;o<e;o++)for(var a=0;a<n;a++)if(!(t[0][o][a]<0)){var l=t[0][o][a],c=t[2][o][a],u=QUt.tauRand(r);eVt(s,o,u,l,c),eVt(s,l,u,o,c),t[2][o][a]=0}return s},HUt.deheapSort=function(t){for(var e=t[0],n=t[1],i=0;i<e.length;i++)for(var r=e[i],s=n[i],o=0;o<r.length-1;o++){var a=r.length-o-1,l=s.length-o-1,c=r[0];r[0]=r[a],r[a]=c;var u=s[0];s[0]=s[l],s[l]=u,iVt(s,r,l,0)}return{indices:e,weights:n}},HUt.smallestFlagged=function(t,e){for(var n=t[0][e],i=t[1][e],r=t[2][e],s=1/0,o=-1,a=0;a>n.length;a++)1===r[a]&&i[a]<s&&(s=i[a],o=a);return o>=0?(r[o]=0,Math.floor(n[o])):-1};var rVt,sVt={},oVt=Ti&&Ti.__read||function(t,e){var n="function"==typeof Symbol&&t[Symbol.iterator];if(!n)return t;var i,r,s=n.call(t),o=[];try{for(;(void 0===e||e-- >0)&&!(i=s.next()).done;)o.push(i.value)}catch(t){r={error:t}}finally{try{i&&!i.done&&(n=s.return)&&n.call(s)}finally{if(r)throw r.error}}return o},aVt=Ti&&Ti.__values||function(t){var e="function"==typeof Symbol&&t[Symbol.iterator],n=0;return e?e.call(t):{next:function(){return t&&n>=t.length&&(t=void 0),{value:t&&t[n++],done:!t}}}},lVt=Ti&&Ti.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e};Object.defineProperty(sVt,"__esModule",{value:!0});var cVt=lVt(jUt),uVt=function(){function t(t,e,n,i){if(this.entries=new Map,this.nRows=0,this.nCols=0,t.length!==e.length||t.length!==n.length)throw new Error("rows, cols and values arrays must all have the same length");this.nRows=i[0],this.nCols=i[1];for(var r=0;r<n.length;r++){var s=t[r],o=e[r];this.checkDims(s,o);var a=this.makeKey(s,o);this.entries.set(a,{value:n[r],row:s,col:o})}}return t.prototype.makeKey=function(t,e){return t+":"+e},t.prototype.checkDims=function(t,e){if(!(t<this.nRows&&e<this.nCols))throw new Error("row and/or col specified outside of matrix dimensions")},t.prototype.set=function(t,e,n){this.checkDims(t,e);var i=this.makeKey(t,e);this.entries.has(i)?this.entries.get(i).value=n:this.entries.set(i,{value:n,row:t,col:e})},t.prototype.get=function(t,e,n){void 0===n&&(n=0),this.checkDims(t,e);var i=this.makeKey(t,e);return this.entries.has(i)?this.entries.get(i).value:n},t.prototype.getAll=function(t){void 0===t&&(t=!0);var e=[];return this.entries.forEach((function(t){e.push(t)})),t&&e.sort((function(t,e){return t.row===e.row?t.col-e.col:t.row-e.row})),e},t.prototype.getDims=function(){return[this.nRows,this.nCols]},t.prototype.getRows=function(){return Array.from(this.entries,(function(t){var e=oVt(t,2);return e[0],e[1].row}))},t.prototype.getCols=function(){return Array.from(this.entries,(function(t){var e=oVt(t,2);return e[0],e[1].col}))},t.prototype.getValues=function(){return Array.from(this.entries,(function(t){var e=oVt(t,2);return e[0],e[1].value}))},t.prototype.forEach=function(t){this.entries.forEach((function(e){return t(e.value,e.row,e.col)}))},t.prototype.map=function(e){var n=[];this.entries.forEach((function(t){n.push(e(t.value,t.row,t.col))}));var i=[this.nRows,this.nCols];return new t(this.getRows(),this.getCols(),n,i)},t.prototype.toArray=function(){var t=this,e=cVt.empty(this.nRows).map((function(){return cVt.zeros(t.nCols)}));return this.entries.forEach((function(t){e[t.row][t.col]=t.value})),e},t}();sVt.SparseMatrix=uVt,sVt.transpose=function(t){var e=[],n=[],i=[];t.forEach((function(t,r,s){e.push(r),n.push(s),i.push(t)}));var r=[t.nCols,t.nRows];return new uVt(n,e,i,r)},sVt.identity=function(t){for(var e=oVt(t,1)[0],n=new uVt([],[],[],t),i=0;i<e;i++)n.set(i,i,1);return n},sVt.pairwiseMultiply=function(t,e){return dVt(t,e,(function(t,e){return t*e}))},sVt.add=function(t,e){return dVt(t,e,(function(t,e){return t+e}))},sVt.subtract=function(t,e){return dVt(t,e,(function(t,e){return t-e}))},sVt.maximum=function(t,e){return dVt(t,e,(function(t,e){return t>e?t:e}))},sVt.multiplyScalar=function(t,e){return t.map((function(t){return t*e}))},sVt.eliminateZeros=function(t){for(var e=new Set,n=t.getValues(),i=t.getRows(),r=t.getCols(),s=0;s<n.length;s++)0===n[s]&&e.add(s);var o=function(t,n){return!e.has(n)},a=n.filter(o),l=i.filter(o),c=r.filter(o);return new uVt(l,c,a,t.getDims())},sVt.normalize=function(t,e){var n,i;void 0===e&&(e="l2");var r=hVt[e],s=new Map;t.forEach((function(t,e,n){var i=s.get(e)||[];i.push(n),s.set(e,i)}));var o=new uVt([],[],[],t.getDims()),a=function(e){for(var n=s.get(e).sort(),i=n.map((function(n){return t.get(e,n)})),a=r(i),l=0;l<a.length;l++)o.set(e,n[l],a[l])};try{for(var l=aVt(s.keys()),c=l.next();!c.done;c=l.next()){a(c.value)}}catch(t){n={error:t}}finally{try{c&&!c.done&&(i=l.return)&&i.call(l)}finally{if(n)throw n.error}}return o};var hVt=((rVt={}).max=function(t){for(var e=-1/0,n=0;n<t.length;n++)e=t[n]>e?t[n]:e;return t.map((function(t){return t/e}))},rVt.l1=function(t){for(var e=0,n=0;n<t.length;n++)e+=t[n];return t.map((function(t){return t/e}))},rVt.l2=function(t){for(var e=0,n=0;n<t.length;n++)e+=Math.pow(t[n],2);return t.map((function(t){return Math.sqrt(Math.pow(t,2)/e)}))},rVt);function dVt(t,e,n){for(var i=new Set,r=[],s=[],o=[],a=function(i,a){r.push(i),s.push(a);var l=n(t.get(i,a),e.get(i,a));o.push(l)},l=t.getValues(),c=t.getRows(),u=t.getCols(),h=0;h<l.length;h++){var d=(g=c[h])+":"+(y=u[h]);i.add(d),a(g,y)}var p=e.getValues(),f=e.getRows(),m=e.getCols();for(h=0;h<p.length;h++){var g,y;d=(g=f[h])+":"+(y=m[h]);i.has(d)||a(g,y)}var b=[t.nRows,t.nCols];return new uVt(r,s,o,b)}sVt.getCSR=function(t){var e=[];t.forEach((function(t,n,i){e.push({value:t,row:n,col:i})})),e.sort((function(t,e){return t.row===e.row?t.col-e.col:t.row-e.row}));for(var n=[],i=[],r=[],s=-1,o=0;o<e.length;o++){var a=e[o],l=a.row,c=a.col,u=a.value;l!==s&&(s=l,r.push(o)),n.push(c),i.push(u)}return{indices:n,values:i,indptr:r}};var pVt={},fVt={},mVt=Ti&&Ti.__read||function(t,e){var n="function"==typeof Symbol&&t[Symbol.iterator];if(!n)return t;var i,r,s=n.call(t),o=[];try{for(;(void 0===e||e-- >0)&&!(i=s.next()).done;)o.push(i.value)}catch(t){r={error:t}}finally{try{i&&!i.done&&(n=s.return)&&n.call(s)}finally{if(r)throw r.error}}return o},gVt=Ti&&Ti.__spread||function(){for(var t=[],e=0;e<arguments.length;e++)t=t.concat(mVt(arguments[e]));return t},yVt=Ti&&Ti.__values||function(t){var e="function"==typeof Symbol&&t[Symbol.iterator],n=0;return e?e.call(t):{next:function(){return t&&n>=t.length&&(t=void 0),{value:t&&t[n++],done:!t}}}},bVt=Ti&&Ti.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e};Object.defineProperty(fVt,"__esModule",{value:!0});var vVt=bVt(jUt),xVt=function(t,e,n,i){this.hyperplanes=t,this.offsets=e,this.children=n,this.indices=i};function wVt(t,e,n,i,r){if(void 0===n&&(n=30),e.length>n){var s=function(t,e,n){var i=t[0].length,r=vVt.tauRandInt(e.length,n),s=vVt.tauRandInt(e.length,n);s=(s+=r===s?1:0)%e.length;for(var o=e[r],a=e[s],l=0,c=vVt.zeros(i),u=0;u<c.length;u++)c[u]=t[o][u]-t[a][u],l-=c[u]*(t[o][u]+t[a][u])/2;var h=0,d=0,p=vVt.zeros(e.length);for(u=0;u<e.length;u++){for(var f=l,m=0;m<i;m++)f+=c[m]*t[e[u]][m];0===f?(p[u]=vVt.tauRandInt(2,n),0===p[u]?h+=1:d+=1):f>0?(p[u]=0,h+=1):(p[u]=1,d+=1)}var g=vVt.zeros(h),y=vVt.zeros(d);h=0,d=0;for(u=0;u<p.length;u++)0===p[u]?(g[h]=e[u],h+=1):(y[d]=e[u],d+=1);return{indicesLeft:g,indicesRight:y,hyperplane:c,offset:l}}(t,e,r),o=s.indicesLeft,a=s.indicesRight,l=s.hyperplane,c=s.offset;return{leftChild:wVt(t,o,n,i+1,r),rightChild:wVt(t,a,n,i+1,r),isLeaf:!1,hyperplane:l,offset:c}}return{indices:e,isLeaf:!0}}function SVt(t,e,n,i,r,s,o){var a;if(t.isLeaf)return i[s][0]=-o,(a=r[o]).splice.apply(a,gVt([0,t.indices.length],t.indices)),{nodeNum:s,leafNum:o+=1};e[s]=t.hyperplane,n[s]=t.offset,i[s][0]=s+1;var l=s,c=SVt(t.leftChild,e,n,i,r,s+1,o);return s=c.nodeNum,o=c.leafNum,i[l][1]=s+1,{nodeNum:(c=SVt(t.rightChild,e,n,i,r,s+1,o)).nodeNum,leafNum:c.leafNum}}function kVt(t){return t.isLeaf?1:1+kVt(t.leftChild)+kVt(t.rightChild)}function CVt(t){return t.isLeaf?1:CVt(t.leftChild)+CVt(t.rightChild)}function TVt(t,e,n,i){for(var r=e,s=0;s<n.length;s++)r+=t[s]*n[s];return 0===r?vVt.tauRandInt(2,i):r>0?0:1}fVt.FlatTree=xVt,fVt.makeForest=function(t,e,n,i){var r=Math.max(10,e),s=vVt.range(n).map((function(e,n){return function(t,e,n,i){void 0===e&&(e=30);var r=vVt.range(t.length),s=wVt(t,r,e,n,i);return s}(t,r,n,i)})),o=s.map((function(t){return function(t,e){var n=kVt(t),i=CVt(t),r=vVt.range(n).map((function(){return vVt.zeros(t.hyperplane?t.hyperplane.length:0)})),s=vVt.zeros(n),o=vVt.range(n).map((function(){return[-1,-1]})),a=vVt.range(i).map((function(){return vVt.range(e).map((function(){return-1}))}));return SVt(t,r,s,o,a,0,0),new xVt(r,s,o,a)}(t,r)}));return o},fVt.makeLeafArray=function(t){var e,n;if(t.length>0){var i=[];try{for(var r=yVt(t),s=r.next();!s.done;s=r.next()){var o=s.value;i.push.apply(i,gVt(o.indices))}}catch(t){e={error:t}}finally{try{s&&!s.done&&(n=r.return)&&n.call(r)}finally{if(e)throw e.error}}return i}return[[-1]]},fVt.searchFlatTree=function(t,e,n){for(var i=0;e.children[i][0]>0;){i=0===TVt(e.hyperplanes[i],e.offsets[i],t,n)?e.children[i][0]:e.children[i][1]}var r=-1*e.children[i][0];return e.indices[r]};var _Vt=Ti&&Ti.__values||function(t){var e="function"==typeof Symbol&&t[Symbol.iterator],n=0;return e?e.call(t):{next:function(){return t&&n>=t.length&&(t=void 0),{value:t&&t[n++],done:!t}}}},EVt=Ti&&Ti.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e};Object.defineProperty(pVt,"__esModule",{value:!0});var MVt=EVt(HUt),$Vt=EVt(sVt),IVt=EVt(fVt),AVt=EVt(jUt);pVt.makeNNDescent=function(t,e){return function(n,i,r,s,o,a,l,c){void 0===s&&(s=10),void 0===o&&(o=50),void 0===a&&(a=.001),void 0===l&&(l=.5),void 0===c&&(c=!0);for(var u=n.length,h=MVt.makeHeap(n.length,r),d=0;d<n.length;d++)for(var p=MVt.rejectionSample(r,n.length,e),f=0;f<p.length;f++){var m=t(n[d],n[p[f]]);MVt.heapPush(h,d,m,p[f],1),MVt.heapPush(h,p[f],m,d,1)}if(c)for(var g=0;g<i.length;g++)for(d=0;d<i[g].length&&!(i[g][d]<0);d++)for(f=d+1;f<i[g].length&&!(i[g][f]<0);f++){m=t(n[i[g][d]],n[i[g][f]]);MVt.heapPush(h,i[g][d],m,i[g][f],1),MVt.heapPush(h,i[g][f],m,i[g][d],1)}for(g=0;g<s;g++){var y=MVt.buildCandidates(h,u,r,o,e),b=0;for(d=0;d<u;d++)for(f=0;f<o;f++){var v=Math.floor(y[0][d][f]);if(!(v<0||AVt.tauRand(e)<l))for(var x=0;x<o;x++){var w=Math.floor(y[0][d][x]),S=y[2][d][f],k=y[2][d][x];if(!(w<0||!S&&!k)){m=t(n[v],n[w]);b+=MVt.heapPush(h,v,m,w,1),b+=MVt.heapPush(h,w,m,v,1)}}}if(b<=a*r*n.length)break}return MVt.deheapSort(h)}},pVt.makeInitializations=function(t){return{initFromRandom:function(e,n,i,r,s){for(var o=0;o<i.length;o++)for(var a=AVt.rejectionSample(e,n.length,s),l=0;l<a.length;l++)if(!(a[l]<0)){var c=t(n[a[l]],i[o]);MVt.heapPush(r,o,c,a[l],1)}},initFromTree:function(e,n,i,r,s){for(var o=0;o<i.length;o++)for(var a=IVt.searchFlatTree(i[o],e,s),l=0;l<a.length;l++){if(a[l]<0)return;var c=t(n[a[l]],i[o]);MVt.heapPush(r,o,c,a[l],1)}}}},pVt.makeInitializedNNSearch=function(t){return function(e,n,i,r){for(var s,o,a=$Vt.getCSR(n),l=a.indices,c=a.indptr,u=0;u<r.length;u++)for(var h=new Set(i[0][u]);;){var d=MVt.smallestFlagged(i,u);if(-1===d)break;var p=l.slice(c[d],c[d+1]);try{for(var f=_Vt(p),m=f.next();!m.done;m=f.next()){var g=m.value;if(g!==d&&-1!==g&&!h.has(g)){var y=t(e[g],r[u]);MVt.uncheckedHeapPush(i,u,y,g,1),h.add(g)}}}catch(t){s={error:t}}finally{try{m&&!m.done&&(o=f.return)&&o.call(f)}finally{if(s)throw s.error}}}return i}},pVt.initializeSearch=function(t,e,n,i,r,s,o){var a,l,c=MVt.makeHeap(n.length,i);if(r(i,e,n,c,o),t)try{for(var u=_Vt(t),h=u.next();!h.done;h=u.next()){s(h.value,e,n,c,o)}}catch(t){a={error:t}}finally{try{h&&!h.done&&(l=u.return)&&l.call(u)}finally{if(a)throw a.error}}return c};const NVt=Object.prototype.toString;function RVt(t){return NVt.call(t).endsWith("Array]")}function PVt(t,e,n){let i=0;const r=n(e);for(let e=0;e<t.x.length;e++)i+=Math.abs(t.y[e]-r(t.x[e]));return i}function OVt(t,e,n,i,r){let s=n*i*i,o=Pbt.eye(e.length,e.length,s);const a=r(e);let l=new Float64Array(t.x.length);for(let e=0;e<t.x.length;e++)l[e]=a(t.x[e]);let c=function(t,e,n,i,r){const s=n.length,o=t.x.length;let a=new Array(s);for(let l=0;l<s;l++){a[l]=new Array(o);let s=n.slice();s[l]+=i;let c=r(s);for(let n=0;n<o;n++)a[l][n]=e[n]-c(t.x[n])}return new Pbt(a)}(t,l,e,i,r),u=function(t,e){const n=t.x.length;let i=new Array(n);for(let r=0;r<n;r++)i[r]=[t.y[r]-e[r]];return new Pbt(i)}(t,l),h=Bbt(o.add(c.mmul(c.transpose())));return(e=(e=new Pbt([e])).sub(h.mmul(c).mmul(u).mul(i).transpose())).to1DArray()}var LVt=Object.freeze({__proto__:null,default:function(t,e,n={}){let{maxIterations:i=100,gradientDifference:r=.1,damping:s=0,errorTolerance:o=.01,minValues:a,maxValues:l,initialValues:c}=n;if(s<=0)throw new Error("The damping option must be a positive number");if(!t.x||!t.y)throw new Error("The data parameter must have x and y elements");if(!RVt(t.x)||t.x.length<2||!RVt(t.y)||t.y.length<2)throw new Error("The data parameter elements must be an array with more than 2 points");if(t.x.length!==t.y.length)throw new Error("The data parameter elements must have the same size");let u=c||new Array(e.length).fill(1),h=u.length;if(l=l||new Array(h).fill(Number.MAX_SAFE_INTEGER),a=a||new Array(h).fill(Number.MIN_SAFE_INTEGER),l.length!==a.length)throw new Error("minValues and maxValues must be the same size");if(!RVt(u))throw new Error("initialValues must be an array");let d,p=PVt(t,u,e),f=p<=o;for(d=0;d<i&&!f;d++){u=OVt(t,u,s,r,e);for(let t=0;t<h;t++)u[t]=Math.min(Math.max(a[t],u[t]),l[t]);if(p=PVt(t,u,e),isNaN(p))break;f=p<=o}return{parameterValues:u,parameterError:p,iterations:d}}}),DVt=Ei(LVt),FVt=Ti&&Ti.__awaiter||function(t,e,n,i){return new(n||(n=Promise))((function(r,s){function o(t){try{l(i.next(t))}catch(t){s(t)}}function a(t){try{l(i.throw(t))}catch(t){s(t)}}function l(t){t.done?r(t.value):new n((function(e){e(t.value)})).then(o,a)}l((i=i.apply(t,e||[])).next())}))},zVt=Ti&&Ti.__generator||function(t,e){var n,i,r,s,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function a(s){return function(a){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,i&&(r=2&s[0]?i.return:s[0]?i.throw||((r=i.return)&&r.call(i),0):i.next)&&!(r=r.call(i,s[1])).done)return r;switch(i=0,r&&(s=[2&s[0],r.value]),s[0]){case 0:case 1:r=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,i=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(r=o.trys,(r=r.length>0&&r[r.length-1])||6!==s[0]&&2!==s[0])){o=0;continue}if(3===s[0]&&(!r||s[1]>r[0]&&s[1]<r[3])){o.label=s[1];break}if(6===s[0]&&o.label<r[1]){o.label=r[1],r=s;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(s);break}r[2]&&o.ops.pop(),o.trys.pop();continue}s=e.call(t,o)}catch(t){s=[6,t],i=0}finally{n=r=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,a])}}},BVt=Ti&&Ti.__read||function(t,e){var n="function"==typeof Symbol&&t[Symbol.iterator];if(!n)return t;var i,r,s=n.call(t),o=[];try{for(;(void 0===e||e-- >0)&&!(i=s.next()).done;)o.push(i.value)}catch(t){r={error:t}}finally{try{i&&!i.done&&(n=s.return)&&n.call(s)}finally{if(r)throw r.error}}return o},UVt=Ti&&Ti.__spread||function(){for(var t=[],e=0;e<arguments.length;e++)t=t.concat(BVt(arguments[e]));return t},VVt=Ti&&Ti.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e},WVt=Ti&&Ti.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(WUt,"__esModule",{value:!0});var HVt=VVt(HUt),jVt=VVt(sVt),GVt=VVt(pVt),qVt=VVt(fVt),XVt=VVt(jUt),KVt=WVt(DVt),YVt=1e-5,ZVt=.001,JVt=function(){function t(t){void 0===t&&(t={});var e=this;this.learningRate=1,this.localConnectivity=1,this.minDist=.1,this.nComponents=2,this.nEpochs=0,this.nNeighbors=15,this.negativeSampleRate=5,this.random=Math.random,this.repulsionStrength=1,this.setOpMixRatio=1,this.spread=1,this.transformQueueSize=4,this.targetMetric="categorical",this.targetWeight=.5,this.targetNNeighbors=this.nNeighbors,this.distanceFn=QVt,this.isInitialized=!1,this.rpForest=[],this.embedding=[],this.optimizationState=new tWt;var n=function(n){void 0!==t[n]&&(e[n]=t[n])};n("distanceFn"),n("learningRate"),n("localConnectivity"),n("minDist"),n("nComponents"),n("nEpochs"),n("nNeighbors"),n("negativeSampleRate"),n("random"),n("repulsionStrength"),n("setOpMixRatio"),n("spread"),n("transformQueueSize")}return t.prototype.fit=function(t){return this.initializeFit(t),this.optimizeLayout(),this.embedding},t.prototype.fitAsync=function(t,e){return void 0===e&&(e=function(){return!0}),FVt(this,void 0,void 0,(function(){return zVt(this,(function(n){switch(n.label){case 0:return this.initializeFit(t),[4,this.optimizeLayoutAsync(e)];case 1:return n.sent(),[2,this.embedding]}}))}))},t.prototype.setSupervisedProjection=function(t,e){void 0===e&&(e={}),this.Y=t,this.targetMetric=e.targetMetric||this.targetMetric,this.targetWeight=e.targetWeight||this.targetWeight,this.targetNNeighbors=e.targetNNeighbors||this.targetNNeighbors},t.prototype.setPrecomputedKNN=function(t,e){this.knnIndices=t,this.knnDistances=e},t.prototype.initializeFit=function(t){if(t.length<=this.nNeighbors)throw new Error("Not enough data points ("+t.length+") to create nNeighbors: "+this.nNeighbors+".  Add more data points or adjust the configuration.");if(this.X===t&&this.isInitialized)return this.getNEpochs();if(this.X=t,!this.knnIndices&&!this.knnDistances){var e=this.nearestNeighbors(t);this.knnIndices=e.knnIndices,this.knnDistances=e.knnDistances}this.graph=this.fuzzySimplicialSet(t,this.nNeighbors,this.setOpMixRatio),this.makeSearchFns(),this.searchGraph=this.makeSearchGraph(t),this.processGraphForSupervisedProjection();var n=this.initializeSimplicialSetEmbedding(),i=n.head,r=n.tail,s=n.epochsPerSample;return this.optimizationState.head=i,this.optimizationState.tail=r,this.optimizationState.epochsPerSample=s,this.initializeOptimization(),this.prepareForOptimizationLoop(),this.isInitialized=!0,this.getNEpochs()},t.prototype.makeSearchFns=function(){var t=GVt.makeInitializations(this.distanceFn),e=t.initFromTree,n=t.initFromRandom;this.initFromTree=e,this.initFromRandom=n,this.search=GVt.makeInitializedNNSearch(this.distanceFn)},t.prototype.makeSearchGraph=function(t){for(var e=this.knnIndices,n=this.knnDistances,i=[t.length,t.length],r=new jVt.SparseMatrix([],[],[],i),s=0;s<e.length;s++)for(var o=e[s],a=n[s],l=0;l<o.length;l++){var c=o[l],u=a[l];u>0&&r.set(s,c,u)}var h=jVt.transpose(r);return jVt.maximum(r,h)},t.prototype.transform=function(t){var e=this,n=this.X;if(void 0===n||0===n.length)throw new Error("No data has been fit.");var i=Math.floor(this.nNeighbors*this.transformQueueSize);i=Math.min(n.length,i);var r=GVt.initializeSearch(this.rpForest,n,t,i,this.initFromRandom,this.initFromTree,this.random),s=this.search(n,this.searchGraph,r,t),o=HVt.deheapSort(s),a=o.indices,l=o.weights;a=a.map((function(t){return t.slice(0,e.nNeighbors)})),l=l.map((function(t){return t.slice(0,e.nNeighbors)}));var c=Math.max(0,this.localConnectivity-1),u=this.smoothKNNDistance(l,this.nNeighbors,c),h=u.sigmas,d=u.rhos,p=this.computeMembershipStrengths(a,l,h,d),f=p.rows,m=p.cols,g=p.vals,y=[t.length,n.length],b=new jVt.SparseMatrix(f,m,g,y),v=jVt.normalize(b,"l1"),x=jVt.getCSR(v),w=t.length,S=oWt(XVt.reshape2d(x.indices,w,this.nNeighbors),XVt.reshape2d(x.values,w,this.nNeighbors),this.embedding),k=this.nEpochs?this.nEpochs/3:b.nRows<=1e4?100:30,C=b.getValues().reduce((function(t,e){return e>t?e:t}),0);b=b.map((function(t){return t<C/k?0:t})),b=jVt.eliminateZeros(b);var T=this.makeEpochsPerSample(b.getValues(),k),_=b.getRows(),E=b.getCols();return this.assignOptimizationStateParameters({headEmbedding:S,tailEmbedding:this.embedding,head:_,tail:E,currentEpoch:0,nEpochs:k,nVertices:b.getDims()[1],epochsPerSample:T}),this.prepareForOptimizationLoop(),this.optimizeLayout()},t.prototype.processGraphForSupervisedProjection=function(){var t=this.Y,e=this.X;if(t){if(t.length!==e.length)throw new Error("Length of X and y must be equal");if("categorical"===this.targetMetric){var n=this.targetWeight<1?1/(1-this.targetWeight)*2.5:1e12;this.graph=this.categoricalSimplicialSetIntersection(this.graph,t,n)}}},t.prototype.step=function(){var t=this.optimizationState.currentEpoch;return t<this.getNEpochs()&&this.optimizeLayoutStep(t),this.optimizationState.currentEpoch},t.prototype.getEmbedding=function(){return this.embedding},t.prototype.nearestNeighbors=function(t){var e=this.distanceFn,n=this.nNeighbors,i=GVt.makeNNDescent(e,this.random),r=5+Math.floor(function(t){return.5===t?0:Math.round(t)}(Math.pow(t.length,.5)/20)),s=Math.max(5,Math.floor(Math.round(function(t){return Math.log(t)/Math.log(2)}(t.length))));this.rpForest=qVt.makeForest(t,n,r,this.random);var o=i(t,qVt.makeLeafArray(this.rpForest),n,s);return{knnIndices:o.indices,knnDistances:o.weights}},t.prototype.fuzzySimplicialSet=function(t,e,n){void 0===n&&(n=1);var i=this,r=i.knnIndices,s=void 0===r?[]:r,o=i.knnDistances,a=void 0===o?[]:o,l=i.localConnectivity,c=this.smoothKNNDistance(a,e,l),u=c.sigmas,h=c.rhos,d=this.computeMembershipStrengths(s,a,u,h),p=d.rows,f=d.cols,m=d.vals,g=[t.length,t.length],y=new jVt.SparseMatrix(p,f,m,g),b=jVt.transpose(y),v=jVt.pairwiseMultiply(y,b),x=jVt.subtract(jVt.add(y,b),v),w=jVt.multiplyScalar(x,n),S=jVt.multiplyScalar(v,1-n);return jVt.add(w,S)},t.prototype.categoricalSimplicialSetIntersection=function(t,e,n,i){void 0===i&&(i=1);var r=rWt(t,e,i,n);return sWt(r=jVt.eliminateZeros(r))},t.prototype.smoothKNNDistance=function(t,e,n,i,r){void 0===n&&(n=1),void 0===i&&(i=64),void 0===r&&(r=1);for(var s=Math.log(e)/Math.log(2)*r,o=XVt.zeros(t.length),a=XVt.zeros(t.length),l=0;l<t.length;l++){var c=0,u=1/0,h=1,d=t[l],p=d.filter((function(t){return t>0}));if(p.length>=n){var f=Math.floor(n),m=n-f;f>0?(o[l]=p[f-1],m>YVt&&(o[l]+=m*(p[f]-p[f-1]))):o[l]=m*p[0]}else p.length>0&&(o[l]=XVt.max(p));for(var g=0;g<i;g++){for(var y=0,b=1;b<t[l].length;b++){var v=t[l][b]-o[l];y+=v>0?Math.exp(-v/h):1}if(Math.abs(y-s)<YVt)break;y>s?h=(c+(u=h))/2:(c=h,u===1/0?h*=2:h=(c+u)/2)}if(a[l]=h,o[l]>0){var x=XVt.mean(d);a[l]<ZVt*x&&(a[l]=ZVt*x)}else{var w=XVt.mean(t.map(XVt.mean));a[l]<ZVt*w&&(a[l]=ZVt*w)}}return{sigmas:a,rhos:o}},t.prototype.computeMembershipStrengths=function(t,e,n,i){for(var r=t.length,s=t[0].length,o=XVt.zeros(r*s),a=XVt.zeros(r*s),l=XVt.zeros(r*s),c=0;c<r;c++)for(var u=0;u<s;u++){var h=0;-1!==t[c][u]&&(h=t[c][u]===c?0:e[c][u]-i[c]<=0?1:Math.exp(-(e[c][u]-i[c])/n[c]),o[c*s+u]=c,a[c*s+u]=t[c][u],l[c*s+u]=h)}return{rows:o,cols:a,vals:l}},t.prototype.initializeSimplicialSetEmbedding=function(){for(var t=this,e=this.getNEpochs(),n=this.nComponents,i=this.graph.getValues(),r=0,s=0;s<i.length;s++){var o=i[s];r<i[s]&&(r=o)}var a=this.graph.map((function(t){return t<r/e?0:t}));this.embedding=XVt.zeros(a.nRows).map((function(){return XVt.zeros(n).map((function(){return 20*XVt.tauRand(t.random)-10}))}));var l=[],c=[],u=[],h=a.getAll();for(s=0;s<h.length;s++){var d=h[s];d.value&&(l.push(d.value),u.push(d.row),c.push(d.col))}return{head:c,tail:u,epochsPerSample:this.makeEpochsPerSample(l,e)}},t.prototype.makeEpochsPerSample=function(t,e){var n=XVt.filled(t.length,-1),i=XVt.max(t),r=t.map((function(t){return t/i*e}));return r.forEach((function(t,i){t>0&&(n[i]=e/r[i])})),n},t.prototype.assignOptimizationStateParameters=function(t){Object.assign(this.optimizationState,t)},t.prototype.prepareForOptimizationLoop=function(){var t=this,e=t.repulsionStrength,n=t.learningRate,i=t.negativeSampleRate,r=this.optimizationState,s=r.epochsPerSample,o=r.headEmbedding,a=r.tailEmbedding,l=o[0].length,c=o.length===a.length,u=s.map((function(t){return t/i})),h=UVt(u),d=UVt(s);this.assignOptimizationStateParameters({epochOfNextSample:d,epochOfNextNegativeSample:h,epochsPerNegativeSample:u,moveOther:c,initialAlpha:n,alpha:n,gamma:e,dim:l})},t.prototype.initializeOptimization=function(){var t=this.embedding,e=this.embedding,n=this.optimizationState,i=n.head,r=n.tail,s=n.epochsPerSample,o=this.getNEpochs(),a=this.graph.nCols,l=iWt(this.spread,this.minDist),c=l.a,u=l.b;this.assignOptimizationStateParameters({headEmbedding:t,tailEmbedding:e,head:i,tail:r,epochsPerSample:s,a:c,b:u,nEpochs:o,nVertices:a})},t.prototype.optimizeLayoutStep=function(t){for(var e=this.optimizationState,n=e.head,i=e.tail,r=e.headEmbedding,s=e.tailEmbedding,o=e.epochsPerSample,a=e.epochOfNextSample,l=e.epochOfNextNegativeSample,c=e.epochsPerNegativeSample,u=e.moveOther,h=e.initialAlpha,d=e.alpha,p=e.gamma,f=e.a,m=e.b,g=e.dim,y=e.nEpochs,b=e.nVertices,v=0;v<o.length;v++)if(!(a[v]>t)){var x=n[v],w=i[v],S=r[x],k=s[w],C=nWt(S,k),T=0;C>0&&(T=-2*f*m*Math.pow(C,m-1),T/=f*Math.pow(C,m)+1);for(var _=0;_<g;_++){var E=eWt(T*(S[_]-k[_]),4);S[_]+=E*d,u&&(k[_]+=-E*d)}a[v]+=o[v];for(var M=Math.floor((t-l[v])/c[v]),$=0;$<M;$++){var I=XVt.tauRandInt(b,this.random),A=s[I],N=nWt(S,A),R=0;if(N>0)R=2*p*m,R/=(.001+N)*(f*Math.pow(N,m)+1);else if(x===I)continue;for(_=0;_<g;_++){E=4;R>0&&(E=eWt(R*(S[_]-A[_]),4)),S[_]+=E*d}}l[v]+=M*c[v]}return e.alpha=h*(1-t/y),e.currentEpoch+=1,r},t.prototype.optimizeLayoutAsync=function(t){var e=this;return void 0===t&&(t=function(){return!0}),new Promise((function(n,i){var r=function(){return FVt(e,void 0,void 0,(function(){var e,s,o,a,l,c;return zVt(this,(function(u){try{if(e=this.optimizationState,s=e.nEpochs,o=e.currentEpoch,this.embedding=this.optimizeLayoutStep(o),a=this.optimizationState.currentEpoch,l=!1===t(a),c=a===s,l||c)return[2,n(c)];setTimeout((function(){return r()}),0)}catch(t){i(t)}return[2]}))}))};setTimeout((function(){return r()}),0)}))},t.prototype.optimizeLayout=function(t){void 0===t&&(t=function(){return!0});for(var e=!1,n=[];!e;){var i=this.optimizationState,r=i.nEpochs,s=i.currentEpoch;n=this.optimizeLayoutStep(s);var o=this.optimizationState.currentEpoch,a=!1===t(o);e=o===r||a}return n},t.prototype.getNEpochs=function(){var t=this.graph;if(this.nEpochs>0)return this.nEpochs;var e=t.nRows;return e<=2500?500:e<=5e3?400:e<=7500?300:200},t}();function QVt(t,e){for(var n=0,i=0;i<t.length;i++)n+=Math.pow(t[i]-e[i],2);return Math.sqrt(n)}WUt.UMAP=JVt,WUt.euclidean=QVt,WUt.cosine=function(t,e){for(var n=0,i=0,r=0,s=0;s<t.length;s++)n+=t[s]*e[s],i+=Math.pow(t[s],2),r+=Math.pow(e[s],2);return 0===i&&0===r?0:0===i||0===r?1:1-n/Math.sqrt(i*r)};var tWt=function(){this.currentEpoch=0,this.headEmbedding=[],this.tailEmbedding=[],this.head=[],this.tail=[],this.epochsPerSample=[],this.epochOfNextSample=[],this.epochOfNextNegativeSample=[],this.epochsPerNegativeSample=[],this.moveOther=!0,this.initialAlpha=1,this.alpha=1,this.gamma=1,this.a=1.5769434603113077,this.b=.8950608779109733,this.dim=2,this.nEpochs=500,this.nVertices=0};function eWt(t,e){return t>e?e:t<-e?-e:t}function nWt(t,e){for(var n=0,i=0;i<t.length;i++)n+=Math.pow(t[i]-e[i],2);return n}function iWt(t,e){var n=XVt.linear(0,3*t,300).map((function(t){return t<e?1:t})),i=XVt.zeros(n.length).map((function(i,r){return n[r]>=e?Math.exp(-(n[r]-e)/t):i})),r={x:n,y:i},s={damping:1.5,initialValues:[.5,.5],gradientDifference:.1,maxIterations:100,errorTolerance:.01},o=KVt.default(r,(function(t){var e=BVt(t,2),n=e[0],i=e[1];return function(t){return 1/(1+n*Math.pow(t,2*i))}}),s).parameterValues,a=BVt(o,2);return{a:a[0],b:a[1]}}function rWt(t,e,n,i){return void 0===n&&(n=1),void 0===i&&(i=5),t.map((function(t,r,s){return-1===e[r]||-1===e[s]?t*Math.exp(-n):e[r]!==e[s]?t*Math.exp(-i):t}))}function sWt(t){t=jVt.normalize(t,"max");var e=jVt.transpose(t),n=jVt.pairwiseMultiply(e,t);return t=jVt.add(t,jVt.subtract(e,n)),jVt.eliminateZeros(t)}function oWt(t,e,n){for(var i=XVt.zeros(t.length).map((function(t){return XVt.zeros(n[0].length)})),r=0;r<t.length;r++)for(var s=0;s<t[0].length;s++)for(var o=0;o<n[0].length;o++){var a=t[r][s];i[r][o]+=e[r][s]*n[a][o]}return i}WUt.findABParams=iWt,WUt.fastIntersection=rWt,WUt.resetLocalConnectivity=sWt,WUt.initTransform=oWt,Object.defineProperty(VUt,"__esModule",{value:!0});var aWt=WUt,lWt=VUt.UMAP=aWt.UMAP;class cWt extends i3{constructor({nComponents:t=2,nNeighbors:e=15,minDist:n=.1,spread:i=1,supervised:r=!1}={}){super(),this.title="UMAP",this.serviceName="umap",this.parameters={nComponents:new eK(t,!0),nNeighbors:new eK(e,!0),minDist:new eK(n,!0),spread:new eK(i,!0),supervised:new eK(r,!0)}}async train(t){this.$training.set({status:"start",epochs:-1});const e=n3(t)?t.items():t,n=await e.toArray(),i=n.reduce(((t,{x:e})=>t.concat([e])),[]);if(this.model=new lWt({nComponents:this.parameters.nComponents.get()}),this.parameters.supervised.get()){const t=n.map((t=>t.y));this.model.setSupervisedProjection(t)}const r=this.model.initializeFit(i);this.$training.set({status:"start",epochs:r});for(let t=0;t<r;t++)this.model.step(),this.$training.set({status:"epoch",epoch:t+1,epochs:r,data:{embedding:this.model.getEmbedding()}});this.$training.set({status:"success",data:{embedding:this.model.getEmbedding()}})}async predict(t){return this.model?this.model.transform([t])[0]:null}save(){throw new Error("Umap does not support saving")}load(){throw new Error("Umap does not support loading")}download(){throw new Error("Umap does not support downloading")}upload(){throw new Error("Umap does not support uploading")}}function uWt(...t){return new cWt(...t)}const hWt=Symbol(0);let dWt=!1,pWt=!1,fWt=null,mWt=null,gWt=null,yWt=0,bWt=[],vWt={};const xWt=()=>{},wWt=0,SWt=1,kWt=2,CWt=3;function TWt(){if(bWt.length){pWt=!0;for(let t=0;t<bWt.length;t++)bWt[t].$st!==wWt&&_Wt(bWt[t]);bWt=[],dWt=!1,pWt=!1}else dWt=!1}function _Wt(t){let e=[t];for(;t=t[hWt];)t.$e&&t.$st!==wWt&&e.push(t);for(let t=e.length-1;t>=0;t--)KWt(e[t])}function EWt(t){const e=HWt();return DWt(e,t.length?t.bind(null,PWt.bind(e)):t,null)}function MWt(t){return DWt(fWt,t,null)}function $Wt(){pWt||TWt()}function IWt(){return fWt}function AWt(t,e){try{return DWt(e,t,null)}catch(t){return void FWt(e,t)}}function NWt(t,e=fWt){return e?.$cx[t]}function RWt(t){if(!t||!fWt)return t||xWt;const e=fWt;return e.$d?Array.isArray(e.$d)?e.$d.push(t):e.$d=[e.$d,t]:e.$d=t,function(){e.$st!==CWt&&(t.call(null),XWt(e.$d)?e.$d=null:Array.isArray(e.$d)&&e.$d.splice(e.$d.indexOf(t),1))}}function PWt(t=!0){if(this.$st===CWt)return;let e=t?this.$ps||this[hWt]:this,n=this.$ns,i=null;for(;n&&n[hWt]===this;)PWt.call(n,!0),OWt(n),i=n.$ns,n.$ns=null,n=i;t&&OWt(this),n&&(n.$ps=t?this.$ps:this),e&&(e.$ns=n)}function OWt(t){t.$st=CWt,t.$d&&LWt(t),t.$s&&QWt(t,0),t.$ps&&(t.$ps.$ns=null),t[hWt]=null,t.$s=null,t.$o=null,t.$ps=null,t.$cx=vWt,t.$eh=null}function LWt(t){try{if(Array.isArray(t.$d))for(let e=t.$d.length-1;e>=0;e--){const n=t.$d[e];n.call(n)}else t.$d.call(t.$d);t.$d=null}catch(e){FWt(t,e)}}function DWt(t,e,n){const i=fWt,r=mWt;fWt=t,mWt=n;try{return e.call(t)}finally{fWt=i,mWt=r}}function FWt(t,e){if(!t||!t.$eh)throw e;let n=0,i=t.$eh.length,r=zWt(e);for(n=0;n<i;n++)try{t.$eh[n](r);break}catch(t){r=zWt(t)}if(n===i)throw r}function zWt(t){return t instanceof Error?t:Error(JSON.stringify(t))}function BWt(){return this.$st===CWt||(mWt&&!this.$e&&(!gWt&&mWt.$s&&mWt.$s[yWt]==this?yWt++:gWt?gWt.push(this):gWt=[this]),this.$c&&KWt(this)),this.$v}function UWt(t){const e=XWt(t)?t(this.$v):t;if(this.$ch(this.$v,e)&&(this.$v=e,this.$o))for(let t=0;t<this.$o.length;t++)JWt(this.$o[t],kWt);return this.$v}const VWt=function(){this[hWt]=null,this.$ns=null,this.$ps=null,fWt&&fWt.append(this)},WWt=VWt.prototype;function HWt(){return new VWt}WWt.$cx=vWt,WWt.$eh=null,WWt.$c=null,WWt.$d=null,WWt.append=function(t){if(t[hWt]=this,t.$ps=this,this.$ns)if(t.$ns){let e=t.$ns;for(;e.$ns;)e=e.$ns;e.$ns=this.$ns,this.$ns.$ps=e}else t.$ns=this.$ns,this.$ns.$ps=t;this.$ns=t,t.$cx=t.$cx===vWt?this.$cx:{...this.$cx,...t.$cx},this.$eh&&(t.$eh=t.$eh?[...t.$eh,...this.$eh]:this.$eh)},WWt.dispose=function(){PWt.call(this)};const jWt=function(t,e,n){VWt.call(this),this.$st=e?kWt:wWt,this.$i=!1,this.$e=!1,this.$s=null,this.$o=null,this.$v=t,e&&(this.$c=e),n&&n.dirty&&(this.$ch=n.dirty)},GWt=jWt.prototype;function qWt(t,e,n){return new jWt(t,e,n)}function XWt(t){return"function"==typeof t}function KWt(t){if(t.$st===SWt)for(let e=0;e<t.$s.length&&(KWt(t.$s[e]),t.$st!==kWt);e++);t.$st===kWt?ZWt(t):t.$st=wWt}function YWt(t){t.$ns&&t.$ns[hWt]===t&&PWt.call(t,!1),t.$d&&LWt(t),t.$eh=t[hWt]?t[hWt].$eh:null}function ZWt(t){let e=gWt,n=yWt;gWt=null,yWt=0;try{YWt(t);const e=DWt(t,t.$c,t);if(gWt){if(t.$s&&QWt(t,yWt),t.$s&&yWt>0){t.$s.length=yWt+gWt.length;for(let e=0;e<gWt.length;e++)t.$s[yWt+e]=gWt[e]}else t.$s=gWt;let e;for(let n=yWt;n<t.$s.length;n++)e=t.$s[n],e.$o?e.$o.push(t):e.$o=[t]}else t.$s&&yWt<t.$s.length&&(QWt(t,yWt),t.$s.length=yWt);!t.$e&&t.$i?UWt.call(t,e):(t.$v=e,t.$i=!0)}catch(e){return FWt(t,e),void(t.$st===kWt&&(YWt(t),t.$s&&QWt(t,0)))}gWt=e,yWt=n,t.$st=wWt}function JWt(t,e){if(!(t.$st>=e)&&(t.$e&&t.$st===wWt&&(bWt.push(t),dWt||(dWt=!0,queueMicrotask(TWt))),t.$st=e,t.$o))for(let e=0;e<t.$o.length;e++)JWt(t.$o[e],SWt)}function QWt(t,e){let n,i;for(let r=e;r<t.$s.length;r++)n=t.$s[r],n.$o&&(i=n.$o.indexOf(t),n.$o[i]=n.$o[n.$o.length-1],n.$o.pop())}function tHt(...t){}function eHt(t){return null===t}function nHt(t){return void 0===t}function iHt(t){return"number"==typeof t&&!Number.isNaN(t)}function rHt(t){return"string"==typeof t}function sHt(t){return"function"==typeof t}function oHt(t){return Array.isArray(t)}Object.setPrototypeOf(GWt,WWt),GWt.$ch=function(t,e){return t!==e},GWt.call=BWt;const aHt=Event,lHt=Symbol("DOM_EVENT");class cHt extends aHt{[lHt]=!0;detail;trigger;get originEvent(){return uHt(this)??this}get isOriginTrusted(){return uHt(this)?.isTrusted??!1}constructor(t,...e){super(t,e[0]),this.detail=e[0]?.detail,this.trigger=e[0]?.trigger}}function uHt(t){let e=t.trigger;for(;e&&e.trigger;)e=e.trigger;return e}function hHt(t,e){const n=uHt(t)??t;if(n===e)throw Error("");Object.defineProperty(n,"trigger",{configurable:!0,enumerable:!0,get:()=>e})}class dHt extends EventTarget{$ts__events;addEventListener(t,e,n){return super.addEventListener(t,e,n)}removeEventListener(t,e,n){return super.removeEventListener(t,e,n)}}function pHt(t,e,n,i){return t.addEventListener(e,n,i),RWt((()=>t.removeEventListener(e,n,i)))}function fHt(t){return!!t?.type.startsWith("pointer")}function mHt(t){return!!t?.type.startsWith("touch")}function gHt(t){return!!t?.type.startsWith("key")}function yHt(t){return gHt(t)&&("Enter"===t.key||" "===t.key)}function bHt(t,e,n){if(t)if(n||""===n||0===n){const i=!0===n?"":n+"";t.getAttribute(e)!==i&&t.setAttribute(e,i)}else t.removeAttribute(e)}function vHt(t,e,n){t&&(n||0===n?t.style.setProperty(e,n+""):t.style.removeProperty(e))}function xHt(t,e){const n=qWt(t,null,e),i=BWt.bind(n);return i[hWt]=!0,i.set=UWt.bind(n),i}function wHt(t,e){const n=qWt(e?.initial,t,e),i=BWt.bind(n);return i[hWt]=!0,i}function SHt(t){return function(t){return XWt(t)&&hWt in t}(t)&&"set"in t}const kHt=function(t,e){const n=qWt(null,(function(){let e=t();return XWt(e)&&RWt(e),null}),void 0);return n.$e=!0,ZWt(n),PWt.bind(n,!0)};function CHt(t){return{id:Symbol(),provide:t}}function THt(t,e,n=IWt()){const i=!nHt(e);!function(t,e,n=fWt){n&&(n.$cx={...n.$cx,[t]:e})}(t.id,i?e:t.provide?.(),n)}function _Ht(t){return NWt(t.id)}function EHt(t){return!nHt(NWt(t.id))}const MHt=Symbol(0),$Ht=Symbol(0),IHt=Symbol(0),AHt={};class NHt{$ts__events;$ts__vars;[IHt]=null;$el=xHt(null);f=null;a=null;g=null;h=null;e=null;q=!1;i=AHt;c=null;d=null;k;j;n=[];o=[];m=[];p=[];constructor(t,e,n){this.a=e,n?.scope&&n.scope.append(e);let i=t.state,r=t.props;if(i&&(this.j=i.create(),this.k=new Proxy(this.j,{get:(t,e)=>this.j[e]()}),THt(i,this.j)),r&&(this.i=function(t){const e={};for(const n of Object.keys(t)){const i=t[n];e[n]=xHt(i,i)}return e}(r),n?.props))for(const t of Object.keys(n.props))this.i[t]?.set(n.props[t]);RWt(this.b.bind(this))}w(){AWt((()=>{for(const t of this.n)t()}),this.a)}x(t){this.f||(this.f=t,this.$el.set(t),AWt((()=>{this.g=HWt(),AWt((()=>{for(const t of this.o)t(this.f);this.r(),this.s()}),this.g)}),this.a),t.dispatchEvent(new Event("attached")))}t(){this.g?.dispose(),this.g=null,this.h=null,this.f=null,this.$el.set(null)}y(){this.f&&this.g&&this.m.length&&AWt((()=>{this.h=HWt(),AWt((()=>{for(const t of this.m)t(this.f)}),this.h)}),this.g)}z(){this.h?.dispose(),this.h=null}b(){if(this.q)return;this.q=!0,AWt((()=>{for(const t of this.p)t(this.f)}),this.a);const t=this.f;this.t(),this.a.dispose(),this.n.length=0,this.o.length=0,this.m.length=0,this.p.length=0,this.e=null,this.c=null,this.d=null,this.i=AHt,this.a=null,this.k=AHt,this.j=null,t&&delete t.$}l(t){t.onSetup&&this.n.push(t.onSetup.bind(t)),t.onAttach&&this.o.push(t.onAttach.bind(t)),t.onConnect&&this.m.push(t.onConnect.bind(t)),t.onDestroy&&this.p.push(t.onDestroy.bind(t))}r(){if(this.c)for(const t of Object.keys(this.c))sHt(this.c[t])?kHt(this.u.bind(this,t)):bHt(this.f,t,this.c[t])}s(){if(this.d)for(const t of Object.keys(this.d))sHt(this.d[t])?kHt(this.v.bind(this,t)):vHt(this.f,t,this.d[t])}u(t){bHt(this.f,t,this.c[t].call(this.e))}v(t){vHt(this.f,t,this.d[t].call(this.e))}}let RHt={$$:null};class PHt extends EventTarget{$$;get el(){return this.$$.f}get $el(){return this.$$.$el()}get scope(){return this.$$.a}get attachScope(){return this.$$.g}get connectScope(){return this.$$.h}get $props(){return this.$$.i}get $state(){return this.$$.j}get state(){return this.$$.k}constructor(){super(),RHt.$$&&this.attach(RHt)}attach({$$:t}){return this.$$=t,t.l(this),this}addEventListener(t,e,n){this.listen(t,e,n)}removeEventListener(t,e,n){this.el?.removeEventListener(t,e,n)}setAttributes(t){this.$$.c||(this.$$.c={}),Object.assign(this.$$.c,t)}setStyles(t){this.$$.d||(this.$$.d={}),Object.assign(this.$$.d,t)}setCSSVars(t){this.setStyles(t)}createEvent(t,...e){return new cHt(t,e[0])}dispatch(t,...e){if(!this.el)return!1;const n=t instanceof Event?t:new cHt(t,e[0]);return Object.defineProperty(n,"target",{get:()=>this.$$.e}),function(t){return DWt(null,t,null)}((()=>(this.$$[IHt]?.(n),this.el.dispatchEvent(n))))}dispatchEvent(t){return this.dispatch(t)}listen(t,e,n){return this.el?pHt(this.el,t,e,n):tHt}}class OHt extends PHt{subscribe(t){return AWt((()=>kHt((()=>t(this.state)))),this.$$.a)}destroy(){this.$$.b()}}function LHt(t,e,n){t[MHt]||(t[MHt]=new Set),t[MHt].add(e)}function DHt(t,e,n){t[$Ht]||(t[$Ht]=new Set),t[$Ht].add(e)}class FHt{id=Symbol(0);record;A;constructor(t){this.record=t,this.A=Object.getOwnPropertyDescriptors(t)}create(){const t={},e=new Proxy(t,{get:(e,n)=>t[n]()});for(const n of Object.keys(this.record)){const i=this.A[n].get;t[n]=i?wHt(i.bind(e)):xHt(this.record[n])}return t}reset(t,e){for(const n of Object.keys(t))this.A[n].get||e&&!e(n)||t[n].set(this.record[n])}}function zHt(t){return _Ht(t)}function BHt(t){return t.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function UHt(t){return t.replace(/-./g,(t=>t[1].toUpperCase()))}function VHt(t){return sHt(t)?t():t}function WHt(t){return t?"true":"false"}function HHt(){const t=new Set;return{add(...e){for(const n of e)t.add(n)},empty(){for(const e of t)e();t.clear()}}}function jHt(){let t,e;return{promise:new Promise(((n,i)=>{t=n,e=i})),resolve:t,reject:e}}function GHt(t){let e,n=-1;return function(...i){e=i,n>=0||(n=window.requestAnimationFrame((()=>{t.apply(this,e),n=-1,e=void 0})))}}const qHt="undefined"!=typeof window?"requestIdleCallback"in window?window.requestIdleCallback:t=>window.setTimeout(t,1):tHt;const XHt=Math.min,KHt=Math.max,YHt=Math.round,ZHt=Math.floor,JHt=t=>({x:t,y:t});function QHt(t){return t.split("-")[0]}function tjt(t){return["top","bottom"].includes(QHt(t))?"y":"x"}function ejt(t){return{...t,top:t.y,left:t.x,right:t.x+t.width,bottom:t.y+t.height}}function njt(t,e,n){let{reference:i,floating:r}=t;const s=tjt(e),o=function(t){return"x"===tjt(t)?"y":"x"}(e),a="y"===o?"height":"width";const l=QHt(e),c="y"===s,u=i.x+i.width/2-r.width/2,h=i.y+i.height/2-r.height/2,d=i[a]/2-r[a]/2;let p;switch(l){case"top":p={x:u,y:i.y-r.height};break;case"bottom":p={x:u,y:i.y+i.height};break;case"right":p={x:i.x+i.width,y:h};break;case"left":p={x:i.x-r.width,y:h};break;default:p={x:i.x,y:i.y}}switch(function(t){return t.split("-")[1]}(e)){case"start":p[o]-=d*(n&&c?-1:1);break;case"end":p[o]+=d*(n&&c?-1:1)}return p}function ijt(t){return ojt(t)?(t.nodeName||"").toLowerCase():"#document"}function rjt(t){var e;return(null==t||null==(e=t.ownerDocument)?void 0:e.defaultView)||window}function sjt(t){var e;return null==(e=(ojt(t)?t.ownerDocument:t.document)||window.document)?void 0:e.documentElement}function ojt(t){return t instanceof Node||t instanceof rjt(t).Node}function ajt(t){return t instanceof Element||t instanceof rjt(t).Element}function ljt(t){return t instanceof HTMLElement||t instanceof rjt(t).HTMLElement}function cjt(t){return"undefined"!=typeof ShadowRoot&&(t instanceof ShadowRoot||t instanceof rjt(t).ShadowRoot)}function ujt(t){const{overflow:e,overflowX:n,overflowY:i,display:r}=mjt(t);return/auto|scroll|overlay|hidden|clip/.test(e+i+n)&&!["inline","contents"].includes(r)}function hjt(t){return["table","td","th"].includes(ijt(t))}function djt(t){const e=pjt(),n=mjt(t);return"none"!==n.transform||"none"!==n.perspective||!!n.containerType&&"normal"!==n.containerType||!e&&!!n.backdropFilter&&"none"!==n.backdropFilter||!e&&!!n.filter&&"none"!==n.filter||["transform","perspective","filter"].some((t=>(n.willChange||"").includes(t)))||["paint","layout","strict","content"].some((t=>(n.contain||"").includes(t)))}function pjt(){return!("undefined"==typeof CSS||!CSS.supports)&&CSS.supports("-webkit-backdrop-filter","none")}function fjt(t){return["html","body","#document"].includes(ijt(t))}function mjt(t){return rjt(t).getComputedStyle(t)}function gjt(t){return ajt(t)?{scrollLeft:t.scrollLeft,scrollTop:t.scrollTop}:{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function yjt(t){if("html"===ijt(t))return t;const e=t.assignedSlot||t.parentNode||cjt(t)&&t.host||sjt(t);return cjt(e)?e.host:e}function bjt(t){const e=yjt(t);return fjt(e)?t.ownerDocument?t.ownerDocument.body:t.body:ljt(e)&&ujt(e)?e:bjt(e)}function vjt(t,e,n){var i;void 0===e&&(e=[]),void 0===n&&(n=!0);const r=bjt(t),s=r===(null==(i=t.ownerDocument)?void 0:i.body),o=rjt(r);return s?e.concat(o,o.visualViewport||[],ujt(r)?r:[],o.frameElement&&n?vjt(o.frameElement):[]):e.concat(r,vjt(r,[],n))}function xjt(t){const e=mjt(t);let n=parseFloat(e.width)||0,i=parseFloat(e.height)||0;const r=ljt(t),s=r?t.offsetWidth:n,o=r?t.offsetHeight:i,a=YHt(n)!==s||YHt(i)!==o;return a&&(n=s,i=o),{width:n,height:i,$:a}}function wjt(t){return ajt(t)?t:t.contextElement}function Sjt(t){const e=wjt(t);if(!ljt(e))return JHt(1);const n=e.getBoundingClientRect(),{width:i,height:r,$:s}=xjt(e);let o=(s?YHt(n.width):n.width)/i,a=(s?YHt(n.height):n.height)/r;return o&&Number.isFinite(o)||(o=1),a&&Number.isFinite(a)||(a=1),{x:o,y:a}}const kjt=JHt(0);function Cjt(t){const e=rjt(t);return pjt()&&e.visualViewport?{x:e.visualViewport.offsetLeft,y:e.visualViewport.offsetTop}:kjt}function Tjt(t,e,n,i){void 0===e&&(e=!1),void 0===n&&(n=!1);const r=t.getBoundingClientRect(),s=wjt(t);let o=JHt(1);e&&(i?ajt(i)&&(o=Sjt(i)):o=Sjt(t));const a=function(t,e,n){return void 0===e&&(e=!1),!(!n||e&&n!==rjt(t))&&e}(s,n,i)?Cjt(s):JHt(0);let l=(r.left+a.x)/o.x,c=(r.top+a.y)/o.y,u=r.width/o.x,h=r.height/o.y;if(s){const t=rjt(s),e=i&&ajt(i)?rjt(i):i;let n=t.frameElement;for(;n&&i&&e!==t;){const t=Sjt(n),e=n.getBoundingClientRect(),i=mjt(n),r=e.left+(n.clientLeft+parseFloat(i.paddingLeft))*t.x,s=e.top+(n.clientTop+parseFloat(i.paddingTop))*t.y;l*=t.x,c*=t.y,u*=t.x,h*=t.y,l+=r,c+=s,n=rjt(n).frameElement}}return ejt({width:u,height:h,x:l,y:c})}function _jt(t){return Tjt(sjt(t)).left+gjt(t).scrollLeft}function Ejt(t,e,n){let i;if("viewport"===e)i=function(t,e){const n=rjt(t),i=sjt(t),r=n.visualViewport;let s=i.clientWidth,o=i.clientHeight,a=0,l=0;if(r){s=r.width,o=r.height;const t=pjt();(!t||t&&"fixed"===e)&&(a=r.offsetLeft,l=r.offsetTop)}return{width:s,height:o,x:a,y:l}}(t,n);else if("document"===e)i=function(t){const e=sjt(t),n=gjt(t),i=t.ownerDocument.body,r=KHt(e.scrollWidth,e.clientWidth,i.scrollWidth,i.clientWidth),s=KHt(e.scrollHeight,e.clientHeight,i.scrollHeight,i.clientHeight);let o=-n.scrollLeft+_jt(t);const a=-n.scrollTop;return"rtl"===mjt(i).direction&&(o+=KHt(e.clientWidth,i.clientWidth)-r),{width:r,height:s,x:o,y:a}}(sjt(t));else if(ajt(e))i=function(t,e){const n=Tjt(t,!0,"fixed"===e),i=n.top+t.clientTop,r=n.left+t.clientLeft,s=ljt(t)?Sjt(t):JHt(1);return{width:t.clientWidth*s.x,height:t.clientHeight*s.y,x:r*s.x,y:i*s.y}}(e,n);else{const n=Cjt(t);i={...e,x:e.x-n.x,y:e.y-n.y}}return ejt(i)}function Mjt(t,e){const n=yjt(t);return!(n===e||!ajt(n)||fjt(n))&&("fixed"===mjt(n).position||Mjt(n,e))}function $jt(t,e,n){const i=ljt(e),r=sjt(e),s="fixed"===n,o=Tjt(t,!0,s,e);let a={scrollLeft:0,scrollTop:0};const l=JHt(0);if(i||!i&&!s)if(("body"!==ijt(e)||ujt(r))&&(a=gjt(e)),i){const t=Tjt(e,!0,s,e);l.x=t.x+e.clientLeft,l.y=t.y+e.clientTop}else r&&(l.x=_jt(r));return{x:o.left+a.scrollLeft-l.x,y:o.top+a.scrollTop-l.y,width:o.width,height:o.height}}function Ijt(t,e){return ljt(t)&&"fixed"!==mjt(t).position?e?e(t):t.offsetParent:null}function Ajt(t,e){const n=rjt(t);if(!ljt(t))return n;let i=Ijt(t,e);for(;i&&hjt(i)&&"static"===mjt(i).position;)i=Ijt(i,e);return i&&("html"===ijt(i)||"body"===ijt(i)&&"static"===mjt(i).position&&!djt(i))?n:i||function(t){let e=yjt(t);for(;ljt(e)&&!fjt(e);){if(djt(e))return e;e=yjt(e)}return null}(t)||n}const Njt={convertOffsetParentRelativeRectToViewportRelativeRect:function(t){let{rect:e,offsetParent:n,strategy:i}=t;const r=ljt(n),s=sjt(n);if(n===s)return e;let o={scrollLeft:0,scrollTop:0},a=JHt(1);const l=JHt(0);if((r||!r&&"fixed"!==i)&&(("body"!==ijt(n)||ujt(s))&&(o=gjt(n)),ljt(n))){const t=Tjt(n);a=Sjt(n),l.x=t.x+n.clientLeft,l.y=t.y+n.clientTop}return{width:e.width*a.x,height:e.height*a.y,x:e.x*a.x-o.scrollLeft*a.x+l.x,y:e.y*a.y-o.scrollTop*a.y+l.y}},getDocumentElement:sjt,getClippingRect:function(t){let{element:e,boundary:n,rootBoundary:i,strategy:r}=t;const s="clippingAncestors"===n?function(t,e){const n=e.get(t);if(n)return n;let i=vjt(t,[],!1).filter((t=>ajt(t)&&"body"!==ijt(t))),r=null;const s="fixed"===mjt(t).position;let o=s?yjt(t):t;for(;ajt(o)&&!fjt(o);){const e=mjt(o),n=djt(o);n||"fixed"!==e.position||(r=null),(s?!n&&!r:!n&&"static"===e.position&&r&&["absolute","fixed"].includes(r.position)||ujt(o)&&!n&&Mjt(t,o))?i=i.filter((t=>t!==o)):r=e,o=yjt(o)}return e.set(t,i),i}(e,this.Dh):[].concat(n),o=[...s,i],a=o[0],l=o.reduce(((t,n)=>{const i=Ejt(e,n,r);return t.top=KHt(i.top,t.top),t.right=XHt(i.right,t.right),t.bottom=XHt(i.bottom,t.bottom),t.left=KHt(i.left,t.left),t}),Ejt(e,a,r));return{width:l.right-l.left,height:l.bottom-l.top,x:l.left,y:l.top}},getOffsetParent:Ajt,getElementRects:async function(t){let{reference:e,floating:n,strategy:i}=t;const r=this.getOffsetParent||Ajt,s=this.getDimensions;return{reference:$jt(e,await r(n),i),floating:{x:0,y:0,...await s(n)}}},getClientRects:function(t){return Array.from(t.getClientRects())},getDimensions:function(t){return xjt(t)},getScale:Sjt,isElement:ajt,isRTL:function(t){return"rtl"===mjt(t).direction}};function Rjt(t,e,n,i){void 0===i&&(i={});const{ancestorScroll:r=!0,ancestorResize:s=!0,elementResize:o="function"==typeof ResizeObserver,layoutShift:a="function"==typeof IntersectionObserver,animationFrame:l=!1}=i,c=wjt(t),u=r||s?[...c?vjt(c):[],...vjt(e)]:[];u.forEach((t=>{r&&t.addEventListener("scroll",n,{passive:!0}),s&&t.addEventListener("resize",n)}));const h=c&&a?function(t,e){let n,i=null;const r=sjt(t);function s(){clearTimeout(n),i&&i.disconnect(),i=null}return function o(a,l){void 0===a&&(a=!1),void 0===l&&(l=1),s();const{left:c,top:u,width:h,height:d}=t.getBoundingClientRect();if(a||e(),!h||!d)return;const p={rootMargin:-ZHt(u)+"px "+-ZHt(r.clientWidth-(c+h))+"px "+-ZHt(r.clientHeight-(u+d))+"px "+-ZHt(c)+"px",threshold:KHt(0,XHt(1,l))||1};let f=!0;function m(t){const e=t[0].intersectionRatio;if(e!==l){if(!f)return o();e?o(!1,e):n=setTimeout((()=>{o(!1,1e-7)}),100)}f=!1}try{i=new IntersectionObserver(m,{...p,root:r.ownerDocument})}catch(t){i=new IntersectionObserver(m,p)}i.observe(t)}(!0),s}(c,n):null;let d,p=-1,f=null;o&&(f=new ResizeObserver((t=>{let[i]=t;i&&i.target===c&&f&&(f.unobserve(e),cancelAnimationFrame(p),p=requestAnimationFrame((()=>{f&&f.observe(e)}))),n()})),c&&!l&&f.observe(c),f.observe(e));let m=l?Tjt(t):null;return l&&function e(){const i=Tjt(t);!m||i.x===m.x&&i.y===m.y&&i.width===m.width&&i.height===m.height||n();m=i,d=requestAnimationFrame(e)}(),n(),()=>{u.forEach((t=>{r&&t.removeEventListener("scroll",n),s&&t.removeEventListener("resize",n)})),h&&h(),f&&f.disconnect(),f=null,l&&cancelAnimationFrame(d)}}const Pjt=(t,e,n)=>{const i=new Map,r={platform:Njt,...n},s={...r.platform,Dh:i};return(async(t,e,n)=>{const{placement:i="bottom",strategy:r="absolute",middleware:s=[],platform:o}=n,a=s.filter(Boolean),l=await(null==o.isRTL?void 0:o.isRTL(e));let c=await o.getElementRects({reference:t,floating:e,strategy:r}),{x:u,y:h}=njt(c,i,l),d=i,p={},f=0;for(let n=0;n<a.length;n++){const{name:s,fn:m}=a[n],{x:g,y:y,data:b,reset:v}=await m({x:u,y:h,initialPlacement:i,placement:d,strategy:r,middlewareData:p,rects:c,platform:o,elements:{reference:t,floating:e}});u=null!=g?g:u,h=null!=y?y:h,p={...p,[s]:{...p[s],...b}},v&&f<=50&&(f++,"object"==typeof v&&(v.placement&&(d=v.placement),v.rects&&(c=!0===v.rects?await o.getElementRects({reference:t,floating:e,strategy:r}):v.rects),({x:u,y:h}=njt(c,d,l))),n=-1)}return{x:u,y:h,placement:d,strategy:r,middlewareData:p}})(t,e,{...r,platform:s})},Ojt=t=>null===t?"":t+"",Ljt=t=>null===t?null:t+"",Djt=t=>null===t?0:Number(t),Fjt=t=>null!==t,zjt=()=>null,Bjt=t=>null===t?[]:JSON.parse(t),Ujt=t=>null===t?{}:JSON.parse(t);function Vjt(t){if(null===t)return Ljt;switch(typeof t){case"undefined":case"string":default:return Ojt;case"boolean":return Fjt;case"number":return Djt;case"function":return zjt;case"object":return oHt(t)?Bjt:Ujt}}const Wjt=Symbol(0),Hjt=Symbol(0),jjt=Symbol(0),Gjt=Symbol(0);function qjt(t,e){class n extends t{static attrs;static[Wjt]=null;static get observedAttributes(){if(!this[Wjt]&&e.props){const t=new Map;for(const n of Object.keys(e.props)){let i=this.attrs?.[n],r=rHt(i)?i:i?i?.attr:i;!1!==r&&(r||(r=BHt(n)),t.set(r,{C:n,B:i&&!rHt(i)&&i?.converter||Vjt(e.props[n])}))}this[Wjt]=t}return this[Wjt]?Array.from(this[Wjt].keys()):[]}$;[jjt]=0;[Gjt]=null;keepAlive=!1;forwardKeepAlive=!0;get scope(){return this.$.$$.a}get attachScope(){return this.$.$$.g}get connectScope(){return this.$.$$.h}get $props(){return this.$.$$.i}get $state(){return this.$.$$.j}get state(){return this.$.state}constructor(...t){if(super(...t),this.$=AWt((()=>function(t,e){return EWt((()=>{RHt.$$=new NHt(t,IWt(),e);const n=new t;return RHt.$$.e=n,RHt.$$=null,n}))}(e)),null),this.$.$$.l(this),e.props){const t=this.$props,n=Object.getOwnPropertyDescriptors(this);for(const i of Object.keys(n))i in e.props&&(t[i].set(this[i]),delete this[i])}}attributeChangedCallback(t,e,n){const i=this.constructor;if(!i[Wjt])return void super.attributeChangedCallback?.(t,e,n);const r=i[Wjt].get(t);r&&(this[r.C]=r.B(n))}connectedCallback(){const t=this.$?.$$;if(!t||t.q)return;if(2!==this[jjt])return void Xjt.call(this);if(!this.isConnected)return;this.hasAttribute("keep-alive")&&(this.keepAlive=!0),t.y(),oHt(this[Gjt])&&function(t,e){for(const n of t)n(e)}(this[Gjt],this),this[Gjt]=null;const e=super.connectedCallback;e&&AWt((()=>e.call(this)),this.connectScope)}disconnectedCallback(){const t=this.$?.$$;if(!t||t.q)return;t.z();const e=super.disconnectedCallback;e&&e.call(this),this.keepAlive||this.hasAttribute("keep-alive")||setTimeout((()=>{requestAnimationFrame((()=>{this.isConnected||t.b()}))}),0)}[Hjt](){const t=this.$.$$,e=this.constructor;if(t.q)return;const n=e[Wjt];if(n)for(const e of this.attributes){let i=n.get(e.name);i&&i.B&&t.i[i.C].set(i.B(this.getAttribute(e.name)))}t.w(),t.x(this),this[jjt]=2,this.connectedCallback()}subscribe(t){return this.$.subscribe(t)}destroy(){this.disconnectedCallback(),this.$.destroy()}}return function(t,e){const n=t.prototype,i=e.prototype;if(e.props)for(const t of Object.keys(e.props))Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get(){return this.$props[t]()},set(e){this.$props[t].set(e)}});if(i[MHt])for(const t of i[MHt])Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get(){return this.$[t]},set(e){this.$[t]=e}});if(i[$Ht])for(const t of i[$Ht])n[t]=function(...e){return this.$[t](...e)}}(n,e),n}function Xjt(){if(0!==this[jjt])return;this[jjt]=1;const t=function(t){let e=t.parentNode,n=t.localName.split("-",1)[0]+"-";for(;e;){if(1===e.nodeType&&e.localName.startsWith(n))return e;e=e.parentNode}return null}(this),e=t&&window.customElements.get(t.localName),n=t&&2===t[jjt];!t||e&&n?Yjt.call(this,t):Kjt.call(this,t)}async function Kjt(t){await window.customElements.whenDefined(t.localName),2!==t[jjt]&&await new Promise((e=>(t[Gjt]??=[]).push(e))),Yjt.call(this,t)}function Yjt(t){if(this.isConnected){if(t){t.keepAlive&&t.forwardKeepAlive&&(this.keepAlive=!0,this.setAttribute("keep-alive",""));const e=this.$.$$.a;e&&t.$.$$.g.append(e)}this[Hjt]()}}function Zjt(t,e=!1){!e&&window.customElements.get(t.tagName)||window.customElements.define(t.tagName,t)}function Jjt(t,e="preconnect"){if(!eHt(document.querySelector(`link[href="${t}"]`)))return!0;const n=document.createElement("link");return n.rel=e,n.href=t,n.crossOrigin="true",document.head.append(n),!0}const Qjt={};function tGt(t){return"use-credentials"===t?"include":rHt(t)?"same-origin":void 0}const eGt={Rc:Symbol(0),ka:Symbol(0),Lc:Symbol(0),Mc:Symbol(0),la:Symbol(0),Ba:Symbol(0),Ca:Symbol(0)};function nGt(t,e){return e>=t.startTime&&e<t.endTime}function iGt(t,e,n){let i=null;function r(){const r=rHt(e)?[e]:e,s=t.toArray().find((t=>r.includes(t.kind)&&"showing"===t.mode));s!==i&&(s?(2==s.readyState?n(s):(n(null),s.addEventListener("load",(()=>n(s)),{once:!0})),i=s):n(null))}return r(),pHt(t,"mode-change",r)}var rGt,sGt,oGt;class aGt extends dHt{constructor(t){super(),this.id="",this.label="",this.language="",this.default=!1,this.Mc=!1,this.Ic=0,this.Ga="disabled",this.Nc={},this.Kc=[],this.Hc=[],this.Jc=[],this[rGt]=0,this[sGt]=null,this[oGt]=null;for(const e of Object.keys(t))this[e]=t[e];this.type||(this.type="vtt"),t.content?Promise.resolve().then((function(){return K2t})).then((({parseText:e,VTTCue:n,VTTRegion:i})=>{"json"===t.type?this.Oc(t.content,n,i):e(t.content,{type:t.type}).then((({cues:t,regions:e})=>{this.Hc=t,this.Kc=e,this.ka()}))})):t.src||(this[eGt.ka]=2)}static createId(t){return`id::${t.type}-${t.kind}-${t.src??t.label}`}get metadata(){return this.Nc}get regions(){return this.Kc}get cues(){return this.Hc}get activeCues(){return this.Jc}get readyState(){return this[eGt.ka]}get mode(){return this.Ga}set mode(t){this.setMode(t)}addCue(t,e){let n=0,i=this.Hc.length;for(n=0;n<i&&!(t.endTime<=this.Hc[n].startTime);n++);n===i?this.Hc.push(t):this.Hc.splice(n,0,t),"cuechange"!==e?.type&&this[eGt.Ba]?.track.addCue(t),this.dispatchEvent(new cHt("add-cue",{detail:t,trigger:e})),nGt(t,this.Ic)&&this[eGt.Lc](this.Ic,e)}removeCue(t,e){const n=this.Hc.indexOf(t);if(n>=0){const i=this.Jc.includes(t);this.Hc.splice(n,1),this[eGt.Ba]?.track.removeCue(t),this.dispatchEvent(new cHt("remove-cue",{detail:t,trigger:e})),i&&this[eGt.Lc](this.Ic,e)}}setMode(t,e){this.Ga!==t&&(this.Ga=t,"disabled"===t?(this.Jc=[],this.Pc()):2===this.readyState?this[eGt.Lc](this.Ic,e):this.Kb(),this.dispatchEvent(new cHt("mode-change",{detail:this,trigger:e})),this[eGt.la]?.())}[(rGt=eGt.ka,sGt=eGt.la,oGt=eGt.Ba,eGt.Lc)](t,e){if(this.Ic=t,"disabled"===this.mode||!this.Hc.length)return;const n=[];for(let e=0,i=this.Hc.length;e<i;e++){const i=this.Hc[e];nGt(i,t)&&n.push(i)}let i=n.length!==this.Jc.length;if(!i)for(let t=0;t<n.length;t++)if(!this.Jc.includes(n[t])){i=!0;break}this.Jc=n,i&&this.Pc(e)}[eGt.Mc](){this.Mc=!0,"disabled"!==this.Ga&&this.Kb()}async Kb(){if(this.Mc&&this.src&&!(this[eGt.ka]>0)){this[eGt.ka]=1,this.dispatchEvent(new cHt("load-start"));try{const{parseResponse:t,VTTCue:e,VTTRegion:n}=await Promise.resolve().then((function(){return K2t})),i=this[eGt.Rc]?.(),r=fetch(this.src,{headers:"json"===this.type?{"Content-Type":"application/json"}:void 0,credentials:tGt(i)});if("json"===this.type)this.Oc(await(await r).text(),e,n);else{const{errors:e,metadata:n,regions:i,cues:s}=await t(r,{type:this.type,encoding:this.encoding});if(0===e[0]?.code)throw e[0];this.Nc=n,this.Kc=i,this.Hc=s}this.ka()}catch(t){this.Qc(t)}}}ka(){if(this[eGt.ka]=2,!this.src||"vtt"!==this.type){const t=this[eGt.Ba]?.track;if(t)for(const e of this.Hc)t.addCue(e)}const t=new cHt("load");this[eGt.Lc](this.Ic,t),this.dispatchEvent(t)}Qc(t){this[eGt.ka]=3,this.dispatchEvent(new cHt("error",{detail:t}))}Oc(t,e,n){try{const{regions:i,cues:r}=uGt(t,e,n);this.Kc=i,this.Hc=r}catch(t){this.Qc(t)}}Pc(t){this.dispatchEvent(new cHt("cue-change",{trigger:t}))}}const lGt=/captions|subtitles/;function cGt(t){return lGt.test(t.kind)}function uGt(t,e,n){const i=JSON.parse(t);let r=[],s=[];return i.regions&&n&&(r=i.regions.map((t=>Object.assign(new n,t)))),(i.cues||oHt(i))&&(s=(oHt(i)?i:i.cues).filter((t=>iHt(t.startTime)&&iHt(t.endTime))).map((t=>Object.assign(new e(0,0,""),t)))),{regions:r,cues:s}}function hGt(t,e,n){t.hasAttribute(e)||t.setAttribute(e,n)}function dGt(t,e){t.hasAttribute("aria-label")||kHt((function(){bHt(t,"aria-label",e())}))}function pGt(t,e,n){for(;e;){if(e===t)return!0;if(n?.(e))break;e=e.parentElement}return!1}function fGt(t,e){pHt(t,"pointerup",(t=>{0===t.button&&e(t)})),pHt(t,"keydown",(t=>{yHt(t)&&e(t)}))}function mGt(t){return mHt(t)&&(t.touches.length>1||t.changedTouches.length>1)}function gGt(t){let e=IWt(),n=window.requestAnimationFrame((()=>{AWt(t,e),n=-1}));return()=>{window.cancelAnimationFrame(n)}}function yGt(t,e,n){let i,r=t,s=t.parentElement,o=t.content.firstElementChild,a=[];!o&&t.firstElementChild&&(t.innerHTML=t.firstElementChild.outerHTML,t.firstElementChild.remove(),o=t.content.firstElementChild);for(let t=0;t<e;t++)i=document.importNode(o,!0),n?.(i,t),s.insertBefore(i,r.nextSibling),a.push(i),r=i;return RWt((()=>{for(let t=0;t<a.length;t++)a[t].remove()})),a}function bGt(t){const e=document.createElement("template");return e.innerHTML=t,e.content}function vGt(t){return t.cloneNode(!0).firstElementChild}function xGt(t,e,n,{offsetVarName:i,xOffset:r,yOffset:s,...o}){if(!t)return;const a=n.replace(" ","-").replace("-center","");if(vHt(t,"visibility",e?null:"hidden"),!e)return;const l=t=>n.includes("top")?`calc(-1 * ${t})`:t;return Rjt(e,t,(()=>{Pjt(e,t,{placement:a,...o}).then((({x:e,y:n})=>{Object.assign(t.style,{top:`calc(${n+"px"} + ${l(s?s+"px":`var(--${i}-y-offset, 0px)`)})`,left:`calc(${e+"px"} + ${r?r+"px":`var(--${i}-x-offset, 0px)`}`})}))}))}const wGt={F:Symbol(0),D:Symbol(0),H:Symbol(0),ha:Symbol(0),C:Symbol(0),E:Symbol(0),I:Symbol(0),G:Symbol(0),fc:Symbol(0)},SGt=navigator?.userAgent.toLowerCase()||"",kGt=/iphone|ipad|ipod|ios|crios|fxios/i.test(SGt),CGt=/(iphone|ipod)/gi.test(navigator?.platform||""),TGt=!!window.chrome,_Gt=!!window.safari||kGt;function EGt(){return!nHt(window.screen.orientation)&&!nHt(window.screen.orientation.lock)&&sHt(screen.orientation.unlock)}function MGt(t){return t||(t=document.createElement("video")),t.canPlayType("application/vnd.apple.mpegurl").length>0}function $Gt(t){return!!document.pictureInPictureEnabled&&!t.disablePictureInPicture}function IGt(t){return sHt(t.webkitSupportsPresentationMode)&&sHt(t.webkitSetPresentationMode)}async function AGt(){const t=document.createElement("video");return t.volume=.5,await function(t){return new Promise((e=>setTimeout(e,t)))}(0),.5===t.volume}function NGt(){const t=window?.MediaSource??window?.WebKitMediaSource;if(nHt(t))return!1;const e=t&&sHt(t.isTypeSupported)&&t.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'),n=window?.SourceBuffer??window?.WebKitSourceBuffer,i=nHt(n)||!nHt(n.prototype)&&sHt(n.prototype.appendBuffer)&&sHt(n.prototype.remove);return!!e&&!!i}const RGt=/\.(m4a|m4b|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i,PGt=new Set(["audio/mpeg","audio/ogg","audio/3gp","audio/mp4","audio/webm","audio/flac"]),OGt=/\.(mp4|og[gv]|webm|mov|m4v)(#t=[,\d+]+)?($|\?)/i,LGt=new Set(["video/mp4","video/webm","video/3gp","video/ogg","video/avi","video/mpeg"]),DGt=/\.(m3u8)($|\?)/i,FGt=new Set(["application/vnd.apple.mpegurl","audio/mpegurl","audio/x-mpegurl","application/x-mpegurl","video/x-mpegurl","video/mpegurl","application/mpegurl"]);function zGt({src:t,type:e}){return rHt(t)&&DGt.test(t)||FGt.has(e)}function BGt(t,e=2){return Number(t.toFixed(e))}function UGt(t){return String(t).split(".")[1]?.length??0}function VGt(t,e,n){return Math.max(t,Math.min(n,e))}const WGt=Symbol(0),HGt=Symbol(0),jGt=WGt,GGt=HGt;function qGt(t){return t instanceof Error?t:Error(JSON.stringify(t))}var XGt;class KGt extends dHt{constructor(){super(...arguments),this.B=[],this[XGt]=!1}get length(){return this.B.length}get readonly(){return this[wGt.C]}toArray(){return[...this.B]}[(XGt=wGt.C,Symbol.iterator)](){return this.B.values()}[wGt.F](t,e){const n=this.B.length;""+n in this||Object.defineProperty(this,n,{get(){return this.B[n]}}),this.B.includes(t)||(this.B.push(t),this.dispatchEvent(new cHt("add",{detail:t,trigger:e})))}[wGt.D](t,e){const n=this.B.indexOf(t);n>=0&&(this[wGt.G]?.(t,e),this.B.splice(n,1),this.dispatchEvent(new cHt("remove",{detail:t,trigger:e})))}[wGt.H](t){for(const e of[...this.B])this[wGt.D](e,t);this.B=[],this[wGt.E](!1,t),this[wGt.I]?.()}[wGt.E](t,e){this[wGt.C]!==t&&(this[wGt.C]=t,this.dispatchEvent(new cHt("readonly-change",{detail:t,trigger:e})))}}var YGt={fullscreenEnabled:0,fullscreenElement:1,requestFullscreen:2,exitFullscreen:3,fullscreenchange:4,fullscreenerror:5,fullscreen:6},ZGt=["webkitFullscreenEnabled","webkitFullscreenElement","webkitRequestFullscreen","webkitExitFullscreen","webkitfullscreenchange","webkitfullscreenerror","-webkit-full-screen"],JGt=["mozFullScreenEnabled","mozFullScreenElement","mozRequestFullScreen","mozCancelFullScreen","mozfullscreenchange","mozfullscreenerror","-moz-full-screen"],QGt=["msFullscreenEnabled","msFullscreenElement","msRequestFullscreen","msExitFullscreen","MSFullscreenChange","MSFullscreenError","-ms-fullscreen"],tqt="undefined"!=typeof window&&void 0!==window.document?window.document:{},eqt="fullscreenEnabled"in tqt&&Object.keys(YGt)||ZGt[0]in tqt&&ZGt||JGt[0]in tqt&&JGt||QGt[0]in tqt&&QGt||[],nqt={requestFullscreen:function(t){return t[eqt[YGt.requestFullscreen]]()},requestFullscreenFunction:function(t){return t[eqt[YGt.requestFullscreen]]},get exitFullscreen(){return tqt[eqt[YGt.exitFullscreen]].bind(tqt)},get fullscreenPseudoClass(){return":"+eqt[YGt.fullscreen]},addEventListener:function(t,e,n){return tqt.addEventListener(eqt[YGt[t]],e,n)},removeEventListener:function(t,e,n){return tqt.removeEventListener(eqt[YGt[t]],e,n)},get fullscreenEnabled(){return Boolean(tqt[eqt[YGt.fullscreenEnabled]])},set fullscreenEnabled(t){},get fullscreenElement(){return tqt[eqt[YGt.fullscreenElement]]},set fullscreenElement(t){},get onfullscreenchange(){return tqt[("on"+eqt[YGt.fullscreenchange]).toLowerCase()]},set onfullscreenchange(t){return tqt[("on"+eqt[YGt.fullscreenchange]).toLowerCase()]=t},get onfullscreenerror(){return tqt[("on"+eqt[YGt.fullscreenerror]).toLowerCase()]},set onfullscreenerror(t){return tqt[("on"+eqt[YGt.fullscreenerror]).toLowerCase()]=t}},iqt=nqt;const rqt=iqt.fullscreenEnabled;class sqt extends PHt{constructor(){super(...arguments),this.J=!1,this.K=!1}get active(){return this.K}get supported(){return rqt}onConnect(){pHt(iqt,"fullscreenchange",this.L.bind(this)),pHt(iqt,"fullscreenerror",this.M.bind(this)),RWt(this.A.bind(this))}async A(){rqt&&await this.exit()}L(t){const e=oqt(this.el);e!==this.K&&(e||(this.J=!1),this.K=e,this.dispatch("fullscreen-change",{detail:e,trigger:t}))}M(t){this.J&&(this.dispatch("fullscreen-error",{detail:null,trigger:t}),this.J=!1)}async enter(){try{if(this.J=!0,!this.el||oqt(this.el))return;return aqt(),iqt.requestFullscreen(this.el)}catch(t){throw this.J=!1,t}}async exit(){if(this.el&&oqt(this.el))return aqt(),iqt.exitFullscreen()}}function oqt(t){if(iqt.fullscreenElement===t)return!0;try{return t.matches(iqt.fullscreenPseudoClass)}catch(t){return!1}}function aqt(){if(!rqt)throw Error("[vidstack] no fullscreen API")}class lqt extends PHt{constructor(){super(...arguments),this.O=xHt(this.Q()),this.N=xHt(!1)}get type(){return this.O()}get locked(){return this.N()}get portrait(){return this.O().startsWith("portrait")}get landscape(){return this.O().startsWith("landscape")}static{this.supported=EGt()}get supported(){return lqt.supported}onConnect(){if(this.supported)pHt(screen.orientation,"change",this.R.bind(this));else{const t=window.matchMedia("(orientation: landscape)");t.onchange=this.R.bind(this),RWt((()=>t.onchange=null))}RWt(this.A.bind(this))}async A(){this.supported&&this.N()&&await this.unlock()}R(t){this.O.set(this.Q()),this.dispatch("orientation-change",{detail:{orientation:MWt(this.O),lock:this.P},trigger:t})}async lock(t){MWt(this.N)||this.P===t||(this.S(),await screen.orientation.lock(t),this.N.set(!0),this.P=t)}async unlock(){MWt(this.N)&&(this.S(),this.P=void 0,await screen.orientation.unlock(),this.N.set(!1))}S(){if(!this.supported)throw Error("[vidstack] no orientation API")}Q(){return this.supported?window.screen.orientation.type:window.innerWidth>=window.innerHeight?"landscape-primary":"portrait-primary"}}class cqt{get length(){return this.gc.length}constructor(t,e){oHt(t)?this.gc=t:nHt(t)||nHt(e)?this.gc=[]:this.gc=[[t,e]]}start(t){return this.gc[t][0]??1/0}end(t){return this.gc[t][1]??1/0}}function uqt(t){if(!t.length)return null;let e=t.start(0);for(let n=1;n<t.length;n++){const i=t.start(n);i<e&&(e=i)}return e}function hqt(t){if(!t.length)return null;let e=t.end(0);for(let n=1;n<t.length;n++){const i=t.end(n);i>e&&(e=i)}return e}const dqt=new FHt({audioTracks:[],audioTrack:null,autoplay:!1,autoplayError:null,buffered:new cqt,duration:0,canLoad:!1,canFullscreen:!1,canOrientScreen:EGt(),canPictureInPicture:!1,canPlay:!1,controls:!1,controlsVisible:!1,crossorigin:null,poster:"",currentTime:0,ended:!1,error:null,fullscreen:!1,loop:!1,logLevel:"silent",mediaType:"unknown",muted:!1,paused:!0,played:new cqt,playing:!1,playsinline:!1,pictureInPicture:!1,preload:"metadata",playbackRate:1,qualities:[],quality:null,autoQuality:!1,canSetQuality:!0,canSetVolume:!1,seekable:new cqt,seeking:!1,source:{src:"",type:""},sources:[],started:!1,title:"",textTracks:[],textTrack:null,volume:1,waiting:!1,get viewType(){return"unknown"!==this.providedViewType?this.providedViewType:this.inferredViewType},get streamType(){return"unknown"!==this.providedStreamType?this.providedStreamType:this.inferredStreamType},get currentSrc(){return this.source},get bufferedStart(){return uqt(this.buffered)??0},get bufferedEnd(){return hqt(this.buffered)??0},get seekableStart(){return uqt(this.seekable)??0},get seekableEnd(){return this.canPlay?hqt(this.seekable)??1/0:0},get seekableWindow(){return Math.max(0,this.seekableEnd-this.seekableStart)},pointer:"fine",orientation:"landscape",width:0,height:0,mediaWidth:0,mediaHeight:0,userBehindLiveEdge:!1,liveEdgeTolerance:10,minLiveDVRWindow:60,get canSeek(){return/unknown|on-demand|:dvr/.test(this.streamType)&&Number.isFinite(this.seekableWindow)&&(!this.live||/:dvr/.test(this.streamType)&&this.seekableWindow>=this.minLiveDVRWindow)},get live(){return this.streamType.includes("live")||!Number.isFinite(this.duration)},get liveEdgeStart(){return this.live&&Number.isFinite(this.seekableEnd)?Math.max(0,(this.liveSyncPosition??this.seekableEnd)-this.liveEdgeTolerance):0},get liveEdge(){return this.live&&(!this.canSeek||!this.userBehindLiveEdge&&this.currentTime>=this.liveEdgeStart)},get liveEdgeWindow(){return this.live&&Number.isFinite(this.seekableEnd)?this.seekableEnd-this.liveEdgeStart:0},autoplaying:!1,inferredViewType:"unknown",providedViewType:"unknown",providedStreamType:"unknown",inferredStreamType:"unknown",liveSyncPosition:null}),pqt=new Set(["autoplay","canFullscreen","canLoad","canPictureInPicture","canSetVolume","controls","crossorigin","fullscreen","height","logLevel","loop","mediaHeight","mediaWidth","mediaType","muted","orientation","pictureInPicture","playsinline","pointer","poster","preload","providedStreamType","inferredViewType","providedViewType","source","sources","textTrack","textTracks","title","volume","width"]);const fqt=CHt();function mqt(){return _Ht(fqt)}class gqt{constructor(t=void 0){this.z=null,this.ic=null,this.kc=-1,this.y=t}setTarget(t){this.z=t}getPlayer(t){return this.ic||(t??this.z)?.dispatchEvent(new cHt("find-media-player",{detail:t=>{this.ic=t},bubbles:!0,composed:!0})),this.ic}setPlayer(t){this.ic=t}startLoading(t){this.hc("media-start-loading",t)}play(t){this.hc("media-play-request",t)}pause(t){this.hc("media-pause-request",t)}mute(t){this.hc("media-mute-request",t)}unmute(t){this.hc("media-unmute-request",t)}enterFullscreen(t,e){this.hc("media-enter-fullscreen-request",e,t)}exitFullscreen(t,e){this.hc("media-exit-fullscreen-request",e,t)}lockScreenOrientation(t,e){this.hc("media-orientation-lock-request",e,t)}unlockScreenOrientation(t){this.hc("media-orientation-unlock-request",t)}enterPictureInPicture(t){this.hc("media-enter-pip-request",t)}exitPictureInPicture(t){this.hc("media-exit-pip-request",t)}seeking(t,e){this.hc("media-seeking-request",e,t)}seek(t,e){this.hc("media-seek-request",e,t)}seekToLiveEdge(t){this.hc("media-live-edge-request",t)}changeVolume(t,e){this.hc("media-volume-change-request",e,Math.max(0,Math.min(1,t)))}changeAudioTrack(t,e){this.hc("media-audio-track-change-request",e,t)}changeQuality(t,e){this.hc("media-quality-change-request",e,t)}requestAutoQuality(t){this.changeQuality(-1,t)}changeTextTrackMode(t,e,n){this.hc("media-text-track-change-request",n,{index:t,mode:e})}changePlaybackRate(t,e){this.hc("media-rate-change-request",e,t)}resumeControls(t){this.hc("media-resume-controls-request",t)}pauseControls(t){this.hc("media-pause-controls-request",t)}togglePaused(t){const e=this.getPlayer(t?.target);e&&(e.state.paused?this.play(t):this.pause(t))}toggleControls(t){const e=this.getPlayer(t?.target);e&&(e.controls.showing?e.controls.hide(0,t):e.controls.show(0,t))}toggleMuted(t){const e=this.getPlayer(t?.target);e&&(e.state.muted?this.unmute(t):this.mute(t))}toggleFullscreen(t,e){const n=this.getPlayer(e?.target);n&&(n.state.fullscreen?this.exitFullscreen(t,e):this.enterFullscreen(t,e))}togglePictureInPicture(t){const e=this.getPlayer(t?.target);e&&(e.state.pictureInPicture?this.exitPictureInPicture(t):this.enterPictureInPicture(t))}disableCaptions(t){const e=this.getPlayer(t?.target);if(!e)return;const n=e.state.textTracks,i=e.state.textTrack;if(i){const e=n.indexOf(i);this.changeTextTrackMode(e,"disabled",t)}}toggleCaptions(t){const e=this.getPlayer(t?.target);if(!e)return;const n=e.state.textTracks,i=e.state.textTrack;if(i){const e=n.indexOf(i);this.changeTextTrackMode(e,"disabled",t),this.kc=e}else{let e=this.kc;n[e]&&cGt(n[e])||(e=-1),-1===e&&(e=n.findIndex((t=>cGt(t)&&t.default))),-1===e&&(e=n.findIndex((t=>cGt(t)))),e>=0&&this.changeTextTrackMode(e,"showing",t),this.kc=-1}}hc(t,e,n){const i=new cHt(t,{bubbles:!0,composed:!0,detail:n,trigger:e});let r=e?.target||null;r&&r instanceof OHt&&(r=r.el);const s=!r||r===document||r===window||r===document.body||this.ic?.el&&r instanceof Node&&!this.ic.el.contains(r);r=s?this.z??this.getPlayer()?.el:r??this.z,this.ic?this.ic.canPlayQueue.lc(t,(()=>r?.dispatchEvent(i))):r?.dispatchEvent(i)}jc(t){}}class yqt extends PHt{}class bqt extends yqt{constructor(){super(...arguments),this.pc=-2,this.mc=!1,this.nc=null,this.defaultDelay=2e3}get showing(){return this.$state.controlsVisible()}show(t=0,e){this.qc(),this.mc||this.oc(!0,t,e)}hide(t=this.defaultDelay,e){this.qc(),this.mc||this.oc(!1,t,e)}pause(t){this.mc=!0,this.qc(),this.oc(!0,0,t)}resume(t){this.mc=!1,this.$state.paused()||this.oc(!1,this.defaultDelay,t)}onConnect(){kHt(this.rc.bind(this));const t=this.db.bind(this),e=this.ib.bind(this);this.listen("can-play",(t=>this.show(0,t))),this.listen("play",t),this.listen("pause",e),this.listen("autoplay-fail",e)}rc(){const{paused:t,started:e,autoplayError:n}=this.$state;if(t()||n()&&!e())return;const i=this.sc.bind(this);kHt((()=>{const t="coarse"===this.$state.pointer(),e=[t?"touchend":"pointerup","keydown"];for(const t of e)pHt(this.el,t,i,{passive:!1});t||pHt(this.el,"pointermove",i)}))}db(t){this.show(0,t),this.hide(this.defaultDelay,t)}ib(t){this.show(0,t)}qc(){window.clearTimeout(this.pc),this.pc=-1}sc(t){t.MEDIA_GESTURE||this.mc||mGt(t)||(gHt(t)&&("Escape"===t.key?(this.el?.focus(),this.nc=null):this.nc&&(t.preventDefault(),requestAnimationFrame((()=>{this.nc?.focus(),this.nc=null})))),this.show(0,t),this.hide(this.defaultDelay,t))}oc(t,e,n){0!==e?this.pc=window.setTimeout((()=>{this.scope&&this.Da(t&&!this.mc,n)}),e):this.Da(t,n)}Da(t,e){this.$state.controlsVisible()!==t&&(this.$state.controlsVisible.set(t),!t&&document.activeElement&&this.el?.contains(document.activeElement)&&(this.nc=document.activeElement,requestAnimationFrame((()=>this.el?.focus()))),this.dispatch("controls-change",{detail:t,trigger:e}))}}class vqt{constructor(){this.priority=0,this.Fh=!0,this.v=null,this.Dc=null,this.Eh=new Set}canRender(){return!0}attach(t){this.v=t,t.textTracks.onchange=this.Da.bind(this)}addTrack(t){this.Eh.add(t),this.Hh(t)}removeTrack(t){t[eGt.Ba]?.remove?.(),t[eGt.Ba]=null,this.Eh.delete(t)}changeTrack(t){const e=t?.[eGt.Ba];e&&"showing"!==e.track.mode&&(e.track.mode="showing"),this.Dc=t}setDisplay(t){this.Fh=t,this.Da()}detach(){this.v&&(this.v.textTracks.onchange=null);for(const t of this.Eh)this.removeTrack(t);this.Eh.clear(),this.v=null,this.Dc=null}Hh(t){if(!this.v)return;const e=t[eGt.Ba]??=this.Ih(t);e instanceof HTMLElement&&(this.v.append(e),e.track.mode=e.default?"showing":"hidden")}Ih(t){const e=document.createElement("track"),n=t.default||"showing"===t.mode,i=t.src&&"vtt"===t.type;return e.id=t.id,e.src=i?t.src:"https://cdn.jsdelivr.net/npm/vidstack@next/empty.vtt",e.label=t.label,e.kind=t.kind,e.default=n,t.language&&(e.srclang=t.language),n&&!i&&this.Gh(t,e.track),e}Gh(t,e){if(!(t.src&&"vtt"===t.type||e.cues?.length))for(const n of t.cues)e.addCue(n)}Da(t){for(const e of this.Eh){const n=e[eGt.Ba]?.track;if(!n)continue;if(!this.Fh){n.mode="disabled";continue}const i="showing"===n.mode;i&&this.Gh(e,n),e.setMode(i?"showing":"disabled",t)}}}class xqt{constructor(t){this.v=null,this.vc=[],this.xc=!1,this.tc=null,this.uc=null,this.g=t;const e=t.textTracks;this.wc=e,kHt(this.Ac.bind(this)),RWt(this.yc.bind(this)),pHt(e,"add",this.za.bind(this)),pHt(e,"remove",this.Bc.bind(this)),pHt(e,"mode-change",this.Hb.bind(this))}Ac(){const{$state:t,$iosControls:e}=this.g;this.xc=t.controls()||e(),this.Hb()}add(t){this.vc.push(t),this.Hb()}remove(t){t.detach(),this.vc.splice(this.vc.indexOf(t),1),this.Hb()}j(t){requestAnimationFrame((()=>{if(this.v=t,t){this.tc=new vqt,this.tc.attach(t);for(const t of this.wc)this.zc(t)}this.Hb()}))}zc(t){cGt(t)&&this.tc?.addTrack(t)}Cc(t){cGt(t)&&this.tc?.removeTrack(t)}za(t){this.zc(t.detail)}Bc(t){this.Cc(t.detail)}Hb(){if(!this.v)return void this.yc();const t=this.wc.selected;if(this.xc||t?.[eGt.Ca])return this.uc?.changeTrack(null),this.tc?.setDisplay(!0),void this.tc?.changeTrack(t);if(this.tc?.setDisplay(!1),this.tc?.changeTrack(null),!t)return void this.uc?.changeTrack(null);const e=this.vc.sort(((t,e)=>t.priority-e.priority)).find((e=>e.canRender(t)));this.uc!==e&&(this.uc?.detach(),e?.attach(this.v),this.uc=e??null),e?.changeTrack(t)}yc(){this.tc?.detach(),this.tc=null,this.uc?.detach(),this.uc=null}}class wqt extends KGt{constructor(){super(...arguments),this.Mc=!1,this.Sc={},this.Tc=this.Uc.bind(this)}get selected(){const t=this.B.find((t=>"showing"===t.mode&&cGt(t)));return t??null}add(t,e){const n=t instanceof aGt?t:new aGt(t);return this.Sc[t.kind]&&t.default&&delete t.default,n.addEventListener("mode-change",this.Tc),this[wGt.F](n,e),n[eGt.Rc]=this[eGt.Rc],this.Mc&&n[eGt.Mc](),t.default&&(this.Sc[t.kind]=n,n.mode="showing"),this}remove(t,e){if(this.B.includes(t))return t===this.Sc[t.kind]&&delete this.Sc[t.kind],t.mode="disabled",t[eGt.la]=null,t.removeEventListener("mode-change",this.Tc),this[wGt.D](t,e),this}clear(t){for(const e of[...this.B])this.remove(e,t);return this}getById(t){return this.B.find((e=>e.id===t))??null}getByKind(t){const e=Array.isArray(t)?t:[t];return this.B.filter((t=>e.includes(t.kind)))}[eGt.Mc](){if(!this.Mc){for(const t of this.B)t[eGt.Mc]();this.Mc=!0}}Uc(t){const e=t.detail;if("showing"===e.mode){const t=cGt(e)?["captions","subtitles"]:[e.kind];for(const n of this.B)"showing"===n.mode&&n!=e&&t.includes(n.kind)&&(n.mode="disabled")}this.dispatchEvent(new cHt("mode-change",{detail:t.detail,trigger:t}))}}const Sqt=Symbol(0);class kqt extends KGt{get selected(){return this.B.find((t=>t.selected))??null}get selectedIndex(){return this.B.findIndex((t=>t.selected))}[wGt.G](t,e){this[wGt.ha](t,!1,e)}[wGt.F](t,e){t[Sqt]=!1,Object.defineProperty(t,"selected",{get(){return this[Sqt]},set:e=>{this.readonly||(this[wGt.fc]?.(),this[wGt.ha](t,e))}}),super[wGt.F](t,e)}[wGt.ha](t,e,n){if(e===t[Sqt])return;const i=this.selected;t[Sqt]=e;(e?i!==t:i===t)&&(i&&(i[Sqt]=!1),this.dispatchEvent(new cHt("change",{detail:{prev:i,current:this.selected},trigger:n})))}}class Cqt extends kqt{getById(t){return""===t?null:this.B.find((e=>e.id===t))??null}}const Tqt=eval,_qt=/:\s+'?"?(.*?)'?"?\)/g,Eqt=/\s+not\s+/g,Mqt=/\s+and\s+/g,$qt=/\s+or\s+/g,Iqt=/(\d)px/g;class Aqt extends dHt{constructor(t,e){super(),this.Vc=xHt("true"),this.Wc=new Set,this.Xc=xHt(!0),this.$matches=wHt((()=>{let t=this.Vc();if("never"===t)return!1;for(const e of this.Wc){const n=this.Zc[e](),i=rHt(n)?`'${n}'`:n+"";t=t.replace(BHt(e),i)}return Tqt(`!!(${t})`)&&this.Xc()})),this.Yc=e,this.Zc=t,EWt((t=>{kHt(this.r.bind(this)),kHt(this.$c.bind(this)),this._c=t}))}static{this.create=t=>{const e=mqt();return new Aqt(e.$state,t)}}get query(){return VHt(this.Yc)}get matches(){return this.$matches()}r(){const t=this.query;if(""===t)return;if("never"===t)return void this.Vc.set(t);const e=t.trim().split(/\s*,\s*/g),n=e.filter((t=>t.startsWith("@media"))).join(","),i=e.filter((t=>!t.startsWith("@media")));if(n.length){const t=window.matchMedia(n.replace(/@media\s/g,"")),e=()=>{this.Xc.set(t.matches)};e(),pHt(t,"change",e)}if(i.length){const t=this.ad(i),e=Object.keys(dqt.record);for(const n of t.matchAll(/\(([-a-zA-Z]+)\s/g)){const t=UHt(n[1]);e.includes(t)&&this.Wc.add(t)}this.Vc.set(t)}return()=>{this.Wc.clear(),this.Vc.set("true"),this.Xc.set(!0)}}$c(){this.$matches(),this.dispatchEvent(new Event("change"))}ad(t){return t.map((t=>"("+t.replace(_qt,' == "$1")').replace(Eqt,"!").replace(Mqt," && ").replace($qt," || ").replace(Iqt,"$1").trim()+")")).join(" || ")}destroy(){this._c()}}class Nqt extends kqt{constructor(){super(...arguments),this.bd=!1,this.switch="current"}get auto(){return this.bd||this.readonly}[wGt.fc](){this[jGt](!1)}[wGt.I](t){this[jGt](!1,t)}autoSelect(t){this.readonly||this.bd||!this[GGt]||(this[GGt]?.(),this[jGt](!0,t))}[jGt](t,e){this.bd!==t&&(this.bd=t,this.dispatchEvent(new cHt("auto-change",{detail:t,trigger:e})))}}function Rqt(t){return function(t){return t instanceof HTMLAudioElement}(t)||function(t){return t instanceof HTMLVideoElement}(t)}const Pqt=new Set(["Shift","Alt","Meta","Control"]),Oqt='input, textarea, select, [contenteditable], [role^="menuitem"]';class Lqt extends yqt{constructor(t){super(),this.cd=null,this.g=t}onConnect(){kHt(this.gd.bind(this))}gd(){const{keyDisabled:t,keyTarget:e}=this.$props;if(t())return;const n="player"===e()?this.el:document,i=xHt(!1);n===this.el?(this.listen("focusin",(()=>i.set(!0))),this.listen("focusout",(t=>{this.el.contains(t.target)||i.set(!1)}))):(MWt(i)||i.set(document.querySelector("[data-media-player]")===this.el),pHt(document,"focusin",(t=>{const e=t.composedPath().find((t=>t instanceof Element&&"media-player"===t.localName));void 0!==e&&i.set(this.el===e)}))),kHt((()=>{i()&&(pHt(n,"keyup",this.hd.bind(this)),pHt(n,"keydown",this.id.bind(this)),pHt(n,"keydown",this.jd.bind(this),{capture:!0}))}))}hd(t){const e=document.activeElement;if(!t.key||!this.$state.canSeek()||e?.matches(Oqt))return;let{method:n,value:i}=this.ed(t);if(rHt(i)||oHt(i)){if(n?.startsWith("seek")&&(t.preventDefault(),t.stopPropagation(),this.cd?(this.fd(t,"seekForward"===n),this.cd=null):(this.g.remote.seek(this.dd,t),this.dd=void 0)),n?.startsWith("volume")){const e=this.el.querySelector("[data-media-volume-slider]");e?.dispatchEvent(new KeyboardEvent("keyup",{key:"volumeUp"===n?"Up":"Down",shiftKey:t.shiftKey,trigger:t}))}}else i?.callback(t)}id(t){if(!t.key||Pqt.has(t.key))return;const e=document.activeElement;if(e?.matches(Oqt)||yHt(t)&&e?.matches('button, [role="button"]'))return;let{method:n,value:i}=this.ed(t);if(rHt(i)||oHt(i)){if(!n&&!t.metaKey&&/[0-9]/.test(t.key))return t.preventDefault(),t.stopPropagation(),void this.g.remote.seek(this.$state.duration()/10*Number(t.key),t);if(n)switch(t.preventDefault(),t.stopPropagation(),n){case"seekForward":case"seekBackward":this.kd(t,n,"seekForward"===n);break;case"volumeUp":case"volumeDown":const e=this.el.querySelector("[data-media-volume-slider]");if(e)e.dispatchEvent(new KeyboardEvent("keydown",{key:"volumeUp"===n?"Up":"Down",shiftKey:t.shiftKey,trigger:t}));else{const e=t.shiftKey?.1:.05;this.g.remote.changeVolume(this.$state.volume()+("volumeUp"===n?+e:-e),t)}break;case"toggleFullscreen":this.g.remote.toggleFullscreen("prefer-media",t);break;case"speedUp":case"slowDown":const i=this.$state.playbackRate();this.g.remote.changePlaybackRate(Math.max(.25,Math.min(2,i+("speedUp"===n?.25:-.25))),t);break;default:this.g.remote[n]?.(t)}}else i?.callback(t)}jd(t){Rqt(t.target)&&this.ed(t).method&&t.preventDefault()}ed(t){const e={...this.$props.keyShortcuts(),...this.g.ariaKeys},n=Object.keys(e).find((n=>{const i=e[n],r=oHt(i)?i.join(" "):rHt(i)?i:i?.keys;return(oHt(r)?r:r?.split(" "))?.some((e=>function(t){return t.replace(/Shift\+(\d)/g,((t,e)=>Dqt[e-1]))}(e).replace(/Control/g,"Ctrl").split("+").every((e=>Pqt.has(e)?t[e.toLowerCase()+"Key"]:t.key===e.replace("Space"," ")))))}));return{method:n,value:n?e[n]:null}}ld(t,e){const n=t.shiftKey?10:5;return this.dd=Math.max(0,Math.min((this.dd??this.$state.currentTime())+("seekForward"===e?+n:-n),this.$state.duration()))}fd(t,e){this.cd?.dispatchEvent(new KeyboardEvent(t.type,{key:e?"Right":"Left",shiftKey:t.shiftKey,trigger:t}))}kd(t,e,n){this.$state.canSeek()&&(this.cd||(this.cd=this.el.querySelector("[data-media-time-slider]")),this.cd?this.fd(t,n):this.g.remote.seeking(this.ld(t,e),t))}}const Dqt=["!","@","#","$","%","^","&","*","(",")"];class Fqt extends PHt{constructor(t){super(),this.md=t}onAttach(t){const{$props:e,ariaKeys:n}=mqt(),i=t.getAttribute("aria-keyshortcuts");if(i)return n[this.md]=i,void RWt((()=>{delete n[this.md]}));const r=e.keyShortcuts()[this.md];if(r){const e=oHt(r)?r.join(" "):rHt(r)?r:r?.keys;t.setAttribute("aria-keyshortcuts",oHt(e)?e.join(" "):e)}}}class zqt{canPlay({src:t,type:e}){return rHt(t)?RGt.test(t)||PGt.has(e)||t.startsWith("blob:")&&"audio/object"===e:"audio/object"===e}mediaType(){return"audio"}async load(){return new((await Promise.resolve().then((function(){return t3t}))).AudioProvider)(this.target)}}class Bqt{canPlay(t){return rHt(t.src)?OGt.test(t.src)||LGt.has(t.type)||t.src.startsWith("blob:")&&"video/object"===t.type||zGt(t)&&MGt():"video/object"===t.type}mediaType(){return"video"}async load(t){return new((await Promise.resolve().then((function(){return a3t}))).VideoProvider)(this.target,t)}}class Uqt extends Bqt{static{this.supported=NGt()}preconnect(){Jjt("https://cdn.jsdelivr.net","preconnect")}canPlay(t){return Uqt.supported&&zGt(t)}async load(t){return new((await Promise.resolve().then((function(){return h3t}))).HLSProvider)(this.target,t)}}const Vqt=Symbol(0),Wqt=["autoplay","autoplayError","canFullscreen","canPictureInPicture","canLoad","canPlay","canSeek","ended","fullscreen","loop","live","liveEdge","mediaType","muted","paused","pictureInPicture","playing","playsinline","seeking","started","streamType","viewType","waiting"],Hqt={autoplay:!1,controls:!1,currentTime:0,crossorigin:null,fullscreenOrientation:"landscape",load:"visible",logLevel:"silent",loop:!1,muted:!1,paused:!0,playsinline:!1,playbackRate:1,poster:"",preload:"metadata",preferNativeHLS:!1,src:"",controlsDelay:2e3,viewType:"unknown",streamType:"unknown",volume:1,liveEdgeTolerance:10,minLiveDVRWindow:60,keyDisabled:!1,keyTarget:"player",keyShortcuts:{togglePaused:"k Space",toggleMuted:"m",toggleFullscreen:"f",togglePictureInPicture:"i",toggleCaptions:"c",seekBackward:"j J ArrowLeft",seekForward:"l L ArrowRight",volumeUp:"ArrowUp",volumeDown:"ArrowDown",speedUp:">",slowDown:"<"},title:""};class jqt extends yqt{constructor(t){super(),this.sa=t}async onAttach(t){const e=this.$props.load();if("eager"===e)requestAnimationFrame(this.sa);else if("idle"===e)!function(t,e){new Promise((n=>{qHt((e=>{t?.(e),n()}),e)}))}(this.sa);else if("visible"===e){const e=new IntersectionObserver((t=>{this.scope&&t[0].isIntersecting&&(e.disconnect(),this.sa())}));return e.observe(t),e.disconnect.bind(e)}}}class Gqt{constructor(t,e){this.Md=t,this.g=e}f(t,...e){this.Md(new cHt(t,e?.[0]))}async sb(t,e){const{$state:n,logger:i}=this.g;MWt(n.canPlay)||(this.f("can-play",{detail:t,trigger:e}),$Wt(),n.canPlay()&&n.autoplay()&&!n.started()&&await this.Kh(e))}async Kh(t){const{player:e,$state:n}=this.g;n.autoplaying.set(!0);const i=new cHt("autoplay-attempt",{trigger:t});try{await e.play(i)}catch(t){}}}class qqt{constructor(){this.Mh=new Map}lc(t,e){this.Mh.has(t)||this.Mh.set(t,new Set),this.Mh.get(t).add(e)}ti(t,e){const n=this.Mh.get(t);if(n)for(const t of n)e(t);this.Mh.delete(t)}Qh(t){this.Mh.delete(t)}Ri(t){return this.Mh.get(t)?.size??0}H(){this.Mh.clear()}}class Xqt{constructor(){this.kd=!1,this.Rh=!1,this.Oh=!1,this.Mh=new qqt}}class Kqt extends yqt{constructor(t,e,n){super(),this.Ph=!1,this.od=t,this.Lh=e,this.g=n,this.Ra=n.$provider,this.Nd=new bqt,this.Nh=new sqt,this.Ke=new lqt}onAttach(){this.listen("fullscreen-change",this.L.bind(this))}onConnect(){const t=Object.getOwnPropertyNames(Object.getPrototypeOf(this)),e=this.Vh.bind(this);for(const n of t)n.startsWith("media-")&&this.listen(n,e);kHt(this.Wh.bind(this)),kHt(this.Xh.bind(this)),kHt(this.Yh.bind(this))}Vh(t){t.stopPropagation(),MWt(this.Ra)&&this[t.type]?.(t)}async Kd(t){const{canPlay:e,paused:n,ended:i,autoplaying:r,seekableStart:s}=this.$state;if(MWt(n))if("media-play-request"===t?.type){this.Lh.Mh.lc("play",t);try{const t=MWt(this.Ra);return Yqt(t,MWt(e)),MWt(i)&&(t.currentTime=s()+.1),await t.play()}catch(e){const n=this.createEvent("play-fail",{detail:qGt(e),trigger:t});throw n.autoplay=r(),this.od.Md(n),e}}else this.dispatchEvent(this.createEvent("media-play-request",{trigger:t}))}async Jd(t){const{canPlay:e,paused:n}=this.$state;if(MWt(n))return;if("media-pause-request"!==t?.type)return void this.dispatchEvent(this.createEvent("media-pause-request",{trigger:t}));this.Lh.Mh.lc("pause",t);const i=MWt(this.Ra);return Yqt(i,MWt(e)),i.pause()}Sd(t){const{canPlay:e,live:n,liveEdge:i,canSeek:r,liveSyncPosition:s,seekableEnd:o,userBehindLiveEdge:a}=this.$state;if(a.set(!1),MWt((()=>!n()||i()||!r())))return;const l=MWt(this.Ra);Yqt(l,MWt(e)),l.currentTime=s()??o()-2}async Od(t="prefer-media",e){const n=this.Sh(t);if(Zqt(t,n),!n.active){if(MWt(this.$state.pictureInPicture)&&(this.Ph=!0,await this.Rd(e)),"media-enter-fullscreen-request"===e?.type)return this.Lh.Mh.lc("fullscreen",e),n.enter();this.dispatchEvent(this.createEvent("media-enter-fullscreen-request",{detail:t,trigger:e}))}}async Pd(t="prefer-media",e){const n=this.Sh(t);if(Zqt(t,n),n.active)if("media-exit-fullscreen-request"===e?.type)try{this.Lh.Mh.lc("fullscreen",e);const t=await n.exit();return this.Ph&&MWt(this.$state.canPictureInPicture)&&await this.Qd(),t}finally{this.Ph=!1}else this.dispatchEvent(this.createEvent("media-exit-fullscreen-request",{detail:t,trigger:e}))}Sh(t){const e=MWt(this.Ra);return"prefer-media"===t&&this.Nh.supported||"media"===t?this.Nh:e?.fullscreen}async Qd(t){if(this.Th(),!this.$state.pictureInPicture()){if("media-enter-pip-request"===t?.type)return this.Lh.Mh.lc("pip",t),await this.Ra().pictureInPicture.enter();this.dispatchEvent(this.createEvent("media-enter-pip-request",{trigger:t}))}}async Rd(t){if(this.Th(),this.$state.pictureInPicture()){if("media-exit-pip-request"===t?.type)return this.Lh.Mh.lc("pip",t),await this.Ra().pictureInPicture.exit();this.dispatchEvent(this.createEvent("media-exit-pip-request",{trigger:t}))}}Th(){if(!this.$state.canPictureInPicture())throw Error("[vidstack] no pip support")}Wh(){this.Nd.defaultDelay=this.$props.controlsDelay()}Xh(){const{canLoad:t,canFullscreen:e}=this.$state,n=this.Nh.supported||this.Ra()?.fullscreen?.supported||!1;t()&&MWt(e)===n||e.set(n)}Yh(){const{canLoad:t,canPictureInPicture:e}=this.$state,n=this.Ra()?.pictureInPicture?.supported||!1;t()&&MWt(e)===n||e.set(n)}"media-audio-track-change-request"(t){if(this.g.audioTracks.readonly)return;const e=t.detail,n=this.g.audioTracks[e];n&&(this.Lh.Mh.lc("audioTrack",t),n.selected=!0)}async"media-enter-fullscreen-request"(t){try{await this.Od(t.detail,t)}catch(e){this.M(e,t)}}async"media-exit-fullscreen-request"(t){try{await this.Pd(t.detail,t)}catch(e){this.M(e,t)}}async L(t){const e=MWt(this.$props.fullscreenOrientation),n=t.detail;if(!nHt(e)&&this.Ke.supported)if(n){if(this.Ke.locked)return;this.dispatch("media-orientation-lock-request",{detail:e,trigger:t})}else this.Ke.locked&&this.dispatch("media-orientation-unlock-request",{trigger:t})}M(t,e){this.od.Md(this.createEvent("fullscreen-error",{detail:qGt(t)}))}async"media-orientation-lock-request"(t){try{this.Lh.Mh.lc("orientation",t),await this.Ke.lock(t.detail)}catch(t){this.Lh.Mh.Qh("orientation")}}async"media-orientation-unlock-request"(t){try{this.Lh.Mh.lc("orientation",t),await this.Ke.unlock()}catch(t){this.Lh.Mh.Qh("orientation")}}async"media-enter-pip-request"(t){try{await this.Qd(t)}catch(e){this.Uh(e,t)}}async"media-exit-pip-request"(t){try{await this.Rd(t)}catch(e){this.Uh(e,t)}}Uh(t,e){this.od.Md(this.createEvent("picture-in-picture-error",{detail:qGt(t)}))}"media-live-edge-request"(t){const{live:e,liveEdge:n,canSeek:i}=this.$state;if(e()&&!n()&&i()){this.Lh.Mh.lc("seeked",t);try{this.Sd()}catch(t){}}}"media-loop-request"(t){window.requestAnimationFrame((async()=>{try{this.Lh.Rh=!0,this.Lh.Oh=!0,await this.Kd(t)}catch(t){this.Lh.Rh=!1,this.Lh.Oh=!1}}))}async"media-pause-request"(t){if(!this.$state.paused())try{await this.Jd(t)}catch(t){this.Lh.Mh.Qh("pause")}}async"media-play-request"(t){if(this.$state.paused())try{await this.Kd(t)}catch(t){}}"media-rate-change-request"(t){this.$state.playbackRate()!==t.detail&&(this.Lh.Mh.lc("rate",t),this.Ra().playbackRate=t.detail)}"media-quality-change-request"(t){if(this.g.qualities.readonly)return;this.Lh.Mh.lc("quality",t);const e=t.detail;if(e<0)this.g.qualities.autoSelect(t);else{const t=this.g.qualities[e];t&&(t.selected=!0)}}"media-pause-controls-request"(t){this.Lh.Mh.lc("controls",t),this.Nd.pause(t)}"media-resume-controls-request"(t){this.Lh.Mh.lc("controls",t),this.Nd.resume(t)}"media-seek-request"(t){const{seekableStart:e,seekableEnd:n,ended:i,canSeek:r,live:s,userBehindLiveEdge:o}=this.$state;i()&&(this.Lh.Oh=!0),this.Lh.kd=!1,this.Lh.Mh.Qh("seeking");const a=Math.min(Math.max(e()+.1,t.detail),n()-.1);Number.isFinite(a)&&r()&&(this.Lh.Mh.lc("seeked",t),this.Ra().currentTime=a,s()&&t.isOriginTrusted&&Math.abs(n()-a)>=2&&o.set(!0))}"media-seeking-request"(t){this.Lh.Mh.lc("seeking",t),this.$state.seeking.set(!0),this.Lh.kd=!0}"media-start-loading"(t){this.$state.canLoad()||(this.Lh.Mh.lc("load",t),this.od.Md(this.createEvent("can-load")))}"media-text-track-change-request"(t){const{index:e,mode:n}=t.detail,i=this.g.textTracks[e];i&&(this.Lh.Mh.lc("textTrack",t),i.setMode(n,t))}"media-mute-request"(t){this.$state.muted()||(this.Lh.Mh.lc("volume",t),this.Ra().muted=!0)}"media-unmute-request"(t){const{muted:e,volume:n}=this.$state;e()&&(this.Lh.Mh.lc("volume",t),this.g.$provider().muted=!1,0===n()&&(this.Lh.Mh.lc("volume",t),this.Ra().volume=.25))}"media-volume-change-request"(t){const{muted:e,volume:n}=this.$state,i=t.detail;n()!==i&&(this.Lh.Mh.lc("volume",t),this.Ra().volume=i,i>0&&e()&&(this.Lh.Mh.lc("volume",t),this.Ra().muted=!1))}}function Yqt(t,e){if(!t||!e)throw Error("[vidstack] media not ready")}function Zqt(t,e){if(!e?.supported)throw Error("[vidstack] no fullscreen support")}var Jqt=function(t,e,n){var i=null,r=null,s=function(){i&&(clearTimeout(i),r=null,i=null)},o=function(){if(!e)return t.apply(this,arguments);var o=this,a=arguments,l=n&&!i;return s(),r=function(){t.apply(o,a)},i=setTimeout((function(){if(i=null,!l){var t=r;return r=null,t()}}),e),l?r():void 0};return o.cancel=s,o.flush=function(){var t=r;s(),t&&t()},o};var Qqt=function(t,e,n){var i=null,r=null,s=n&&n.leading,o=n&&n.trailing;null==s&&(s=!0);null==o&&(o=!s);1==s&&(o=!1);var a=function(){i&&(clearTimeout(i),i=null)},l=function(){var n=s&&!i,a=this,l=arguments;if(r=function(){return t.apply(a,l)},i||(i=setTimeout((function(){if(i=null,o)return r()}),e)),n)return n=!1,r()};return l.cancel=a,l.flush=function(){var t=r;a(),t&&t()},l};const tXt=new Set(["autoplay","autoplay-fail","can-load","sources-change","source-change","load-start","abort","error","loaded-metadata","loaded-data","can-play","play","play-fail","pause","playing","seeking","seeked","waiting"]);class eXt extends yqt{constructor(t,e){super(),this.Zh=new Map,this.ci=!1,this.bi=!1,this.seeking=Qqt((t=>{const{seeking:e,currentTime:n,paused:i}=this.$state;e.set(!0),n.set(t.detail),this._h("seeking",t),i()&&(this.$h=t,this.ei())}),150,{leading:!0}),this.ei=Jqt((()=>{if(!this.$h)return;this.ci=!0;const{waiting:t,playing:e}=this.$state;t.set(!0),e.set(!1);const n=this.createEvent("waiting",{trigger:this.$h});this.Zh.set("waiting",n),this.dispatch(n),this.$h=void 0,this.ci=!1}),300),this.Lh=t,this.g=e}onAttach(t){t.setAttribute("aria-busy","true"),this.listen("fullscreen-change",this["fullscreen-change"].bind(this)),this.listen("fullscreen-error",this["fullscreen-error"].bind(this)),this.listen("orientation-change",this["orientation-change"].bind(this))}onConnect(t){this.li(),this.mi(),this.ni(),this.oi(),RWt(this.pi.bind(this))}Md(t){if(!this.scope)return;const e=t.type;this[t.type]?.(t),tXt.has(e)&&this.Zh.set(e,t),this.dispatch(t)}oi(){this.bi&&(this.g.$provider()?.paused&&requestAnimationFrame((()=>{this.scope&&this.g.remote.play(new cHt("dom-connect"))})),this.bi=!1)}pi(){this.bi||(this.bi=!this.g.$state.paused(),this.g.$provider()?.pause())}ai(){this.fi(),this.Lh.Oh=!1,this.Lh.Rh=!1,this.ci=!1,this.$h=void 0,this.Zh.clear()}_h(t,e){this.Lh.Mh.ti(t,(t=>{e.request=t,hHt(e,t)}))}li(){this.di(),this.gi();const t=this.g.textTracks;pHt(t,"add",this.di.bind(this)),pHt(t,"remove",this.di.bind(this)),pHt(t,"mode-change",this.gi.bind(this))}mi(){const t=this.g.qualities;pHt(t,"add",this.hi.bind(this)),pHt(t,"remove",this.hi.bind(this)),pHt(t,"change",this.da.bind(this)),pHt(t,"auto-change",this.qi.bind(this)),pHt(t,"readonly-change",this.ri.bind(this))}ni(){const t=this.g.audioTracks;pHt(t,"add",this.ii.bind(this)),pHt(t,"remove",this.ii.bind(this)),pHt(t,"change",this.si.bind(this))}di(t){const{textTracks:e}=this.$state;e.set(this.g.textTracks.toArray()),this.dispatch("text-tracks-change",{detail:e(),trigger:t})}gi(t){t&&this._h("textTrack",t);const e=this.g.textTracks.selected,{textTrack:n}=this.$state;n()!==e&&(n.set(e),this.dispatch("text-track-change",{detail:e,trigger:t}))}ii(t){const{audioTracks:e}=this.$state;e.set(this.g.audioTracks.toArray()),this.dispatch("audio-tracks-change",{detail:e(),trigger:t})}si(t){const{audioTrack:e}=this.$state;e.set(this.g.audioTracks.selected),this._h("audioTrack",t),this.dispatch("audio-track-change",{detail:e(),trigger:t})}hi(t){const{qualities:e}=this.$state;e.set(this.g.qualities.toArray()),this.dispatch("qualities-change",{detail:e(),trigger:t})}da(t){const{quality:e}=this.$state;e.set(this.g.qualities.selected),this._h("quality",t),this.dispatch("quality-change",{detail:e(),trigger:t})}qi(){this.$state.autoQuality.set(this.g.qualities.auto)}ri(){this.$state.canSetQuality.set(!this.g.qualities.readonly)}"provider-change"(t){const e=this.g.$provider(),n=t.detail;e?.type!==n?.type&&(e?.destroy?.(),e?.scope?.dispose(),this.g.$provider.set(t.detail),e&&null===t.detail&&this.ji(t))}"provider-loader-change"(t){}autoplay(t){this.$state.autoplayError.set(null)}"autoplay-fail"(t){this.$state.autoplayError.set(t.detail),this.ai()}"can-load"(t){this.$state.canLoad.set(!0),this.Zh.set("can-load",t),this._h("load",t),this.g.textTracks[eGt.Mc]()}"media-type-change"(t){hHt(t,this.Zh.get("source-change"));const e=this.$state.viewType();this.$state.mediaType.set(t.detail);const n=this.$state.providedViewType(),i="unknown"===n?t.detail:n;e!==i&&setTimeout((()=>{requestAnimationFrame((()=>{this.scope&&(this.$state.inferredViewType.set(t.detail),this.dispatch("view-type-change",{detail:i,trigger:t}))}))}),0)}"stream-type-change"(t){const{streamType:e,inferredStreamType:n}=this.$state;hHt(t,this.Zh.get("source-change")),n.set(t.detail),t.detail=e()}"rate-change"(t){this.$state.playbackRate.set(t.detail),this._h("rate",t)}"sources-change"(t){this.$state.sources.set(t.detail)}"source-change"(t){hHt(t,this.Zh.get("sources-change")),this.ji(t),this.Zh.set(t.type,t),this.$state.source.set(t.detail),this.el?.setAttribute("aria-busy","true")}ji(t){var e;this.g.audioTracks[wGt.H](t),this.g.qualities[wGt.H](t),this.ai(),e=this.g.$state,dqt.reset(e,(t=>!pqt.has(t))),$Wt()}abort(t){const e=this.Zh.get("source-change");hHt(t,e),e?.trigger||hHt(t,this.Zh.get("can-load"))}"load-start"(t){hHt(t,this.Zh.get("source-change"))}error(t){this.$state.error.set(t.detail),hHt(t,this.Zh.get("abort"))}"loaded-metadata"(t){hHt(t,this.Zh.get("load-start"))}"loaded-data"(t){hHt(t,this.Zh.get("load-start"))}"can-play"(t){"loadedmetadata"!==t.trigger?.type&&hHt(t,this.Zh.get("loaded-metadata")),this.ki(t.detail),this.el?.setAttribute("aria-busy","false")}"can-play-through"(t){this.ki(t.detail),hHt(t,this.Zh.get("can-play"))}ki(t){const{seekable:e,seekableEnd:n,buffered:i,duration:r,canPlay:s}=this.$state;s.set(!0),i.set(t.buffered),e.set(t.seekable),r.set(n())}"duration-change"(t){const{live:e,duration:n}=this.$state,i=t.detail;e()||n.set(Number.isNaN(i)?0:i)}progress(t){const{buffered:e,seekable:n,live:i,duration:r,seekableEnd:s}=this.$state,o=t.detail;e.set(o.buffered),n.set(o.seekable),i()&&(r.set(s),this.dispatch("duration-change",{detail:s(),trigger:t}))}play(t){const{paused:e,autoplayError:n,ended:i,autoplaying:r,playsinline:s,pointer:o,muted:a}=this.$state;t.autoplay=r(),!this.Lh.Rh&&e()?(hHt(t,this.Zh.get("waiting")),this._h("play",t),this.Zh.set("play",t),e.set(!1),n.set(null),r()&&(this.Md(this.createEvent("autoplay",{detail:{muted:a()},trigger:t})),r.set(!1)),(i()||this.Lh.Oh)&&(this.Lh.Oh=!1,i.set(!1),this.Md(this.createEvent("replay",{trigger:t}))),s()||"coarse"!==o()||this.g.remote.enterFullscreen("prefer-media",t)):t.stopImmediatePropagation()}"play-fail"(t){const{muted:e,autoplaying:n}=this.$state;hHt(t,this.Zh.get("play")),this._h("play",t);const{paused:i,playing:r}=this.$state;i.set(!0),r.set(!1),this.ai(),this.Zh.set("play-fail",t),n()&&(this.Md(this.createEvent("autoplay-fail",{detail:{muted:e(),error:t.detail},trigger:t})),n.set(!1))}playing(t){const e=this.Zh.get("play");e?(hHt(t,this.Zh.get("waiting")),hHt(t,e)):hHt(t,this.Zh.get("seeked")),setTimeout((()=>this.ai()),0);const{paused:n,playing:i,live:r,liveSyncPosition:s,seekableEnd:o,started:a,currentTime:l,seeking:c,ended:u}=this.$state;if(n.set(!1),i.set(!0),c.set(!1),u.set(!1),this.Lh.Rh)return t.stopImmediatePropagation(),void(this.Lh.Rh=!1);if(r()&&!a()&&0===l()){const t=s()??o()-2;Number.isFinite(t)&&(this.g.$provider().currentTime=t)}this.started(t)}started(t){const{started:e}=this.$state;e()||(e.set(!0),this.Md(this.createEvent("started",{trigger:t})))}pause(t){if(this.el?.isConnected||(this.bi=!0),this.Lh.Rh)return void t.stopImmediatePropagation();hHt(t,this.Zh.get("seeked")),this._h("pause",t);const{paused:e,playing:n,seeking:i}=this.$state;e.set(!0),n.set(!1),i.set(!1),this.ai()}"time-update"(t){const{currentTime:e,played:n,waiting:i}=this.$state,r=t.detail;e.set(r.currentTime),n.set(r.played),i.set(!1);for(const e of this.g.textTracks)e[eGt.Lc](r.currentTime,t)}"volume-change"(t){const{volume:e,muted:n}=this.$state,i=t.detail;e.set(i.volume),n.set(i.muted||0===i.volume),this._h("volume",t)}seeked(t){const{seeking:e,currentTime:n,paused:i,duration:r,ended:s}=this.$state;if(this.Lh.kd)e.set(!0),t.stopImmediatePropagation();else if(e()){const o=this.Zh.get("waiting");hHt(t,o),"seeking"!==o?.trigger?.type&&hHt(t,this.Zh.get("seeking")),i()&&this.fi(),e.set(!1),t.detail!==r()&&s.set(!1),n.set(t.detail),this._h("seeked",t);const a=t.originEvent;a&&a.isTrusted&&!/seek/.test(a.type)&&this.started(t)}}waiting(t){this.ci||this.Lh.kd||(t.stopImmediatePropagation(),this.$h=t,this.ei())}ended(t){if(this.Lh.Rh)return void t.stopImmediatePropagation();const{paused:e,playing:n,seeking:i,ended:r}=this.$state;e.set(!0),n.set(!1),i.set(!1),r.set(!0),this.ai()}fi(){this.ei.cancel(),this.$state.waiting.set(!1)}"fullscreen-change"(t){this.$state.fullscreen.set(t.detail),this._h("fullscreen",t)}"fullscreen-error"(t){this._h("fullscreen",t)}"orientation-change"(t){this._h("orientation",t)}"picture-in-picture-change"(t){this.$state.pictureInPicture.set(t.detail),this._h("pip",t)}"picture-in-picture-error"(t){this._h("pip",t)}"poster-change"(t){this.$state.poster.set(t.detail)}}class nXt extends yqt{onSetup(){kHt(this.vi.bind(this)),kHt(this.wi.bind(this)),kHt(this.xi.bind(this)),kHt(this.yi.bind(this)),kHt(this.zi.bind(this)),kHt(this.Ai.bind(this)),kHt(this.Bi.bind(this)),kHt(this.Ci.bind(this)),kHt(this.Di.bind(this))}ui(){}vi(){const t=this.$props.autoplay();this.$state.autoplay.set(t),this.dispatch("autoplay-change",{detail:t})}xi(){const t=this.$props.loop();this.$state.loop.set(t),this.dispatch("loop-change",{detail:t})}yi(){const t=this.$props.controls();this.$state.controls.set(t)}wi(){const t=this.$props.poster();this.$state.poster.set(t),this.dispatch("poster-change",{detail:t})}zi(){const t=this.$props.crossorigin();this.$state.crossorigin.set(!0===t?"":t)}Ai(){const t=this.$props.playsinline();this.$state.playsinline.set(t),this.dispatch("playsinline-change",{detail:t})}Ci(){this.dispatch("live-change",{detail:this.$state.live()})}Bi(){this.$state.liveEdgeTolerance.set(this.$props.liveEdgeTolerance()),this.$state.minLiveDVRWindow.set(this.$props.minLiveDVRWindow())}Di(){this.dispatch("live-edge-change",{detail:this.$state.liveEdge()})}}let iXt=xHt(!1);pHt(document,"pointerdown",(()=>{iXt.set(!1)})),pHt(document,"keydown",(t=>{t.metaKey||t.altKey||t.ctrlKey||iXt.set(!0)}));class rXt extends PHt{constructor(){super(...arguments),this.Ii=xHt(!1)}onConnect(t){kHt((()=>{if(!iXt())return this.Ii.set(!1),sXt(t,!1),this.listen("pointerenter",this.Ji.bind(this)),void this.listen("pointerleave",this.Ki.bind(this));const e=document.activeElement===t;this.Ii.set(e),sXt(t,e),this.listen("focus",this.Li.bind(this)),this.listen("blur",this.Mi.bind(this))}))}focused(){return this.Ii()}Li(){this.Ii.set(!0),sXt(this.el,!0)}Mi(){this.Ii.set(!1),sXt(this.el,!1)}Ji(){oXt(this.el,!0)}Ki(){oXt(this.el,!1)}}function sXt(t,e){bHt(t,"data-focus",e),bHt(t,"data-hocus",e)}function oXt(t,e){bHt(t,"data-hocus",e),bHt(t,"data-hover",e)}class aXt{constructor(){this.Ni=!1,this.Oi=jHt(),this.Mh=new Map}get Ri(){return this.Mh.size}get Si(){return this.Ni}async Ti(){this.Ni||await this.Oi.promise}lc(t,e){this.Ni?e():(this.Mh.delete(t),this.Mh.set(t,e))}ti(t){this.Mh.get(t)?.(),this.Mh.delete(t)}ia(){this.Pi(),this.Ni=!0,this.Mh.size>0&&this.Pi()}ja(){this.Ni=!1}H(){this.ja(),this.Mh.clear(),this.Qi()}Pi(){for(const t of this.Mh.keys())this.ti(t);this.Qi()}Qi(){this.Oi.resolve(),this.Oi=jHt()}}var lXt=Object.defineProperty,cXt=Object.getOwnPropertyDescriptor,uXt=(t,e,n,i)=>{for(var r,s=i>1?void 0:i?cXt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);return i&&s&&lXt(e,n,s),s};const hXt=class t extends OHt{constructor(){super(),this.canPlayQueue=new aXt,this.zd(),new nXt;const t={player:this,scope:IWt(),qualities:new Nqt,audioTracks:new Cqt,$provider:xHt(null),$props:this.$props,$state:this.$state};t.remote=new gqt(void 0),t.remote.setPlayer(this),t.$iosControls=wHt(this.Ad.bind(this)),t.textTracks=new wqt,t.textTracks[eGt.Rc]=this.$state.crossorigin,t.textRenderers=new xqt(t),t.ariaKeys={},this.g=t,THt(fqt,t),this.orientation=new lqt,new rXt,new Lqt(t);const e=new Xqt;this.od=new eXt(e,t),this.nd=new Kqt(this.od,e,t),t.delegate=new Gqt(this.od.Md.bind(this.od),t),new jqt(this.startLoading.bind(this))}static{this.props=Hqt}static{this.state=dqt}get Ra(){return this.g.$provider()}onSetup(){this.Bd(),kHt(this.Cd.bind(this)),kHt(this.Dd.bind(this)),kHt(this.rc.bind(this)),kHt(this.Ed.bind(this)),kHt(this.Fd.bind(this)),kHt(this.Gd.bind(this)),kHt(this.Hd.bind(this))}onAttach(t){t.setAttribute("data-media-player",""),hGt(t,"tabindex","0"),hGt(t,"role","region"),kHt(this.qd.bind(this)),kHt(this.rd.bind(this)),pHt(t,"find-media-player",this.Id.bind(this))}onConnect(t){CGt&&bHt(t,"data-iphone",""),AGt().then(this.$state.canSetVolume.set);const e=window.matchMedia("(pointer: coarse)");this.sd(e),e.onchange=this.sd.bind(this);const n=new ResizeObserver(GHt(this.pd.bind(this)));n.observe(t),kHt(this.pd.bind(this)),this.dispatch("media-player-connect",{detail:this,bubbles:!0,composed:!0}),RWt((()=>{n.disconnect(),e.onchange=null}))}onDestroy(){this.g.player=null,this.canPlayQueue.H()}zd(){const t={viewType:"providedViewType",streamType:"providedStreamType"};for(const e of Object.keys(this.$props))this.$state[t[e]??e]?.set(this.$props[e]());kHt(this.td.bind(this)),this.$state.muted.set(this.$props.muted()||0===this.$props.volume())}qd(){const{title:t}=this.$props,{live:e,viewType:n}=this.$state,i=e(),r=(o=n()).charAt(0).toUpperCase()+o.slice(1),s="Unknown"!==r?`${i?"Live ":""}${r}`:i?"Live":"Media";var o;const a=t();a&&(this.el?.setAttribute("data-title",a),this.el?.removeAttribute("title"));const l=this.el?.getAttribute("data-title")||"";this.$state.title.set(l),bHt(this.el,"aria-label",l?`${s} - ${l}`:s+" Player")}rd(){const t=this.orientation.landscape?"landscape":"portrait";this.$state.orientation.set(t),bHt(this.el,"data-orientation",t),this.pd()}Cd(){this.$state.canPlay()&&this.Ra?this.canPlayQueue.ia():this.canPlayQueue.ja()}td(){this.$state.providedViewType.set(this.$props.viewType()),this.$state.providedStreamType.set(this.$props.streamType())}Bd(){if(t[Vqt])return void this.setAttributes(t[Vqt]);const e={"data-captions":function(){const t=this.$state.textTrack();return!!t&&cGt(t)},"data-ios-controls":function(){return this.g.$iosControls()},"data-controls":function(){return this.controls.showing},"data-buffering":function(){const{canPlay:t,waiting:e}=this.$state;return!t()||e()},"data-error":function(){const{error:t}=this.$state;return!!t()}},n={canPictureInPicture:"can-pip",pictureInPicture:"pip"};for(const t of Wqt){e["data-"+(n[t]??BHt(t))]=function(){return this.$state[t]()}}delete e.title,t[Vqt]=e,this.setAttributes(e)}Id(t){t.detail(this)}pd(){if(!this.el)return;const t=this.el.clientWidth,e=this.el.clientHeight;this.$state.width.set(t),this.$state.height.set(e),vHt(this.el,"--player-width",t+"px"),vHt(this.el,"--player-height",e+"px")}sd(t){const e=t.matches?"coarse":"fine";bHt(this.el,"data-pointer",e),this.$state.pointer.set(e),this.pd()}Ad(){const{playsinline:t,fullscreen:e}=this.$state;return CGt&&!rqt&&"video"===this.$state.mediaType()&&(!t()||e())}get provider(){return this.Ra}get controls(){return this.nd.Nd}get qualities(){return this.g.qualities}get audioTracks(){return this.g.audioTracks}get textTracks(){return this.g.textTracks}get textRenderers(){return this.g.textRenderers}get paused(){return this.Ra?.paused??!0}set paused(t){this.ud(t)}rc(){this.ud(this.$props.paused())}ud(t){t?this.canPlayQueue.lc("paused",(()=>this.nd.Jd())):this.canPlayQueue.lc("paused",(()=>this.nd.Kd()))}get muted(){return this.Ra?.muted??!1}set muted(t){this.vd(t)}Dd(){this.vd(this.$props.muted())}vd(t){this.canPlayQueue.lc("muted",(()=>this.Ra.muted=t))}get currentTime(){return this.Ra?.currentTime??0}set currentTime(t){this.wd(t)}Fd(){this.wd(this.$props.currentTime())}wd(t){this.canPlayQueue.lc("currentTime",(()=>{const e=this.Ra;t!==e.currentTime&&MWt((()=>{const n=Math.min(Math.max(this.$state.seekableStart()+.1,t),this.$state.seekableEnd()-.1);Number.isFinite(n)&&(e.currentTime=n)}))}))}get volume(){return this.Ra?.volume??1}set volume(t){this.xd(t)}Ed(){this.xd(this.$props.volume())}xd(t){const e=VGt(0,t,1);this.canPlayQueue.lc("volume",(()=>this.Ra.volume=e))}get playbackRate(){return this.Ra?.playbackRate??1}set playbackRate(t){this.yd(t)}Hd(){this.yd(this.$props.playbackRate())}yd(t){this.canPlayQueue.lc("rate",(()=>this.Ra.playbackRate=t))}Gd(){this.Ld(this.$props.playsinline())}Ld(t){this.canPlayQueue.lc("playsinline",(()=>this.Ra.playsinline=t))}async play(t){return this.nd.Kd(t)}async pause(t){return this.nd.Jd(t)}async enterFullscreen(t,e){return this.nd.Od(t,e)}async exitFullscreen(t,e){return this.nd.Pd(t,e)}enterPictureInPicture(t){return this.nd.Qd(t)}exitPictureInPicture(t){return this.nd.Rd(t)}seekToLiveEdge(t){this.nd.Sd(t)}startLoading(t){this.g.delegate.f("can-load",{trigger:t})}matchQuery(t){return AWt((()=>Aqt.create(t)),this.scope)}destroy(){this.g.remote.setPlayer(null),this.dispatch("destroy")}};uXt([LHt],hXt.prototype,"canPlayQueue",2),uXt([LHt],hXt.prototype,"provider",1),uXt([LHt],hXt.prototype,"controls",1),uXt([LHt],hXt.prototype,"orientation",2),uXt([LHt],hXt.prototype,"qualities",1),uXt([LHt],hXt.prototype,"audioTracks",1),uXt([LHt],hXt.prototype,"textTracks",1),uXt([LHt],hXt.prototype,"textRenderers",1),uXt([LHt],hXt.prototype,"paused",1),uXt([LHt],hXt.prototype,"muted",1),uXt([LHt],hXt.prototype,"currentTime",1),uXt([LHt],hXt.prototype,"volume",1),uXt([LHt],hXt.prototype,"playbackRate",1),uXt([DHt],hXt.prototype,"play",1),uXt([DHt],hXt.prototype,"pause",1),uXt([DHt],hXt.prototype,"enterFullscreen",1),uXt([DHt],hXt.prototype,"exitFullscreen",1),uXt([DHt],hXt.prototype,"enterPictureInPicture",1),uXt([DHt],hXt.prototype,"exitPictureInPicture",1),uXt([DHt],hXt.prototype,"seekToLiveEdge",1),uXt([DHt],hXt.prototype,"startLoading",1),uXt([DHt],hXt.prototype,"matchQuery",1);let dXt=hXt;function pXt(t,e){return fetch(t,e).then((t=>t.text())).then((n=>{const i=function(t){const e=t.match(/#EXT-X-STREAM-INF:[^\n]+(\n[^\n]+)*/g);return e?e[0].split("\n")[1].trim():null}(n);if(i)return pXt(/^https?:/.test(i)?i:new URL(i,t).href,e);const r=/EXT-X-PLAYLIST-TYPE:\s*VOD/.test(n)?"on-demand":"live";return"live"===r&&function(t){const e=t.split("\n");for(const t of e)if(t.startsWith("#EXT-X-TARGETDURATION")){const e=parseFloat(t.split(":")[1]);if(!isNaN(e))return e}return-1}(n)>=10&&(/#EXT-X-DVR-ENABLED:\s*true/.test(n)||n.includes("#EXT-X-DISCONTINUITY"))?"live:dvr":r}))}const fXt=Symbol(0);class mXt{constructor(t,e,n){this.Ui=!1,this.Wd=t,this.g=e,this.Td=n;const i=new Uqt,r=new Bqt,s=new zqt;this.Vi=wHt((()=>e.$props.preferNativeHLS()?[r,s,i]:[i,r,s]));const{$state:o}=e;o.sources.set(gXt(e.$props.src()));for(const t of o.sources()){const e=this.Vi().find((e=>e.canPlay(t)));if(!e)continue;const n=e.mediaType(t);this.g.$state.source.set(t),this.g.$state.mediaType.set(n),this.g.$state.inferredViewType.set(n),this.Td.set(e),this.Ui=!0}}connect(){const t=this.Td();this.Ui&&(this.Wi(this.g.$state.source(),t),this.Xi(t),this.Ui=!1),kHt(this.Zi.bind(this)),kHt(this._i.bind(this)),kHt(this.$i.bind(this)),kHt(this.aj.bind(this))}Zi(){this.g.delegate.f("sources-change",{detail:[...gXt(this.g.$props.src()),...this.Wd()]})}_i(){const{$state:t}=this.g,e=t.sources(),n=MWt(t.source),i=this.Yi(n,e);if(e[0]?.src&&!i.src&&!i.type){const{crossorigin:n}=t,i=tGt(n()),r=new AbortController;return Promise.all(e.map((t=>rHt(t.src)&&"?"===t.type?fetch(t.src,{method:"HEAD",credentials:i,signal:r.signal}).then((e=>(t.type=e.headers.get("content-type")||"??",t))).catch((()=>t)):t))).then((e=>{r.signal.aborted||(this.Yi(MWt(t.source),e),$Wt())})),()=>r.abort()}$Wt()}Yi(t,e){let n={src:"",type:""},i=null;for(const t of e){const e=MWt(this.Vi).find((e=>e.canPlay(t)));e&&(n=t,i=e)}return yXt(t,n)||this.Wi(n,i),i!==MWt(this.Td)&&this.Xi(i),n}Wi(t,e){this.g.delegate.f("source-change",{detail:t}),this.g.delegate.f("media-type-change",{detail:e?.mediaType(t)||"unknown"})}Xi(t){this.g.delegate.f("provider-change",{detail:null}),t&&MWt((()=>t.preconnect?.(this.g))),this.Td.set(t),this.g.delegate.f("provider-loader-change",{detail:t})}$i(){const t=this.g.$provider();if(t&&!t[fXt])return this.g.$state.canLoad()?(AWt((()=>t.setup(this.g)),t.scope),void(t[fXt]=!0)):void MWt((()=>t.preconnect?.(this.g)))}aj(){const t=this.g.$provider(),e=this.g.$state.source(),n=MWt(this.g.$state.crossorigin);if(!yXt(t?.currentSrc,e)){if(this.g.$state.canLoad()){const i=new AbortController;return zGt(e)?NGt()||pXt(e.src,{credentials:tGt(n),signal:i.signal}).then((t=>{this.g.delegate.f("stream-type-change",{detail:t})})).catch(tHt):this.g.delegate.f("stream-type-change",{detail:"on-demand"}),MWt((()=>t?.loadSource(e,MWt(this.g.$state.preload)))),()=>i.abort()}try{rHt(e.src)&&Jjt(new URL(e.src).origin,"preconnect")}catch(t){}}}}function gXt(t){return(oHt(t)?t:[!rHt(t)&&"src"in t?t:{src:t}]).map((({src:t,type:e})=>({src:t,type:e??(!rHt(t)||t.startsWith("blob:")?"video/object":"?")})))}function yXt(t,e){return t?.src===e?.src&&t?.type===e?.type}class bXt{constructor(t,e){this.bj=[],this.Xd=t,this.g=e,kHt(this.cj.bind(this))}cj(){const t=this.Xd();for(const e of this.bj)if(!t.some((t=>t.id===e.id))){const t=e.id&&this.g.textTracks.getById(e.id);t&&this.g.textTracks.remove(t)}for(const e of t){const t=e.id||aGt.createId(e);this.g.textTracks.getById(t)||(e.id=t,this.g.textTracks.add(e))}this.bj=t}}var vXt=Object.defineProperty,xXt=Object.getOwnPropertyDescriptor;class wXt extends OHt{constructor(){super(...arguments),this.Wd=xHt([]),this.Xd=xHt([]),this.Td=null,this.Ud=-1}static{this.state=new FHt({loader:null})}onSetup(){this.g=mqt(),this.Vd=new mXt(this.Wd,this.g,this.$state.loader)}onAttach(t){t.setAttribute("data-media-provider","")}onConnect(t){this.Vd.connect(),new bXt(this.Xd,this.g);const e=new ResizeObserver(GHt(this.pd.bind(this)));e.observe(t);const n=new MutationObserver(this.Jb.bind(this));n.observe(t,{attributes:!0,childList:!0}),this.pd(),this.Jb(),RWt((()=>{e.disconnect(),n.disconnect()}))}load(t){window.cancelAnimationFrame(this.Ud),this.Ud=requestAnimationFrame((()=>this.Zd(t))),RWt((()=>{window.cancelAnimationFrame(this.Ud)}))}Zd(t){if(!this.scope)return;const e=this.$state.loader(),{$provider:n}=this.g;this.Td===e&&e?.target===t&&MWt(n)||(this.Yd(),this.Td=e,e&&(e.target=t||null),e&&t&&e.load(this.g).then((t=>{this.scope&&MWt(this.$state.loader)===e&&(t&&MWt((()=>{const{muted:e,volume:n,playsinline:i}=this.g.$state;t.muted=e(),t.volume=n(),t.playsinline=i()})),this.g.delegate.f("provider-change",{detail:t}))})))}onDestroy(){this.Td=null,this.Yd()}Yd(){this.g.delegate.f("provider-change",{detail:null})}pd(){if(!this.el)return;const t=this.g.player,e=this.el.offsetWidth,n=this.el.offsetHeight;t&&(t.$state.mediaWidth.set(e),t.$state.mediaHeight.set(n),t.el&&(vHt(t.el,"--media-width",e+"px"),vHt(t.el,"--media-height",n+"px")))}Jb(){const t=[],e=[],n=this.el.children;for(const i of n)i instanceof HTMLSourceElement?t.push({src:i.src,type:i.type}):i instanceof HTMLTrackElement&&e.push({id:i.id,src:i.src,kind:i.track.kind,language:i.srclang,label:i.label,default:i.default,type:i.getAttribute("data-type")});this.Wd.set(t),this.Xd.set(e),$Wt()}}((t,e,n,i)=>{for(var r,s=i>1?void 0:i?xXt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);i&&s&&vXt(e,n,s)})([DHt],wXt.prototype,"load",1);class SXt extends OHt{static{this.props={hideDelay:2e3}}onSetup(){this.g=mqt(),kHt(this.$d.bind(this))}onAttach(t){const{pictureInPicture:e,fullscreen:n}=this.g.$state;vHt(t,"pointer-events","none"),hGt(t,"role","group"),this.setAttributes({"data-visible":this._d.bind(this),"data-fullscreen":n,"data-pip":e}),kHt((()=>{this.dispatch("change",{detail:this._d()})})),kHt(this.ae.bind(this)),kHt((()=>{const e=n();for(const n of["top","right","bottom","left"])vHt(t,`padding-${n}`,e&&`env(safe-area-inset-${n})`)}))}ae(){if(!this.el)return;const{$iosControls:t}=this.g,{controls:e}=this.g.$state,n=e()||t();bHt(this.el,"aria-hidden",n?"true":null),vHt(this.el,"display",n?"none":null)}$d(){const{controls:t}=this.g.player,{hideDelay:e}=this.$props;t.defaultDelay=2e3===e()?this.g.$props.controlsDelay():e()}_d(){const{controlsVisible:t}=this.g.$state;return t()}}class kXt extends PHt{constructor(t){super(),this.ej=-1,this.fj=-1,this.dj=null,this.Ka=t,kHt(this.gj.bind(this))}onDestroy(){this.dj?.(),this.dj=null}gj(){const t=this.Ka.be();if(!t)return void this.hide();const e=this.show.bind(this),n=this.hide.bind(this);this.Ka.ke(t,e,n)}show(t){window.cancelAnimationFrame(this.fj),this.fj=-1,this.dj?.(),this.dj=null,this.ej=window.setTimeout((()=>{this.ej=-1;const e=this.Ka.ce();e&&e.style.removeProperty("display"),MWt((()=>this.Ka.Da(!0,t)))}),this.Ka.je?.()??0)}hide(t){window.clearTimeout(this.ej),this.ej=-1,MWt((()=>this.Ka.Da(!1,t))),this.fj=requestAnimationFrame((()=>{this.fj=-1;const t=this.Ka.ce();if(t){const e=()=>{t.style.display="none",this.dj=null};if("none"!==getComputedStyle(t).animationName){this.dj?.();const n=pHt(t,"animationend",e,{once:!0});this.dj=n}else e()}}))}}const CXt=CHt();let TXt=0;class _Xt extends OHt{constructor(){super(),this.de="media-tooltip-"+ ++TXt,this.be=xHt(null),this.ce=xHt(null),new rXt;const{showDelay:t}=this.$props;new kXt({be:this.be,ce:this.ce,je:t,ke(t,e,n){pHt(t,"touchstart",(t=>t.preventDefault()),{passive:!1}),pHt(t,"focus",e),pHt(t,"blur",n),pHt(t,"mouseenter",e),pHt(t,"mouseleave",n)},Da:this.ie.bind(this)})}static{this.props={showDelay:500}}onAttach(t){t.style.setProperty("display","contents")}onSetup(){THt(CXt,{be:this.be,ce:this.ce,ee:this.ee.bind(this),fe:this.fe.bind(this),ge:this.ge.bind(this),he:this.he.bind(this)})}ee(t){this.be.set(t);let e=t.getAttribute("data-media-tooltip");e&&this.el?.setAttribute(`data-media-${e}-tooltip`,""),bHt(t,"data-describedby",this.de)}fe(t){t.removeAttribute("data-describedby"),t.removeAttribute("aria-describedby"),this.be.set(null)}ge(t){t.setAttribute("id",this.de),t.style.display="none",hGt(t,"role","tooltip"),this.ce.set(t)}he(t){t.removeAttribute("id"),t.removeAttribute("role"),this.ce.set(null)}ie(t){const e=this.be(),n=this.ce();e&&bHt(e,"aria-describedby",t?this.de:null);for(const i of[this.el,e,n])i&&bHt(i,"data-visible",t)}}class EXt extends OHt{static{this.props={placement:"top center",offset:0,alignOffset:0}}constructor(){super(),new rXt;const{placement:t}=this.$props;this.setAttributes({"data-placement":t})}onAttach(t){this.me(t),Object.assign(t.style,{position:"absolute",top:0,left:0,width:"max-content"})}onConnect(t){this.me(t);const e=_Ht(CXt);RWt((()=>e.he(t))),RWt(gGt((()=>{this.connectScope&&kHt(this.ne.bind(this))})))}me(t){_Ht(CXt).ge(t)}ne(){const{placement:t,offset:e,alignOffset:n}=this.$props;return xGt(this.el,this.oe(),t(),{offsetVarName:"media-tooltip",xOffset:n(),yOffset:e()})}oe(){return _Ht(CXt).be()}}class MXt extends PHt{constructor(t){super(),this.Ka=t,new rXt,t.te&&new Fqt(t.te)}static{this.props={disabled:!1}}onSetup(){const{disabled:t}=this.$props;this.setAttributes({"data-pressed":this.Ka.qe,"aria-pressed":this.hj.bind(this),"aria-disabled":()=>t()?"true":null})}onAttach(t){hGt(t,"tabindex","0"),hGt(t,"role","button"),hGt(t,"type","button")}onConnect(t){fGt(t,this.ij.bind(this))}hj(){return WHt(this.Ka.qe())}jj(t){SHt(this.Ka.qe)&&this.Ka.qe.set((t=>!t))}ij(t){this.$props.disabled()||this.el.hasAttribute("data-disabled")?t.stopImmediatePropagation():(t.preventDefault(),(this.Ka.re??this.jj).call(this,t))}}var $Xt=Object.defineProperty,IXt=Object.getOwnPropertyDescriptor;class AXt extends OHt{constructor(){super(),this.pe=xHt(!1),new MXt({qe:this.pe})}static{this.props={disabled:!1,defaultPressed:!1}}get pressed(){return this.pe()}}((t,e,n,i)=>{for(var r,s=i>1?void 0:i?IXt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);i&&s&&$Xt(e,n,s)})([LHt],AXt.prototype,"pressed",1);class NXt extends OHt{constructor(){super(),new MXt({qe:this.qe.bind(this),te:"togglePaused",re:this.re.bind(this)})}static{this.props=MXt.props}onSetup(){this.g=mqt();const{paused:t,ended:e}=this.g.$state;this.setAttributes({"data-paused":t,"data-ended":e})}onAttach(t){t.setAttribute("data-media-tooltip","play"),dGt(t,this.se.bind(this))}re(t){const e=this.g.remote;this.qe()?e.pause(t):e.play(t)}qe(){const{paused:t}=this.g.$state;return!t()}se(){const{paused:t}=this.g.$state;return t()?"Play":"Pause"}}function RXt(t){return()=>t()?"true":"false"}class PXt extends OHt{constructor(){super(),new MXt({qe:this.qe.bind(this),te:"toggleCaptions",re:this.re.bind(this)})}static{this.props=MXt.props}onSetup(){this.g=mqt(),this.setAttributes({"data-active":this.qe.bind(this),"data-supported":()=>!this.ue(),"aria-hidden":RXt(this.ue.bind(this))})}onAttach(t){t.setAttribute("data-media-tooltip","caption"),dGt(t,this.se.bind(this))}re(t){this.g.remote.toggleCaptions(t)}qe(){const{textTrack:t}=this.g.$state,e=t();return!!e&&cGt(e)}ue(){const{textTracks:t}=this.g.$state;return 0==t().filter(cGt).length}se(){const{textTrack:t}=this.g.$state;return t()?"Closed-Captions Off":"Closed-Captions On"}}class OXt extends OHt{constructor(){super(),new MXt({qe:this.qe.bind(this),te:"toggleFullscreen",re:this.re.bind(this)})}static{this.props={...MXt.props,target:"prefer-media"}}onSetup(){this.g=mqt();const{fullscreen:t}=this.g.$state,e=this.ve.bind(this);this.setAttributes({"data-active":t,"data-supported":e,"aria-hidden":RXt((()=>!e()))})}onAttach(t){t.setAttribute("data-media-tooltip","fullscreen"),dGt(t,this.se.bind(this))}re(t){const e=this.g.remote,n=this.$props.target();this.qe()?e.exitFullscreen(n,t):e.enterFullscreen(n,t)}qe(){const{fullscreen:t}=this.g.$state;return t()}ve(){const{canFullscreen:t}=this.g.$state;return t()}se(){const{fullscreen:t}=this.g.$state;return t()?"Exit Fullscreen":"Enter Fullscreen"}}class LXt extends OHt{constructor(){super(),new MXt({qe:this.qe.bind(this),te:"toggleMuted",re:this.re.bind(this)})}static{this.props=MXt.props}onSetup(){this.g=mqt(),this.setAttributes({"data-muted":this.qe.bind(this),"data-state":this.we.bind(this)})}onAttach(t){t.setAttribute("data-media-mute-button",""),t.setAttribute("data-media-tooltip","mute"),dGt(t,this.se.bind(this))}re(t){const e=this.g.remote;this.qe()?e.unmute(t):e.mute(t)}qe(){const{muted:t,volume:e}=this.g.$state;return t()||0===e()}se(){return this.qe()?"Unmute":"Mute"}we(){const{muted:t,volume:e}=this.g.$state,n=e();return t()||0===n?"muted":n>=.5?"high":n<.5?"low":void 0}}class DXt extends OHt{constructor(){super(),new MXt({qe:this.qe.bind(this),te:"togglePictureInPicture",re:this.re.bind(this)})}static{this.props=MXt.props}onSetup(){this.g=mqt();const{pictureInPicture:t}=this.g.$state,e=this.ve.bind(this);this.setAttributes({"data-active":t,"data-supported":e,"aria-hidden":RXt((()=>!e()))})}onAttach(t){t.setAttribute("data-media-tooltip","pip"),dGt(t,this.se.bind(this))}re(t){const e=this.g.remote;this.qe()?e.exitPictureInPicture(t):e.enterPictureInPicture(t)}qe(){const{pictureInPicture:t}=this.g.$state;return t()}ve(){const{canPictureInPicture:t}=this.g.$state;return t()}se(){const{pictureInPicture:t}=this.g.$state;return t()?"Exit Picture In Picture":"Enter Picture In Picture"}}class FXt extends OHt{constructor(){super(),new rXt}static{this.props={disabled:!1,seconds:30}}onSetup(){this.g=mqt();const{seeking:t}=this.g.$state,{seconds:e}=this.$props,n=this.ve.bind(this);this.setAttributes({seconds:e,"data-seeking":t,"data-supported":n,"aria-hidden":RXt((()=>!n()))})}onAttach(t){hGt(t,"tabindex","0"),hGt(t,"role","button"),hGt(t,"type","button"),t.setAttribute("data-media-tooltip","seek"),dGt(t,this.se.bind(this))}onConnect(t){fGt(t,this.re.bind(this))}ve(){const{canSeek:t}=this.g.$state;return t()}se(){const{seconds:t}=this.$props;return`Seek ${t()>0?"forward":"backward"} ${t()} seconds`}re(t){const{seconds:e,disabled:n}=this.$props;if(n())return;const{currentTime:i}=this.g.$state,r=i()+e();this.g.remote.seek(r,t)}}class zXt extends OHt{constructor(){super(),new rXt}static{this.props={disabled:!1}}onSetup(){this.g=mqt();const{disabled:t}=this.$props,{live:e,liveEdge:n}=this.g.$state,i=()=>!e();this.setAttributes({"data-edge":n,"data-hidden":i,"aria-disabled":RXt(t),"aria-hidden":RXt(i)})}onAttach(t){hGt(t,"tabindex","0"),hGt(t,"role","button"),hGt(t,"type","button"),t.setAttribute("data-media-tooltip","live")}onConnect(t){fGt(t,this.re.bind(this))}re(t){const{disabled:e}=this.$props,{liveEdge:n}=this.g.$state;e()||n()||this.g.remote.seekToLiveEdge(t)}}const BXt=new FHt({min:0,max:100,value:0,pointerValue:0,focused:!1,dragging:!1,pointing:!1,get active(){return this.dragging||this.focused||this.pointing},get fillRate(){return UXt(this.min,this.max,this.value)},get fillPercent(){return 100*this.fillRate},get pointerRate(){return UXt(this.min,this.max,this.pointerValue)},get pointerPercent(){return 100*this.pointerRate}});function UXt(t,e,n){const i=e-t;return i>0?(n-t)/i:0}const VXt={Left:-1,ArrowLeft:-1,Up:1,ArrowUp:1,Right:1,ArrowRight:1,Down:-1,ArrowDown:-1};class WXt extends PHt{constructor(t,e){super(),this.Ra=null,this.kj=null,this.mj=null,this.Aj=Qqt((t=>{this.lj(this.nj(t),t)}),20,{leading:!0}),this.Ka=t,this.g=e}onConnect(){if(kHt(this.tj.bind(this)),kHt(this.uj.bind(this)),this.Ka.nf){const t=this.g.player.el?.querySelector("media-provider,[data-media-provider]");t&&(this.Ra=t,pHt(t,"touchstart",this.vj.bind(this),{passive:!0}),pHt(t,"touchmove",this.wj.bind(this),{passive:!1}))}}vj(t){this.kj=t.touches[0]}wj(t){if(eHt(this.kj)||mGt(t))return;const e=t.touches[0],n=e.clientX-this.kj.clientX,i=e.clientY-this.kj.clientY,r=this.$state.dragging();!r&&Math.abs(i)>20||r||Math.abs(n)>20&&(this.kj=e,this.mj=this.$state.value(),this.oj(this.mj,t))}tj(){this.Ka.De()||(this.listen("focus",this.Li.bind(this)),this.listen("pointerenter",this.Ji.bind(this)),this.listen("pointermove",this.xj.bind(this)),this.listen("pointerleave",this.Ki.bind(this)),this.listen("pointerdown",this.yj.bind(this)),this.listen("keydown",this.id.bind(this)),this.listen("keyup",this.hd.bind(this)))}uj(){!this.Ka.De()&&this.$state.dragging()&&(pHt(document,"pointerup",this.zj.bind(this)),pHt(document,"pointermove",this.Aj.bind(this)),_Gt&&pHt(document,"touchmove",this.Bj.bind(this),{passive:!1}))}Li(){this.lj(this.$state.value())}pj(t,e){const{value:n,min:i,max:r,dragging:s}=this.$state,o=Math.max(i(),Math.min(t,r()));n.set(o);const a=this.createEvent("value-change",{detail:o,trigger:e});if(this.dispatch(a),this.Ka.Gb?.(a),s()){const t=this.createEvent("drag-value-change",{detail:o,trigger:e});this.dispatch(t),this.Ka.Ye?.(t)}}lj(t,e){const{pointerValue:n,dragging:i}=this.$state;n.set(t),this.dispatch("pointer-value-change",{detail:t,trigger:e}),i()&&this.pj(t,e)}nj(t){let e,n=this.el.getBoundingClientRect(),{min:i,max:r}=this.$state;if("vertical"===this.$props.orientation()){const{bottom:i,height:r}=n;e=(i-t.clientY)/r}else if(this.kj&&iHt(this.mj)){const{width:n}=this.Ra.getBoundingClientRect(),s=(t.clientX-this.kj.clientX)/n,o=r()-i(),a=o*Math.abs(s);e=(s<0?this.mj-a:this.mj+a)/o}else{const{left:i,width:r}=n;e=(t.clientX-i)/r}return Math.max(i(),Math.min(r(),this.Ka.Ce(function(t,e,n,i){return t+i*((e-t)*VGt(0,n,1)/i)}(i(),r(),e,this.Ka.Ae()))))}Ji(t){this.$state.pointing.set(!0)}xj(t){const{dragging:e}=this.$state;e()||this.lj(this.nj(t),t)}Ki(t){this.$state.pointing.set(!1)}yj(t){if(0!==t.button)return;const e=this.nj(t);this.oj(e,t),this.lj(e,t)}oj(t,e){const{dragging:n}=this.$state;if(n())return;n.set(!0),this.g.remote.pauseControls(e);const i=this.createEvent("drag-start",{detail:t,trigger:e});this.dispatch(i),this.Ka.df?.(i)}rj(t,e){const{dragging:n}=this.$state;if(!n())return;n.set(!1),this.g.remote.resumeControls(e);const i=this.createEvent("drag-end",{detail:t,trigger:e});this.dispatch(i),this.Ka.af?.(i),this.kj=null,this.mj=null}id(t){const{key:e}=t,{min:n,max:i}=this.$state;let r;if("Home"===e||"PageUp"===e?r=n():"End"===e||"PageDown"===e?r=i():!t.metaKey&&/[0-9]/.test(e)&&(r=(i()-n())/10*Number(e)),!nHt(r))return this.lj(r,t),void this.pj(r,t);const s=this.sj(t);if(nHt(s))return;const o=e===this.qj;!this.$state.dragging()&&o&&this.oj(s,t),this.lj(s,t),o||this.pj(s,t),this.qj=e}hd(t){this.qj="";const{dragging:e,value:n}=this.$state;if(!e())return;const i=this.sj(t)??n();this.lj(i),this.rj(i,t)}sj(t){const{key:e,shiftKey:n}=t;if(!Object.keys(VXt).includes(e))return;t.preventDefault(),t.stopPropagation();const{shiftKeyMultiplier:i}=this.$props,{value:r,min:s,max:o}=this.$state,a=this.Ka.Ae(),l=this.Ka.Be(),c=(n?l*i():l)*Number(VXt[e]),u=(r()+c)/a;return Math.max(s(),Math.min(o(),Number((a*u).toFixed(3))))}zj(t){if(0!==t.button)return;const e=this.nj(t);this.lj(e,t),this.rj(e,t)}Bj(t){t.preventDefault()}}const HXt=CHt((()=>({}))),jXt=CHt();class GXt extends PHt{constructor(t){super(),this.Je=GHt(((t,e)=>{this.el?.style.setProperty("--slider-fill",t+"%"),this.el?.style.setProperty("--slider-pointer",e+"%")})),this.Ka=t}static{this.props={disabled:!1,step:1,keyStep:1,orientation:"horizontal",shiftKeyMultiplier:5}}onSetup(){this.g=mqt();const t=new rXt;t.attach(this),this.$state.focused=t.focused.bind(t),EHt(HXt)||THt(HXt,{default:"value"}),THt(jXt,{Ke:this.$props.orientation,Le:this.Ka.De,Me:xHt(null)}),kHt(this.Fe.bind(this)),kHt(this.Ge.bind(this)),this.He(),new WXt(this.Ka,this.g).attach(this)}onAttach(t){hGt(t,"role","slider"),hGt(t,"tabindex","0"),hGt(t,"autocomplete","off"),kHt(this.Ee.bind(this))}Fe(){const{dragging:t,value:e,min:n,max:i}=this.$state;MWt(t)||e.set(function(t,e,n,i){return VGt(t,BGt(n,UGt(i)),e)}(n(),i(),e(),this.Ka.Ae()))}Ge(){if(!this.Ka.De())return;const{dragging:t,pointing:e}=this.$state;t.set(!1),e.set(!1)}Ie(){return WHt(this.Ka.De())}He(){const{orientation:t}=this.$props,{dragging:e,active:n,pointing:i}=this.$state;this.setAttributes({"data-dragging":e,"data-pointing":i,"data-active":n,"aria-disabled":this.Ie.bind(this),"aria-valuemin":this.$state.min,"aria-valuemax":this.$state.max,"aria-valuenow":this.Ka.xe,"aria-valuetext":this.Ka.ye,"aria-orientation":t})}Ee(){const{fillPercent:t,pointerPercent:e}=this.$state;this.Je(BGt(t(),3),BGt(e(),3))}}class qXt extends OHt{static{this.props={...GXt.props,min:0,max:100,value:0}}static{this.state=BXt}constructor(){super(),new GXt({Ae:this.$props.step,Be:this.$props.keyStep,Ce:Math.round,De:this.$props.disabled,xe:this.xe.bind(this),ye:this.ye.bind(this)})}onSetup(){kHt(this.ze.bind(this))}xe(){const{value:t}=this.$state;return Math.round(t())}ye(){const{value:t,max:e}=this.$state;return BGt(t()/e()*100,2)+"%"}ze(){const{min:t,max:e}=this.$props;this.$state.min.set(t()),this.$state.max.set(e())}}const XXt=new Map,KXt=new Set,YXt=new Set;class ZXt{constructor(t,e){this.$cues=xHt([]),this.$src=t,this.g=e,kHt(this.xh.bind(this)),YXt.add(this),RWt((()=>YXt.delete(this)))}static create(t){const e=mqt();return new ZXt(t,e)}xh(){const{canLoad:t}=this.g.$state;if(!t())return;const e=new AbortController,{crossorigin:n}=this.g.$state,i=this.$src();if(i){if(XXt.has(i)){const t=XXt.get(i);if(XXt.delete(i),XXt.set(i,t),XXt.size>30){const t=XXt.keys().next().value;XXt.delete(t)}this.$cues.set(XXt.get(i))}else KXt.has(i)||(KXt.add(i),Promise.resolve().then((function(){return K2t})).then((async({parseResponse:t})=>{try{const r=await fetch(i,{signal:e.signal,credentials:tGt(n())});if("application/json"===r.headers.get("content-type")){try{const{cues:t}=uGt(await r.text(),window.VTTCue);this.wh(i,t)}catch(t){}return}const{cues:s}=await t(r);this.wh(i,s)}catch(t){}})));return()=>{e.abort(),this.$cues.set([])}}}wh(t,e){this.$cues.set(e);for(const n of YXt)MWt(n.$src)===t&&n.$cues.set(e);XXt.set(t,e),KXt.delete(t)}}class JXt extends OHt{constructor(){super(...arguments),this.oh=[],this.ph=GHt(this.vh.bind(this))}static{this.props={src:"",time:0}}static{this.state=new FHt({src:"",img:null,coords:null,activeCue:null,loading:!1,error:null,hidden:!1})}onSetup(){this.g=mqt(),this.nh=ZXt.create(this.$props.src),this.setAttributes({"data-loading":this.Pe.bind(this),"data-error":this.Oe.bind(this),"data-hidden":this.$state.hidden,"aria-hidden":RXt(this.$state.hidden)})}onConnect(t){kHt(this.jh.bind(this)),kHt(this.Se.bind(this)),kHt(this.pa.bind(this)),kHt(this.qh.bind(this)),kHt(this.rh.bind(this))}jh(){const t=this.$state.img();t&&(pHt(t,"load",this.qa.bind(this)),pHt(t,"error",this.X.bind(this)))}pa(){const{src:t,loading:e,error:n}=this.$state;t(),e.set(!0),n.set(null)}qa(){const{loading:t,error:e}=this.$state;t.set(!1),e.set(null),this.ph()}X(t){const{loading:e,error:n}=this.$state;e.set(!1),n.set(t)}Pe(){const{loading:t,hidden:e}=this.$state;return!e()&&t()}Oe(){const{error:t}=this.$state;return!eHt(t())}Se(){const{hidden:t}=this.$state,{duration:e}=this.g.$state,n=this.nh.$cues();t.set(this.Oe()||!Number.isFinite(e())||0===n.length)}Ne(){return this.$props.time()}qh(){const t=this.Ne(),{activeCue:e}=this.$state,{duration:n}=this.g.$state,i=this.nh.$cues();i&&Number.isFinite(n())?e.set(function(t,e){for(let n=0,i=t.length;n<i;n++)if(nGt(t[n],e))return t[n];return null}(i,t)):e.set(null)}rh(){let{activeCue:t}=this.$state,e=t(),n=MWt(this.$props.src);if(/^https?:/.test(n)||(n=location.href),!n||!e)return this.$state.src.set(""),void this.sh();const[i,r=""]=(e.text||"").split("#");this.$state.coords.set(this.th(r)),this.$state.src.set(this.uh(i,n)),this.ph()}uh(t,e){return/^https?:/.test(t)?t:new URL(t,e).href}th(t){const[e,n]=t.split("="),i={},r=n?.split(",");if(!e||!n)return null;for(let t=0;t<e.length;t++)i[e[t]]=+r[t];return i}vh(){if(!this.scope)return;const t=this.$state.img(),e=this.$state.coords();if(!t||!this.el)return;const n=e?.w??t.naturalWidth,i=e?.h??t.naturalHeight,{maxWidth:r,maxHeight:s,minWidth:o,minHeight:a}=getComputedStyle(this.el),l=Math.max(parseInt(o)/n,parseInt(a)/i),c=Math.min(parseInt(r)/n,parseInt(s)/i),u=c<1?c:l>1?l:1;this.mh(this.el,"--thumbnail-width",n*u+"px"),this.mh(this.el,"--thumbnail-height",i*u+"px"),this.mh(t,"width",t.naturalWidth*u+"px"),this.mh(t,"height",t.naturalHeight*u+"px"),this.mh(t,"transform",e?`translate(-${e.x*u}px, -${e.y*u}px)`:""),this.mh(t,"max-width","none")}mh(t,e,n){t.style.setProperty(e,n),this.oh.push((()=>t.style.removeProperty(e)))}sh(){for(const t of this.oh)t();this.oh=[]}}var QXt=Object.defineProperty,tKt=Object.getOwnPropertyDescriptor;class eKt extends OHt{static{this.props={src:null}}static{this.state=new FHt({video:null,src:null,canPlay:!1,error:null,hidden:!1})}get video(){return this.$state.video()}onSetup(){this.g=mqt(),this.t=zHt(qXt.state),this.setAttributes({"data-loading":this.Pe.bind(this),"data-hidden":this.$state.hidden,"data-error":this.Oe.bind(this),"aria-hidden":RXt(this.$state.hidden)})}onAttach(t){kHt(this.Qe.bind(this)),kHt(this.Re.bind(this)),kHt(this.Se.bind(this)),kHt(this.Te.bind(this)),kHt(this.Ue.bind(this))}Qe(){const t=this.$state.video();t&&(t.readyState>=2&&this.ab(),pHt(t,"canplay",this.ab.bind(this)),pHt(t,"error",this.X.bind(this)))}Re(){const{src:t}=this.$state,{canLoad:e}=this.g.$state;t.set(e()?this.$props.src():null)}Pe(){const{canPlay:t,hidden:e}=this.$state;return!t()&&!e()}Oe(){const{error:t}=this.$state;return!eHt(t)}Se(){const{src:t,hidden:e}=this.$state,{canLoad:n,duration:i}=this.g.$state;e.set(n()&&(!t()||this.Oe()||!Number.isFinite(i())))}Te(){const{src:t,canPlay:e,error:n}=this.$state;t(),e.set(!1),n.set(null)}ab(t){const{canPlay:e,error:n}=this.$state;e.set(!0),n.set(null),this.dispatch("can-play",{trigger:t})}X(t){const{canPlay:e,error:n}=this.$state;e.set(!1),n.set(t),this.dispatch("error",{trigger:t})}Ue(){const{video:t,canPlay:e}=this.$state,{duration:n}=this.g.$state,{pointerRate:i}=this.t,r=t();e()&&r&&Number.isFinite(n())&&Number.isFinite(i())&&(r.currentTime=i()*n())}}function nKt(t,e){const n=String(t),i=n.length;if(i<e){return`${"0".repeat(e-i)}${t}`}return n}function iKt(t){return{hours:Math.trunc(t/3600),minutes:Math.trunc(t%3600/60),seconds:Math.trunc(t%60),fraction:Number((t-Math.trunc(t)).toPrecision(3))}}function rKt(t,e=null,n=null,i=!1){const{hours:r,minutes:s,seconds:o}=iKt(t),a=e?nKt(r,2):r,l=n||eHt(n)&&t>=3600?nKt(s,2):s,c=nKt(o,2);return r>0||i?`${a}:${l}:${c}`:`${l}:${c}`}function sKt(t){const e=[],{hours:n,minutes:i,seconds:r}=iKt(t);return n>0&&e.push(`${n} hour`),i>0&&e.push(`${i} min`),(r>0||0===e.length)&&e.push(`${r} sec`),e.join(" ")}((t,e,n,i)=>{for(var r,s=i>1?void 0:i?tKt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);i&&s&&QXt(e,n,s)})([LHt],eKt.prototype,"video",1);var oKt=Object.defineProperty,aKt=Object.getOwnPropertyDescriptor;class lKt extends OHt{static{this.props={type:"pointer",format:null,showHours:!1,padHours:null,padMinutes:null,decimalPlaces:2}}onSetup(){this.t=zHt(qXt.state),this.Ve=_Ht(HXt),this.We=wHt(this.getValueText.bind(this))}getValueText(){const{type:t,format:e,decimalPlaces:n,padHours:i,padMinutes:r,showHours:s}=this.$props,{value:o,pointerValue:a,min:l,max:c}=this.t,u=e()??this.Ve.default,h="current"===t()?o():a();if("percent"===u){const t=h/(c()-l())*100;return(this.Ve.percent??BGt)(t,n())+""}return"time"===u?(this.Ve.time??rKt)(h,i(),r(),s()):this.Ve.value?.(h)??h.toFixed(2)}}((t,e,n,i)=>{for(var r,s=i>1?void 0:i?aKt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);i&&s&&oKt(e,n,s)})([DHt],lKt.prototype,"getValueText",1);class cKt extends OHt{static{this.props={offset:0,noClamp:!1}}onSetup(){this.t=_Ht(jXt);const{active:t}=zHt(qXt.state);this.setAttributes({"data-visible":t})}onAttach(t){Object.assign(t.style,{position:"absolute",top:0,left:0,width:"max-content"})}onConnect(t){const{Me:e}=this.t;e.set(t),RWt((()=>e.set(null))),kHt(this.Xe.bind(this));const n=new ResizeObserver(this.Xe.bind(this));n.observe(t),RWt((()=>n.disconnect()))}Xe(){const{Le:t,Ke:e}=this.t;if(t())return;const n=this.el,{offset:i,noClamp:r}=this.$props;!function(t,{clamp:e,offset:n,orientation:i}){const{width:r,height:s}=t.getBoundingClientRect(),o={top:null,right:null,bottom:null,left:null};if(o["horizontal"===i?"bottom":"left"]=`calc(100% + var(--media-slider-preview-offset, ${n}px))`,"horizontal"===i){const t=r/2;if(e){const e=`max(0px, calc(var(--slider-pointer) - ${t}px))`,n=`calc(100% - ${r}px)`;o.left=`min(${e}, ${n})`}else o.left=`calc(var(--slider-pointer) - ${t}px)`}else{const t=s/2;if(e){const e=`max(${t}px, calc(var(--slider-pointer) - ${t}px))`,n=`calc(100% - ${s}px)`;o.bottom=`min(${e}, ${n})`}else o.bottom=`calc(var(--slider-pointer) - ${t}px)`}Object.assign(t.style,o)}(n,{clamp:!r(),offset:i(),orientation:e()})}}class uKt extends OHt{constructor(){super(...arguments),this.Ze=Qqt(this.ob.bind(this),25)}static{this.props={...GXt.props,keyStep:5,shiftKeyMultiplier:2}}static{this.state=BXt}onSetup(){this.g=mqt(),THt(HXt,{default:"percent"}),new GXt({Ae:this.$props.step,Be:this.$props.keyStep,De:this.$props.disabled,Ce:Math.round,xe:this.xe.bind(this),ye:this.ye.bind(this),Ye:this.Ye.bind(this),Gb:this.Gb.bind(this)}).attach(this),kHt(this.Ed.bind(this))}onAttach(t){t.setAttribute("data-media-volume-slider",""),hGt(t,"aria-label","Volume");const{canSetVolume:e}=this.g.$state;this.setAttributes({"data-supported":e,"aria-hidden":RXt((()=>!e()))})}xe(){const{value:t}=this.$state;return Math.round(t())}ye(){const{value:t,max:e}=this.$state;return BGt(t()/e()*100,2)+"%"}Ed(){const{muted:t,volume:e}=this.g.$state,n=t()?0:100*e();this.$state.value.set(n),this.dispatch("value-change",{detail:n})}ob(t){if(!t.trigger)return;const e=BGt(t.detail/100,3);this.g.remote.changeVolume(e,t)}Gb(t){this.Ze(t)}Ye(t){this.Ze(t)}}class hKt extends OHt{constructor(){super(),this.cf=xHt(null),this.bf=!1,new GXt({nf:!0,Ae:this.Ae.bind(this),Be:this.Be.bind(this),De:this.De.bind(this),Ce:this.Ce,xe:this.xe.bind(this),ye:this.ye.bind(this),df:this.df.bind(this),Ye:this.Ye.bind(this),af:this.af.bind(this),Gb:this.Gb.bind(this)})}static{this.props={...GXt.props,step:.1,keyStep:5,shiftKeyMultiplier:2,pauseWhileDragging:!1,seekingRequestThrottle:100}}static{this.state=BXt}onSetup(){this.g=mqt(),THt(HXt,{default:"time",value:this.ef.bind(this),time:this.ff.bind(this)}),this.setAttributes({"data-chapters":this.gf.bind(this)}),this.setStyles({"--slider-progress":this.hf.bind(this)}),kHt(this.Fd.bind(this)),kHt(this.jf.bind(this))}onAttach(t){t.setAttribute("data-media-time-slider",""),hGt(t,"aria-label","Seek")}onConnect(t){kHt(this.kf.bind(this)),iGt(this.g.textTracks,"chapters",this.cf.set)}hf(){const{bufferedEnd:t,duration:e}=this.g.$state;return BGt(100*Math.min(t()/Math.max(e(),1),1),3)+"%"}gf(){const{duration:t}=this.g.$state;return this.cf()?.cues.length&&Number.isFinite(t())&&t()>0}jf(){this.$e=Qqt(this.kd.bind(this),this.$props.seekingRequestThrottle())}Fd(){const{currentTime:t}=this.g.$state,{value:e,dragging:n}=this.$state,i=this.lf(t());MWt(n)||(e.set(i),this.dispatch("value-change",{detail:i}))}kf(){const t=this.g.player.el,{Me:e}=_Ht(jXt);t&&e()&&bHt(t,"data-preview",this.$state.active())}kd(t,e){this.g.remote.seeking(t,e)}mf(t,e,n){this.$e.cancel();const{live:i}=this.g.$state;i()&&e>=99?this.g.remote.seekToLiveEdge(n):this.g.remote.seek(t,n)}df(t){const{pauseWhileDragging:e}=this.$props;if(e()){const{paused:e}=this.g.$state;this.bf=!e(),this.g.remote.pause(t)}}Ye(t){this.$e(this._e(t.detail),t)}af(t){const e=t.detail;this.mf(this._e(e),e,t);const{pauseWhileDragging:n}=this.$props;n()&&this.bf&&(this.g.remote.play(t),this.bf=!1)}Gb(t){const{dragging:e}=this.$state;!e()&&t.trigger&&this.af(t)}Ae(){const t=this.$props.step()/this.g.$state.duration()*100;return Number.isFinite(t)?t:1}Be(){const t=this.$props.keyStep()/this.g.$state.duration()*100;return Number.isFinite(t)?t:1}Ce(t){return BGt(t,3)}De(){const{canSeek:t}=this.g.$state;return this.$props.disabled()||!t()}xe(){const{value:t}=this.$state;return Math.round(t())}ye(){const t=this._e(this.$state.value()),{duration:e}=this.g.$state;return Number.isFinite(t)?`${sKt(t)} out of ${sKt(e())}`:"live"}_e(t){const{duration:e}=this.g.$state;return Math.round(t/100*e())}lf(t){const{liveEdge:e,duration:n}=this.g.$state,i=Math.max(0,Math.min(1,e()?1:Math.min(t,n())/n()));return Number.isNaN(i)?0:Number.isFinite(i)?100*i:100}ef(t){const e=this._e(t),{live:n,duration:i}=this.g.$state;return Number.isFinite(e)?(n()?e-i():e).toFixed(0):"LIVE"}ff(t,e,n,i){const r=this._e(t),{live:s,duration:o}=this.g.$state,a=s()?r-o():r;return Number.isFinite(r)?`${a<0?"-":""}${rKt(Math.abs(a),e,n,i)}`:"LIVE"}}var dKt=Object.defineProperty,pKt=Object.getOwnPropertyDescriptor,fKt=(t,e,n,i)=>{for(var r,s=i>1?void 0:i?pKt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);return i&&s&&dKt(e,n,s),s};class mKt extends OHt{constructor(){super(...arguments),this.pf=null,this.cf=null,this.uf=xHt(null),this.of=[],this.Hc=[],this.vf=xHt(this.Hc),this.qf=xHt(-1),this.rf=xHt(-1),this.wf=0,this.Lf=GHt((t=>{let e;for(let n=this.wf;n<this.of.length;n++)if(e=this.yf(this.Hc[n],t),this.of[n]?.style.setProperty("--chapter-progress",e+"%"),e<100){this.wf=n;break}})),this.Mf=wHt(this.Nf.bind(this))}static{this.props={disabled:!1}}get cues(){return this.vf()}get activeCue(){return this.Hc[this.qf()]||null}get activePointerCue(){return this.Hc[this.rf()]||null}onSetup(){this.g=mqt(),this.sf=zHt(hKt.state)}onAttach(t){const e=this.Df.bind(this);iGt(this.g.textTracks,"chapters",e),kHt(this.zf.bind(this))}onConnect(){RWt(this.H.bind(this))}setRefs(t){if(this.of=t,this.tf?.dispose(),1===this.of.length){const t=this.of[0];t.style.width="100%",t.style.setProperty("--chapter-fill","var(--slider-fill)"),t.style.setProperty("--chapter-progress","var(--slider-progress)")}else this.of.length>0&&AWt((()=>this.Hb()),this.tf=HWt())}Af(t){MWt(this.uf)!==t&&(this.uf.set(t),this.H(),this.Ef())}Ef(){const t=this.uf();if(!t?.cues.length||this.Hc.length)return;const e=this.Ff(t.cues);this.Hc=e,this.vf.set(e),0===e[0].startTime&&this.qf.set(0)}H(){this.Hc.length&&(this.of=[],this.Hc=[],this.vf.set(this.Hc),this.qf.set(-1),this.rf.set(-1),this.wf=0,this.tf?.dispose())}Hb(){this.Gf(),kHt(this.Hf.bind(this)),kHt(this.If.bind(this)),kHt(this.Jf.bind(this))}Kf(){return this.Hc[this.Hc.length-1].endTime}Gf(){let t,e=this.Kf();for(let n=0;n<this.Hc.length;n++)t=this.Hc[n],this.of[n].style.width=BGt((t.endTime-t.startTime)/e*100,3)+"%"}Hf(){const{liveEdge:t,ended:e}=this.g.$state;let{fillPercent:n,value:i}=this.sf,r=t(),s=MWt(this.qf),o=this.Hc[s],a=r?this.Hc.length-1:this.Bf(o.startTime<=MWt(i)?s:0,n());r||e()?this.xf(0,this.Hc.length,"100%"):a>s?this.xf(s,a,"100%"):a<s&&this.xf(a+1,s+1,"0%");const l=r?"100%":this.yf(this.Hc[a],n())+"%";this.Cf(this.of[a],l),this.qf.set(a)}If(){let{pointing:t,pointerPercent:e}=this.sf;if(!t())return void this.rf.set(-1);const n=this.Bf(0,e());this.rf.set(n)}xf(t,e,n){for(let i=t;i<e;i++)this.Cf(this.of[i],n)}Cf(t,e){t&&t.style.setProperty("--chapter-fill",e)}Bf(t,e){let n=0;for(let i=t;i<this.Hc.length;i++)if(n=this.yf(this.Hc[i],e),n>=0&&n<100)return i;return 0}Jf(){this.Lf(this.Mf())}Nf(){const{bufferedEnd:t,duration:e}=this.g.$state;return 100*BGt(Math.min(t()/Math.max(e(),1),1),3)}yf(t,e){const n=this.Hc[this.Hc.length-1],i=t.startTime/n.endTime*100,r=t.endTime/n.endTime*100;return Math.max(0,BGt(e>=r?100:(e-i)/(r-i)*100,3))}Ff(t){const e=[];0!==t[0].startTime&&e.push(new window.VTTCue(0,t[0].startTime,""));for(let n=0;n<t.length-1;n++){const i=t[n],r=t[n+1];if(e.push(i),r){const t=r.startTime-i.endTime;t>0&&e.push(new window.VTTCue(i.endTime,i.endTime+t,""))}}return e.push(t[t.length-1]),e}Df(t){this.cf=t,this.zf()}zf(){if(!this.scope)return;const{disabled:t}=this.$props;return t()?void 0:(this.Af(this.cf),this.pf=this.Of()?.querySelector('[data-part="chapter-title"]')||null,this.pf&&kHt(this.Pf.bind(this)),()=>{this.Af(null),this.pf&&(this.pf.textContent="",this.pf=null)})}Pf(){const t=this.activePointerCue||this.activeCue;this.pf&&(this.pf.textContent=t?.text||"")}Of(){let t=this.el;for(;t&&"slider"!==t.getAttribute("role");)t=t.parentElement;return t}}fKt([LHt],mKt.prototype,"cues",1),fKt([LHt],mKt.prototype,"activeCue",1),fKt([LHt],mKt.prototype,"activePointerCue",1),fKt([DHt],mKt.prototype,"setRefs",1);const gKt=CHt(),yKt=["a[href]","[tabindex]","input","select","button"].map((t=>`${t}:not([aria-hidden])`)).join(","),bKt=new Set(["Escape","Tab","ArrowUp","ArrowDown","Home","PageUp","End","PageDown","Enter"," "]);class vKt{constructor(t){this.Mg=0,this.Dj=null,this.Cj=[],this.Ka=t}get B(){return this.Cj}ig(t){return pHt(t,"focus",this.Li.bind(this)),this.Dj=t,RWt((()=>{this.Dj=null})),this}ke(){this.Dj&&(this.Hb(),pHt(this.Dj,"keyup",this.hd.bind(this)),pHt(this.Dj,"keydown",this.id.bind(this)),RWt((()=>{this.Mg=0,this.Cj=[]})))}Hb(){this.Mg=0,this.Cj=this.Hj()}Ag(t=this.Gj()){const e=this.Cj[t],n=this.Ka.ug();e&&n&&requestAnimationFrame((()=>{n.scrollTop=e.offsetTop-n.offsetHeight/2+e.offsetHeight/2}))}Ej(t){this.Mg=t,this.Cj[t]?.focus(),this.Ag(t)}Gj(){return this.Cj.findIndex((t=>"true"===t.getAttribute("aria-checked")))}Li(){this.Hb(),setTimeout((()=>{const t=this.Gj();this.Ej(t>=0?t:0)}),100)}hd(t){bKt.has(t.key)&&(t.stopPropagation(),t.preventDefault())}id(t){if(bKt.has(t.key))switch(t.stopPropagation(),t.preventDefault(),t.key){case"Escape":this.Ka.vg(t);break;case"Tab":this.Ej(this.Fj(t.shiftKey?-1:1));break;case"ArrowUp":this.Ej(this.Fj(-1));break;case"ArrowDown":this.Ej(this.Fj(1));break;case"Home":case"PageUp":this.Ej(0);break;case"End":case"PageDown":this.Ej(this.Cj.length-1)}}Fj(t){let e=this.Mg;do{e=(e+t+this.Cj.length)%this.Cj.length}while(null===this.Cj[e]?.offsetParent);return e}Hj(){if(!this.Dj)return[];const t=this.Dj.querySelectorAll(yKt),e=[],n=t=>"menu"===t.getAttribute("role");for(const i of t)i instanceof HTMLElement&&null!==i.offsetParent&&pGt(this.Dj,i,n)&&e.push(i);return e}}var xKt=Object.defineProperty,wKt=Object.getOwnPropertyDescriptor,SKt=(t,e,n,i)=>{for(var r,s=i>1?void 0:i?wKt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);return i&&s&&xKt(e,n,s),s};let kKt=0;class CKt extends OHt{constructor(){super(),this.Qf=xHt(!1),this.Le=xHt(!1),this.be=xHt(null),this.ce=xHt(null),this.Zf=xHt(!1),this.Sf=new Set,this.Tf=null,this.qg=this.rg.bind(this),this.og=this.sg.bind(this),this.pg=this.tg.bind(this);const{showDelay:t}=this.$props;this.Uf=new kXt({be:this.be,ce:this.ce,je:t,ke:(t,e,n)=>{fGt(t,(t=>{this.Qf()?n(t):e(t)}));const i=this.fg();i&&fGt(i,(t=>{t.stopPropagation(),n(t)}))},Da:this.gg.bind(this)})}static{this.props={showDelay:0}}get triggerElement(){return this.be()}get contentElement(){return this.ce()}get isSubmenu(){return!!this.Xf}onSetup(){this.g=mqt();const t=++kKt;this.Vf=`media-menu-${t}`,this.Wf=`media-menu-button-${t}`,this.Rf=new vKt({ug:this.hg.bind(this),vg:this.close.bind(this)}),EHt(gKt)&&(this.Xf=_Ht(gKt)),this.setAttributes({"data-open":this.Qf,"data-submenu":this.isSubmenu,"data-disabled":this.De.bind(this)}),THt(gKt,{wg:this.be,Qf:this.Qf,xg:xHt(""),_f:this._f.bind(this),$f:this.$f.bind(this),ag:this.ag.bind(this),bg:this.bg.bind(this),cg:this.cg.bind(this),Yf:this.Yf.bind(this)})}onAttach(t){t.style.setProperty("display","contents"),this.Rf.ig(t)}onConnect(t){kHt(this.jg.bind(this)),this.isSubmenu&&this.Xf?.Yf(this),requestAnimationFrame((()=>{this.pd()}))}onDestroy(){this.be.set(null),this.ce.set(null),this.Tf=null}jg(){const t=this.kg();this.pd(),this.dg(t),t&&(kHt((()=>{const{height:t}=this.g.$state,e=this.ce();e&&vHt(e,"--player-height",t()+"px")})),this.Rf.ke(),this.listen("pointerup",this.lg.bind(this)),pHt(window,"pointerup",this.mg.bind(this)))}$f(t){const e=t.el,n=this.isSubmenu,i=RXt(this.De.bind(this));hGt(e,"tabindex",n?"-1":"0"),hGt(e,"role",n?"menuitem":"button"),bHt(e,"id",this.Wf),bHt(e,"aria-haspopup","menu"),bHt(e,"aria-expanded","false"),bHt(e,"data-submenu",this.isSubmenu),this.isSubmenu||this.eg(e);kHt((()=>{bHt(e,"data-open",this.Qf()),bHt(e,"aria-disabled",i())})),this.be.set(e),RWt((()=>{this.be.set(null)}))}ag(t){const e=t.el;e.style.setProperty("display","none"),bHt(e,"id",this.Vf),hGt(e,"role","menu"),hGt(e,"tabindex","-1"),bHt(e,"data-submenu",this.isSubmenu),this.ce.set(e),RWt((()=>this.ce.set(null))),this.isSubmenu||this.eg(e);kHt((()=>{bHt(e,"data-open",this.Qf())})),this.Rf.ig(e),this.dg(!1),requestAnimationFrame(this.pd.bind(this))}bg(t){this.Tf=t}eg(t){pHt(t,"click",(t=>t.stopPropagation())),pHt(t,"pointerup",(t=>t.stopPropagation()))}dg(t){const e=MWt(this.ce);e&&bHt(e,"aria-hidden",WHt(!t))}cg(t){this.Zf.set(t)}gg(t,e){if(e?.stopPropagation(),this.Qf()===t)return;if(this.De())return void(t&&this.Uf.hide(e));const n=this.be(),i=this.ce();if(n&&(bHt(n,"aria-controls",t&&this.Vf),bHt(n,"aria-expanded",WHt(t))),i&&bHt(i,"aria-labelledby",t&&this.Wf),this.Qf.set(t),this.ng(e),$Wt(),gHt(e)){t?i?.focus():n?.focus();for(const t of[this.el,i])t&&t.setAttribute("data-keyboard","")}else for(const t of[this.el,i])t&&t.removeAttribute("data-keyboard");this.dispatch(t?"open":"close",{trigger:e}),t?(this.isSubmenu||this.g.activeMenu===this||(this.g.activeMenu?.close(e),this.g.activeMenu=this),this.Tf?.yg?.(e)):(this.isSubmenu?setTimeout((()=>{for(const t of this.Sf)t.close(e)}),300):this.g.activeMenu=null,this.Tf?.zg?.(e)),t&&!gHt(e)&&requestAnimationFrame((()=>{this.Rf.Hb(),setTimeout((()=>{this.Rf.Ag()}),100)}))}kg(){return!this.De()&&this.Qf()}De(){return this.Le()||this.Zf()}_f(t){this.Le.set(t)}lg(t){t.stopPropagation()}mg(t){if(this.isSubmenu)return setTimeout(this.close.bind(this,t),800);this.close(t)}fg(){const t=this.el.querySelector('[data-part="close-target"]');return pGt(this.el,t,(t=>"menu"===t.getAttribute("role")))?t:null}hg(){if(this.isSubmenu){let t=this.el;for(;t&&"media-menu"!==t.tagName&&t.hasAttribute("data-submenu");)t=t.parentNode;return t}return MWt(this.ce)||null}ng(t){this.isSubmenu||(this.Qf()?this.g.remote.pauseControls(t):this.g.remote.resumeControls(t))}Yf(t){this.Sf.add(t),pHt(t,"open",this.og),pHt(t,"close",this.pg),RWt(this.qg)}rg(t){this.Sf.delete(t)}sg(t){for(const e of this.Sf)if(e!==t.target)for(const t of[e.el,e.triggerElement])t?.setAttribute("aria-hidden","true");requestAnimationFrame((()=>{this.pd()}))}tg(){for(const t of this.Sf)for(const e of[t.el,t.triggerElement])e?.setAttribute("aria-hidden","false");requestAnimationFrame((()=>{this.pd()}))}pd(){const t=MWt(this.ce);if(!t)return;let{paddingTop:e,paddingBottom:n,borderTopWidth:i,borderBottomWidth:r}=getComputedStyle(t),s=parseFloat(e)+parseFloat(n)+parseFloat(i)+parseFloat(r),o=[...t.children];for(const t of o)t instanceof HTMLElement&&"contents"===t.style.display?o.push(...t.children):s+=t.offsetHeight||0;requestAnimationFrame((()=>{t&&(bHt(t,"data-resizing",""),setTimeout((()=>{t&&bHt(t,"data-resizing",!1)}),400),vHt(t,"--menu-height",s+"px"))}))}open(t){MWt(this.Qf)||(this.Uf.show(t),$Wt())}close(t){MWt(this.Qf)&&(this.Uf.hide(t),$Wt())}}SKt([LHt],CKt.prototype,"triggerElement",1),SKt([LHt],CKt.prototype,"contentElement",1),SKt([LHt],CKt.prototype,"isSubmenu",1),SKt([DHt],CKt.prototype,"open",1),SKt([DHt],CKt.prototype,"close",1);var TKt=Object.defineProperty,_Kt=Object.getOwnPropertyDescriptor;class EKt extends OHt{constructor(){super(),new rXt}static{this.props={disabled:!1}}get expanded(){return this.Bg?.Qf()??!1}onSetup(){this.Bg=_Ht(gKt)}onAttach(t){this.Bg.$f(this),kHt(this.Ge.bind(this)),hGt(t,"type","button")}onConnect(t){const e=Array.from(t.querySelectorAll('[data-part="hint"]')).pop();e&&kHt((()=>{const t=this.Bg.xg();t&&(e.textContent=t)})),fGt(t,(t=>{this.dispatch("select",{trigger:t})}))}Ge(){this.Bg.cg(this.$props.disabled())}}((t,e,n,i)=>{for(var r,s=i>1?void 0:i?_Kt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);i&&s&&TKt(e,n,s)})([LHt],EKt.prototype,"expanded",1);let MKt=class extends OHt{constructor(){super(...arguments),this.z=null}static{this.props={container:null,disabled:!1}}onSetup(){this.g=mqt(),THt($Kt,{me:this.Dg.bind(this)})}onAttach(t){t.style.setProperty("display","contents")}onConnect(t){}onDestroy(){this.z?.remove(),this.z=null}Dg(t){this.Cg(!1),this.z=t,gGt((()=>{gGt((()=>{this.connectScope&&kHt(this.Ge.bind(this))}))}))}Ge(){const{fullscreen:t}=this.g.$state,{disabled:e}=this.$props,n=e();this.Cg("fullscreen"===n?!t():!n)}Cg(t){if(!this.z)return;let e=this.Eg(this.$props.container());if(!e)return;const n=this.z.parentElement===e;bHt(this.z,"data-portal",t),t?n||(this.z.remove(),e.append(this.z)):n&&this.z.parentElement===e&&(this.z.remove(),this.el?.append(this.z))}Eg(t){return t instanceof HTMLElement?t:t?document.querySelector(t):document.body}};const $Kt=CHt();class IKt extends OHt{constructor(){super(),new rXt;const{placement:t}=this.$props;this.setAttributes({"data-placement":t})}static{this.props={placement:null,offset:0,alignOffset:0}}onAttach(t){if(this.Bg=_Ht(gKt),this.Bg.ag(this),EHt($Kt)){const e=_Ht($Kt);e&&(THt($Kt,null),e.me(t),RWt((()=>e.me(null))))}}onConnect(t){kHt(this.ne.bind(this))}ne(){if(!this.el)return;const t=this.$props.placement();if(t){Object.assign(this.el.style,{position:"absolute",top:0,left:0,width:"max-content"});const{offset:e,alignOffset:n}=this.$props;return xGt(this.el,this.le(),t,{offsetVarName:"media-menu",xOffset:n(),yOffset:e()})}this.el.removeAttribute("style"),this.el.style.display="none"}le(){return this.Bg.wg()}}const AKt=CHt();class NKt extends PHt{constructor(){super(...arguments),this.Ij=new Set,this.Lg=xHt(""),this.a=null,this.Mj=this.Da.bind(this)}get Fg(){return Array.from(this.Ij).map((t=>t.Lg()))}get value(){return this.Lg()}set value(t){this.Da(t)}onSetup(){THt(AKt,{add:this.Kj.bind(this),remove:this.Lj.bind(this)})}onAttach(t){EHt(gKt)||hGt(t,"role","radiogroup"),this.setAttributes({value:this.Lg})}onDestroy(){this.Ij.clear()}Kj(t){this.Ij.has(t)||(this.Ij.add(t),t.Ig=this.Mj,t.Hg(t.Lg()===this.Lg()))}Lj(t){t.Ig=null,this.Ij.delete(t)}Da(t,e){const n=MWt(this.Lg);if(!t||t===n)return;const i=this.Jj(n),r=this.Jj(t);i?.Hg(!1,e),r?.Hg(!0,e),this.Lg.set(t),this.Gb?.(t,e)}Jj(t){for(const e of this.Ij)if(t===MWt(e.Lg))return e;return null}}var RKt=Object.defineProperty,PKt=Object.getOwnPropertyDescriptor,OKt=(t,e,n,i)=>{for(var r,s=i>1?void 0:i?PKt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);return i&&s&&RKt(e,n,s),s};class LKt extends OHt{constructor(){super(),this.a=new NKt,this.a.Gb=this.Gb.bind(this)}static{this.props={value:""}}get values(){return this.a.Fg}get value(){return this.a.value}set value(t){this.a.value=t}onSetup(){kHt(this.Fe.bind(this))}Fe(){this.a.value=this.$props.value()}Gb(t,e){const n=this.createEvent("change",{detail:t,trigger:e});this.dispatch(n)}}OKt([LHt],LKt.prototype,"values",1),OKt([LHt],LKt.prototype,"value",1);var DKt=Object.defineProperty,FKt=Object.getOwnPropertyDescriptor;class zKt extends OHt{constructor(){super(),this.Gg=xHt(!1),this.a={Lg:this.$props.value,Hg:this.Hg.bind(this),Ig:null},new rXt}static{this.props={value:""}}get checked(){return this.Gg()}onSetup(){this.setAttributes({value:this.$props.value,"data-checked":this.Gg,"aria-checked":RXt(this.Gg)})}onAttach(t){const e=EHt(gKt);hGt(t,"tabindex",e?"-1":"0"),hGt(t,"role",e?"menuitemradio":"radio"),kHt(this.Fe.bind(this))}onConnect(t){this.Jg(),fGt(t,this.re.bind(this)),RWt(this.A.bind(this))}A(){AWt((()=>{_Ht(AKt).remove(this.a)}),this.connectScope)}Jg(){_Ht(AKt).add(this.a)}Fe(){const{value:t}=this.$props,e=t();MWt(this.Gg)&&this.a.Ig?.(e)}re(t){MWt(this.Gg)||(this.Da(!0,t),this.Kg(t),this.a.Ig?.(MWt(this.$props.value),t))}Hg(t,e){MWt(this.Gg)!==t&&this.Da(t,e)}Da(t,e){this.Gg.set(t),this.dispatch("change",{detail:t,trigger:e})}Kg(t){this.dispatch("select",{trigger:t})}}((t,e,n,i)=>{for(var r,s=i>1?void 0:i?FKt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);i&&s&&DKt(e,n,s)})([LHt],zKt.prototype,"checked",1);var BKt=Object.defineProperty,UKt=Object.getOwnPropertyDescriptor,VKt=(t,e,n,i)=>{for(var r,s=i>1?void 0:i?UKt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);return i&&s&&BKt(e,n,s),s};class WKt extends OHt{constructor(){super(),this.Mg=xHt(0),this.Dc=xHt(null),this.a=new NKt,this.a.Gb=this.Gb.bind(this)}static{this.props={thumbnails:""}}get value(){return this.a.value}get disabled(){const t=this.Dc();return!t||!t.cues.length}onSetup(){this.g=mqt(),EHt(gKt)&&(this.Bg=_Ht(gKt));const{thumbnails:t}=this.$props;this.setAttributes({"data-thumbnails":()=>!!t()})}onAttach(t){this.Bg?.bg({yg:this.yg.bind(this)})}getOptions(){const t=this.Dc();return t?t.cues.map(((t,e)=>({cue:t,value:e+"",label:t.text,startTime:rKt(t.startTime,!1),duration:sKt(t.endTime-t.startTime)}))):[]}yg(){MWt((()=>this.Fd()))}onConnect(t){kHt(this.Fe.bind(this)),kHt(this.Fd.bind(this)),kHt(this.Ng.bind(this)),iGt(this.g.textTracks,"chapters",this.Dc.set)}Fe(){this.a.value=this.Og()}Fd(){if(!this.Bg?.Qf())return;const t=this.Dc();if(!t)return void this.Mg.set(-1);const{currentTime:e}=this.g.$state,n=e(),i=t.cues.findIndex((t=>nGt(t,n)));if(this.Mg.set(i),i>=0){const e=t.cues[i],r=this.el.querySelector("[aria-checked='true']"),s=(n-e.startTime)/(e.endTime-e.startTime)*100;r&&vHt(r,"--progress",BGt(s,3)+"%")}}Ng(){this.Bg?._f(this.disabled)}Og(){return this.Mg()+""}Gb(t,e){if(this.disabled||!e)return;const n=+t,i=this.Dc()?.cues;iHt(n)&&i?.[n]&&(this.Mg.set(n),this.g.remote.seek(i[n].startTime,e),this.dispatch("change",{detail:i[n],trigger:e}))}}VKt([LHt],WKt.prototype,"value",1),VKt([LHt],WKt.prototype,"disabled",1),VKt([DHt],WKt.prototype,"getOptions",1);var HKt=Object.defineProperty,jKt=Object.getOwnPropertyDescriptor,GKt=(t,e,n,i)=>{for(var r,s=i>1?void 0:i?jKt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);return i&&s&&HKt(e,n,s),s};class qKt extends OHt{constructor(){super(),this.a=new NKt,this.a.Gb=this.Gb.bind(this)}static{this.props={emptyLabel:"Default"}}get value(){return this.a.value}get disabled(){const{audioTracks:t}=this.g.$state;return 0===t().length}onSetup(){this.g=mqt(),EHt(gKt)&&(this.Bg=_Ht(gKt))}onConnect(t){kHt(this.Fe.bind(this)),kHt(this.Ng.bind(this)),kHt(this.Pg.bind(this))}getOptions(){const{audioTracks:t}=this.g.$state;return t().map((t=>({track:t,label:t.label,value:t.label.toLowerCase()})))}Fe(){this.a.value=this.Og()}Pg(){const{emptyLabel:t}=this.$props,{audioTrack:e}=this.g.$state,n=e();this.Bg?.xg.set(n?.label??t())}Ng(){this.Bg?._f(this.disabled)}Og(){const{audioTrack:t}=this.g.$state,e=t();return e?e.label.toLowerCase():""}Gb(t,e){if(this.disabled)return;const n=this.g.audioTracks.toArray().findIndex((e=>e.label.toLowerCase()===t));if(n>=0){const t=this.g.audioTracks[n];this.g.remote.changeAudioTrack(n,e),this.dispatch("change",{detail:t,trigger:e})}}}GKt([LHt],qKt.prototype,"value",1),GKt([LHt],qKt.prototype,"disabled",1),GKt([DHt],qKt.prototype,"getOptions",1);var XKt=Object.defineProperty,KKt=Object.getOwnPropertyDescriptor,YKt=(t,e,n,i)=>{for(var r,s=i>1?void 0:i?KKt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);return i&&s&&XKt(e,n,s),s};class ZKt extends OHt{constructor(){super(),this.a=new NKt,this.a.Gb=this.Gb.bind(this)}static{this.props={offLabel:"Off"}}get value(){return this.a.value}get disabled(){const{textTracks:t}=this.g.$state;return 0===t().filter(cGt).length}onSetup(){this.g=mqt(),EHt(gKt)&&(this.Bg=_Ht(gKt))}onConnect(t){super.onConnect?.(t),kHt(this.Fe.bind(this)),kHt(this.Ng.bind(this)),kHt(this.Pg.bind(this))}getOptions(){const{offLabel:t}=this.$props,{textTracks:e}=this.g.$state;return[{value:"off",label:t},...e().filter(cGt).map((t=>({track:t,label:t.label,value:t.label.toLowerCase()})))]}Fe(){this.a.value=this.Og()}Pg(){const{offLabel:t}=this.$props,{textTrack:e}=this.g.$state,n=e();this.Bg?.xg.set(n&&cGt(n)&&"showing"===n.mode?n.label:t())}Ng(){this.Bg?._f(this.disabled)}Og(){const{textTrack:t}=this.g.$state,e=t();return e&&cGt(e)&&"showing"===e.mode?e.label.toLowerCase():"off"}Gb(t,e){if(this.disabled)return;if("off"===t){const t=this.g.textTracks.selected;if(t){const n=this.g.textTracks.toArray().indexOf(t);this.g.remote.changeTextTrackMode(n,"disabled",e),this.dispatch("change",{detail:null,trigger:e})}return}const n=this.g.textTracks.toArray().findIndex((e=>e.label.toLowerCase()===t));if(n>=0){const t=this.g.textTracks[n];this.g.remote.changeTextTrackMode(n,"showing",e),this.dispatch("change",{detail:t,trigger:e})}}}YKt([LHt],ZKt.prototype,"value",1),YKt([LHt],ZKt.prototype,"disabled",1),YKt([DHt],ZKt.prototype,"getOptions",1);var JKt=Object.defineProperty,QKt=Object.getOwnPropertyDescriptor,tYt=(t,e,n,i)=>{for(var r,s=i>1?void 0:i?QKt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);return i&&s&&JKt(e,n,s),s};class eYt extends OHt{constructor(){super(),this.a=new NKt,this.a.Gb=this.Gb.bind(this)}static{this.props={normalLabel:"Normal",rates:[.25,.5,.75,1,1.25,1.5,1.75,2]}}get value(){return this.a.value}onSetup(){this.g=mqt(),EHt(gKt)&&(this.Bg=_Ht(gKt))}onConnect(t){kHt(this.Fe.bind(this)),kHt(this.Pg.bind(this))}getOptions(){const{rates:t,normalLabel:e}=this.$props;return t().map((t=>({label:1===t?e:t+"",value:t+""})))}Fe(){this.a.value=this.Og()}Pg(){const{normalLabel:t}=this.$props,{playbackRate:e}=this.g.$state,n=e();this.Bg?.xg.set(1===n?t():n+"")}Og(){const{playbackRate:t}=this.g.$state;return t()+""}Gb(t,e){const n=+t;this.g.remote.changePlaybackRate(n,e),this.dispatch("change",{detail:n,trigger:e})}}tYt([LHt],eYt.prototype,"value",1),tYt([DHt],eYt.prototype,"getOptions",1);var nYt=Object.defineProperty,iYt=Object.getOwnPropertyDescriptor,rYt=(t,e,n,i)=>{for(var r,s=i>1?void 0:i?iYt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);return i&&s&&nYt(e,n,s),s};class sYt extends OHt{constructor(){super(),this.Rg=wHt((()=>{const{qualities:t}=this.g.$state;return[...t()].sort(((t,e)=>e.height===t.height?e.bitrate-t.bitrate:e.height-t.height))})),this.a=new NKt,this.a.Gb=this.Gb.bind(this)}static{this.props={autoLabel:"Auto",hideBitrate:!1}}get value(){return this.a.value}get disabled(){const{canSetQuality:t,qualities:e}=this.g.$state;return!t()||0===e().length}onSetup(){this.g=mqt(),EHt(gKt)&&(this.Bg=_Ht(gKt))}onConnect(t){kHt(this.Fe.bind(this)),kHt(this.Ng.bind(this)),kHt(this.Pg.bind(this))}getOptions(){const{autoLabel:t,hideBitrate:e}=this.$props;return[{value:"auto",label:t},...this.Rg().map((t=>{const n=`${BGt(t.bitrate/1e6,2)} Mbps`;return{quality:t,label:t.height+"p",value:this.Qg(t),bitrate:()=>e()?null:n}}))]}Fe(){this.a.value=this.Og()}Pg(){const{autoLabel:t}=this.$props,{autoQuality:e,quality:n}=this.g.$state,i=n()?n().height+"p":"";this.Bg?.xg.set(e()?t()+` (${i})`:i)}Ng(){const{qualities:t}=this.g.$state;this.Bg?._f(0===t().length)}Gb(t,e){if(this.disabled)return;if("auto"===t)return this.g.remote.changeQuality(-1,e),void this.dispatch("change",{detail:"auto",trigger:e});const{qualities:n}=this.g.$state,i=MWt(n).findIndex((e=>this.Qg(e)===t));if(i>=0){const t=MWt(n)[i];this.g.remote.changeQuality(i,e),this.dispatch("change",{detail:t,trigger:e})}}Og(){const{quality:t,autoQuality:e}=this.g.$state;if(e())return"auto";const n=t();return n?this.Qg(n):"auto"}Qg(t){return t.height+"_"+t.bitrate}}rYt([LHt],sYt.prototype,"value",1),rYt([LHt],sYt.prototype,"disabled",1),rYt([DHt],sYt.prototype,"getOptions",1);class oYt extends OHt{constructor(){super(...arguments),this.Ra=null,this.Sg=0,this.Tg=-1}static{this.props={event:void 0,action:void 0}}onSetup(){this.g=mqt();const{event:t,action:e}=this.$props;this.setAttributes({event:t,action:e})}onAttach(t){t.setAttribute("data-media-gesture",""),t.style.setProperty("pointer-events","none")}onConnect(t){this.Ra=this.g.player.el?.querySelector("[data-media-provider]"),kHt(this.Vg.bind(this))}Vg(){let t=this.$props.event();if(this.Ra&&t){if(/^dbl/.test(t)&&(t=t.split(/^dbl/)[1]),"pointerup"===t||"pointerdown"===t){"coarse"===this.g.$state.pointer()&&(t="pointerup"===t?"touchend":"touchstart")}pHt(this.Ra,t,this.Wg.bind(this),{passive:!1})}}Wg(t){if(fHt(t)&&(0!==t.button||this.g.activeMenu)||mHt(t)&&this.g.activeMenu||mGt(t)||!this.Xg(t))return;t.MEDIA_GESTURE=!0,t.preventDefault();const e=MWt(this.$props.event),n=e?.startsWith("dbl");if(n){if(1===this.Sg)return queueMicrotask((()=>this.Ug(t))),clearTimeout(this.Tg),void(this.Sg=0)}else 0===this.Sg&&setTimeout((()=>{1===this.Sg&&this.Ug(t)}),250);0===this.Sg&&(this.Tg=window.setTimeout((()=>{this.Sg=0}),275)),this.Sg++}Ug(t){this.el.setAttribute("data-triggered",""),requestAnimationFrame((()=>{this.Yg()&&this.Zg(MWt(this.$props.action),t),requestAnimationFrame((()=>{this.el.removeAttribute("data-triggered")}))}))}Xg(t){if(!this.el)return!1;if(fHt(t)||function(t){return/^(click|mouse)/.test(t?.type??"")}(t)||mHt(t)){const e=mHt(t)?t.changedTouches[0]??t.touches[0]:void 0,n=e?.clientX??t.clientX,i=e?.clientY??t.clientY,r=this.el.getBoundingClientRect(),s=i>=r.top&&i<=r.bottom&&n>=r.left&&n<=r.right;return t.type.includes("leave")?!s:s}return!0}Yg(){const t=this.g.player.el.querySelectorAll("[data-media-gesture][data-triggered]");return Array.from(t).sort(((t,e)=>+getComputedStyle(e).zIndex-+getComputedStyle(t).zIndex))[0]===this.el}Zg(t,e){if(!t)return;const n=new cHt("will-trigger",{detail:t,cancelable:!0,trigger:e});if(this.dispatchEvent(n),n.defaultPrevented)return;const[i,r]=t.replace(/:([a-z])/,"-$1").split(":");t.includes(":fullscreen")?this.g.remote.toggleFullscreen("prefer-media",e):t.includes("seek:")?this.g.remote.seek(MWt(this.g.$state.currentTime)+(+r||0),e):this.g.remote[UHt(i)](e),this.dispatch("trigger",{detail:t,trigger:e})}}class aYt{constructor(t){this.priority=10,this.Dc=null,this.va=HHt(),this.$g=t}attach(){}canRender(){return!0}detach(){this.va.empty(),this.$g.reset(),this.Dc=null}changeTrack(t){t&&this.Dc!==t&&(this.va.empty(),t.readyState<2?(this.$g.reset(),this.va.add(pHt(t,"load",(()=>this.Nj(t)),{once:!0}))):this.Nj(t),this.va.add(pHt(t,"add-cue",(t=>{this.$g.addCue(t.detail)})),pHt(t,"remove-cue",(t=>{this.$g.removeCue(t.detail)}))),this.Dc=t)}Nj(t){this.$g.changeTrack({cues:[...t.cues],regions:[...t.regions]})}}class lYt extends OHt{static{this.props={textDir:"ltr"}}onSetup(){this.g=mqt(),this.setAttributes({"aria-hidden":RXt(this.ue.bind(this))})}onAttach(t){t.style.setProperty("pointer-events","none")}onConnect(t){this.$g?kHt(this.ah.bind(this)):Promise.resolve().then((function(){return K2t})).then((e=>{this.connectScope&&AWt((()=>{this.na=e;const{CaptionsRenderer:n}=this.na;this.$g=new n(t),this._g=new aYt(this.$g),kHt(this.ah.bind(this))}),this.connectScope)}))}onDestroy(){this._g&&(this._g.detach(),this.g.textRenderers.remove(this._g)),this.$g?.destroy()}ue(){const{textTrack:t}=this.g.$state,e=t();return this.g.$iosControls()||!e||!cGt(e)}ah(){const{viewType:t}=this.g.$state;return"audio"===t()?this.ch():this.dh()}ch(){return kHt(this.zf.bind(this)),()=>{this.el.textContent=""}}zf(){if(this.ue())return;const{textTrack:t}=this.g.$state;this.bh(),pHt(t(),"cue-change",this.bh.bind(this)),kHt(this.eh.bind(this))}bh(){this.el.textContent="";const{currentTime:t,textTrack:e}=this.g.$state,n=MWt(t),i=MWt(e).activeCues,{renderVTTCueString:r}=this.na;for(const t of i){const e=document.createElement("div");e.setAttribute("data-part","cue"),e.innerHTML=r(t,n),this.el.append(e)}}eh(){const{currentTime:t}=this.g.$state,{updateTimedVTTCueNodes:e}=this.na;e(this.el,t())}dh(){return kHt(this.fh.bind(this)),kHt(this.gh.bind(this)),this.g.textRenderers.add(this._g),()=>{this.el.textContent="",this._g.detach(),this.g.textRenderers.remove(this._g)}}fh(){this.$g.dir=this.$props.textDir()}gh(){if(this.ue())return;const{currentTime:t}=this.g.$state;this.$g.currentTime=t()}}class cYt extends OHt{static{this.props={src:void 0,alt:void 0}}static{this.state=new FHt({img:null,src:null,alt:null,loading:!0,error:null,hidden:!1})}onSetup(){this.g=mqt(),this.hh(),this.ih(),this.Se()}onAttach(t){t.style.setProperty("pointer-events","none"),kHt(this.jh.bind(this)),kHt(this.hh.bind(this)),kHt(this.ih.bind(this)),kHt(this.Se.bind(this));const{started:e}=this.g.$state;this.setAttributes({"data-visible":()=>!e(),"data-loading":this.Pe.bind(this),"data-error":this.Oe.bind(this),"data-hidden":this.$state.hidden})}onConnect(t){const{canLoad:e,poster:n}=this.g.$state;window.requestAnimationFrame((()=>{e()||Jjt(n())})),kHt(this.pa.bind(this))}Oe(){const{error:t}=this.$state;return!eHt(t())}Se(){const{src:t}=this.$props,{$iosControls:e}=this.g,{poster:n}=this.g.$state;this.el&&bHt(this.el,"display",e()?"none":null),this.$state.hidden.set(this.Oe()||!(t()||n())||e())}Pe(){const{loading:t,hidden:e}=this.$state;return!e()&&t()}jh(){const t=this.$state.img();t&&(pHt(t,"load",this.kh.bind(this)),pHt(t,"error",this.X.bind(this)))}hh(){const{src:t}=this.$props,{src:e}=this.$state,{canLoad:n,poster:i}=this.g.$state,r=t()||i();i()!==r&&this.g.delegate.f("poster-change",{detail:r}),e.set(n()&&r.length?r:null)}ih(){const{src:t,alt:e}=this.$state;e.set(t()?this.$props.alt():null)}pa(){const{loading:t,error:e}=this.$state,{canLoad:n,poster:i}=this.g.$state;t.set(n()&&!!i()),e.set(null)}kh(){const{loading:t,error:e}=this.$state;t.set(!1),e.set(null)}X(t){const{loading:e,error:n}=this.$state;e.set(!1),n.set(t)}}class uYt extends OHt{static{this.props={type:"current",showHours:!1,padHours:null,padMinutes:null,remainder:!1}}static{this.state=new FHt({timeText:""})}onSetup(){this.g=mqt(),this.u();const{type:t,remainder:e}=this.$props;this.setAttributes({"data-type":t,"data-remainder":e})}onAttach(t){kHt(this.u.bind(this))}u(){const{type:t,remainder:e,padHours:n,padMinutes:i,showHours:r}=this.$props,s=this.lh(t()),o=this.g.$state.duration();if(!Number.isFinite(s+o))return void this.$state.timeText.set("LIVE");const a=rKt(e()?Math.max(0,o-s):s,n(),i(),r());this.$state.timeText.set(a)}lh(t){const{bufferedEnd:e,duration:n,currentTime:i}=this.g.$state;switch(t){case"buffered":return e();case"duration":return n();default:return i()}}}var hYt=Object.defineProperty,dYt=Object.getOwnPropertyDescriptor,pYt=(t,e,n,i)=>{for(var r,s=i>1?void 0:i?dYt(e,n):e,o=t.length-1;o>=0;o--)(r=t[o])&&(s=(i?r(e,n,s):r(s))||s);return i&&s&&hYt(e,n,s),s};class fYt extends OHt{constructor(){super(...arguments),this.menuContainer=null}static{this.props={when:"",smallWhen:"",thumbnails:"",customIcons:!1,translations:null,menuGroup:"bottom",noModal:!1}}get isMatch(){return this.Cb.matches}get isSmallLayout(){return this.Bb.matches}onSetup(){const{when:t,smallWhen:e,thumbnails:n,translations:i,menuGroup:r,noModal:s}=this.$props;this.Cb=Aqt.create(t),this.Bb=Aqt.create(e),this.setAttributes({"data-match":this.Cb.$matches,"data-size":()=>this.Bb.matches?"sm":null});const o=this;THt(bYt,{smQueryList:this.Bb,thumbnails:n,translations:i,menuGroup:r,noModal:s,get menuContainer(){return o.menuContainer}})}}pYt([LHt],fYt.prototype,"menuContainer",2),pYt([LHt],fYt.prototype,"isMatch",1),pYt([LHt],fYt.prototype,"isSmallLayout",1);class mYt extends fYt{static{this.props={...super.props,when:"(view-type: audio)",smallWhen:"(width < 576)"}}}class gYt extends fYt{static{this.props={...super.props,when:"(view-type: video)",smallWhen:"(width < 576) or (height < 380)"}}}function yYt(t,e){return t()?.[e]??e}const bYt=CHt();function vYt(){return _Ht(bYt)}class xYt extends(qjt(HTMLElement,wXt)){constructor(){super(...arguments),this.k=null}static{this.tagName="media-provider"}onSetup(){this.g=mqt(),this.setAttribute("keep-alive","")}onDestroy(){this.k?.remove(),this.k=null}onConnect(){kHt((()=>{const t=this.$state.loader(),e=t?"audio"===t.mediaType()?this.l():this.m():null;if(this.k!==e){const t=this.k?.parentElement??this;this.k?.remove(),this.k=e,e&&t.prepend(e)}this.load(e)}))}l(){const t=this.k instanceof HTMLAudioElement?this.k:document.createElement("audio");bHt(t,"preload","none"),bHt(t,"aria-hidden","true");const{controls:e,crossorigin:n}=this.g.$state;return kHt((()=>{bHt(t,"controls",e()),bHt(t,"crossorigin",n())})),t}m(){const t=this.k instanceof HTMLVideoElement?this.k:document.createElement("video"),{controls:e,crossorigin:n,poster:i}=this.g.$state,{$iosControls:r}=this.g,s=wHt((()=>e()||r()?"":null)),o=wHt((()=>i()&&(e()||r())?i():null));return kHt((()=>{bHt(t,"controls",s()),bHt(t,"crossorigin",n()),bHt(t,"poster",o())})),t}}class wYt extends(qjt(HTMLElement,dXt)){static{this.tagName="media-player"}static{this.attrs={preferNativeHLS:"prefer-native-hls"}}}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var SYt;Zjt(wYt),Zjt(xYt);const kYt=window,CYt=kYt.trustedTypes,TYt=CYt?CYt.createPolicy("lit-html",{createHTML:t=>t}):void 0,_Yt="$lit$",EYt=`lit$${(Math.random()+"").slice(9)}$`,MYt="?"+EYt,$Yt=`<${MYt}>`,IYt=document,AYt=()=>IYt.createComment(""),NYt=t=>null===t||"object"!=typeof t&&"function"!=typeof t,RYt=Array.isArray,PYt="[ \t\n\f\r]",OYt=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,LYt=/-->/g,DYt=/>/g,FYt=RegExp(`>|${PYt}(?:([^\\s"'>=/]+)(${PYt}*=${PYt}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),zYt=/'/g,BYt=/"/g,UYt=/^(?:script|style|textarea|title)$/i,VYt=(qYt=1,(t,...e)=>({Sb:qYt,strings:t,values:e})),WYt=Symbol.for("lit-noChange"),HYt=Symbol.for("lit-nothing"),jYt=new WeakMap,GYt=IYt.createTreeWalker(IYt,129,null,!1);var qYt;function XYt(t,e){if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==TYt?TYt.createHTML(e):e}class KYt{constructor({strings:t,Sb:e},n){let i;this.parts=[];let r=0,s=0;const o=t.length-1,a=this.parts,[l,c]=((t,e)=>{const n=t.length-1,i=[];let r,s=2===e?"<svg>":"",o=OYt;for(let e=0;e<n;e++){const n=t[e];let a,l,c=-1,u=0;for(;u<n.length&&(o.lastIndex=u,l=o.exec(n),null!==l);)u=o.lastIndex,o===OYt?"!--"===l[1]?o=LYt:void 0!==l[1]?o=DYt:void 0!==l[2]?(UYt.test(l[2])&&(r=RegExp("</"+l[2],"g")),o=FYt):void 0!==l[3]&&(o=FYt):o===FYt?">"===l[0]?(o=null!=r?r:OYt,c=-1):void 0===l[1]?c=-2:(c=o.lastIndex-l[2].length,a=l[1],o=void 0===l[3]?FYt:'"'===l[3]?BYt:zYt):o===BYt||o===zYt?o=FYt:o===LYt||o===DYt?o=OYt:(o=FYt,r=void 0);const h=o===FYt&&t[e+1].startsWith("/>")?" ":"";s+=o===OYt?n+$Yt:c>=0?(i.push(a),n.slice(0,c)+_Yt+n.slice(c)+EYt+h):n+EYt+(-2===c?(i.push(void 0),e):h)}return[XYt(t,s+(t[n]||"<?>")+(2===e?"</svg>":"")),i]})(t,e);if(this.el=KYt.createElement(l,n),GYt.currentNode=this.el.content,2===e){const t=this.el.content,e=t.firstChild;e.remove(),t.append(...e.childNodes)}for(;null!==(i=GYt.nextNode())&&a.length<o;){if(1===i.nodeType){if(i.hasAttributes()){const t=[];for(const e of i.getAttributeNames())if(e.endsWith(_Yt)||e.startsWith(EYt)){const n=c[s++];if(t.push(e),void 0!==n){const t=i.getAttribute(n.toLowerCase()+_Yt).split(EYt),e=/([.?@])?(.*)/.exec(n);a.push({type:1,index:r,name:e[2],strings:t,ctor:"."===e[1]?tZt:"?"===e[1]?nZt:"@"===e[1]?iZt:QYt})}else a.push({type:6,index:r})}for(const e of t)i.removeAttribute(e)}if(UYt.test(i.tagName)){const t=i.textContent.split(EYt),e=t.length-1;if(e>0){i.textContent=CYt?CYt.emptyScript:"";for(let n=0;n<e;n++)i.append(t[n],AYt()),GYt.nextNode(),a.push({type:2,index:++r});i.append(t[e],AYt())}}}else if(8===i.nodeType)if(i.data===MYt)a.push({type:2,index:r});else{let t=-1;for(;-1!==(t=i.data.indexOf(EYt,t+1));)a.push({type:7,index:r}),t+=EYt.length-1}r++}}static createElement(t,e){const n=IYt.createElement("template");return n.innerHTML=t,n}}function YYt(t,e,n=t,i){var r,s,o,a;if(e===WYt)return e;let l=void 0!==i?null===(r=n.Ub)||void 0===r?void 0:r[i]:n.Zb;const c=NYt(e)?void 0:e.bc;return(null==l?void 0:l.constructor)!==c&&(null===(s=null==l?void 0:l.cc)||void 0===s||s.call(l,!1),void 0===c?l=void 0:(l=new c(t),l.dc(t,n,i)),void 0!==i?(null!==(o=(a=n).Ub)&&void 0!==o?o:a.Ub=[])[i]=l:n.Zb=l),void 0!==l&&(e=YYt(t,l.ec(t,e.values),l,i)),e}class ZYt{constructor(t,e){this.Vb=[],this.Tb=void 0,this.Wb=t,this.Mb=e}get parentNode(){return this.Mb.parentNode}get Nb(){return this.Mb.Nb}u(t){var e;const{el:{content:n},parts:i}=this.Wb,r=(null!==(e=null==t?void 0:t.creationScope)&&void 0!==e?e:IYt).importNode(n,!0);GYt.currentNode=r;let s=GYt.nextNode(),o=0,a=0,l=i[0];for(;void 0!==l;){if(o===l.index){let e;2===l.type?e=new JYt(s,s.nextSibling,this,t):1===l.type?e=new l.ctor(s,l.name,l.strings,this,t):6===l.type&&(e=new rZt(s,this,t)),this.Vb.push(e),l=i[++a]}o!==(null==l?void 0:l.index)&&(s=GYt.nextNode(),o++)}return GYt.currentNode=IYt,r}v(t){let e=0;for(const n of this.Vb)void 0!==n&&(void 0!==n.strings?(n.Ob(t,n,e),e+=n.strings.length-2):n.Ob(t[e])),e++}}class JYt{constructor(t,e,n,i){var r;this.type=2,this.Lb=HYt,this.Tb=void 0,this.Pb=t,this.Qb=e,this.Mb=n,this.options=i,this.Xb=null===(r=null==i?void 0:i.isConnected)||void 0===r||r}get Nb(){var t,e;return null!==(e=null===(t=this.Mb)||void 0===t?void 0:t.Nb)&&void 0!==e?e:this.Xb}get parentNode(){let t=this.Pb.parentNode;const e=this.Mb;return void 0!==e&&11===(null==t?void 0:t.nodeType)&&(t=e.parentNode),t}get startNode(){return this.Pb}get endNode(){return this.Qb}Ob(t,e=this){t=YYt(this,t,e),NYt(t)?t===HYt||null==t||""===t?(this.Lb!==HYt&&this.Rb(),this.Lb=HYt):t!==this.Lb&&t!==WYt&&this.Yb(t):void 0!==t.Sb?this.g(t):void 0!==t.nodeType?this.$(t):(t=>RYt(t)||"function"==typeof(null==t?void 0:t[Symbol.iterator]))(t)?this.T(t):this.Yb(t)}k(t){return this.Pb.parentNode.insertBefore(t,this.Qb)}$(t){this.Lb!==t&&(this.Rb(),this.Lb=this.k(t))}Yb(t){this.Lb!==HYt&&NYt(this.Lb)?this.Pb.nextSibling.data=t:this.$(IYt.createTextNode(t)),this.Lb=t}g(t){var e;const{values:n,Sb:i}=t,r="number"==typeof i?this._b(t):(void 0===i.el&&(i.el=KYt.createElement(XYt(i.h,i.h[0]),this.options)),i);if((null===(e=this.Lb)||void 0===e?void 0:e.Wb)===r)this.Lb.v(n);else{const t=new ZYt(r,this),e=t.u(this.options);t.v(n),this.$(e),this.Lb=t}}_b(t){let e=jYt.get(t.strings);return void 0===e&&jYt.set(t.strings,e=new KYt(t)),e}T(t){RYt(this.Lb)||(this.Lb=[],this.Rb());const e=this.Lb;let n,i=0;for(const r of t)i===e.length?e.push(n=new JYt(this.k(AYt()),this.k(AYt()),this,this.options)):n=e[i],n.Ob(r),i++;i<e.length&&(this.Rb(n&&n.Qb.nextSibling,i),e.length=i)}Rb(t=this.Pb.nextSibling,e){var n;for(null===(n=this.$b)||void 0===n||n.call(this,!1,!0,e);t&&t!==this.Qb;){const e=t.nextSibling;t.remove(),t=e}}setConnected(t){var e;void 0===this.Mb&&(this.Xb=t,null===(e=this.$b)||void 0===e||e.call(this,t))}}class QYt{constructor(t,e,n,i,r){this.type=1,this.Lb=HYt,this.Tb=void 0,this.element=t,this.name=e,this.Mb=i,this.options=r,n.length>2||""!==n[0]||""!==n[1]?(this.Lb=Array(n.length-1).fill(new String),this.strings=n):this.Lb=HYt}get tagName(){return this.element.tagName}get Nb(){return this.Mb.Nb}Ob(t,e=this,n,i){const r=this.strings;let s=!1;if(void 0===r)t=YYt(this,t,e,0),s=!NYt(t)||t!==this.Lb&&t!==WYt,s&&(this.Lb=t);else{const i=t;let o,a;for(t=r[0],o=0;o<r.length-1;o++)a=YYt(this,i[n+o],e,o),a===WYt&&(a=this.Lb[o]),s||(s=!NYt(a)||a!==this.Lb[o]),a===HYt?t=HYt:t!==HYt&&(t+=(null!=a?a:"")+r[o+1]),this.Lb[o]=a}s&&!i&&this.j(t)}j(t){t===HYt?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:"")}}class tZt extends QYt{constructor(){super(...arguments),this.type=3}j(t){this.element[this.name]=t===HYt?void 0:t}}const eZt=CYt?CYt.emptyScript:"";class nZt extends QYt{constructor(){super(...arguments),this.type=4}j(t){t&&t!==HYt?this.element.setAttribute(this.name,eZt):this.element.removeAttribute(this.name)}}class iZt extends QYt{constructor(t,e,n,i,r){super(t,e,n,i,r),this.type=5}Ob(t,e=this){var n;if((t=null!==(n=YYt(this,t,e,0))&&void 0!==n?n:HYt)===WYt)return;const i=this.Lb,r=t===HYt&&i!==HYt||t.capture!==i.capture||t.once!==i.once||t.passive!==i.passive,s=t!==HYt&&(i===HYt||r);r&&this.element.removeEventListener(this.name,this,i),s&&this.element.addEventListener(this.name,this,t),this.Lb=t}handleEvent(t){var e,n;"function"==typeof this.Lb?this.Lb.call(null!==(n=null===(e=this.options)||void 0===e?void 0:e.host)&&void 0!==n?n:this.element,t):this.Lb.handleEvent(t)}}class rZt{constructor(t,e,n){this.element=t,this.type=6,this.Tb=void 0,this.Mb=e,this.options=n}get Nb(){return this.Mb.Nb}Ob(t){YYt(this,t)}}const sZt=kYt.litHtmlPolyfillSupport;null==sZt||sZt(KYt,JYt),(null!==(SYt=kYt.litHtmlVersions)&&void 0!==SYt?SYt:kYt.litHtmlVersions=[]).push("2.8.0");const oZt=(t,e,n)=>{var i,r;const s=null!==(i=null==n?void 0:n.renderBefore)&&void 0!==i?i:e;let o=s.ac;if(void 0===o){const t=null!==(r=null==n?void 0:n.renderBefore)&&void 0!==r?r:null;s.ac=o=new JYt(e.insertBefore(AYt(),t),t,void 0,null!=n?n:{})}return o.Ob(t),o},aZt=1,lZt=2,cZt=t=>(...e)=>({bc:t,values:e});
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */class uZt{constructor(t){}get Nb(){return this.Mb.Nb}dc(t,e,n){this.Ah=t,this.Mb=e,this.Ch=n}ec(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const hZt=(t,e)=>{var n,i;const r=t.Tb;if(void 0===r)return!1;for(const t of r)null===(i=(n=t).cc)||void 0===i||i.call(n,e,!1),hZt(t,e);return!0},dZt=t=>{let e,n;do{if(void 0===(e=t.Mb))break;n=e.Tb,n.delete(t),t=e}while(0===(null==n?void 0:n.size))},pZt=t=>{for(let e;e=t.Mb;t=e){let n=e.Tb;if(void 0===n)e.Tb=n=new Set;else if(n.has(t))break;n.add(t),gZt(e)}};function fZt(t){void 0!==this.Tb?(dZt(this),this.Mb=t,pZt(this)):this.Mb=t}function mZt(t,e=!1,n=0){const i=this.Lb,r=this.Tb;if(void 0!==r&&0!==r.size)if(e)if(Array.isArray(i))for(let t=n;t<i.length;t++)hZt(i[t],!1),dZt(i[t]);else null!=i&&(hZt(i,!1),dZt(i));else hZt(this,t)}const gZt=t=>{var e,n,i,r;t.type==lZt&&(null!==(e=(i=t).$b)&&void 0!==e||(i.$b=mZt),null!==(n=(r=t).Bh)&&void 0!==n||(r.Bh=fZt))};class yZt extends uZt{constructor(){super(...arguments),this.Tb=void 0}dc(t,e,n){super.dc(t,e,n),pZt(this),this.isConnected=t.Nb}cc(t,e=!0){var n,i;t!==this.isConnected&&(this.isConnected=t,t?null===(n=this.reconnected)||void 0===n||n.call(this):null===(i=this.disconnected)||void 0===i||i.call(this)),e&&(hZt(this,t),dZt(this))}setValue(t){if(void 0===this.Ah.strings)this.Ah.Ob(t,this);else{const e=[...this.Ah.Lb];e[this.Ch]=t,this.Ah.Ob(e,this,0)}}disconnected(){}reconnected(){}}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const bZt=t=>null!=t?t:HYt
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */;class vZt extends uZt{constructor(t){if(super(t),this.et=HYt,t.type!==lZt)throw Error(this.constructor.directiveName+"() can only be used in child bindings")}render(t){if(t===HYt||null==t)return this.ft=void 0,this.et=t;if(t===WYt)return t;if("string"!=typeof t)throw Error(this.constructor.directiveName+"() called with a non-string value");if(t===this.et)return this.ft;this.et=t;const e=[t];return e.raw=e,this.ft={Sb:this.constructor.resultType,strings:e,values:[]}}}vZt.directiveName="unsafeHTML",vZt.resultType=1;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class xZt extends vZt{}xZt.directiveName="unsafeSVG",xZt.resultType=2;const wZt=cZt(xZt);const SZt=cZt(class extends yZt{constructor(t){super(t),this.Db=null,this.ja=null,this.Eb=!1,this.Eb=t.type===aZt}render(t){this.Db!==t&&(this.Db=t,this.disconnected(),this.isConnected&&this.Fb());const e=this.Db();return this.Eb?bZt(e):e}reconnected(){this.Fb()}disconnected(){this.Eb||this.setValue(null),this.ja?.(),this.ja=null}Fb(){this.Db&&(this.ja=kHt(this.Gb.bind(this)))}Gb(){this.setValue(this.Db?.())}});function kZt(t){return SZt(wHt(t))}class CZt extends HTMLElement{constructor(){super(...arguments),this.rootPart=null}connectedCallback(){this.rootPart=oZt(this.render(),this,{renderBefore:this.firstChild}),this.rootPart.setConnected(!0)}disconnectedCallback(){this.rootPart?.setConnected(!1),this.rootPart=null}}class TZt{constructor(t,e){this.elements=new Set,this.Jb=GHt(this.Hb.bind(this)),this.Ib=t,this.sa=e}connect(){this.Hb();const t=new MutationObserver(this.Jb);t.observe(this.Ib,{childList:!0}),RWt((()=>t.disconnect())),RWt(this.disconnect.bind(this))}disconnect(){this.elements.clear()}assign(t,e){t instanceof Node?(e.textContent="",e.append(t)):oZt(t,e),e.style.display||(e.style.display="contents");const n=e.firstElementChild;if(!n)return;const i=e.getAttribute("data-class");i&&n.classList.add(...i.split(" "))}Hb(){for(const t of this.Ib.querySelectorAll("slot"))t.hasAttribute("name")&&this.elements.add(t);this.sa(this.elements)}}let _Zt=0,EZt="data-slot-id";class MZt{constructor(t){this.Jb=GHt(this.Hb.bind(this)),this.Ib=t,this.slots=new TZt(t,this.Hb.bind(this))}connect(){this.slots.connect(),this.Hb();const t=new MutationObserver(this.Jb);t.observe(this.Ib,{childList:!0}),RWt((()=>t.disconnect()))}Hb(){for(const t of this.Ib.children){if(1!==t.nodeType)continue;const e=t.getAttribute("slot");if(!e)continue;t.style.display="none";let n=t.getAttribute(EZt);n||t.setAttribute(EZt,n=++_Zt+"");for(const i of this.slots.elements){if(i.getAttribute("name")!==e||i.getAttribute(EZt)===n)continue;const r=document.importNode(t,!0);e.includes("-icon")&&r.classList.add("vds-icon"),r.style.display="",r.removeAttribute("slot"),this.slots.assign(r,i),i.setAttribute(EZt,n)}}}}function $Zt({label:t,icon:e}){return VYt`
    <media-menu-button class="vds-menu-button">
      <slot name="menu-arrow-left-icon" data-class="vds-menu-button-close-icon"></slot>
      <slot name="${e}-icon" data-class="vds-menu-button-icon"></slot>
      <span class="vds-menu-button-label">${SZt(t)}</span>
      <span class="vds-menu-button-hint" data-part="hint"></span>
      <slot name="menu-arrow-right-icon" data-class="vds-menu-button-open-icon"></slot>
    </media-menu-button>
  `}function IZt(t,e){return kZt((()=>yYt(t,e)))}function AZt({tooltip:t}){const{translations:e}=vYt(),{paused:n}=mqt().$state,i=kZt((()=>yYt(e,n()?"Play":"Pause")));return VYt`
    <media-tooltip class="vds-play-tooltip vds-tooltip">
      <media-tooltip-trigger>
        <media-play-button class="vds-play-button vds-button" aria-label=${i}>
          <slot name="play-icon" data-class="vds-play-icon"></slot>
          <slot name="pause-icon" data-class="vds-pause-icon"></slot>
          <slot name="replay-icon" data-class="vds-replay-icon"></slot>
        </media-play-button>
      </media-tooltip-trigger>
      <media-tooltip-content class="vds-tooltip-content" placement=${t}>
        <span class="vds-play-tooltip-text">${IZt(e,"Play")}</span>
        <span class="vds-pause-tooltip-text">${IZt(e,"Pause")}</span>
      </media-tooltip-content>
    </media-tooltip>
  `}function NZt({tooltip:t}){const{translations:e}=vYt(),{muted:n}=mqt().$state,i=kZt((()=>yYt(e,(n(),"Unmute"))));return VYt`
    <media-tooltip class="vds-mute-tooltip vds-tooltip">
      <media-tooltip-trigger>
        <media-mute-button class="vds-mute-button vds-button" aria-label=${i}>
          <slot name="mute-icon" data-class="vds-mute-icon"></slot>
          <slot name="volume-low-icon" data-class="vds-volume-low-icon"></slot>
          <slot name="volume-high-icon" data-class="vds-volume-high-icon"></slot>
        </media-mute-button>
      </media-tooltip-trigger>
      <media-tooltip-content class="vds-tooltip-content" placement=${t}>
        <span class="vds-mute-tooltip-text">${IZt(e,"Unmute")}</span>
        <span class="vds-unmute-tooltip-text">${IZt(e,"Mute")}</span>
      </media-tooltip-content>
    </media-tooltip>
  `}function RZt({tooltip:t}){const{translations:e}=vYt(),{textTrack:n}=mqt().$state,i=kZt((()=>yYt(e,n()?"Closed-Captions Off":"Closed-Captions On")));return VYt`
    <media-tooltip class="vds-caption-tooltip vds-tooltip">
      <media-tooltip-trigger>
        <media-caption-button class="vds-caption-button vds-button" aria-label=${i}>
          <slot name="cc-on-icon" data-class="vds-cc-on-icon"></slot>
          <slot name="cc-off-icon" data-class="vds-cc-off-icon"></slot>
        </media-caption-button>
      </media-tooltip-trigger>
      <media-tooltip-content class="vds-tooltip-content" placement=${t}>
        <span class="vds-cc-on-tooltip-text">${IZt(e,"Closed-Captions Off")}</span>
        <span class="vds-cc-off-tooltip-text">${IZt(e,"Closed-Captions On")}</span>
      </media-tooltip-content>
    </media-tooltip>
  `}function PZt({tooltip:t}){const{translations:e}=vYt(),{fullscreen:n}=mqt().$state,i=kZt((()=>yYt(e,n()?"Exit Fullscreen":"Enter Fullscreen")));return VYt`
    <media-tooltip class="vds-fullscreen-tooltip vds-tooltip">
      <media-tooltip-trigger>
        <media-fullscreen-button class="vds-fullscreen-button vds-button" aria-label=${i}>
          <slot name="fs-enter-icon" data-class="vds-fs-enter-icon"></slot>
          <slot name="fs-exit-icon" data-class="vds-fs-exit-icon"></slot>
        </media-fullscreen-button>
      </media-tooltip-trigger>
      <media-tooltip-content class="vds-tooltip-content" placement=${t}>
        <span class="vds-fs-enter-tooltip-text">${IZt(e,"Enter Fullscreen")}</span>
        <span class="vds-fs-exit-tooltip-text">${IZt(e,"Exit Fullscreen")}</span>
      </media-tooltip-content>
    </media-tooltip>
  `}function OZt({seconds:t,tooltip:e}){const{translations:n}=vYt(),i=t>=0?"Seek Forward":"Seek Backward",r=IZt(n,i);return VYt`
    <media-tooltip class="vds-seek-tooltip vds-tooltip">
      <media-tooltip-trigger>
        <media-seek-button
          class="vds-seek-button vds-button"
          seconds=${t}
          aria-label=${r}
        >
          ${t>=0?VYt`<slot name="seek-forward-icon"></slot>`:VYt`<slot name="seek-backward-icon"></slot>`}
        </media-seek-button>
      </media-tooltip-trigger>
      <media-tooltip-content class="vds-tooltip-content" placement=${e}>
        ${IZt(n,i)}
      </media-tooltip-content>
    </media-tooltip>
  `}function LZt(){const{translations:t}=vYt(),e=IZt(t,"Volume");return VYt`
    <media-volume-slider class="vds-volume-slider vds-slider" aria-label=${e}>
      <div class="vds-slider-track"></div>
      <div class="vds-slider-track-fill vds-slider-track"></div>
      <media-slider-preview class="vds-slider-preview" no-clamp>
        <media-slider-value class="vds-slider-value"></media-slider-value>
      </media-slider-preview>
      <div class="vds-slider-thumb"></div>
    </media-volume-slider>
  `}function DZt(){const{width:t}=mqt().$state,{thumbnails:e,translations:n}=vYt(),i=IZt(n,"Seek");return VYt`
    <media-time-slider class="vds-time-slider vds-slider" aria-label=${i}>
      <media-slider-chapters class="vds-slider-chapters" ?disabled=${SZt((()=>t()<768))}>
        <template>
          <div class="vds-slider-chapter">
            <div class="vds-slider-track"></div>
            <div class="vds-slider-track-fill vds-slider-track"></div>
            <div class="vds-slider-progress vds-slider-track"></div>
          </div>
        </template>
      </media-slider-chapters>
      <div class="vds-slider-thumb"></div>
      <media-slider-preview class="vds-slider-preview">
        <media-slider-thumbnail
          class="vds-slider-thumbnail vds-thumbnail"
          src=${SZt(e)}
        ></media-slider-thumbnail>
        <div class="vds-slider-chapter-title" data-part="chapter-title"></div>
        <media-slider-value class="vds-slider-value"></media-slider-value>
      </media-slider-preview>
    </media-time-slider>
  `}function FZt(){const{translations:t}=vYt(),{live:e}=mqt().$state,n=IZt(t,"Skip To Live"),i=IZt(t,"LIVE");return e()?VYt`
    <media-live-button class="vds-live-button" aria-label=${n}>
      <span class="vds-live-button-text">${i}</span>
    </media-live-button
  `:null}function zZt(){const{live:t}=mqt().$state;return t()?FZt():VYt`
    <div class="vds-time-group">
      <media-time class="vds-time" type="current"></media-time>
      <div class="vds-time-divider">/</div>
      <media-time class="vds-time" type="duration"></media-time>
    </div>
  `}function BZt(t,e){return VYt`
    <media-menu-portal .container=${t} disabled="fullscreen">
      ${e}
    </media-menu-portal>
  `}function UZt({placement:t,tooltip:e,portal:n}){const{viewType:i}=mqt().$state,{translations:r,smQueryList:s,thumbnails:o,menuContainer:a,noModal:l,menuGroup:c}=vYt(),u=wHt((()=>l()?VHt(t):s.matches?null:VHt(t))),h=wHt((()=>s.matches||"bottom"!==c()||"video"!==i()?0:26)),d=VYt`
    <media-menu-items
      class="vds-chapters-menu-items vds-menu-items"
      placement=${SZt(u)}
      offset=${SZt(h)}
    >
      <media-chapters-radio-group
        class="vds-chapters-radio-group vds-radio-group"
        thumbnails=${SZt(o)}
      >
        <template>
          <media-radio class="vds-chapter-radio vds-radio">
            <media-thumbnail class="vds-thumbnail"></media-thumbnail>
            <div class="vds-chapter-radio-content">
              <span class="vds-chapter-radio-label" data-part="label"></span>
              <span class="vds-chapter-radio-start-time" data-part="start-time"></span>
              <span class="vds-chapter-radio-duration" data-part="duration"></span>
            </div>
          </media-radio>
        </template>
      </media-chapters-radio-group>
    </media-menu-items>
  `;return VYt`
    <!-- Chapters Menu -->
    <media-menu class="vds-chapters-menu vds-menu">
      <media-tooltip class="vds-tooltip">
        <media-tooltip-trigger>
          <media-menu-button
            class="vds-menu-button vds-button"
            aria-label=${IZt(r,"Chapters")}
          >
            <slot name="menu-chapters-icon"></slot>
          </media-menu-button>
        </media-tooltip-trigger>
        <media-tooltip-content
          class="vds-tooltip-content"
          placement=${sHt(e)?SZt(e):e}
        >
          ${IZt(r,"Chapters")}
        </media-tooltip-content>
      </media-tooltip>
      ${n?BZt(a,d):d}
    </media-menu>
  `}function VZt({placement:t,portal:e,tooltip:n}){const{viewType:i}=mqt().$state,{translations:r,smQueryList:s,menuContainer:o,noModal:a,menuGroup:l}=vYt(),c=wHt((()=>a()?VHt(t):s.matches?null:VHt(t))),u=wHt((()=>s.matches||"bottom"!==l()||"video"!==i()?0:26)),h=VYt`
    <media-menu-items
      class="vds-settings-menu-items vds-menu-items"
      placement=${SZt(c)}
      offset=${SZt(u)}
    >
      ${function(){const{translations:t}=vYt();return VYt`
    <!-- Audio Menu -->
    <media-menu class="vds-audio-menu vds-menu">
      ${$Zt({label:()=>yYt(t,"Audio"),icon:"menu-audio"})}
      <media-menu-items class="vds-menu-items">
        <media-audio-radio-group
          class="vds-audio-radio-group vds-radio-group"
          empty-label=${IZt(t,"Default")}
        >
          <template>
            <media-radio class="vds-audio-radio vds-radio">
              <div class="vds-radio-check"></div>
              <span class="vds-radio-label" data-part="label"></span>
            </media-radio>
          </template>
        </media-audio-radio-group>
      </media-menu-items>
    </media-menu>
  `}()}${function(){const{translations:t}=vYt();return VYt`
    <!-- Speed Menu -->
    <media-menu class="vds-speed-menu vds-menu">
      ${$Zt({label:()=>yYt(t,"Speed"),icon:"menu-speed"})}
      <media-menu-items class="vds-menu-items">
        <media-speed-radio-group
          class="vds-speed-radio-group vds-radio-group"
          normal-label=${IZt(t,"Normal")}
        >
          <template>
            <media-radio class="vds-speed-radio vds-radio">
              <div class="vds-radio-check"></div>
              <span class="vds-radio-label" data-part="label"></span>
            </media-radio>
          </template>
        </media-speed-radio-group>
      </media-menu-items>
    </media-menu>
  `}()}${function(){const{translations:t}=vYt();return VYt`
    <!-- Quality Menu -->
    <media-menu class="vds-quality-menu vds-menu">
      ${$Zt({label:()=>yYt(t,"Quality"),icon:"menu-quality"})}
      <media-menu-items class="vds-menu-items">
        <media-quality-radio-group
          class="vds-quality-radio-group vds-radio-group"
          auto-label=${IZt(t,"Auto")}
        >
          <template>
            <media-radio class="vds-quality-radio vds-radio">
              <div class="vds-radio-check"></div>
              <span class="vds-radio-label" data-part="label"></span>
              <span class="vds-radio-hint" data-part="bitrate"></span>
            </media-radio>
          </template>
        </media-quality-radio-group>
      </media-menu-items>
    </media-menu>
  `}()}${function(){const{translations:t}=vYt();return VYt`
    <!-- Captions Menu -->
    <media-menu class="vds-captions-menu vds-menu">
      ${$Zt({label:()=>yYt(t,"Captions"),icon:"menu-captions"})}
      <media-menu-items class="vds-menu-items">
        <media-captions-radio-group
          class="vds-captions-radio-group vds-radio-group"
          off-label=${IZt(t,"Off")}
        >
          <template>
            <media-radio class="vds-caption-radio vds-radio">
              <div class="vds-radio-check"></div>
              <span class="vds-radio-label" data-part="label"></span>
            </media-radio>
          </template>
        </media-captions-radio-group>
      </media-menu-items>
    </media-menu>
  `}()}
    </media-menu-items>
  `;return VYt`
    <media-menu class="vds-settings-menu vds-menu">
      <media-tooltip class="vds-tooltip">
        <media-tooltip-trigger>
          <media-menu-button
            class="vds-menu-button vds-button"
            aria-label=${IZt(r,"Settings")}
          >
            <slot name="menu-settings-icon" data-class="vds-rotate-icon"></slot>
          </media-menu-button>
        </media-tooltip-trigger>
        <media-tooltip-content
          class="vds-tooltip-content"
          placement=${sHt(n)?SZt(n):n}
        >
          ${IZt(r,"Settings")}
        </media-tooltip-content>
      </media-tooltip>
      ${e?BZt(o,h):h}
    </media-menu>
  `}function WZt(t){let e=document.querySelector(`body > .${t}`);return e||(e=document.createElement("div"),e.style.display="contents",e.classList.add(t),document.body.append(e)),e}function HZt({name:t,class:e,state:n,paths:i}){return VYt`<svg
    class="${"vds-icon"+(e?` ${e}`:"")}"
    viewBox="0 0 32 32"
    fill="none"
    aria-hidden="true"
    focusable="false"
    xmlns="http://www.w3.org/2000/svg"
    data-icon=${bZt(t??n)}
  >
    ${rHt(i)?wZt(i):SZt(i)}
  </svg>`}class jZt{constructor(t){this.Oj={},this.Pj=!1,this.Ib=t,this.slots=new TZt(t,this.Qj.bind(this))}connect(){this.slots.connect(),RWt(this.disconnect.bind(this))}load(){this.Kb().then((t=>{this.Oj=t,this.Pj=!0,this.Qj()}))}disconnect(){for(const{slot:t}of this.Rj())t.textContent=""}*Rj(){for(const t of Object.keys(this.Oj)){const e=`${t}-icon`;for(const n of this.slots.elements)n.name===e&&(yield{icon:this.Oj[t],slot:n})}}Qj(){if(this.Pj)for(const{icon:t,slot:e}of this.Rj())this.slots.assign(t,e)}}class GZt extends jZt{connect(){const t=this.zh();t&&(super.connect(),t.$state.canLoad()?this.load():pHt(t,"can-load",(()=>this.load()),{once:!0}))}zh(){let t=this.Ib.parentElement;for(;t&&"media-player"!==t.localName;)t=t.parentElement;return t}}class qZt extends GZt{async Kb(){const t=(await Promise.resolve().then((function(){return f3t}))).icons,e={};for(const n of Object.keys(t))e[n]=HZt({name:n,paths:t[n]});return e}}function XZt(){const{live:t,canSeek:e}=mqt().$state;return t()&&!e()?AZt({tooltip:"top start"}):null}function KZt(){const{live:t}=mqt().$state;return t()?null:VYt`
        <media-controls-group class="vds-controls-group">
          <media-time class="vds-time" type="current"></media-time>
          <div class="vds-controls-spacer"></div>
          <media-time class="vds-time" type="duration"></media-time>
        </media-controls-group>
      `}function YZt(){const{canSeek:t}=mqt().$state;return t()?VYt`
        <media-controls-group class="vds-controls-group">
          <div class="vds-controls-spacer"></div>
          ${OZt({seconds:-10,tooltip:"top"})}
          ${AZt({tooltip:"top"})}
          ${OZt({tooltip:"top",seconds:10})}
          <div class="vds-controls-spacer"></div>
        </media-controls-group>
      `:null}function ZZt(){const t="top end";return VYt`
    ${UZt({tooltip:"top",placement:t,portal:!0})}
    ${VZt({tooltip:"top end",placement:t,portal:!0})}
  `}class JZt extends(qjt(CZt,mYt)){static{this.tagName="media-audio-layout"}onSetup(){this.forwardKeepAlive=!1,this.g=mqt(),this.classList.add("vds-audio-layout"),this.menuContainer=WZt("vds-audio-layout"),kHt((()=>{this.menuContainer&&bHt(this.menuContainer,"data-size",this.isSmallLayout&&"sm")})),RWt((()=>this.menuContainer?.remove()))}onConnect(){kHt((()=>{this.$props.customIcons()?new MZt(this).connect():new qZt(this).connect()}))}s(){const{streamType:t}=this.g.$state;return this.isMatch&&"unknown"!==t()?this.isSmallLayout?VYt`
    <media-captions class="vds-captions"></media-captions>
    <media-controls class="vds-controls">
      <media-controls-group class="vds-controls-group">
        ${kZt(XZt)}
        ${NZt({tooltip:"top start"})}${kZt(FZt)}
        <media-chapter-title class="vds-chapter-title"></media-chapter-title>
        ${RZt({tooltip:"top"})}${ZZt()}
      </media-controls-group>

      <media-controls-group class="vds-controls-group">${DZt()}</media-controls-group>

      ${kZt(KZt)}${kZt(YZt)}
    </media-controls>
  `:VYt`
    <media-captions class="vds-captions"></media-captions>

    <media-controls class="vds-controls">
      <media-controls-group class="vds-controls-group">${DZt()}</media-controls-group>

      <media-controls-group class="vds-controls-group">
        ${OZt({seconds:-10,tooltip:"top start"})}
        ${AZt({tooltip:"top"})}${OZt({tooltip:"top",seconds:10})}
        ${kZt(zZt)}
        <media-chapter-title class="vds-chapter-title"></media-chapter-title>
        ${NZt({tooltip:"top"})}
        ${LZt()}${RZt({tooltip:"top"})} ${ZZt()}
      </media-controls-group>
    </media-controls>
  `:null}render(){return VYt`${kZt(this.s.bind(this))}`}}function QZt(){return VYt`
    ${sJt()}${iJt()}
    <media-captions class="vds-captions"></media-captions>

    <div class="vds-scrim"></div>

    <media-controls class="vds-controls">
      ${kZt(eJt)}

      <div class="vds-controls-spacer"></div>

      <media-controls-group class="vds-controls-group">${DZt()}</media-controls-group>

      <media-controls-group class="vds-controls-group">
        ${AZt({tooltip:"top start"})}
        ${NZt({tooltip:"top"})}${LZt()}
        ${kZt(zZt)}
        <media-chapter-title class="vds-chapter-title"></media-chapter-title>
        ${RZt({tooltip:"top"})}${kZt(tJt)}
        ${function(){const{translations:t}=vYt(),{pictureInPicture:e}=mqt().$state,n=kZt((()=>yYt(t,e()?"Exit PiP":"Enter PiP")));return VYt`
    <media-tooltip class="vds-pip-tooltip vds-tooltip">
      <media-tooltip-trigger>
        <media-pip-button class="vds-pip-button vds-button" aria-label=${n}>
          <slot name="pip-enter-icon" data-class="vds-pip-enter-icon"></slot>
          <slot name="pip-exit-icon" data-class="vds-pip-exit-icon"></slot>
        </media-pip-button>
      </media-tooltip-trigger>
      <media-tooltip-content class="vds-tooltip-content">
        <span class="vds-pip-enter-tooltip-text">${IZt(t,"Enter PiP")}</span>
        <span class="vds-pip-exit-tooltip-text">${IZt(t,"Exit PiP")}</span>
      </media-tooltip-content>
    </media-tooltip>
  `}()} ${PZt({tooltip:"top end"})}
      </media-controls-group>
    </media-controls>
  `}function tJt(){const{menuGroup:t}=vYt();return"bottom"===t()?rJt():null}function eJt(){const{menuGroup:t}=vYt(),e="top"===t()?VYt`
            <div class="vds-controls-spacer"></div>
            ${rJt()}
          `:null;return VYt`
    <media-controls-group class="vds-controls-group">${e}</media-controls-group>
  `}function nJt(){const{duration:t}=mqt().$state;return 0===t()?null:VYt`
    <div class="vds-start-duration">
      <media-time class="vds-time" type="duration"></media-time>
    </div>
  `}function iJt(){return VYt`
    <div class="vds-buffering-indicator">
      <svg class="vds-buffering-icon" fill="none" viewBox="0 0 120 120" aria-hidden="true">
        <circle class="vds-buffering-track" cx="60" cy="60" r="54" stroke="currentColor"></circle>
        <circle
          class="vds-buffering-track-fill"
          cx="60"
          cy="60"
          r="54"
          stroke="currentColor"
          pathLength="100"
        ></circle>
      </svg>
    </div>
  `}function rJt(){const{menuGroup:t,smQueryList:e}=vYt(),n=()=>"top"===t()||e.matches?"bottom":"top",i=wHt((()=>`${n()} ${"top"===t()?"end":"center"}`)),r=wHt((()=>`${n()} end`));return VYt`
    ${UZt({tooltip:i,placement:r,portal:!0})}
    ${VZt({tooltip:i,placement:r,portal:!0})}
  `}function sJt(){return VYt`
    <div class="vds-gestures">
      <media-gesture class="vds-gesture" event="pointerup" action="toggle:paused"></media-gesture>
      <media-gesture class="vds-gesture" event="pointerup" action="toggle:controls"></media-gesture>
      <media-gesture
        class="vds-gesture"
        event="dblpointerup"
        action="toggle:fullscreen"
      ></media-gesture>
      <media-gesture class="vds-gesture" event="dblpointerup" action="seek:-10"></media-gesture>
      <media-gesture class="vds-gesture" event="dblpointerup" action="seek:10"></media-gesture>
    </div>
  `}class oJt extends(qjt(CZt,gYt)){static{this.tagName="media-video-layout"}onSetup(){this.forwardKeepAlive=!1,this.g=mqt(),this.classList.add("vds-video-layout"),this.menuContainer=WZt("vds-video-layout"),kHt((()=>{this.menuContainer&&bHt(this.menuContainer,"data-size",this.isSmallLayout&&"sm")})),RWt((()=>this.menuContainer?.remove()))}onConnect(){kHt((()=>{this.$props.customIcons()?new MZt(this).connect():new qZt(this).connect()}))}s(){const{streamType:t}=this.g.$state;return this.isMatch?"unknown"===t()?iJt():this.isSmallLayout?VYt`
    ${sJt()}${iJt()}
    <media-captions class="vds-captions"></media-captions>

    <div class="vds-scrim"></div>

    <media-controls class="vds-controls">
      <media-controls-group class="vds-controls-group">
        <div class="vds-controls-spacer"></div>
        ${RZt({tooltip:"bottom"})}
        ${rJt()}${NZt({tooltip:"bottom end"})}
      </media-controls-group>

      <div class="vds-controls-group">${AZt({tooltip:"top"})}</div>

      <media-controls-group class="vds-controls-group">
        ${kZt(zZt)}
        <media-chapter-title class="vds-chapter-title"></media-chapter-title>
        <div class="vds-controls-spacer"></div>
        ${PZt({tooltip:"top end"})}
      </media-controls-group>

      <media-controls-group class="vds-controls-group">${DZt()}</media-controls-group>
    </media-controls>

    ${kZt(nJt)}
  `:QZt():null}render(){return VYt`${kZt(this.s.bind(this))}`}}Zjt(JZt),Zjt(oJt);class aJt extends OHt{onAttach(t){vHt(t,"pointer-events","auto")}}class lJt extends OHt{constructor(){super(),new rXt}onConnect(t){RWt(gGt((()=>{if(!this.connectScope)return;this.me();const t=_Ht(CXt);RWt((()=>{const e=this.le();e&&t.fe(e)}))})))}me(){const t=this.le(),e=_Ht(CXt);t&&e.ee(t)}le(){return"button"===this.el.firstElementChild?.getAttribute("role")?this.el.firstElementChild:this.el}}class cJt extends EKt{}class uJt extends(qjt(HTMLElement,lYt)){static{this.tagName="media-captions"}}class hJt extends(qjt(HTMLElement,oYt)){static{this.tagName="media-gesture"}}class dJt extends(qjt(HTMLElement,cYt)){constructor(){super(...arguments),this.n=document.createElement("img")}static{this.tagName="media-poster"}onSetup(){this.g=mqt(),this.$state.img.set(this.n)}onConnect(){const{src:t,alt:e}=this.$state,{crossorigin:n}=this.g.$state;this.n.parentNode!==this&&this.prepend(this.n),kHt((()=>{bHt(this.n,"src",t()),bHt(this.n,"alt",e()),bHt(this.n,"crossorigin",n())}))}}const pJt=bGt('<img loading="eager" decoding="async" aria-hidden="true">');class fJt extends(qjt(HTMLElement,JXt)){constructor(){super(...arguments),this.n=this.o()}static{this.tagName="media-thumbnail"}onSetup(){this.g=mqt(),this.$state.img.set(this.n)}onConnect(){const{src:t}=this.$state,{crossorigin:e}=this.g.$props;this.n.parentNode!==this&&this.prepend(this.n),kHt((()=>{bHt(this.n,"src",t()),bHt(this.n,"crossorigin",e())}))}o(){return vGt(pJt)}}class mJt extends(qjt(HTMLElement,uYt)){static{this.tagName="media-time"}onConnect(){kHt((()=>{this.textContent=this.$state.timeText()}))}}class gJt extends(qjt(HTMLElement,SXt)){static{this.tagName="media-controls"}}class yJt extends(qjt(HTMLElement,aJt)){static{this.tagName="media-controls-group"}}class bJt extends OHt{}class vJt extends(qjt(HTMLElement,bJt)){constructor(){super(...arguments),this.p=xHt(""),this.q=wHt((()=>{const{title:t,started:e}=this.g.$state;return e()&&this.p()||t()}))}static{this.tagName="media-chapter-title"}onSetup(){this.g=mqt()}onConnect(){iGt(this.g.textTracks,"chapters",(t=>{if(!t)return void this.p.set("");const e=()=>{const e=t?.activeCues[0];this.p.set(e?.text||"")};e(),pHt(t,"cue-change",e)})),kHt((()=>{this.textContent=this.q()}))}}class xJt extends OHt{static{this.props={when:""}}}class wJt extends(qjt(HTMLElement,xJt)){static{this.tagName="media-layout"}onSetup(){this.query=Aqt.create(this.$props.when)}onConnect(){kHt(this.r.bind(this))}r(){const t=this.firstElementChild,e="template"===t?.localName,n=t instanceof HTMLElement;if(this.query.matches)e?this.append(t.cloneNode(!0)):n&&(t.style.display="");else if(e)for(const t of this.children)"template"!==t.localName&&t.remove();else n&&(t.style.display="none")}}class SJt extends(qjt(HTMLElement,NXt)){static{this.tagName="media-play-button"}}class kJt extends(qjt(HTMLElement,LXt)){static{this.tagName="media-mute-button"}}class CJt extends(qjt(HTMLElement,PXt)){static{this.tagName="media-caption-button"}}class TJt extends(qjt(HTMLElement,OXt)){static{this.tagName="media-fullscreen-button"}}class _Jt extends(qjt(HTMLElement,DXt)){static{this.tagName="media-pip-button"}}class EJt extends(qjt(HTMLElement,FXt)){static{this.tagName="media-seek-button"}}class MJt extends(qjt(HTMLElement,AXt)){static{this.tagName="media-toggle-button"}}class $Jt extends(qjt(HTMLElement,zXt)){static{this.tagName="media-live-button"}}class IJt extends(qjt(HTMLElement,_Xt)){static{this.tagName="media-tooltip"}}class AJt extends(qjt(HTMLElement,lJt)){static{this.tagName="media-tooltip-trigger"}onConnect(){this.style.display="contents"}}class NJt extends(qjt(HTMLElement,EXt)){static{this.tagName="media-tooltip-content"}}function RJt(t,e){gGt((()=>{if(!t.connectScope)return;const n=t.querySelector("template");n&&kHt((()=>{const i=t.getOptions();yGt(n,i.length,((t,n)=>{const{label:r,value:s}=i[n],o=t.querySelector('[data-part="label"]');t.setAttribute("value",s),o&&(rHt(r)?o.textContent=r:kHt((()=>{o.textContent=r()}))),e?.(t,i[n],n)}))}))}))}class PJt extends(qjt(HTMLElement,qKt)){static{this.tagName="media-audio-radio-group"}onConnect(){RJt(this)}}class OJt extends(qjt(HTMLElement,ZKt)){static{this.tagName="media-captions-radio-group"}onConnect(){RJt(this)}}class LJt extends(qjt(HTMLElement,CKt)){static{this.tagName="media-menu"}}class DJt extends(qjt(HTMLElement,EKt)){static{this.tagName="media-menu-button"}}class FJt extends(qjt(HTMLElement,MKt)){static{this.tagName="media-menu-portal"}static{this.attrs={disabled:{converter:t=>rHt(t)?t:null!==t}}}}class zJt extends(qjt(HTMLElement,cJt)){static{this.tagName="media-menu-item"}}class BJt extends(qjt(HTMLElement,IKt)){static{this.tagName="media-menu-items"}}class UJt extends(qjt(HTMLElement,WKt)){static{this.tagName="media-chapters-radio-group"}onConnect(){RJt(this,((t,e)=>{const{cue:n,startTime:i,duration:r}=e,s=t.querySelector(".vds-thumbnail,media-thumbnail"),o=t.querySelector('[data-part="start-time"]'),a=t.querySelector('[data-part="duration"]');o&&(o.textContent=i),a&&(a.textContent=r),s&&(s.setAttribute("time",n.startTime+""),kHt((()=>{const{thumbnails:t}=this.$props;s.setAttribute("src",t())})))}))}}class VJt extends(qjt(HTMLElement,eYt)){static{this.tagName="media-speed-radio-group"}onConnect(){RJt(this)}}class WJt extends(qjt(HTMLElement,sYt)){static{this.tagName="media-quality-radio-group"}onConnect(){RJt(this,((t,e)=>{const n=e.bitrate,i=t.querySelector('[data-part="bitrate"]');n&&i&&kHt((()=>{i.textContent=n()||""}))}))}}class HJt extends(qjt(HTMLElement,zKt)){static{this.tagName="media-radio"}}class jJt extends(qjt(HTMLElement,LKt)){static{this.tagName="media-radio-group"}}class GJt extends(qjt(HTMLElement,qXt)){static{this.tagName="media-slider"}}class qJt extends fJt{static{this.tagName="media-slider-thumbnail"}onSetup(){super.onSetup(),this.t=zHt(qXt.state)}onConnect(){super.onConnect(),kHt(this.u.bind(this))}u(){const{duration:t}=this.g.$state;this.time=this.t.pointerRate()*t()}}class XJt extends(qjt(HTMLElement,lKt)){static{this.tagName="media-slider-value"}static{this.attrs={padMinutes:{converter:Fjt}}}onConnect(){kHt((()=>{this.textContent=this.getValueText()}))}}const KJt=bGt('<video muted playsinline preload="none" style="max-width: unset;"></video>');class YJt extends(qjt(HTMLElement,eKt)){constructor(){super(...arguments),this.v=this.m()}static{this.tagName="media-slider-video"}onSetup(){this.g=mqt(),this.$state.video.set(this.v)}onConnect(){const{crossorigin:t,canLoad:e}=this.g.$state,{src:n}=this.$state;this.v.parentNode!==this&&this.prepend(this.v),kHt((()=>{bHt(this.v,"src",n()),bHt(this.v,"crossorigin",t()),bHt(this.v,"preload",e()?"auto":"none")}))}m(){return vGt(KJt)}}class ZJt extends(qjt(HTMLElement,hKt)){static{this.tagName="media-time-slider"}}class JJt extends(qjt(HTMLElement,cKt)){static{this.tagName="media-slider-preview"}}class QJt extends(qjt(HTMLElement,uKt)){static{this.tagName="media-volume-slider"}}class tQt extends(qjt(HTMLElement,mKt)){constructor(){super(...arguments),this.w=null}static{this.tagName="media-slider-chapters"}onConnect(){gGt((()=>{if(!this.connectScope)return;const t=this.querySelector("template");t&&(this.w=t,kHt(this.x.bind(this)))}))}x(){if(!this.w)return;const t=yGt(this.w,this.cues.length||1);this.setRefs(t)}}function eQt(t){let e,n,i,r,s,o,a,l,c,u;return{c(){e=MB("media-player"),n=MB("media-provider"),r=AB(),s=MB("media-audio-layout"),o=AB(),a=MB("media-video-layout"),LB(n,"style",i=t[7]?"transform: scaleX(-1)":""),LB(e,"class","player svelte-uyp4ar"),LB(e,"title",t[0]),oB(e.src,l=t[5]||"")||LB(e,"src",l),LB(e,"crossorigin",""),LB(e,"paused",t[6])},m(i,l){TB(i,e,l),SB(e,n),SB(e,r),SB(e,s),SB(e,o),SB(e,a),t[10](e),c||(u=[RB(e,"provider-change",t[8]),RB(e,"can-play",iQt)],c=!0)},p(t,r){128&r&&i!==(i=t[7]?"transform: scaleX(-1)":"")&&LB(n,"style",i),1&r&&LB(e,"title",t[0]),32&r&&!oB(e.src,l=t[5]||"")&&LB(e,"src",l),64&r&&LB(e,"paused",t[6])},d(n){n&&_B(e),t[10](null),c=!1,nB(u)}}}function nQt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[eQt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),4337&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function iQt(t){}function rQt(t,e,n){let i,r,s,o=Jz,a=()=>(o(),o=aB(p,(t=>n(5,i=t))),p),l=Jz,c=()=>(l(),l=aB(f,(t=>n(6,r=t))),f),u=Jz,h=()=>(u(),u=aB(y,(t=>n(7,s=t))),y);t.$$.on_destroy.push((()=>o())),t.$$.on_destroy.push((()=>l())),t.$$.on_destroy.push((()=>u()));let{title:d}=e,{src:p}=e;a();let{paused:f}=e;c();let m,{progress:g}=e,{mirror:y}=e;h();let b=!0;return tU((()=>(g.subscribe((t=>{b&&m&&n(4,m.currentTime=t,m)})),m.subscribe((t=>{t.paused!==f.get()&&f.set(t.paused),b=!1,g.set(t.currentTime),b=!0}))))),t.$$set=t=>{"title"in t&&n(0,d=t.title),"src"in t&&a(n(1,p=t.src)),"paused"in t&&c(n(2,f=t.paused)),"progress"in t&&n(9,g=t.progress),"mirror"in t&&h(n(3,y=t.mirror))},[d,p,f,y,m,i,r,s,function(t){const e=t.detail;(function(t){return"HLS"===t?.$$PROVIDER_TYPE})(e)&&(e.config={})},g,function(t){aU[t?"unshift":"push"]((()=>{m=t,n(4,m)}))}]}Zjt(wJt),Zjt(gJt),Zjt(yJt),Zjt(dJt),Zjt(CJt),Zjt(TJt),Zjt(kJt),Zjt(_Jt),Zjt(SJt),Zjt(EJt),Zjt(MJt),Zjt(GJt),Zjt(QJt),Zjt(ZJt),Zjt(tQt),Zjt(JJt),Zjt(XJt),Zjt(qJt),Zjt(YJt),Zjt(LJt),Zjt(DJt),Zjt(FJt),Zjt(BJt),Zjt(zJt),Zjt(PJt),Zjt(OJt),Zjt(VJt),Zjt(WJt),Zjt(UJt),Zjt(jJt),Zjt(HJt),Zjt(IJt),Zjt(AJt),Zjt(NJt),Zjt(hJt),Zjt(fJt),Zjt(uJt),Zjt($Jt),Zjt(mJt),Zjt(vJt);class sQt extends UU{constructor(t){super(),BU(this,t,rQt,nQt,rB,{title:0,src:1,paused:2,progress:9,mirror:3})}}class oQt extends xK{constructor(t=""){super(),this.title="Video Player",this.$paused=new eK(!0,!0),this.$progress=new eK(0,!0),this.$mirror=new eK(!1,!0),this.$src=new eK(t,!0)}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new sQt({target:e,props:{title:this.title,src:this.$src,paused:this.$paused,progress:this.$progress,mirror:this.$mirror}}))}}function aQt(...t){return new oQt(...t)}function lQt(t){let e,n;return e=new LV({}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function cQt(t){let e,n,i;return n=new HU({props:{round:!0,$$slots:{default:[uQt]},$$scope:{ctx:t}}}),n.$on("click",t[15]),{c(){e=MB("div"),DU(n.$$.fragment),OB(e,"class","absolute bottom-2 right-2 text-right")},m(t,r){TB(t,e,r),FU(n,e,null),i=!0},p(t,e){const i={};262144&e&&(i.$$scope={dirty:e,ctx:t}),n.$set(i)},i(t){i||(EU(n.$$.fragment,t),i=!0)},o(t){MU(n.$$.fragment,t),i=!1},d(t){t&&_B(e),zU(n)}}}function uQt(t){let e,n;return{c(){e=$B("svg"),n=$B("path"),OB(n,"stroke-linecap","round"),OB(n,"stroke-linejoin","round"),OB(n,"d","M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99"),OB(e,"xmlns","http://www.w3.org/2000/svg"),OB(e,"fill","none"),OB(e,"viewBox","0 0 24 24"),OB(e,"stroke-width","1.5"),OB(e,"stroke","currentColor"),OB(e,"class","w-6 h-6")},m(t,i){TB(t,e,i),SB(e,n)},p:Jz,d(t){t&&_B(e)}}}function hQt(t){let e,n,i,r,s,o,a,l,c,u,h,d;function p(e){t[13](e)}let f={text:"activate video"};void 0!==t[9]&&(f.checked=t[9]),r=new zV({props:f}),aU.push((()=>LU(r,"checked",p)));let m=t[9]&&!t[10]&&lQt(),g=t[8]>1&&cQt(t);return{c(){e=MB("div"),n=MB("div"),i=MB("div"),DU(r.$$.fragment),o=AB(),a=MB("div"),m&&m.c(),l=AB(),c=MB("video"),u=AB(),g&&g.c(),OB(c,"id","webcam-video"),OB(c,"class","max-w-none svelte-xql639"),zB(c,"width",t[1]>t[2]?`${t[7]}px`:"auto"),zB(c,"height",t[1]>t[2]?"auto":t[7]*t[2]/t[1]+"px"),c.autoplay=!0,c.muted=!0,c.playsInline=!0,WB(c,"mirror","user"===t[11]),OB(a,"class","webcam-container svelte-xql639"),zB(a,"flex-direction",t[1]>t[2]?"column":"row"),zB(a,"height",t[7]*t[2]/t[1]+"px"),fU((()=>t[16].call(a))),OB(e,"class","webcam svelte-xql639")},m(s,p){TB(s,e,p),SB(e,n),SB(n,i),FU(r,i,null),SB(e,o),SB(e,a),m&&m.m(a,null),SB(a,l),SB(a,c),t[14](c),SB(a,u),g&&g.m(a,null),h=function(t,e){"static"===getComputedStyle(t).position&&(t.style.position="relative");const n=MB("iframe");n.setAttribute("style","display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;"),n.setAttribute("aria-hidden","true"),n.tabIndex=-1;const i=VB();let r;return i?(n.src="data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>",r=RB(window,"message",(t=>{t.source===n.contentWindow&&e()}))):(n.src="about:blank",n.onload=()=>{r=RB(n.contentWindow,"resize",e),e()}),SB(t,n),()=>{(i||r&&n.contentWindow)&&r(),_B(n)}}(a,t[16].bind(a)),d=!0},p(t,e){const n={};!s&&512&e&&(s=!0,n.checked=t[9],mU((()=>s=!1))),r.$set(n),t[9]&&!t[10]?m?1536&e&&EU(m,1):(m=lQt(),m.c(),EU(m,1),m.m(a,l)):m&&(TU(),MU(m,1,1,(()=>{m=null})),_U()),(!d||134&e)&&zB(c,"width",t[1]>t[2]?`${t[7]}px`:"auto"),(!d||134&e)&&zB(c,"height",t[1]>t[2]?"auto":t[7]*t[2]/t[1]+"px"),(!d||2048&e)&&WB(c,"mirror","user"===t[11]),t[8]>1?g?(g.p(t,e),256&e&&EU(g,1)):(g=cQt(t),g.c(),EU(g,1),g.m(a,null)):g&&(TU(),MU(g,1,1,(()=>{g=null})),_U()),(!d||6&e)&&zB(a,"flex-direction",t[1]>t[2]?"column":"row"),(!d||134&e)&&zB(a,"height",t[7]*t[2]/t[1]+"px")},i(t){d||(EU(r.$$.fragment,t),EU(m),EU(g),d=!0)},o(t){MU(r.$$.fragment,t),MU(m),MU(g),d=!1},d(n){n&&_B(e),zU(r),m&&m.d(),t[14](null),g&&g.d(),h()}}}function dQt(t){let e,n;return e=new DH({props:{title:t[0],$$slots:{default:[hQt]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title=t[0]),266190&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function pQt(t,e,n){let i,r,s,o=Jz,a=()=>(o(),o=aB(g,(t=>n(9,i=t))),g),l=Jz,c=()=>(l(),l=aB(x,(t=>n(10,r=t))),x),u=Jz,h=()=>(u(),u=aB(m,(t=>n(11,s=t))),m);t.$$.on_destroy.push((()=>o())),t.$$.on_destroy.push((()=>l())),t.$$.on_destroy.push((()=>u()));let{title:d}=e,{width:p}=e,{height:f}=e,{facingMode:m}=e;h();let{active:g}=e;a();let y,b,{mediaStream:v}=e,{ready:x}=e;c();let w=0,S=ZX;tU((async()=>{await pU(),await pU(),S=v.subscribe((t=>{var e;t&&n(6,y.srcObject=t,y),(null===(e=navigator.mediaDevices)||void 0===e?void 0:e.enumerateDevices)&&navigator.mediaDevices.enumerateDevices().then((t=>t.filter((t=>"videoinput"===t.kind)))).then((t=>{n(8,w=t.length)})).catch((t=>{console.error(`${t.name}: ${t.message}`)}))}))})),nU((()=>{S()}));return t.$$set=t=>{"title"in t&&n(0,d=t.title),"width"in t&&n(1,p=t.width),"height"in t&&n(2,f=t.height),"facingMode"in t&&h(n(3,m=t.facingMode)),"active"in t&&a(n(4,g=t.active)),"mediaStream"in t&&n(12,v=t.mediaStream),"ready"in t&&c(n(5,x=t.ready))},[d,p,f,m,g,x,y,b,w,i,r,s,v,function(t){i=t,g.set(i)},function(t){aU[t?"unshift":"push"]((()=>{y=t,n(6,y)}))},()=>m.set("user"===m.get()?"environment":"user"),function(){b=this.clientWidth,n(7,b)}]}class fQt extends UU{constructor(t){super(),BU(this,t,pQt,dQt,rB,{title:0,width:1,height:2,facingMode:3,active:4,mediaStream:12,ready:5})}}var mQt,gQt,yQt,bQt,vQt,xQt,wQt,SQt,kQt,CQt,TQt,_Qt;class EQt extends xK{constructor({width:t=224,height:e=224,period:n=50,facingMode:i="user",audio:r=!1}={}){super(),this.title="webcam",this.$active=new eK(!1,!0),this.$ready=new eK(!1,!0),this.$mediastream=new eK(void 0,!0),this.$images=new eK(Yj(),!0),this.$thumbnails=new eK(Yj(),!0),mQt.set(this,void 0),gQt.set(this,void 0),yQt.set(this,void 0),bQt.set(this,void 0),vQt.set(this,document.createElement("video")),xQt.set(this,60),wQt.set(this,ZX),SQt.set(this,void 0),kQt.set(this,void 0),CQt.set(this,void 0),TQt.set(this,void 0),_Qt.set(this,void 0),WX(this,mQt,t,"f"),WX(this,gQt,e,"f"),this.period=n,this.$facingMode=new eK(i,!0),WX(this,_Qt,r,"f"),this.setupCapture(),VX(this,vQt,"f").autoplay=!0,VX(this,vQt,"f").muted=!0,VX(this,vQt,"f").playsInline=!0;const s=t=>{VX(this,wQt,"f").call(this),t?(this.loadCameras(),WX(this,wQt,function(t,e){let n,i=(new Date).getTime(),r=!1;return n=window.requestAnimationFrame((function s(){r||((new Date).getTime()-i>=e&&(t(),i=(new Date).getTime()),n=window.requestAnimationFrame(s))})),function(){window.cancelAnimationFrame(n),r=!0}}(this.process,this.period),"f")):this.stopCamera()};this.$active.subscribe(s),this.$facingMode.subscribe((()=>this.$active.get()&&s(!0))),this.start()}getWidth(){return VX(this,mQt,"f")}mount(t){const e=t||document.querySelector(`#${this.id}`);e&&(this.destroy(),this.$$.app=new fQt({target:e,props:{title:this.title,width:VX(this,mQt,"f"),height:VX(this,gQt,"f"),facingMode:this.$facingMode,active:this.$active,mediaStream:this.$mediastream,ready:this.$ready}}))}stop(){if(super.stop(),VX(this,wQt,"f").call(this),this.$mediastream.get())for(const t of this.$mediastream.get().getTracks())t.stop()}setupCapture(){WX(this,SQt,document.createElement("canvas"),"f"),VX(this,SQt,"f").width=VX(this,xQt,"f"),VX(this,SQt,"f").height=VX(this,xQt,"f")*VX(this,gQt,"f")/VX(this,mQt,"f"),WX(this,kQt,VX(this,SQt,"f").getContext("2d"),"f"),WX(this,CQt,document.createElement("canvas"),"f"),VX(this,CQt,"f").width=VX(this,mQt,"f"),VX(this,CQt,"f").height=VX(this,gQt,"f"),WX(this,TQt,VX(this,CQt,"f").getContext("2d"),"f")}async loadCameras(){try{const t=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:this.$facingMode.get()}},audio:VX(this,_Qt,"f")});WX(this,yQt,t.getVideoTracks()[0].getSettings().width,"f"),WX(this,bQt,t.getVideoTracks()[0].getSettings().height,"f"),this.loadSrcStream(t)}catch(t){cK(new Error("Webcam not supported"))}}loadSrcStream(t){this.$mediastream.set(t),VX(this,vQt,"f").srcObject=t,VX(this,vQt,"f").play(),VX(this,vQt,"f").onloadedmetadata=()=>{WX(this,yQt,VX(this,vQt,"f").videoWidth,"f"),WX(this,bQt,VX(this,vQt,"f").videoHeight,"f"),this.$ready.set(!0)}}stopCamera(){if(this.$mediastream.get()){const t=this.$mediastream.get().getTracks();for(const e of t)e.stop(),VX(this,vQt,"f").srcObject=null;this.$ready.set(!1)}}process(){this.$ready.get()&&(this.$thumbnails.set(this.captureThumbnail()),this.$images.set(this.captureImage()))}captureThumbnail(){if(!this.$ready.get())return null;if(VX(this,gQt,"f")/VX(this,bQt,"f")>VX(this,mQt,"f")/VX(this,yQt,"f")){const t=VX(this,SQt,"f").height*VX(this,yQt,"f")/VX(this,bQt,"f");VX(this,kQt,"f").drawImage(VX(this,vQt,"f"),VX(this,SQt,"f").width/2-t/2,0,t,VX(this,SQt,"f").height)}else{const t=VX(this,SQt,"f").width*VX(this,bQt,"f")/VX(this,yQt,"f");VX(this,kQt,"f").drawImage(VX(this,vQt,"f"),0,VX(this,SQt,"f").height/2-t/2,VX(this,SQt,"f").width,t)}return VX(this,SQt,"f").toDataURL("image/jpeg")}captureImage(){if(!this.$ready.get())return null;if(VX(this,gQt,"f")/VX(this,bQt,"f")>VX(this,mQt,"f")/VX(this,yQt,"f")){const t=VX(this,gQt,"f")*VX(this,yQt,"f")/VX(this,bQt,"f");VX(this,TQt,"f").drawImage(VX(this,vQt,"f"),VX(this,mQt,"f")/2-t/2,0,t,VX(this,gQt,"f"))}else{const t=VX(this,mQt,"f")*VX(this,bQt,"f")/VX(this,yQt,"f");VX(this,TQt,"f").drawImage(VX(this,vQt,"f"),0,VX(this,gQt,"f")/2-t/2,VX(this,mQt,"f"),t)}return VX(this,TQt,"f").getImageData(0,0,VX(this,mQt,"f"),VX(this,gQt,"f"))}}function MQt(...t){return new EQt(...t)}function $Qt(t){return"string"==typeof t}function IQt(t){return Array.isArray(t)}mQt=new WeakMap,gQt=new WeakMap,yQt=new WeakMap,bQt=new WeakMap,vQt=new WeakMap,xQt=new WeakMap,wQt=new WeakMap,SQt=new WeakMap,kQt=new WeakMap,CQt=new WeakMap,TQt=new WeakMap,_Qt=new WeakMap;class AQt{constructor(t,e){this.path=t,this.name=e,this.keys=[],this.fns=[],this.params={},this.regex=function(t,e,n,i){return t instanceof RegExp?t:(t instanceof Array&&(t=`(${t.join("|")})`),t=t.concat(i?"":"/?").replace(/\/\(/g,"(?:/").replace(/\+/g,"__plus__").replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?/g,((t,n,i,r,s,o)=>(e.push({name:r,optional:!!o}),n=n||"",`${o?"":n}(?:${o?n:""}${i||""}${s||i&&"([^/.]+?)"||"([^/]+?)"})${o||""}`))).replace(/([/.])/g,"\\$1").replace(/__plus__/g,"(.+)").replace(/\*/g,"(.*)"),new RegExp(`^${t}$`,n?"":"i"))}(this.path,this.keys,!1,!1)}addHandler(t){this.fns.push(t)}removeHandler(t){this.fns=this.fns.filter((e=>t===e))}run(t){for(const e of this.fns)e.apply(this,t)}match(t,e){const n=this.regex.exec(t);if(!n)return!1;for(let t=1,i=n.length;t<i;t++){const i=this.keys[t-1],r="string"==typeof n[t]?decodeURIComponent(n[t]):n[t];i&&(this.params[i.name]=r),e.push(r)}return!0}}function NQt(t,e){const n=[];return!!e.match(t,n)&&(e.run(n),!0)}class RQt{constructor(){this.map={},this.routes=[],this.addListener()}route(t,e){const n=t.split(" "),i=2===n.length?n[0]:null;t=2===n.length?n[1]:n[0],Object.keys(this.map).includes(t)||(this.map[t]=new AQt(t,i),this.routes.push(this.map[t])),this.map[t].addHandler(e),this.reload()}addListener(){window.addEventListener("hashchange",this.reload.bind(this),!1)}removeListener(){window.removeEventListener("hashchange",this.reload.bind(this))}reload(){const t=window.location.hash.substring(1);for(let e=0;e<this.routes.length;e++){if(NQt(t,this.routes[e]))return}}navigate(t,{silent:e=!1}={}){e&&this.removeListener(),setTimeout((()=>{window.location.hash=t,e&&setTimeout((()=>{this.addListener()}),1)}),1)}}function PQt(t,e,n){const i=t.slice();return i[1]=e[n],i}function OQt(t,e,n){const i=t.slice();return i[4]=e[n].id,i}function LQt(t,e,n){const i=t.slice();return i[4]=e[n].id,i}function DQt(t){let e,n,i=t[0].showSidebar&&FQt(t),r=t[0].components,s=[];for(let e=0;e<r.length;e+=1)s[e]=HQt(PQt(t,r,e));return{c(){i&&i.c(),e=AB(),n=MB("div");for(let t=0;t<s.length;t+=1)s[t].c();OB(n,"class","right svelte-15dyumc"),WB(n,"fullw",!t[0].showSidebar)},m(t,r){i&&i.m(t,r),TB(t,e,r),TB(t,n,r);for(let t=0;t<s.length;t+=1)s[t]&&s[t].m(n,null)},p(t,o){if(t[0].showSidebar?i?i.p(t,o):(i=FQt(t),i.c(),i.m(e.parentNode,e)):i&&(i.d(1),i=null),1&o){let e;for(r=t[0].components,e=0;e<r.length;e+=1){const i=PQt(t,r,e);s[e]?s[e].p(i,o):(s[e]=HQt(i),s[e].c(),s[e].m(n,null))}for(;e<s.length;e+=1)s[e].d(1);s.length=r.length}1&o&&WB(n,"fullw",!t[0].showSidebar)},d(t){i&&i.d(t),t&&_B(e),t&&_B(n),EB(s,t)}}}function FQt(t){let e,n=t[0].componentsLeft,i=[];for(let e=0;e<n.length;e+=1)i[e]=zQt(LQt(t,n,e));return{c(){e=MB("div");for(let t=0;t<i.length;t+=1)i[t].c();OB(e,"class","left svelte-15dyumc")},m(t,n){TB(t,e,n);for(let t=0;t<i.length;t+=1)i[t]&&i[t].m(e,null)},p(t,r){if(1&r){let s;for(n=t[0].componentsLeft,s=0;s<n.length;s+=1){const o=LQt(t,n,s);i[s]?i[s].p(o,r):(i[s]=zQt(o),i[s].c(),i[s].m(e,null))}for(;s<i.length;s+=1)i[s].d(1);i.length=n.length}},d(t){t&&_B(e),EB(i,t)}}}function zQt(t){let e,n;return{c(){e=MB("div"),OB(e,"id",n=t[4]),OB(e,"class","card")},m(t,n){TB(t,e,n)},p(t,i){1&i&&n!==(n=t[4])&&OB(e,"id",n)},d(t){t&&_B(e)}}}function BQt(t){let e,n;return{c(){e=MB("div"),OB(e,"id",n=t[1].id),OB(e,"class","card")},m(t,n){TB(t,e,n)},p(t,i){1&i&&n!==(n=t[1].id)&&OB(e,"id",n)},d(t){t&&_B(e)}}}function UQt(t){let e,n,i=t[1]+"";return{c(){e=MB("h2"),n=IB(i),OB(e,"class","svelte-15dyumc")},m(t,i){TB(t,e,i),SB(e,n)},p(t,e){1&e&&i!==(i=t[1]+"")&&DB(n,i)},d(t){t&&_B(e)}}}function VQt(t){let e,n,i=t[1],r=[];for(let e=0;e<i.length;e+=1)r[e]=WQt(OQt(t,i,e));return{c(){e=MB("div");for(let t=0;t<r.length;t+=1)r[t].c();n=AB(),OB(e,"class","flex flex-row flex-wrap items-stretch")},m(t,i){TB(t,e,i);for(let t=0;t<r.length;t+=1)r[t]&&r[t].m(e,null);SB(e,n)},p(t,s){if(1&s){let o;for(i=t[1],o=0;o<i.length;o+=1){const a=OQt(t,i,o);r[o]?r[o].p(a,s):(r[o]=WQt(a),r[o].c(),r[o].m(e,n))}for(;o<r.length;o+=1)r[o].d(1);r.length=i.length}},d(t){t&&_B(e),EB(r,t)}}}function WQt(t){let e,n;return{c(){e=MB("div"),OB(e,"id",n=t[4]),OB(e,"class","card flex-none xl:flex-1 w-full xl:w-auto")},m(t,n){TB(t,e,n)},p(t,i){1&i&&n!==(n=t[4])&&OB(e,"id",n)},d(t){t&&_B(e)}}}function HQt(t){let e,n;function i(t,n){return 1&n&&(e=null),null==e&&(e=!!Array.isArray(t[1])),e?VQt:"string"==typeof t[1]?UQt:BQt}let r=i(t,-1),s=r(t);return{c(){s.c(),n=NB()},m(t,e){s.m(t,e),TB(t,n,e)},p(t,e){r===(r=i(t,e))&&s?s.p(t,e):(s.d(1),s=r(t),s&&(s.c(),s.m(n.parentNode,n)))},d(t){s.d(t),t&&_B(n)}}}function jQt(t){let e,n=t[0]&&DQt(t);return{c(){n&&n.c(),e=NB()},m(t,i){n&&n.m(t,i),TB(t,e,i)},p(t,[i]){t[0]?n?n.p(t,i):(n=DQt(t),n.c(),n.m(e.parentNode,e)):n&&(n.d(1),n=null)},i:Jz,o:Jz,d(t){n&&n.d(t),t&&_B(e)}}}function GQt(t,e,n){let{dashboard:i}=e;return eU((()=>{i.mount()})),t.$$set=t=>{"dashboard"in t&&n(0,i=t.dashboard)},[i]}class qQt extends UU{constructor(t){super(),BU(this,t,GQt,jQt,rB,{dashboard:0})}}function XQt(t){let e;return{c(){e=IB("This dataset is empty")},m(t,n){TB(t,e,n)},p:Jz,d(t){t&&_B(e)}}}function KQt(t){let e,n,i,r,s,o=t[3]?"s":"";return{c(){e=IB("This dataset contains "),n=IB(t[3]),i=IB(" instance"),r=IB(o),s=IB(".")},m(t,o){TB(t,e,o),TB(t,n,o),TB(t,i,o),TB(t,r,o),TB(t,s,o)},p(t,e){8&e&&DB(n,t[3]),8&e&&o!==(o=t[3]?"s":"")&&DB(r,o)},d(t){t&&_B(e),t&&_B(n),t&&_B(i),t&&_B(r),t&&_B(s)}}}function YQt(t){let e,n,i,r;return e=new HU({props:{$$slots:{default:[ZQt]},$$scope:{ctx:t}}}),e.$on("click",t[4]),{c(){DU(e.$$.fragment),n=AB(),i=MB("span"),OB(i,"class","w-1")},m(t,s){FU(e,t,s),TB(t,n,s),TB(t,i,s),r=!0},p(t,n){const i={};256&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){r||(EU(e.$$.fragment,t),r=!0)},o(t){MU(e.$$.fragment,t),r=!1},d(t){zU(e,t),t&&_B(n),t&&_B(i)}}}function ZQt(t){let e;return{c(){e=IB("Download Dataset")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function JQt(t){let e;return{c(){e=IB("Upload Dataset")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function QQt(t){let e;return{c(){e=IB("Clear Dataset")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function t0t(t){let e,n,i,r,s,o,a,l,c,u,h,d,p,f,m,g=t[0].title+"";function y(t,e){return t[3]?KQt:XQt}let b=y(t),v=b(t),x=t[3]&&YQt(t);return l=new HU({props:{$$slots:{default:[JQt]},$$scope:{ctx:t}}}),l.$on("click",t[5]),f=new HU({props:{type:"danger",$$slots:{default:[QQt]},$$scope:{ctx:t}}}),f.$on("click",t[6]),{c(){e=MB("span"),n=IB(g),i=AB(),r=MB("p"),v.c(),s=AB(),o=MB("div"),x&&x.c(),a=AB(),DU(l.$$.fragment),c=AB(),u=MB("span"),h=AB(),d=MB("input"),p=AB(),DU(f.$$.fragment),OB(e,"class","card-title"),OB(r,"class","pb-2"),OB(u,"class","w-1"),OB(d,"type","file"),d.multiple=!0,OB(d,"class","hidden"),OB(o,"class","flex")},m(g,y){TB(g,e,y),SB(e,n),TB(g,i,y),TB(g,r,y),v.m(r,null),TB(g,s,y),TB(g,o,y),x&&x.m(o,null),SB(o,a),FU(l,o,null),SB(o,c),SB(o,u),SB(o,h),SB(o,d),t[7](d),SB(o,p),FU(f,o,null),m=!0},p(t,[e]){(!m||1&e)&&g!==(g=t[0].title+"")&&DB(n,g),b===(b=y(t))&&v?v.p(t,e):(v.d(1),v=b(t),v&&(v.c(),v.m(r,null))),t[3]?x?(x.p(t,e),8&e&&EU(x,1)):(x=YQt(t),x.c(),EU(x,1),x.m(o,a)):x&&(TU(),MU(x,1,1,(()=>{x=null})),_U());const i={};256&e&&(i.$$scope={dirty:e,ctx:t}),l.$set(i);const s={};256&e&&(s.$$scope={dirty:e,ctx:t}),f.$set(s)},i(t){m||(EU(x),EU(l.$$.fragment,t),EU(f.$$.fragment,t),m=!0)},o(t){MU(x),MU(l.$$.fragment,t),MU(f.$$.fragment,t),m=!1},d(n){n&&_B(e),n&&_B(i),n&&_B(r),v.d(),n&&_B(s),n&&_B(o),x&&x.d(),zU(l),t[7](null),zU(f)}}}function e0t(t,e,n){let i,r,s=Jz;t.$$.on_destroy.push((()=>s()));let o,{dataset:a}=e;return tU((async()=>{await pU(),await pU(),o.addEventListener("change",(t=>{const e=t.target.files,n=[];for(let t=0;t<e.length;t++)n.push(e[t]);a.upload(n)}))})),t.$$set=t=>{"dataset"in t&&n(0,a=t.dataset)},t.$$.update=()=>{1&t.$$.dirty&&(n(2,i=a.$count),s(),s=aB(i,(t=>n(3,r=t))))},[a,o,i,r,function(){a.download()},function(){null==o||o.click()},function(){a.clear()},function(t){aU[t?"unshift":"push"]((()=>{o=t,n(1,o)}))}]}class n0t extends UU{constructor(t){super(),BU(this,t,e0t,t0t,rB,{dataset:0})}}function i0t(t){let e,n,i,r={ctx:t,current:null,token:null,hasCatch:!1,pending:a0t,then:s0t,catch:r0t,value:4,blocks:[,,,]};return AU(n=t[0].connect(),r),{c(){e=NB(),r.block.c()},m(t,n){TB(t,e,n),r.block.m(t,r.anchor=n),r.mount=()=>e.parentNode,r.anchor=e,i=!0},p(e,i){t=e,r.ctx=t,1&i&&n!==(n=t[0].connect())&&AU(n,r)||NU(r,t,i)},i(t){i||(EU(r.block),i=!0)},o(t){for(let t=0;t<3;t+=1){MU(r.blocks[t])}i=!1},d(t){t&&_B(e),r.block.d(t),r.token=null,r=null}}}function r0t(t){return{c:Jz,m:Jz,p:Jz,i:Jz,o:Jz,d:Jz}}function s0t(t){let e,n,i,r,s,o,a,l=t[4].email+"";return o=new HU({props:{$$slots:{default:[o0t]},$$scope:{ctx:t}}}),o.$on("click",t[3]),{c(){e=MB("p"),n=IB("Hello, "),i=IB(l),r=AB(),s=MB("div"),DU(o.$$.fragment),OB(e,"class","pb-2"),OB(s,"class","flex")},m(t,l){TB(t,e,l),SB(e,n),SB(e,i),TB(t,r,l),TB(t,s,l),FU(o,s,null),a=!0},p(t,e){(!a||1&e)&&l!==(l=t[4].email+"")&&DB(i,l);const n={};32&e&&(n.$$scope={dirty:e,ctx:t}),o.$set(n)},i(t){a||(EU(o.$$.fragment,t),a=!0)},o(t){MU(o.$$.fragment,t),a=!1},d(t){t&&_B(e),t&&_B(r),t&&_B(s),zU(o)}}}function o0t(t){let e;return{c(){e=IB("Log out")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function a0t(t){let e,n;return e=new LV({}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p:Jz,i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function l0t(t){let e,n,i,r=t[2].join(", ")+"";return{c(){e=MB("div"),n=IB("This data store contains the following services: "),i=IB(r)},m(t,r){TB(t,e,r),SB(e,n),SB(e,i)},p(t,e){4&e&&r!==(r=t[2].join(", ")+"")&&DB(i,r)},d(t){t&&_B(e)}}}function c0t(t){let e,n,i,r=t[0].requiresAuth&&i0t(t),s=t[2]&&l0t(t);return{c(){r&&r.c(),e=AB(),s&&s.c(),n=NB()},m(t,o){r&&r.m(t,o),TB(t,e,o),s&&s.m(t,o),TB(t,n,o),i=!0},p(t,i){t[0].requiresAuth?r?(r.p(t,i),1&i&&EU(r,1)):(r=i0t(t),r.c(),EU(r,1),r.m(e.parentNode,e)):r&&(TU(),MU(r,1,1,(()=>{r=null})),_U()),t[2]?s?s.p(t,i):(s=l0t(t),s.c(),s.m(n.parentNode,n)):s&&(s.d(1),s=null)},i(t){i||(EU(r),i=!0)},o(t){MU(r),i=!1},d(t){r&&r.d(t),t&&_B(e),s&&s.d(t),t&&_B(n)}}}function u0t(t){let e,n;return e=new DH({props:{title:"data store ("+t[0].location+")",$$slots:{default:[c0t]},$$scope:{ctx:t}}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,[n]){const i={};1&n&&(i.title="data store ("+t[0].location+")"),37&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function h0t(t,e,n){let i,r,s=Jz;t.$$.on_destroy.push((()=>s()));let{dataStore:o}=e;return t.$$set=t=>{"dataStore"in t&&n(0,o=t.dataStore)},t.$$.update=()=>{1&t.$$.dirty&&(n(1,i=o.$services),s(),s=aB(i,(t=>n(2,r=t))))},[o,i,r,function(){o.logout()}]}class d0t extends UU{constructor(t){super(),BU(this,t,h0t,u0t,rB,{dataStore:0})}}function p0t(t){let e;return{c(){e=IB("Download Model")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function f0t(t){let e;return{c(){e=IB("Upload Model")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function m0t(t){let e,n,i,r,s,o,a,l,c,u,h,d,p=t[0].title+"";return s=new HU({props:{$$slots:{default:[p0t]},$$scope:{ctx:t}}}),s.$on("click",t[2]),h=new HU({props:{$$slots:{default:[f0t]},$$scope:{ctx:t}}}),h.$on("click",t[3]),{c(){e=MB("span"),n=IB(p),i=AB(),r=MB("div"),DU(s.$$.fragment),o=AB(),a=MB("span"),l=AB(),c=MB("input"),u=AB(),DU(h.$$.fragment),OB(e,"class","card-title"),OB(a,"class","w-1"),OB(c,"type","file"),c.multiple=!0,OB(c,"class","hidden"),OB(r,"class","flex")},m(p,f){TB(p,e,f),SB(e,n),TB(p,i,f),TB(p,r,f),FU(s,r,null),SB(r,o),SB(r,a),SB(r,l),SB(r,c),t[4](c),SB(r,u),FU(h,r,null),d=!0},p(t,[e]){(!d||1&e)&&p!==(p=t[0].title+"")&&DB(n,p);const i={};32&e&&(i.$$scope={dirty:e,ctx:t}),s.$set(i);const r={};32&e&&(r.$$scope={dirty:e,ctx:t}),h.$set(r)},i(t){d||(EU(s.$$.fragment,t),EU(h.$$.fragment,t),d=!0)},o(t){MU(s.$$.fragment,t),MU(h.$$.fragment,t),d=!1},d(n){n&&_B(e),n&&_B(i),n&&_B(r),zU(s),t[4](null),zU(h)}}}function g0t(t){return"download"in t}function y0t(t,e,n){let i,{model:r}=e;return tU((async()=>{await pU(),await pU(),i.addEventListener("change",(t=>{const e=t.target.files,n=[];for(let t=0;t<e.length;t++)n.push(e[t]);g0t(r)&&r.upload(...n)}))})),t.$$set=t=>{"model"in t&&n(0,r=t.model)},[r,i,function(){g0t(r)?r.download():cK(new Error("This model cannot be saved"))},function(){g0t(r)?null==i||i.click():cK(new Error("This model cannot be uploaded"))},function(t){aU[t?"unshift":"push"]((()=>{i=t,n(1,i)}))}]}class b0t extends UU{constructor(t){super(),BU(this,t,y0t,m0t,rB,{model:0})}}function v0t(t){let e;return{c(){e=IB("This batch prediction component is empty")},m(t,n){TB(t,e,n)},p:Jz,d(t){t&&_B(e)}}}function x0t(t){let e,n,i,r,s=t[3]?"s":"";return{c(){e=IB("This batch prediction component contains\n    "),n=IB(t[3]),i=IB("\n    prediction"),r=IB(s)},m(t,s){TB(t,e,s),TB(t,n,s),TB(t,i,s),TB(t,r,s)},p(t,e){8&e&&DB(n,t[3]),8&e&&s!==(s=t[3]?"s":"")&&DB(r,s)},d(t){t&&_B(e),t&&_B(n),t&&_B(i),t&&_B(r)}}}function w0t(t){let e,n,i,r;return e=new HU({props:{$$slots:{default:[S0t]},$$scope:{ctx:t}}}),e.$on("click",t[4]),{c(){DU(e.$$.fragment),n=AB(),i=MB("span"),OB(i,"class","w-1")},m(t,s){FU(e,t,s),TB(t,n,s),TB(t,i,s),r=!0},p(t,n){const i={};256&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){r||(EU(e.$$.fragment,t),r=!0)},o(t){MU(e.$$.fragment,t),r=!1},d(t){zU(e,t),t&&_B(n),t&&_B(i)}}}function S0t(t){let e;return{c(){e=IB("Download Predictions")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function k0t(t){let e;return{c(){e=IB("Upload Predictions")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function C0t(t){let e;return{c(){e=IB("Clear Predictions")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function T0t(t){let e,n,i,r,s,o,a,l,c,u,h,d,p,f,m,g=t[0].title+"";function y(t,e){return t[3]?x0t:v0t}let b=y(t),v=b(t),x=t[3]&&w0t(t);return l=new HU({props:{$$slots:{default:[k0t]},$$scope:{ctx:t}}}),l.$on("click",t[5]),f=new HU({props:{type:"danger",$$slots:{default:[C0t]},$$scope:{ctx:t}}}),f.$on("click",t[6]),{c(){e=MB("span"),n=IB(g),i=AB(),r=MB("p"),v.c(),s=AB(),o=MB("div"),x&&x.c(),a=AB(),DU(l.$$.fragment),c=AB(),u=MB("span"),h=AB(),d=MB("input"),p=AB(),DU(f.$$.fragment),OB(e,"class","card-title"),OB(r,"class","pb-2"),OB(u,"class","w-1"),OB(d,"type","file"),d.multiple=!0,OB(d,"class","hidden"),OB(o,"class","flex")},m(g,y){TB(g,e,y),SB(e,n),TB(g,i,y),TB(g,r,y),v.m(r,null),TB(g,s,y),TB(g,o,y),x&&x.m(o,null),SB(o,a),FU(l,o,null),SB(o,c),SB(o,u),SB(o,h),SB(o,d),t[7](d),SB(o,p),FU(f,o,null),m=!0},p(t,[e]){(!m||1&e)&&g!==(g=t[0].title+"")&&DB(n,g),b===(b=y(t))&&v?v.p(t,e):(v.d(1),v=b(t),v&&(v.c(),v.m(r,null))),t[3]?x?(x.p(t,e),8&e&&EU(x,1)):(x=w0t(t),x.c(),EU(x,1),x.m(o,a)):x&&(TU(),MU(x,1,1,(()=>{x=null})),_U());const i={};256&e&&(i.$$scope={dirty:e,ctx:t}),l.$set(i);const s={};256&e&&(s.$$scope={dirty:e,ctx:t}),f.$set(s)},i(t){m||(EU(x),EU(l.$$.fragment,t),EU(f.$$.fragment,t),m=!0)},o(t){MU(x),MU(l.$$.fragment,t),MU(f.$$.fragment,t),m=!1},d(n){n&&_B(e),n&&_B(i),n&&_B(r),v.d(),n&&_B(s),n&&_B(o),x&&x.d(),zU(l),t[7](null),zU(f)}}}function _0t(t,e,n){let i,r,s=Jz;t.$$.on_destroy.push((()=>s()));let o,{prediction:a}=e;return tU((async()=>{await pU(),await pU(),o.addEventListener("change",(t=>{const e=t.target.files,n=[];for(let t=0;t<e.length;t++)n.push(e[t]);a.upload(n)}))})),t.$$set=t=>{"prediction"in t&&n(0,a=t.prediction)},t.$$.update=()=>{1&t.$$.dirty&&(n(2,i=a.$count),s(),s=aB(i,(t=>n(3,r=t))))},[a,o,i,r,function(){a.download()},function(){null==o||o.click()},function(){a.clear()},function(t){aU[t?"unshift":"push"]((()=>{o=t,n(1,o)}))}]}class E0t extends UU{constructor(t){super(),BU(this,t,_0t,T0t,rB,{prediction:0})}}function M0t(t,e,n){const i=t.slice();return i[1]=e[n],i}function $0t(t,e,n){const i=t.slice();return i[4]=e[n].id,i}function I0t(t,e,n){const i=t.slice();return i[7]=e[n],i}function A0t(t,e,n){const i=t.slice();return i[10]=e[n],i}function N0t(t,e,n){const i=t.slice();return i[13]=e[n],i}function R0t(t,e,n){const i=t.slice();return i[16]=e[n],i}function P0t(t){let e,n,i,r,s,o,a,l,c,u,h,d,p,f,m,g=t[0].xDataStores,y=[];for(let e=0;e<g.length;e+=1)y[e]=O0t(R0t(t,g,e));const b=t=>MU(y[t],1,1,(()=>{y[t]=null}));let v=t[0].xModels,x=[];for(let e=0;e<v.length;e+=1)x[e]=L0t(N0t(t,v,e));const w=t=>MU(x[t],1,1,(()=>{x[t]=null}));let S=t[0].xDatasets,k=[];for(let e=0;e<S.length;e+=1)k[e]=D0t(A0t(t,S,e));const C=t=>MU(k[t],1,1,(()=>{k[t]=null}));let T=t[0].xPredictions,_=[];for(let e=0;e<T.length;e+=1)_[e]=F0t(I0t(t,T,e));const E=t=>MU(_[t],1,1,(()=>{_[t]=null}));let M=t[0].components,$=[];for(let e=0;e<M.length;e+=1)$[e]=W0t(M0t(t,M,e));return{c(){e=MB("div"),n=MB("h2"),n.textContent="Data Stores",i=AB();for(let t=0;t<y.length;t+=1)y[t].c();r=AB(),s=MB("h2"),s.textContent="Models",o=AB();for(let t=0;t<x.length;t+=1)x[t].c();a=AB(),l=MB("h2"),l.textContent="Datasets",c=AB();for(let t=0;t<k.length;t+=1)k[t].c();u=AB(),h=MB("h2"),h.textContent="Predictions",d=AB();for(let t=0;t<_.length;t+=1)_[t].c();p=AB(),f=MB("div");for(let t=0;t<$.length;t+=1)$[t].c();OB(e,"class","left svelte-inuorr"),OB(f,"class","right svelte-inuorr")},m(t,g){TB(t,e,g),SB(e,n),SB(e,i);for(let t=0;t<y.length;t+=1)y[t]&&y[t].m(e,null);SB(e,r),SB(e,s),SB(e,o);for(let t=0;t<x.length;t+=1)x[t]&&x[t].m(e,null);SB(e,a),SB(e,l),SB(e,c);for(let t=0;t<k.length;t+=1)k[t]&&k[t].m(e,null);SB(e,u),SB(e,h),SB(e,d);for(let t=0;t<_.length;t+=1)_[t]&&_[t].m(e,null);TB(t,p,g),TB(t,f,g);for(let t=0;t<$.length;t+=1)$[t]&&$[t].m(f,null);m=!0},p(t,n){if(1&n){let i;for(g=t[0].xDataStores,i=0;i<g.length;i+=1){const s=R0t(t,g,i);y[i]?(y[i].p(s,n),EU(y[i],1)):(y[i]=O0t(s),y[i].c(),EU(y[i],1),y[i].m(e,r))}for(TU(),i=g.length;i<y.length;i+=1)b(i);_U()}if(1&n){let i;for(v=t[0].xModels,i=0;i<v.length;i+=1){const r=N0t(t,v,i);x[i]?(x[i].p(r,n),EU(x[i],1)):(x[i]=L0t(r),x[i].c(),EU(x[i],1),x[i].m(e,a))}for(TU(),i=v.length;i<x.length;i+=1)w(i);_U()}if(1&n){let i;for(S=t[0].xDatasets,i=0;i<S.length;i+=1){const r=A0t(t,S,i);k[i]?(k[i].p(r,n),EU(k[i],1)):(k[i]=D0t(r),k[i].c(),EU(k[i],1),k[i].m(e,u))}for(TU(),i=S.length;i<k.length;i+=1)C(i);_U()}if(1&n){let i;for(T=t[0].xPredictions,i=0;i<T.length;i+=1){const r=I0t(t,T,i);_[i]?(_[i].p(r,n),EU(_[i],1)):(_[i]=F0t(r),_[i].c(),EU(_[i],1),_[i].m(e,null))}for(TU(),i=T.length;i<_.length;i+=1)E(i);_U()}if(1&n){let e;for(M=t[0].components,e=0;e<M.length;e+=1){const i=M0t(t,M,e);$[e]?$[e].p(i,n):($[e]=W0t(i),$[e].c(),$[e].m(f,null))}for(;e<$.length;e+=1)$[e].d(1);$.length=M.length}},i(t){if(!m){for(let t=0;t<g.length;t+=1)EU(y[t]);for(let t=0;t<v.length;t+=1)EU(x[t]);for(let t=0;t<S.length;t+=1)EU(k[t]);for(let t=0;t<T.length;t+=1)EU(_[t]);m=!0}},o(t){y=y.filter(Boolean);for(let t=0;t<y.length;t+=1)MU(y[t]);x=x.filter(Boolean);for(let t=0;t<x.length;t+=1)MU(x[t]);k=k.filter(Boolean);for(let t=0;t<k.length;t+=1)MU(k[t]);_=_.filter(Boolean);for(let t=0;t<_.length;t+=1)MU(_[t]);m=!1},d(t){t&&_B(e),EB(y,t),EB(x,t),EB(k,t),EB(_,t),t&&_B(p),t&&_B(f),EB($,t)}}}function O0t(t){let e,n,i;return n=new d0t({props:{dataStore:t[16]}}),{c(){e=MB("div"),DU(n.$$.fragment),OB(e,"class","card")},m(t,r){TB(t,e,r),FU(n,e,null),i=!0},p(t,e){const i={};1&e&&(i.dataStore=t[16]),n.$set(i)},i(t){i||(EU(n.$$.fragment,t),i=!0)},o(t){MU(n.$$.fragment,t),i=!1},d(t){t&&_B(e),zU(n)}}}function L0t(t){let e,n,i;return n=new b0t({props:{model:t[13]}}),{c(){e=MB("div"),DU(n.$$.fragment),OB(e,"class","card")},m(t,r){TB(t,e,r),FU(n,e,null),i=!0},p(t,e){const i={};1&e&&(i.model=t[13]),n.$set(i)},i(t){i||(EU(n.$$.fragment,t),i=!0)},o(t){MU(n.$$.fragment,t),i=!1},d(t){t&&_B(e),zU(n)}}}function D0t(t){let e,n,i;return n=new n0t({props:{dataset:t[10]}}),{c(){e=MB("div"),DU(n.$$.fragment),OB(e,"class","card")},m(t,r){TB(t,e,r),FU(n,e,null),i=!0},p(t,e){const i={};1&e&&(i.dataset=t[10]),n.$set(i)},i(t){i||(EU(n.$$.fragment,t),i=!0)},o(t){MU(n.$$.fragment,t),i=!1},d(t){t&&_B(e),zU(n)}}}function F0t(t){let e,n,i,r;return n=new E0t({props:{prediction:t[7]}}),{c(){e=MB("div"),DU(n.$$.fragment),i=AB(),OB(e,"class","card")},m(t,s){TB(t,e,s),FU(n,e,null),SB(e,i),r=!0},p(t,e){const i={};1&e&&(i.prediction=t[7]),n.$set(i)},i(t){r||(EU(n.$$.fragment,t),r=!0)},o(t){MU(n.$$.fragment,t),r=!1},d(t){t&&_B(e),zU(n)}}}function z0t(t){let e,n;return{c(){e=MB("div"),OB(e,"id",n=t[1].id),OB(e,"class","card")},m(t,n){TB(t,e,n)},p(t,i){1&i&&n!==(n=t[1].id)&&OB(e,"id",n)},d(t){t&&_B(e)}}}function B0t(t){let e,n,i=t[1]+"";return{c(){e=MB("h2"),n=IB(i)},m(t,i){TB(t,e,i),SB(e,n)},p(t,e){1&e&&i!==(i=t[1]+"")&&DB(n,i)},d(t){t&&_B(e)}}}function U0t(t){let e,n,i=t[1],r=[];for(let e=0;e<i.length;e+=1)r[e]=V0t($0t(t,i,e));return{c(){e=MB("div");for(let t=0;t<r.length;t+=1)r[t].c();n=AB(),OB(e,"class","flex flex-row flex-wrap items-stretch")},m(t,i){TB(t,e,i);for(let t=0;t<r.length;t+=1)r[t]&&r[t].m(e,null);SB(e,n)},p(t,s){if(1&s){let o;for(i=t[1],o=0;o<i.length;o+=1){const a=$0t(t,i,o);r[o]?r[o].p(a,s):(r[o]=V0t(a),r[o].c(),r[o].m(e,n))}for(;o<r.length;o+=1)r[o].d(1);r.length=i.length}},d(t){t&&_B(e),EB(r,t)}}}function V0t(t){let e,n;return{c(){e=MB("div"),OB(e,"id",n=t[4]),OB(e,"class","card flex-none xl:flex-1 w-full xl:w-auto")},m(t,n){TB(t,e,n)},p(t,i){1&i&&n!==(n=t[4])&&OB(e,"id",n)},d(t){t&&_B(e)}}}function W0t(t){let e,n;function i(t,n){return 1&n&&(e=null),null==e&&(e=!!Array.isArray(t[1])),e?U0t:"string"==typeof t[1]?B0t:z0t}let r=i(t,-1),s=r(t);return{c(){s.c(),n=NB()},m(t,e){s.m(t,e),TB(t,n,e)},p(t,e){r===(r=i(t,e))&&s?s.p(t,e):(s.d(1),s=r(t),s&&(s.c(),s.m(n.parentNode,n)))},d(t){s.d(t),t&&_B(n)}}}function H0t(t){let e,n,i=t[0]&&P0t(t);return{c(){i&&i.c(),e=NB()},m(t,r){i&&i.m(t,r),TB(t,e,r),n=!0},p(t,[n]){t[0]?i?(i.p(t,n),1&n&&EU(i,1)):(i=P0t(t),i.c(),EU(i,1),i.m(e.parentNode,e)):i&&(TU(),MU(i,1,1,(()=>{i=null})),_U())},i(t){n||(EU(i),n=!0)},o(t){MU(i),n=!1},d(t){i&&i.d(t),t&&_B(e)}}}function j0t(t,e,n){let{settings:i}=e;return eU((()=>{i.mount()})),t.$$set=t=>{"settings"in t&&n(0,i=t.settings)},[i]}let G0t=class extends UU{constructor(t){super(),BU(this,t,j0t,H0t,rB,{settings:0})}};function q0t(t,e,n){const i=t.slice();return i[8]=e[n][0],i[9]=e[n][1],i[11]=n,i}function X0t(t){let e,n,i,r,s=t[9]+"";return{c(){e=MB("a"),n=IB(s),i=AB(),OB(e,"href",r=`#${t[8]}`),OB(e,"class","ml-2 mr-5 flex items-center hover:text-black border-solid border-0 border-b-2 border-transparent svelte-1ut593v"),WB(e,"active",!t[4]&&t[2]===t[9])},m(t,r){TB(t,e,r),SB(e,n),SB(e,i)},p(t,i){2&i&&s!==(s=t[9]+"")&&DB(n,s),2&i&&r!==(r=`#${t[8]}`)&&OB(e,"href",r),22&i&&WB(e,"active",!t[4]&&t[2]===t[9])},d(t){t&&_B(e)}}}function K0t(t){let e,n,i;return{c(){e=$B("svg"),n=$B("circle"),i=$B("path"),OB(n,"cx","12"),OB(n,"cy","12"),OB(n,"r","3"),OB(i,"d","M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"),OB(e,"xmlns","http://www.w3.org/2000/svg"),OB(e,"width","24"),OB(e,"height","24"),OB(e,"viewBox","0 0 24 24"),OB(e,"fill","none"),OB(e,"stroke","currentColor"),OB(e,"stroke-width","2"),OB(e,"stroke-linecap","round"),OB(e,"stroke-linejoin","round"),OB(e,"class","feather feather-settings")},m(t,r){TB(t,e,r),SB(e,n),SB(e,i)},p:Jz,d(t){t&&_B(e)}}}function Y0t(t){let e,n,i,r;return e=new HU({props:{round:!0,type:"danger",$$slots:{default:[Z0t]},$$scope:{ctx:t}}}),e.$on("click",t[5]),{c(){DU(e.$$.fragment),n=AB(),i=MB("span"),OB(i,"class","w-1")},m(t,s){FU(e,t,s),TB(t,n,s),TB(t,i,s),r=!0},p(t,n){const i={};4096&n&&(i.$$scope={dirty:n,ctx:t}),e.$set(i)},i(t){r||(EU(e.$$.fragment,t),r=!0)},o(t){MU(e.$$.fragment,t),r=!1},d(t){zU(e,t),t&&_B(n),t&&_B(i)}}}function Z0t(t){let e,n,i;return{c(){e=$B("svg"),n=$B("path"),i=$B("line"),OB(n,"d","M18.36 6.64a9 9 0 1 1-12.73 0"),OB(i,"x1","12"),OB(i,"y1","2"),OB(i,"x2","12"),OB(i,"y2","12"),OB(e,"xmlns","http://www.w3.org/2000/svg"),OB(e,"width","24"),OB(e,"height","24"),OB(e,"viewBox","0 0 24 24"),OB(e,"fill","none"),OB(e,"stroke","currentColor"),OB(e,"stroke-width","2"),OB(e,"stroke-linecap","round"),OB(e,"stroke-linejoin","round"),OB(e,"class","feather feather-power")},m(t,r){TB(t,e,r),SB(e,n),SB(e,i)},p:Jz,d(t){t&&_B(e)}}}function J0t(t){let e,n,i,r,s,o,a,l,c,u,h,d,p,f,m=Object.entries(t[1]),g=[];for(let e=0;e<m.length;e+=1)g[e]=X0t(q0t(t,m,e));u=new HU({props:{round:!0,$$slots:{default:[K0t]},$$scope:{ctx:t}}}),u.$on("click",t[6]);let y=t[3]&&Y0t(t);return{c(){e=MB("header"),n=MB("div"),i=MB("a"),r=MB("span"),s=IB(t[0]),o=AB(),a=MB("nav");for(let t=0;t<g.length;t+=1)g[t].c();l=AB(),c=MB("div"),DU(u.$$.fragment),h=AB(),d=MB("span"),p=AB(),y&&y.c(),OB(r,"class","mx-3 text-lg"),OB(i,"href","#/"),OB(i,"class","flex p-3 title-font font-medium items-center text-gray-900 mb-4 md:mb-0 border-solid border-0 border-r border-gray-200 svelte-1ut593v"),OB(a,"class","flex items-stretch justify-start flex-wrap text-base grow mx-4"),OB(d,"class","w-1"),OB(c,"class","flex items-center"),OB(n,"class","mx-auto flex flex-wrap flex-col md:flex-row items-stretch w-full"),OB(e,"class","bg-white text-gray-700 body-font")},m(t,m){TB(t,e,m),SB(e,n),SB(n,i),SB(i,r),SB(r,s),SB(n,o),SB(n,a);for(let t=0;t<g.length;t+=1)g[t]&&g[t].m(a,null);SB(n,l),SB(n,c),FU(u,c,null),SB(c,h),SB(c,d),SB(c,p),y&&y.m(c,null),f=!0},p(t,[e]){if((!f||1&e)&&DB(s,t[0]),22&e){let n;for(m=Object.entries(t[1]),n=0;n<m.length;n+=1){const i=q0t(t,m,n);g[n]?g[n].p(i,e):(g[n]=X0t(i),g[n].c(),g[n].m(a,null))}for(;n<g.length;n+=1)g[n].d(1);g.length=m.length}const n={};4096&e&&(n.$$scope={dirty:e,ctx:t}),u.$set(n),t[3]?y?(y.p(t,e),8&e&&EU(y,1)):(y=Y0t(t),y.c(),EU(y,1),y.m(c,null)):y&&(TU(),MU(y,1,1,(()=>{y=null})),_U())},i(t){f||(EU(u.$$.fragment,t),EU(y),f=!0)},o(t){MU(u.$$.fragment,t),MU(y),f=!1},d(t){t&&_B(e),EB(g,t),zU(u),y&&y.d()}}}function Q0t(t,e,n){let{title:i}=e,{items:r}=e,{current:s}=e,{closable:o}=e,{showSettings:a=!1}=e;const l=iU();return t.$$set=t=>{"title"in t&&n(0,i=t.title),"items"in t&&n(1,r=t.items),"current"in t&&n(2,s=t.current),"closable"in t&&n(3,o=t.closable),"showSettings"in t&&n(4,a=t.showSettings)},[i,r,s,o,a,function(){setTimeout((()=>{l("quit")}),400)},function(){window.location.href=a?window.location.href.split("#")[0]+"#"+Object.keys(r)[Object.values(r).indexOf(s)]:window.location.href.split("#")[0]+"#settings"}]}class t1t extends UU{constructor(t){super(),BU(this,t,Q0t,J0t,rB,{title:0,items:1,current:2,closable:3,showSettings:4,quit:5})}get quit(){return this.$$.ctx[5]}}function e1t(t){let e;return{c(){e=IB("")},m(t,n){TB(t,e,n)},p:Jz,d(t){t&&_B(e)}}}function n1t(t){let e;function n(t,e){return t[1][0]===iK.Warning?s1t:t[1][0]===iK.Error?r1t:i1t}let i=n(t),r=i(t);return{c(){r.c(),e=NB()},m(t,n){r.m(t,n),TB(t,e,n)},p(t,s){i===(i=n(t))&&r?r.p(t,s):(r.d(1),r=i(t),r&&(r.c(),r.m(e.parentNode,e)))},d(t){r.d(t),t&&_B(e)}}}function i1t(t){let e,n=(t[1][1]||"")+"";return{c(){e=IB(n)},m(t,n){TB(t,e,n)},p(t,i){2&i&&n!==(n=(t[1][1]||"")+"")&&DB(e,n)},d(t){t&&_B(e)}}}function r1t(t){let e,n,i=(t[1][1]||"")+"";return{c(){e=IB("Err:\n        "),n=IB(i)},m(t,i){TB(t,e,i),TB(t,n,i)},p(t,e){2&e&&i!==(i=(t[1][1]||"")+"")&&DB(n,i)},d(t){t&&_B(e),t&&_B(n)}}}function s1t(t){let e,n,i=(t[1][1]||"")+"";return{c(){e=IB("Warn:\n        "),n=IB(i)},m(t,i){TB(t,e,i),TB(t,n,i)},p(t,e){2&e&&i!==(i=(t[1][1]||"")+"")&&DB(n,i)},d(t){t&&_B(e),t&&_B(n)}}}function o1t(t){let e,n,i,r,s,o;function a(t,e){return t[1]?n1t:e1t}let l=a(t),c=l(t);return{c(){e=MB("footer"),n=MB("p"),c.c(),i=AB(),r=MB("p"),s=IB(" 2021 "),o=IB(t[0]),OB(n,"class","console svelte-i04gf3"),WB(n,"error",t[1]&&t[1][0]===iK.Error),WB(n,"warning",t[1]&&t[1][0]===iK.Warning),OB(r,"class","text-sm text-gray-500 sm:ml-4 sm:pl-4 sm:border-gray-200"),OB(e,"class","bg-white text-gray-600 border-t px-5 py-1 flex items-center justify-between flex-col sm:flex-row")},m(t,a){TB(t,e,a),SB(e,n),c.m(n,null),SB(e,i),SB(e,r),SB(r,s),SB(r,o)},p(t,[e]){l===(l=a(t))&&c?c.p(t,e):(c.d(1),c=l(t),c&&(c.c(),c.m(n,null))),2&e&&WB(n,"error",t[1]&&t[1][0]===iK.Error),2&e&&WB(n,"warning",t[1]&&t[1][0]===iK.Warning),1&e&&DB(o,t[0])},i:Jz,o:Jz,d(t){t&&_B(e),c.d()}}}function a1t(t,e,n){let i,{author:r}=e;const s=oK();return cB(t,s,(t=>n(1,i=t))),t.$$set=t=>{"author"in t&&n(0,r=t.author)},[r,i,s]}class l1t extends UU{constructor(t){super(),BU(this,t,a1t,o1t,rB,{author:0})}}function c1t(t){let e,n,i,r,s,o,a,l,c,u,h;i=new t1t({props:{title:t[0],items:t[10].reduce(t[12],{}),current:t[9],showSettings:t[8],closable:t[4]}}),i.$on("quit",t[5]);const d=[h1t,u1t],p=[];function f(t,e){return t[8]?0:t[9]?1:-1}return~(o=f(t))&&(a=p[o]=d[o](t)),c=new l1t({props:{author:t[1]}}),{c(){e=MB("div"),n=MB("div"),DU(i.$$.fragment),r=AB(),s=MB("main"),a&&a.c(),l=AB(),DU(c.$$.fragment),OB(s,"class","main-container svelte-1da5cws"),OB(n,"class","app-container svelte-1da5cws"),OB(e,"class","marcelle fixed h-screen w-full max-w-full overflow-y-scroll overflow-x-hidden top-0 left-0 z-50")},m(t,a){TB(t,e,a),SB(e,n),FU(i,n,null),SB(n,r),SB(n,s),~o&&p[o].m(s,null),SB(n,l),FU(c,n,null),h=!0},p(e,n){t=e;const r={};1&n&&(r.title=t[0]),1088&n&&(r.items=t[10].reduce(t[12],{})),512&n&&(r.current=t[9]),256&n&&(r.showSettings=t[8]),16&n&&(r.closable=t[4]),i.$set(r);let l=o;o=f(t),o===l?~o&&p[o].p(t,n):(a&&(TU(),MU(p[l],1,1,(()=>{p[l]=null})),_U()),~o?(a=p[o],a?a.p(t,n):(a=p[o]=d[o](t),a.c()),EU(a,1),a.m(s,null)):a=null);const u={};2&n&&(u.author=t[1]),c.$set(u)},i(e){h||(EU(i.$$.fragment,e),EU(a),EU(c.$$.fragment,e),fU((()=>{h&&(u||(u=IU(n,QU,{amount:10,duration:t[4]?400:0},!0)),u.run(1))})),h=!0)},o(e){MU(i.$$.fragment,e),MU(a),MU(c.$$.fragment,e),u||(u=IU(n,QU,{amount:10,duration:t[4]?400:0},!1)),u.run(0),h=!1},d(t){t&&_B(e),zU(i),~o&&p[o].d(),zU(c),t&&u&&u.end()}}}function u1t(t){let e,n;return e=new qQt({props:{dashboard:t[2][t[9]]}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};516&n&&(i.dashboard=t[2][t[9]]),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function h1t(t){let e,n;return e=new G0t({props:{settings:t[3]}}),{c(){DU(e.$$.fragment)},m(t,i){FU(e,t,i),n=!0},p(t,n){const i={};8&n&&(i.settings=t[3]),e.$set(i)},i(t){n||(EU(e.$$.fragment,t),n=!0)},o(t){MU(e.$$.fragment,t),n=!1},d(t){zU(e,t)}}}function d1t(t){let e,n,i,r;document.title=e=t[0];let s=t[7]&&c1t(t);return{c(){n=AB(),s&&s.c(),i=NB()},m(t,e){TB(t,n,e),s&&s.m(t,e),TB(t,i,e),r=!0},p(t,[n]){(!r||1&n)&&e!==(e=t[0])&&(document.title=e),t[7]?s?(s.p(t,n),128&n&&EU(s,1)):(s=c1t(t),s.c(),EU(s,1),s.m(i.parentNode,i)):s&&(TU(),MU(s,1,1,(()=>{s=null})),_U())},i(t){r||(EU(s),r=!0)},o(t){MU(s),r=!1},d(t){t&&_B(n),s&&s.d(t),t&&_B(i)}}}function p1t(t){let e=t.replace(/^\s+|\s+$/g,"");e=e.toLowerCase();const n="/_,:;";for(let t=0,i=28;t<i;t++)e=e.replace(new RegExp(n.charAt(t),"g"),"aaaaeeeeiiiioooouuuunc------".charAt(t));return e=e.replace(/[^a-z0-9 -]/g,"").replace(/\s+/g,"-").replace(/-+/g,"-"),e}function f1t(t,e,n){let i,r;const s=iU();let{title:o}=e,{author:a}=e,{dashboards:l={}}=e,{settings:c}=e,{page:u}=e,{closable:h}=e,d=!1;tU((()=>{n(7,d=!0)}));let p=!1,f=Object.keys(l)[0]||void 0;tU((()=>{try{const t=new RQt;t.route("settings",(()=>{n(8,p=!0),f&&l[f].destroy(),u.set("settings")})),r.forEach(((e,r)=>{t.route(e,(()=>{n(8,p=!1),f!==i[r]&&(f&&l[f].destroy(),n(9,f=i[r]),u.set(""===e?p1t(i[0]):e))}))}))}catch(t){console.log("Could not enable router",t)}}));return t.$$set=t=>{"title"in t&&n(0,o=t.title),"author"in t&&n(1,a=t.author),"dashboards"in t&&n(2,l=t.dashboards),"settings"in t&&n(3,c=t.settings),"page"in t&&n(11,u=t.page),"closable"in t&&n(4,h=t.closable)},t.$$.update=()=>{4&t.$$.dirty&&n(6,i=Object.keys(l)),64&t.$$.dirty&&n(10,r=[""].concat(i.slice(1).map(p1t)))},[o,a,l,c,h,function(){n(7,d=!1),setTimeout((()=>{s("quit")}),400)},i,d,p,f,r,u,(t,e,n)=>({...t,[e]:i[n]})]}let m1t=class extends UU{constructor(t){super(),BU(this,t,f1t,d1t,rB,{title:0,author:1,dashboards:2,settings:3,page:11,closable:4,quit:5})}get quit(){return this.$$.ctx[5]}};function g1t(t){return"string"==typeof t}function y1t(t){return Array.isArray(t)}class b1t{constructor(){this.name="settings",this.components=[],this.xModels=[],this.xDatasets=[],this.xPredictions=[],this.xDataStores=[]}use(...t){return this.components=this.components.concat(t),this}dataStores(...t){return this.xDataStores=t,this}models(...t){return this.xModels=t,this}datasets(...t){return this.xDatasets=t,this}predictions(...t){return this.xPredictions=t,this}mount(){for(const t of this.components)if(y1t(t))for(const e of t)e.mount();else g1t(t)||t.mount()}destroy(){for(const t of this.components)if(y1t(t))for(const e of t)e.destroy();else g1t(t)||t.destroy()}}class v1t{constructor({title:t="Hello, Marcelle!",author:e="author",closable:n=!1}){this.panels={},this.settings=new b1t,this.$active=new eK(!1,!0),this.$page=new eK("",!0),this.title=t,this.author=e,this.closable=n}page(t,e){return Object.keys(this.panels).includes(t)||(this.panels[t]=new class{constructor(t,e=!0){this.name=t,this.showSidebar=e,this.components=[],this.componentsLeft=[]}use(...t){return this.components=this.components.concat(t),this}sidebar(...t){return this.componentsLeft=this.componentsLeft.concat(t),this}mount(){for(const t of this.components)if(IQt(t))for(const e of t)e.mount();else $Qt(t)||t.mount();for(const t of this.componentsLeft)t.mount()}destroy(){for(const t of this.components)if(IQt(t))for(const e of t)e.destroy();else $Qt(t)||t.destroy();for(const t of this.componentsLeft)t.destroy()}}(t,e)),this.panels[t]}show(){this.app=new m1t({target:document.body,props:{title:this.title,author:this.author,dashboards:this.panels,settings:this.settings,page:this.$page,closable:this.closable}}),this.$active.set(!0),this.app.$on("quit",(()=>{var t;this.$active.set(!1),null===(t=this.app)||void 0===t||t.$destroy();for(const t of Object.values(this.panels))t.destroy();this.app=void 0}))}hide(){var t;null===(t=this.app)||void 0===t||t.quit()}}function x1t(t){return new v1t(t)}function w1t(t,e,n){const i=t.slice();return i[4]=e[n],i}function S1t(t,e,n){const i=t.slice();return i[7]=e[n].id,i}function k1t(t){let e,n;return{c(){e=MB("div"),OB(e,"id",n=t[4].id)},m(t,n){TB(t,e,n)},p(t,i){8&i&&n!==(n=t[4].id)&&OB(e,"id",n)},d(t){t&&_B(e)}}}function C1t(t){let e,n,i=t[4],r=[];for(let e=0;e<i.length;e+=1)r[e]=T1t(S1t(t,i,e));return{c(){e=MB("div");for(let t=0;t<r.length;t+=1)r[t].c();n=AB(),OB(e,"class","flex flex-row flex-wrap items-stretch")},m(t,i){TB(t,e,i);for(let t=0;t<r.length;t+=1)r[t]&&r[t].m(e,null);SB(e,n)},p(t,s){if(8&s){let o;for(i=t[4],o=0;o<i.length;o+=1){const a=S1t(t,i,o);r[o]?r[o].p(a,s):(r[o]=T1t(a),r[o].c(),r[o].m(e,n))}for(;o<r.length;o+=1)r[o].d(1);r.length=i.length}},d(t){t&&_B(e),EB(r,t)}}}function T1t(t){let e,n;return{c(){e=MB("div"),OB(e,"id",n=t[7]),OB(e,"class","flex-none xl:flex-1 w-full xl:w-auto")},m(t,n){TB(t,e,n)},p(t,i){8&i&&n!==(n=t[7])&&OB(e,"id",n)},d(t){t&&_B(e)}}}function _1t(t){let e,n;function i(t,n){return 8&n&&(e=null),null==e&&(e=!!Array.isArray(t[4])),e?C1t:k1t}let r=i(t,-1),s=r(t);return{c(){s.c(),n=NB()},m(t,e){s.m(t,e),TB(t,n,e)},p(t,e){r===(r=i(t,e))&&s?s.p(t,e):(s.d(1),s=r(t),s&&(s.c(),s.m(n.parentNode,n)))},d(t){s.d(t),t&&_B(n)}}}function E1t(t){let e,n,i,r,s,o,a,l,c,u,h,d,p,f,m=t[3],g=[];for(let e=0;e<m.length;e+=1)g[e]=_1t(w1t(t,m,e));return{c(){e=MB("div"),n=MB("div"),i=MB("div"),r=MB("h3"),s=IB(t[0]),o=IB(".\n        "),a=IB(t[1]),l=AB(),c=MB("div"),u=MB("p"),h=IB(t[2]),d=AB(),p=MB("div"),f=MB("div");for(let t=0;t<g.length;t+=1)g[t].c();OB(r,"class","text-lg leading-6 font-medium text-gray-900"),OB(r,"id","modal-headline"),OB(u,"class","text-sm leading-5 text-gray-500"),OB(c,"class","mt-2"),OB(i,"class","desc svelte-tq2nfn"),OB(f,"class","text-center"),OB(p,"class","components svelte-tq2nfn"),OB(n,"class","flex flex-col w-full"),OB(e,"class","bg-white px-4 pt-2 pb-4 sm:px-6 sm:pb-4 flex")},m(t,m){TB(t,e,m),SB(e,n),SB(n,i),SB(i,r),SB(r,s),SB(r,o),SB(r,a),SB(i,l),SB(i,c),SB(c,u),SB(u,h),SB(n,d),SB(n,p),SB(p,f);for(let t=0;t<g.length;t+=1)g[t]&&g[t].m(f,null)},p(t,[e]){if(1&e&&DB(s,t[0]),2&e&&DB(a,t[1]),4&e&&DB(h,t[2]),8&e){let n;for(m=t[3],n=0;n<m.length;n+=1){const i=w1t(t,m,n);g[n]?g[n].p(i,e):(g[n]=_1t(i),g[n].c(),g[n].m(f,null))}for(;n<g.length;n+=1)g[n].d(1);g.length=m.length}},i:Jz,o:Jz,d(t){t&&_B(e),EB(g,t)}}}function M1t(t,e,n){let{index:i}=e,{title:r}=e,{description:s}=e,{components:o=[]}=e;return t.$$set=t=>{"index"in t&&n(0,i=t.index),"title"in t&&n(1,r=t.title),"description"in t&&n(2,s=t.description),"components"in t&&n(3,o=t.components)},[i,r,s,o]}let $1t=class extends UU{constructor(t){super(),BU(this,t,M1t,E1t,rB,{index:0,title:1,description:2,components:3})}};function I1t(t,e,n){const i=t.slice();return i[10]=e[n],i[12]=n,i}function A1t(t){let e;return{c(){e=IB("Close")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function N1t(t){let e,n,i;function r(){return t[6](t[12])}return{c(){e=MB("button"),OB(e,"class","page-button svelte-bhgsnx"),WB(e,"current",t[3]===t[12])},m(t,s){TB(t,e,s),n||(i=RB(e,"click",r),n=!0)},p(n,i){t=n,8&i&&WB(e,"current",t[3]===t[12])},d(t){t&&_B(e),n=!1,i()}}}function R1t(t){let e;return{c(){e=IB("Previous")},m(t,n){TB(t,e,n)},d(t){t&&_B(e)}}}function P1t(t){let e,n=t[3]>=t[0].length-1?"Finish":"Next";return{c(){e=IB(n)},m(t,n){TB(t,e,n)},p(t,i){9&i&&n!==(n=t[3]>=t[0].length-1?"Finish":"Next")&&DB(e,n)},d(t){t&&_B(e)}}}function O1t(t){let e,n,i,r,s,o,a,l,c,u,h,d,p,f,m,g,y,b,v,x;o=new $1t({props:{title:t[0][t[3]].attr.title,description:t[0][t[3]].attr.description,components:t[0][t[3]].components,index:t[3]+1}}),u=new HU({props:{type:"danger",$$slots:{default:[A1t]},$$scope:{ctx:t}}}),u.$on("click",t[2]);let w=Array(t[0].length),S=[];for(let e=0;e<w.length;e+=1)S[e]=N1t(I1t(t,w,e));return m=new HU({props:{disabled:t[3]<=0,$$slots:{default:[R1t]},$$scope:{ctx:t}}}),m.$on("click",t[7]),y=new HU({props:{variant:"filled",type:t[3]>=t[0].length-1?"success":"default",$$slots:{default:[P1t]},$$scope:{ctx:t}}}),y.$on("click",t[8]),{c(){e=MB("div"),n=MB("div"),i=MB("div"),r=AB(),s=MB("div"),DU(o.$$.fragment),a=AB(),l=MB("div"),c=MB("div"),DU(u.$$.fragment),h=AB(),d=MB("div");for(let t=0;t<S.length;t+=1)S[t].c();p=AB(),f=MB("div"),DU(m.$$.fragment),g=AB(),DU(y.$$.fragment),OB(i,"class","absolute inset-0 bg-gray-500 opacity-50"),OB(n,"class","absolute min-h-screen inset-0 transition-opacity"),OB(d,"class","text-center"),OB(f,"class","text-right"),OB(l,"class","bg-white border-t border-gray-300 px-4 py-2 grid grid-cols-3"),OB(s,"class","bg-white rounded-lg overflow-hidden shadow-xl transform transition-all sm:max-w-3xl sm:w-full"),OB(e,"class","marcelle wizard svelte-bhgsnx")},m(w,k){TB(w,e,k),SB(e,n),SB(n,i),SB(e,r),SB(e,s),FU(o,s,null),SB(s,a),SB(s,l),SB(l,c),FU(u,c,null),SB(l,h),SB(l,d);for(let t=0;t<S.length;t+=1)S[t]&&S[t].m(d,null);SB(l,p),SB(l,f),FU(m,f,null),SB(f,g),FU(y,f,null),b=!0,v||(x=[RB(i,"click",t[2]),RB(i,"keypress",PB(t[5]))],v=!0)},p(t,[e]){const n={};9&e&&(n.title=t[0][t[3]].attr.title),9&e&&(n.description=t[0][t[3]].attr.description),9&e&&(n.components=t[0][t[3]].components),8&e&&(n.index=t[3]+1),o.$set(n);const i={};if(8192&e&&(i.$$scope={dirty:e,ctx:t}),u.$set(i),25&e){let n;for(w=Array(t[0].length),n=0;n<w.length;n+=1){const i=I1t(t,w,n);S[n]?S[n].p(i,e):(S[n]=N1t(i),S[n].c(),S[n].m(d,null))}for(;n<S.length;n+=1)S[n].d(1);S.length=w.length}const r={};8&e&&(r.disabled=t[3]<=0),8192&e&&(r.$$scope={dirty:e,ctx:t}),m.$set(r);const s={};9&e&&(s.type=t[3]>=t[0].length-1?"success":"default"),8201&e&&(s.$$scope={dirty:e,ctx:t}),y.$set(s)},i(t){b||(EU(o.$$.fragment,t),EU(u.$$.fragment,t),EU(m.$$.fragment,t),EU(y.$$.fragment,t),b=!0)},o(t){MU(o.$$.fragment,t),MU(u.$$.fragment,t),MU(m.$$.fragment,t),MU(y.$$.fragment,t),b=!1},d(t){t&&_B(e),zU(o),zU(u),EB(S,t),zU(m),zU(y),v=!1,nB(x)}}}function L1t(t,e,n){let i,r=Jz,s=()=>(r(),r=aB(a,(t=>n(3,i=t))),a);t.$$.on_destroy.push((()=>r()));let{pages:o}=e,{current:a}=e;function l(t){if(t>=0&&t<=o.length-1){for(const t of o[a.get()].components)if(Array.isArray(t))for(const e of t)e.destroy();else t.destroy();a.set(t)}}s(),eU((()=>{for(const t of o[a.get()].components)if(Array.isArray(t))for(const e of t)e.mount();else t.mount()})),nU((()=>{for(const t of o[a.get()].components)if(Array.isArray(t))for(const e of t)e.destroy();else t.destroy()}));const c=iU();function u(){c("quit")}return t.$$set=t=>{"pages"in t&&n(0,o=t.pages),"current"in t&&s(n(1,a=t.current))},[o,a,u,i,l,t=>"Escape"===t.key&&u(),t=>l(t),()=>{l(i-1)},()=>{a.get()<o.length-1?l(i+1):u()}]}let D1t=class extends UU{constructor(t){super(),BU(this,t,L1t,O1t,rB,{pages:0,current:1,quit:2})}get quit(){return this.$$.ctx[2]}};class F1t{constructor(t){this.pageFn=t,this.components=[],this.attr={title:"",description:""}}title(t){return this.attr.title=t,this}description(t){return this.attr.description=t,this}use(...t){return this.components=this.components.concat(t),this}page(){return this.pageFn()}}class z1t{constructor(){this.pages=[],this.app=void 0,this.$current=new eK(0,!0),this.$current.start()}page(){const t=new F1t(this.page.bind(this));return this.pages.push(t),t}show(){this.app=new D1t({target:document.body,props:{pages:this.pages,current:this.$current}}),this.app.$on("quit",(()=>{var t;null===(t=this.app)||void 0===t||t.$destroy(),this.app=void 0}))}hide(){var t;null===(t=this.app)||void 0===t||t.quit()}}function B1t(){return new z1t}const U1t={LoadFail:0,BadSignature:1,BadTimestamp:2,BadSettingValue:3,BadFormat:4,UnknownSetting:5};class V1t extends Error{code;line;constructor(t){super(t.reason),this.code=t.code,this.line=t.line}}const W1t=/\r?\n|\r/gm;class H1t{writable;readable;constructor(t){const e=new j1t(t);this.writable=new WritableStream({write(t){e.transform(t)},close(){e.close()}}),this.readable=new ReadableStream({start(t){e.onLine=e=>t.enqueue(e),e.onClose=()=>t.close()}})}}class j1t{x="";y;onLine;onClose;constructor(t){this.y=new TextDecoder(t)}transform(t){this.x+=this.y.decode(t,{stream:!0});const e=this.x.split(W1t);this.x=e.pop()||"";for(let t=0;t<e.length;t++)this.onLine(e[t].trim())}close(){this.x&&this.onLine(this.x.trim()),this.x="",this.onClose()}}async function G1t(t,e){const n=e?.type??"vtt";let i,r;if("string"==typeof n)switch(n){case"srt":i=(await Promise.resolve().then((function(){return y3t}))).default;break;case"ssa":case"ass":i=(await Promise.resolve().then((function(){return $3t}))).default;break;default:i=(await Promise.resolve().then((function(){return g2t}))).default}else i=n;const s=t.getReader(),o=i(),a=!!e?.strict||!!e?.errors;await o.init({strict:!1,...e,errors:a,type:n,cancel(){s.cancel(),r=o.done(!0)}});let l=1;for(;;){const{value:t,done:e}=await s.read();if(e){o.parse("",l),r=o.done(!1);break}o.parse(t,l),l++}return r}async function q1t(t,{encoding:e="utf-8",...n}={}){return G1t(t.pipeThrough(new H1t(e)),n)}class X1t extends EventTarget{id="";startTime;endTime;text;pauseOnExit=!1;constructor(t,e,n){super(),this.startTime=t,this.endTime=e,this.text=n}addEventListener(t,e,n){super.addEventListener(t,e,n)}removeEventListener(t,e,n){super.removeEventListener(t,e,n)}}const K1t="undefined"==typeof document,Y1t=K1t?X1t:window.VTTCue;class Z1t extends Y1t{region=null;vertical="";snapToLines=!0;line="auto";lineAlign="start";position="auto";positionAlign="auto";size=100;align="center";style}class J1t{id="";width=100;lines=3;regionAnchorX=0;regionAnchorY=100;viewportAnchorX=0;viewportAnchorY=100;scroll=""}const Q1t="%";function t2t(t){const e=parseInt(t,10);return Number.isNaN(e)?null:e}function e2t(t){const e=parseInt(t.replace(Q1t,""),10);return!Number.isNaN(e)&&e>=0&&e<=100?e:null}function n2t(t){if(!t.includes(","))return null;const[e,n]=t.split(",").map(e2t);return null!==e&&null!==n?[e,n]:null}function i2t(t){const e=parseFloat(t);return Number.isNaN(e)?null:e}const r2t=/[:=]/,s2t=/^[\s\t]*(region|vertical|line|position|size|align)[:=]/,o2t=/^REGION:?[\s\t]+/,a2t=/[\s\t]+/,l2t=/[\s\t]*-->[\s\t]+/,c2t=/start|center|end|left|right/,u2t=/start|center|end/,h2t=/line-(?:left|right)|center|auto/,d2t=/^(?:(\d{1,2}):)?(\d{2}):(\d{2})(?:\.(\d{1,3}))?$/;var p2t=(t=>(t[t.None=0]="None",t[t.Header=1]="Header",t[t.Cue=2]="Cue",t[t.Region=3]="Region",t[t.Note=4]="Note",t))(p2t||{});class f2t{f;c=0;g={};h={};j=[];a=null;b=null;k=[];d;l="";async init(t){this.f=t,t.strict&&(this.c=1),t.errors&&(this.d=(await Promise.resolve().then((function(){return A3t}))).ParseErrorBuilder)}parse(t,e){if(""===t)this.a?(this.j.push(this.a),this.f.onCue?.(this.a),this.a=null):this.b?(this.h[this.b.id]=this.b,this.f.onRegion?.(this.b),this.b=null):1===this.c&&(this.i(t,e),this.f.onHeaderMetadata?.(this.g)),this.c=0;else if(this.c)switch(this.c){case 1:this.i(t,e);break;case 2:if(this.a){const n=this.a.text.length>0;!n&&s2t.test(t)?this.m(t.split(a2t),e):this.a.text+=(n?"\n":"")+t}break;case 3:this.n(t.split(a2t),e)}else if(t.startsWith("NOTE"))this.c=4;else if(t.startsWith("REGION"))this.c=3,this.b=new J1t,this.n(t.replace(o2t,"").split(a2t),e);else if(t.includes("--\x3e")){const n=this.o(t,e);n&&(this.a=new Z1t(n[0],n[1],""),this.a.id=this.l,this.m(n[2],e)),this.c=2}else 1===e&&this.i(t,e);this.l=t}done(){return{metadata:this.g,cues:this.j,regions:Object.values(this.h),errors:this.k}}i(t,e){if(e>1){if(r2t.test(t)){const[e,n]=t.split(r2t);e&&(this.g[e]=(n||"").replace(a2t,""))}}else t.startsWith("WEBVTT")?this.c=1:this.e(this.d?.p())}o(t,e){const[n,i=""]=t.split(l2t),[r,...s]=i.split(a2t),o=m2t(n),a=m2t(r);if(null!==o&&null!==a&&a>o)return[o,a,s];null===o&&this.e(this.d?.q(n,e)),null===a&&this.e(this.d?.r(r,e)),null!=o&&null!==a&&a>o&&this.e(this.d?.s(o,a,e))}n(t,e){let n;for(let i=0;i<t.length;i++)if(r2t.test(t[i])){n=!1;const[r,s]=t[i].split(r2t);switch(r){case"id":this.b.id=s;break;case"width":const t=e2t(s);null!==t?this.b.width=t:n=!0;break;case"lines":const i=t2t(s);null!==i?this.b.lines=i:n=!0;break;case"regionanchor":const o=n2t(s);null!==o?(this.b.regionAnchorX=o[0],this.b.regionAnchorY=o[1]):n=!0;break;case"viewportanchor":const a=n2t(s);null!==a?(this.b.viewportAnchorX=a[0],this.b.viewportAnchorY=a[1]):n=!0;break;case"scroll":"up"===s?this.b.scroll="up":n=!0;break;default:this.e(this.d?.t(r,s,e))}n&&this.e(this.d?.u(r,s,e))}}m(t,e){let n;for(let i=0;i<t.length;i++)if(n=!1,r2t.test(t[i])){const[r,s]=t[i].split(r2t);switch(r){case"region":const t=this.h[s];t&&(this.a.region=t);break;case"vertical":"lr"===s||"rl"===s?(this.a.vertical=s,this.a.region=null):n=!0;break;case"line":const[i,o]=s.split(",");if(i.includes("%")){const t=e2t(i);null!==t?(this.a.line=t,this.a.snapToLines=!1):n=!0}else{const t=i2t(i);null!==t?this.a.line=t:n=!0}u2t.test(o)?this.a.lineAlign=o:o&&(n=!0),"auto"!==this.a.line&&(this.a.region=null);break;case"position":const[a,l]=s.split(","),c=e2t(a);null!==c?this.a.position=c:n=!0,l&&h2t.test(l)?this.a.positionAlign=l:l&&(n=!0);break;case"size":const u=e2t(s);null!==u?(this.a.size=u,u<100&&(this.a.region=null)):n=!0;break;case"align":c2t.test(s)?this.a.align=s:n=!0;break;default:this.e(this.d?.v(r,s,e))}n&&this.e(this.d?.w(r,s,e))}}e(t){if(t){if(this.k.push(t),this.f.strict)throw this.f.cancel(),t;this.f.onError?.(t)}}}function m2t(t){const e=t.match(d2t);if(!e)return null;const n=e[1]?parseInt(e[1],10):0,i=parseInt(e[2],10),r=parseInt(e[3],10),s=e[4]?parseInt(e[4].padEnd(3,"0"),10):0;return n<0||i<0||r<0||s<0||i>59||r>59?null:3600*n+60*i+r+s/1e3}var g2t=Object.freeze({__proto__:null,VTTBlock:p2t,VTTParser:f2t,default:function(){return new f2t},parseVTTTimestamp:m2t});const y2t=/[0-9]/,b2t=/[\s\t]+/,v2t={c:"span",i:"i",b:"b",u:"u",ruby:"ruby",rt:"rt",v:"span",lang:"span",timestamp:"span"},x2t={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'","&nbsp;":"","&lrm;":"","&rlm;":""},w2t=/&(?:amp|lt|gt|quot|#(0+)?39|nbsp|lrm|rlm);/g,S2t=new Set(["white","lime","cyan","red","yellow","magenta","blue","black"]),k2t=new Set(Object.keys(v2t));function C2t(t){let e,n="",i=1,r=[],s=[];for(let r=0;r<t.text.length;r++){const c=t.text[r];switch(i){case 1:"<"===c?(l(),i=2):n+=c;break;case 2:switch(c){case"\n":case"\t":case" ":o(),i=4;break;case".":o(),i=3;break;case"/":i=5;break;case">":o(),i=1;break;default:!n&&y2t.test(c)&&(i=6),n+=c}break;case 3:switch(c){case"\t":case" ":case"\n":a(),e&&e.class?.trim(),i=4;break;case".":a();break;case">":a(),e&&e.class?.trim(),i=1;break;default:n+=c}break;case 4:">"===c?(n=n.replace(b2t," "),"v"===e?.type?e.voice=T2t(n):"lang"===e?.type&&(e.lang=T2t(n)),n="",i=1):n+=c;break;case 5:">"===c&&(n="",e=s.pop(),i=1);break;case 6:if(">"===c){const r=m2t(n);null!==r&&r>=t.startTime&&r<=t.endTime&&(n="timestamp",o(),e.time=r),n="",i=1}else n+=c}}function o(){if(k2t.has(n)){const i=e;e={tagName:v2t[t=n],type:t,children:[]},i?(s[s.length-1]!==i&&s.push(i),i.children.push(e)):r.push(e)}var t;n="",i=1}function a(){if(e&&n){const t=n.replace("bg_","");S2t.has(t)?e[n.startsWith("bg_")?"bgColor":"color"]=t:e.class=e.class?e.class+" "+n:n}n=""}function l(){if(!n)return;const t={type:"text",data:T2t(n)};e?e.children.push(t):r.push(t),n=""}return 1===i&&l(),r}function T2t(t){return t.replace(w2t,(t=>x2t[t]||"'"))}function _2t(t,e,n){t.style.setProperty(`--${e}`,n+"")}function E2t(t,e,n=!0){t.setAttribute(`data-${e}`,!0===n?"":n+"")}function M2t(t,e){t.setAttribute("data-part",e)}function $2t(t,e=0){return I2t(C2t(t),e)}function I2t(t,e=0){let n,i="";for(const r of t)if("text"===r.type)i+=r.data;else{const t="timestamp"===r.type;n={},n.class=r.class,n.title="v"===r.type&&r.voice,n.lang="lang"===r.type&&r.lang,n["data-part"]="v"===r.type&&"voice",t&&(n["data-part"]="timed",n["data-time"]=r.time,n["data-future"]=r.time>e,n["data-past"]=r.time<e),n.style=`${r.color?`color: ${r.color};`:""}${r.bgColor?`background-color: ${r.bgColor};`:""}`;const s=Object.entries(n).filter((t=>t[1])).map((t=>`${t[0]}="${!0===t[1]?"":t[1]}"`)).join(" ");i+=`<${r.tagName}${s?" "+s:""}>${I2t(r.children)}</${r.tagName}>`}return i}function A2t(t,e){if(!K1t)for(const n of t.querySelectorAll('[data-part="timed"]')){const t=Number(n.getAttribute("data-time"));Number.isNaN(t)||(t>e?E2t(n,"future"):n.removeAttribute("data-future"),t<e?E2t(n,"past"):n.removeAttribute("data-past"))}}const N2t=Symbol(0);function R2t(t){return t instanceof HTMLElement?{top:t.offsetTop,width:t.clientWidth,height:t.clientHeight,left:t.offsetLeft,right:t.offsetLeft+t.clientWidth,bottom:t.offsetTop+t.clientHeight}:{...t}}function P2t(t,e,n){switch(e){case"+x":t.left+=n,t.right+=n;break;case"-x":t.left-=n,t.right-=n;break;case"+y":t.top+=n,t.bottom+=n;break;case"-y":t.top-=n,t.bottom-=n}}function O2t(t,e){return t.left<=e.right&&t.right>=e.left&&t.top<=e.bottom&&t.bottom>=e.top}function L2t(t,e){for(let n=0;n<e.length;n++)if(O2t(t,e[n]))return e[n];return null}function D2t(t,e){return e.top>=0&&e.bottom<=t.height&&e.left>=0&&e.right<=t.width}function F2t(t,e,n){switch(n){case"+x":return e.left<0;case"-x":return e.right>t.width;case"+y":return e.top<0;case"-y":return e.bottom>t.height}}function z2t(t,e){return Math.max(0,Math.min(t.width,e.right)-Math.max(0,e.left))*Math.max(0,Math.min(t.height,e.bottom)-Math.max(0,e.top))/(t.height*t.width)}function B2t(t,e){return{top:e.top/t.height,left:e.left/t.width,right:(t.width-e.right)/t.width,bottom:(t.height-e.bottom)/t.height}}function U2t(t,e){return e.top=e.top*t.height,e.left=e.left*t.width,e.right=t.width-e.right*t.width,e.bottom=t.height-e.bottom*t.height,e}const V2t=["top","left","right","bottom"];function W2t(t,e,n,i){const r=B2t(e,n);for(const e of V2t)_2t(t,`${i}-${e}`,100*r[e]+"%")}function H2t(t,e,n,i){let r,s=1,o={...e};for(let a=0;a<i.length;a++){for(;F2t(t,e,i[a])||D2t(t,e)&&L2t(e,n);)P2t(e,i[a],1);if(D2t(t,e))return e;const l=z2t(t,e);s>l&&(r={...e},s=l),e={...o}}return r||o}const j2t=Symbol(0);function G2t(t,e,n,i){let r,s=n.firstElementChild,o=function(t){if("auto"===t.line)return t.snapToLines?-1:100;return t.line}(e),a=[];if(n[N2t]||(n[N2t]=function(t,e){const n=R2t(e),i=function(t){const e={};for(const n of V2t)e[n]=parseFloat(t.style.getPropertyValue(`--cue-${n}`));return e}(e);e[j2t]=!1,i.top&&(n.top=i.top,n.bottom=i.top+n.height,e[j2t]="top");if(i.bottom){const r=t.height-i.bottom;n.top=r-n.height,n.bottom=r,e[j2t]="bottom"}i.left&&(n.left=i.left);i.right&&(n.right=t.width-i.right);return B2t(t,n)}(t,n)),r=U2t(t,{...n[N2t]}),n[j2t])a=["top"===n[j2t]?"+y":"-y","+x","-x"];else if(e.snapToLines){let n;switch(e.vertical){case"":a=["+y","-y"],n="height";break;case"rl":a=["+x","-x"],n="width";break;case"lr":a=["-x","+x"],n="width"}let i=parseFloat(getComputedStyle(s).lineHeight)||0,l=i*Math.round(o),c=t[n]+i,u=a[0];Math.abs(l)>c&&(l=l<0?-1:1,l*=Math.ceil(c/i)*i),o<0&&(l+=""===e.vertical?t.height:t.width,a=a.reverse()),P2t(r,u,l)}else{const n=""===e.vertical,i=n?"+y":"+x",s=n?r.height:r.width;P2t(r,i,(n?t.height:t.width)*o/100),P2t(r,i,"center"===e.lineAlign?s/2:"end"===e.lineAlign?s:0),a=n?["-y","+y","-x","+x"]:["-x","+x","-y","+y"]}return r=H2t(t,r,i,a),W2t(n,t,r,"cue"),r}const q2t=["-y","+y","-x","+x"];function X2t(t,e,n,i){let r=Array.from(n.querySelectorAll('[data-part="cue-display"]')),s=0,o=Math.max(0,r.length-e.lines);for(let t=r.length-1;t>=o;t--)s+=r[t].offsetHeight;_2t(n,"region-height",s+"px"),n[N2t]||(n[N2t]=B2t(t,R2t(n)));let a={...n[N2t]};return a=U2t(t,a),a.width=n.clientWidth,a.height=s,a.right=a.left+a.width,a.bottom=a.top+s,a=H2t(t,a,i,q2t),W2t(n,t,a,"region"),a}var K2t=Object.freeze({__proto__:null,CaptionsRenderer:class{overlay;z;A=0;C="ltr";B=[];D=!1;E;h=new Map;j=new Map;get dir(){return this.C}set dir(t){this.C=t,E2t(this.overlay,"dir",t)}get currentTime(){return this.A}set currentTime(t){this.A=t,this.update()}constructor(t,e){this.overlay=t,this.dir=e?.dir??"ltr",t.setAttribute("translate","yes"),t.setAttribute("aria-live","off"),t.setAttribute("aria-atomic","true"),M2t(t,"captions"),this.G(),this.E=new ResizeObserver(this.I.bind(this)),this.E.observe(t)}changeTrack({regions:t,cues:e}){this.reset(),this.J(t);for(const t of e)this.j.set(t,null);this.update()}addCue(t){this.j.set(t,null),this.update()}removeCue(t){this.j.delete(t),this.update()}update(t=!1){this.H(t)}reset(){this.j.clear(),this.h.clear(),this.B=[],this.overlay.textContent=""}destroy(){this.reset(),this.E.disconnect()}I(){this.D=!0,this.K()}K=function(t,e){let n,i=null;function r(){s(),t(...n),n=void 0}function s(){clearTimeout(i),i=null}return function(){n=[].slice.call(arguments),s(),i=setTimeout(r,e)}}((()=>{this.D=!1,this.G();for(const t of this.h.values())t[N2t]=null;for(const t of this.j.values())t&&(t[N2t]=null);this.H(!0)}),50);G(){this.z=R2t(this.overlay),_2t(this.overlay,"overlay-width",this.z.width+"px"),_2t(this.overlay,"overlay-height",this.z.height+"px")}H(t=!1){if(!this.j.size||this.D)return;let e,n=[...this.j.keys()].filter((t=>this.A>=t.startTime&&this.A<=t.endTime)).sort(((t,e)=>t.startTime!==e.startTime?t.startTime-e.startTime:t.endTime-e.endTime)),i=n.map((t=>t.region));for(let r=0;r<this.B.length;r++){if(e=this.B[r],n[r]===e)continue;if(e.region&&!i.includes(e.region)){const n=this.h.get(e.region.id);n&&(n.removeAttribute("data-active"),t=!0)}const s=this.j.get(e);s&&(s.remove(),t=!0)}for(let i=0;i<n.length;i++){e=n[i];let r=this.j.get(e);r||this.j.set(e,r=this.L(e));const s=this.F(e)&&this.h.get(e.region.id);s&&!s.hasAttribute("data-active")&&(requestAnimationFrame((()=>E2t(s,"active"))),t=!0),r.isConnected||((s||this.overlay).append(r),t=!0)}if(t){const t=[],i=new Set;for(let r=n.length-1;r>=0;r--){if(e=n[r],i.has(e.region||e))continue;const s=this.F(e),o=s?this.h.get(e.region.id):this.j.get(e);s?t.push(X2t(this.z,e.region,o,t)):t.push(G2t(this.z,e,o,t)),i.add(s?e.region:e)}}A2t(this.overlay,this.A),this.B=n}J(t){if(t)for(const e of t){const t=this.M(e);this.h.set(e.id,t),this.overlay.append(t)}}M(t){const e=document.createElement("div");return M2t(e,"region"),E2t(e,"id",t.id),E2t(e,"scroll",t.scroll),_2t(e,"region-width",t.width+"%"),_2t(e,"region-anchor-x",t.regionAnchorX),_2t(e,"region-anchor-y",t.regionAnchorY),_2t(e,"region-viewport-anchor-x",t.viewportAnchorX),_2t(e,"region-viewport-anchor-y",t.viewportAnchorY),_2t(e,"region-lines",t.lines),e}L(t){const e=document.createElement("div"),n=function(t){if("auto"===t.position)switch(t.align){case"start":case"left":return 0;case"right":case"end":return 100;default:return 50}return t.position}(t),i=function(t,e){if("auto"===t.positionAlign)switch(t.align){case"start":return"ltr"===e?"line-left":"line-right";case"end":return"ltr"===e?"line-right":"line-left";case"center":return"center";default:return`line-${t.align}`}return t.positionAlign}(t,this.C);if(M2t(e,"cue-display"),""!==t.vertical&&E2t(e,"vertical"),_2t(e,"cue-text-align",t.align),t.style)for(const n of Object.keys(t.style))e.style.setProperty(n,t.style[n]);if(this.F(t))_2t(e,"cue-offset",n-("line-right"===i?100:"center"===i?50:0)+"%");else if(_2t(e,"cue-writing-mode",""===t.vertical?"horizontal-tb":"lr"===t.vertical?"vertical-lr":"vertical-rl"),!t.style?.["--cue-width"]){let r=n;"line-left"===i?r=100-n:"center"===i&&n<=50?r=2*n:"center"===i&&n>50&&(r=2*(100-n));const s=t.size<r?t.size:r;""===t.vertical?_2t(e,"cue-width",s+"%"):_2t(e,"cue-height",s+"%")}const r=document.createElement("div");return M2t(r,"cue"),t.id&&E2t(r,"id",t.id),r.innerHTML=$2t(t),e.append(r),e}F(t){return t.region&&100===t.size&&""===t.vertical&&"auto"===t.line}},ParseError:V1t,ParseErrorCode:U1t,TextCue:X1t,VTTCue:Z1t,VTTRegion:J1t,createVTTCueTemplate:function(t){if(K1t)throw Error("[media-captions] called `createVTTCueTemplate` on the server - use `renderVTTCueString`");const e=document.createElement("template");return e.innerHTML=$2t(t),{cue:t,content:e.content}},parseByteStream:q1t,parseResponse:async function(t,e){const n=await t;if(!n.ok||!n.body){let t;return{metadata:{},cues:[],regions:[],errors:[t]}}const i=n.headers.get("content-type")||"",r=i.match(/text\/(.*?)(?:;|$)/)?.[1],s=i.match(/charset=(.*?)(?:;|$)/)?.[1];return q1t(n.body,{type:r,encoding:s,...e})},parseText:async function(t,e){return G1t(new ReadableStream({start(e){const n=t.split(W1t);for(const t of n)e.enqueue(t);e.close()}}),e)},parseTextStream:G1t,parseVTTTimestamp:m2t,renderVTTCueString:$2t,renderVTTTokensString:I2t,tokenizeVTTCue:C2t,updateTimedVTTCueNodes:A2t});class Y2t{constructor(t){this.sa=t}ia(){nHt(this.de)&&this.yh()}ja(){iHt(this.de)&&window.cancelAnimationFrame(this.de),this.de=void 0}yh(){this.de=window.requestAnimationFrame((()=>{nHt(this.de)||(this.sa(),this.yh())}))}}class Z2t{constructor(t,e){this.va=function(){const t=HHt();return RWt(t.empty),t}(),this.Na=!1,this.Pa=!1,this.Qa=!1,this.Oa=new Y2t(this.Va.bind(this)),this.Ua=void 0,this.qb=void 0,this.Ra=t,this.U=e,this.Wa(),kHt(this.Xa.bind(this)),RWt(this.Aa.bind(this))}get g(){return this.Ra.media}get Ka(){return this.U.delegate}Aa(){this.Pa=!1,this.Qa=!1,this.Oa.ja(),this.va.empty()}Va(){const t=this.Ra.currentTime;this.U.$state.currentTime()!==t&&this.Ma(t)}Wa(){this.La("loadstart",this.pa),this.La("abort",this.Ta),this.La("emptied",this.Ya),this.La("error",this.X)}Za(){this.Pa||(this.va.add(this.La("loadeddata",this._a),this.La("loadedmetadata",this.$a),this.La("canplay",this.ab),this.La("canplaythrough",this.bb),this.La("durationchange",this.cb),this.La("play",this.db),this.La("progress",this.eb),this.La("stalled",this.fb),this.La("suspend",this.gb)),this.Pa=!0)}hb(){this.Qa||(this.va.add(this.La("pause",this.ib),this.La("playing",this.jb),this.La("ratechange",this.kb),this.La("seeked",this.lb),this.La("seeking",this.mb),this.La("ended",this.nb),this.La("volumechange",this.ob),this.La("waiting",this.pb)),this.Qa=!0)}La(t,e){return pHt(this.g,t,e.bind(this))}rb(t){}Ma(t,e){this.Ka.f("time-update",{detail:{currentTime:Math.min(t,this.U.$state.seekableEnd()),played:this.g.played},trigger:e})}pa(t){3!==this.g.networkState?(this.Za(),this.Ka.f("load-start",{trigger:t})):this.Ta(t)}Ta(t){this.Ka.f("abort",{trigger:t})}Ya(){this.Ka.f("emptied",{trigger:event})}_a(t){this.Ka.f("loaded-data",{trigger:t})}$a(t){this.hb(),this.Ka.f("volume-change",{detail:{volume:this.g.volume,muted:this.g.muted}}),this.Ka.f("loaded-metadata",{trigger:t}),_Gt&&zGt(this.U.$state.source())&&this.Ka.sb(this.Sa(),t)}Sa(){return{duration:this.g.duration,buffered:this.g.buffered,seekable:this.g.seekable}}db(t){this.U.$state.canPlay&&this.Ka.f("play",{trigger:t})}ib(t){(1!==this.g.readyState||this.Na)&&(this.Na=!1,this.Oa.ja(),this.Ka.f("pause",{trigger:t}))}ab(t){this.Ka.sb(this.Sa(),t)}bb(t){this.U.$state.started()||this.Ka.f("can-play-through",{trigger:t,detail:this.Sa()})}jb(t){this.Na=!1,this.Ka.f("playing",{trigger:t}),this.Oa.ia()}fb(t){this.Ka.f("stalled",{trigger:t}),this.g.readyState<3&&(this.Na=!0,this.Ka.f("waiting",{trigger:t}))}pb(t){this.g.readyState<3&&(this.Na=!0,this.Ka.f("waiting",{trigger:t}))}nb(t){this.Oa.ja(),this.Ma(this.g.duration,t),this.Ka.f("end",{trigger:t}),this.U.$state.loop()?this.tb():this.Ka.f("ended",{trigger:t})}Xa(){this.U.$state.paused()&&pHt(this.g,"timeupdate",this.ub.bind(this))}ub(t){this.Ma(this.g.currentTime,t)}cb(t){this.U.$state.ended()&&this.Ma(this.g.duration,t),this.Ka.f("duration-change",{detail:this.g.duration,trigger:t})}ob(t){this.Ka.f("volume-change",{detail:{volume:this.g.volume,muted:this.g.muted},trigger:t})}lb(t){this.Ma(this.g.currentTime,t),this.Ka.f("seeked",{detail:this.g.currentTime,trigger:t}),Math.trunc(this.g.currentTime)===Math.trunc(this.g.duration)&&UGt(this.g.duration)>UGt(this.g.currentTime)&&(this.Ma(this.g.duration,t),this.g.ended||this.U.player.dispatch(new cHt("media-play-request",{trigger:t})))}mb(t){this.Ka.f("seeking",{detail:this.g.currentTime,trigger:t})}eb(t){this.Ka.f("progress",{detail:{buffered:this.g.buffered,seekable:this.g.seekable},trigger:t})}tb(){var t;(eHt(t=this.g.controls)||nHt(t))&&(this.g.controls=!1),this.U.player.dispatch(new cHt("media-loop-request"))}gb(t){this.Ka.f("suspend",{trigger:t})}kb(t){this.Ka.f("rate-change",{detail:this.g.playbackRate,trigger:t})}X(t){const e=this.g.error;e&&this.Ka.f("error",{detail:{message:e.message,code:e.code,mediaError:e},trigger:t})}}class J2t{constructor(t,e){this.Ra=t,this.ya=e,this.vb.onaddtrack=this.xb.bind(this),this.vb.onremovetrack=this.yb.bind(this),this.vb.onchange=this.zb.bind(this),pHt(this.ya.audioTracks,"change",this.Ab.bind(this))}get vb(){return this.Ra.media.audioTracks}xb(t){const e=t.track;if(""===e.label)return;const n={id:e.id+"",label:e.label,language:e.language,kind:e.kind,selected:!1};this.ya.audioTracks[wGt.F](n,t),e.enabled&&(n.selected=!0)}yb(t){const e=this.ya.audioTracks.getById(t.track.id);e&&this.ya.audioTracks[wGt.D](e,t)}zb(t){let e=this.wb();if(!e)return;const n=this.ya.audioTracks.getById(e.id);n&&this.ya.audioTracks[wGt.ha](n,!0,t)}wb(){return Array.from(this.vb).find((t=>t.enabled))}Ab(t){const{current:e}=t.detail;if(!e)return;const n=this.vb.getTrackById(e.id);if(n){const t=this.wb();t&&(t.enabled=!1),n.enabled=!0}}}class Q2t{constructor(t){this.scope=HWt(),this.h=null,this.g=t}setup(t){new Z2t(this,t),"audioTracks"in this.media&&new J2t(this,t),RWt((()=>{this.g.setAttribute("src",""),this.g.load()}))}get type(){return""}get media(){return this.g}get currentSrc(){return this.h}get paused(){return this.g.paused}get muted(){return this.g.muted}set muted(t){this.g.muted=t}get volume(){return this.g.volume}set volume(t){this.g.volume=t}get currentTime(){return this.g.currentTime}set currentTime(t){this.g.currentTime=t}get playsinline(){return this.g.hasAttribute("playsinline")}set playsinline(t){bHt(this.g,"playsinline",t)}get playbackRate(){return this.g.playbackRate}set playbackRate(t){this.g.playbackRate=t}async play(){return this.g.play()}async pause(){return this.g.pause()}async loadSource({src:t,type:e},n){this.g.preload=n||"",!function(t){return void 0!==window.MediaStream&&t instanceof window.MediaStream}(t)?(this.g.srcObject=null,this.g.src=rHt(t)?t:window.URL.createObjectURL(t)):this.g.srcObject=t,this.g.load(),this.h={src:t,type:e}}}var t3t=Object.freeze({__proto__:null,AudioProvider:class extends Q2t{constructor(){super(...arguments),this.$$PROVIDER_TYPE="AUDIO"}get type(){return"audio"}setup(t){super.setup(t),"audio"===this.type&&t.delegate.f("provider-setup",{detail:this})}get audio(){return this.g}}});class e3t{constructor(t,e){this.v=t,this.ya=e,t.textTracks.onaddtrack=this.za.bind(this),RWt(this.Aa.bind(this))}za(t){const e=t.track;if(!e||function(t,e){return Array.from(t.children).find((t=>t.track===e))}(this.v,e))return;const n=new aGt({id:e.id,kind:e.kind,label:e.label,language:e.language,type:"vtt"});n[eGt.Ba]={track:e},n[eGt.ka]=2,n[eGt.Ca]=!0;let i=0;const r=t=>{if(e.cues)for(let r=i;r<e.cues.length;r++)n.addCue(e.cues[r],t),i++};r(t),e.oncuechange=r,this.ya.textTracks.add(n,t),n.setMode(e.mode,t)}Aa(){this.v.textTracks.onaddtrack=null;for(const t of this.ya.textTracks){const e=t[eGt.Ba]?.track;e?.oncuechange&&(e.oncuechange=null)}}}class n3t{constructor(t,e){this.Da=(t,e)=>{this.g.delegate.f("picture-in-picture-change",{detail:t,trigger:e})},this.v=t,this.g=e,pHt(this.v,"enterpictureinpicture",this.Ea.bind(this)),pHt(this.v,"leavepictureinpicture",this.Fa.bind(this))}get active(){return document.pictureInPictureElement===this.v}get supported(){return $Gt(this.v)}async enter(){return this.v.requestPictureInPicture()}exit(){return document.exitPictureInPicture()}Ea(t){this.Da(!0,t)}Fa(t){this.Da(!1,t)}}class i3t{constructor(t,e){this.Ga="inline",this.v=t,this.g=e,pHt(this.v,"webkitpresentationmodechanged",this.la.bind(this))}get Ja(){return IGt(this.v)}async Ia(t){this.Ga!==t&&this.v.webkitSetPresentationMode(t)}la(){const t=this.Ga;this.Ga=this.v.webkitPresentationMode,this.g.player?.dispatch(new cHt("video-presentation-change",{detail:this.Ga,trigger:event})),["fullscreen","picture-in-picture"].forEach((e=>{this.Ga!==e&&t!==e||this.g.delegate.f(`${e}-change`,{detail:this.Ga===e,trigger:event})}))}}class r3t{constructor(t){this.Ha=t}get active(){return"fullscreen"===this.Ha.Ga}get supported(){return this.Ha.Ja}async enter(){this.Ha.Ia("fullscreen")}async exit(){this.Ha.Ia("inline")}}class s3t{constructor(t){this.Ha=t}get active(){return"picture-in-picture"===this.Ha.Ga}get supported(){return this.Ha.Ja}async enter(){this.Ha.Ia("picture-in-picture")}async exit(){this.Ha.Ia("inline")}}class o3t extends Q2t{constructor(t,e){super(t),this.$$PROVIDER_TYPE="VIDEO",AWt((()=>{if(IGt(t)){const n=new i3t(t,e);this.fullscreen=new r3t(n),this.pictureInPicture=new s3t(n)}else $Gt(t)&&(this.pictureInPicture=new n3t(t,e))}),this.scope)}get type(){return"video"}setup(t){super.setup(t),MGt(this.video)&&new e3t(this.video,t),t.textRenderers.j(this.video),RWt((()=>{t.textRenderers.j(null)})),"video"===this.type&&t.delegate.f("provider-setup",{detail:this})}get video(){return this.g}}var a3t=Object.freeze({__proto__:null,VideoProvider:o3t});class l3t{constructor(t){this.T=null,this.V=null,this.d={},this.e=new Set,this.v=t}get instance(){return this.T}setup(t,e){this.U=e;const n=MWt(e.$state.streamType).includes("live"),i=MWt(e.$state.streamType).includes("ll-");this.T=new t({lowLatencyMode:i,backBufferLength:i?4:n?8:void 0,renderTextTracksNatively:!1,...this.d});const r=this.W.bind(this);for(const e of Object.values(t.Events))this.T.on(e,r);this.T.on(t.Events.ERROR,this.X.bind(this));for(const t of this.e)t(this.T);e.player.dispatch(new cHt("hls-instance",{detail:this.T})),this.T.attachMedia(this.v),this.T.on(t.Events.AUDIO_TRACK_SWITCHED,this.Y.bind(this)),this.T.on(t.Events.LEVEL_SWITCHED,this.Z.bind(this)),this.T.on(t.Events.LEVEL_LOADED,this._.bind(this)),this.T.on(t.Events.NON_NATIVE_TEXT_TRACKS_FOUND,this.$.bind(this)),this.T.on(t.Events.CUES_PARSED,this.aa.bind(this)),e.qualities[GGt]=this.ca.bind(this),pHt(e.qualities,"change",this.da.bind(this)),pHt(e.audioTracks,"change",this.ea.bind(this)),this.V=kHt(this.fa.bind(this))}fa(){if(!this.U.$state.live())return;const t=new Y2t(this.ga.bind(this));return t.ia(),t.ja.bind(t)}ga(){this.U.$state.liveSyncPosition.set(this.T?.liveSyncPosition??1/0)}W(t,e){this.U.player?.dispatch(new cHt(BHt(t),{detail:e}))}$(t,e){const n=new cHt(t,{detail:e});let i=-1;for(let t=0;t<e.tracks.length;t++){const r=e.tracks[t],s=r.subtitleTrack??r.closedCaptions,o=new aGt({id:`hls-${r.kind}${t}`,src:s?.url,label:r.label,language:s?.lang,kind:r.kind});o[eGt.ka]=2,o[eGt.la]=()=>{"showing"===o.mode?(this.T.subtitleTrack=t,i=t):i===t&&(this.T.subtitleTrack=-1,i=-1)},r.default&&o.setMode("showing",n),this.U.textTracks.add(o,n)}}aa(t,e){const n=this.U.textTracks.getById(`hls-${e.track}`);if(!n)return;const i=new cHt(t,{detail:e});for(const t of e.cues)t.positionAlign="auto",n.addCue(t,i)}Y(t,e){const n=this.U.audioTracks[e.id];n&&this.U.audioTracks[wGt.ha](n,!0,new cHt(t,{detail:e}))}Z(t,e){const n=this.U.qualities[e.level];n&&this.U.qualities[wGt.ha](n,!0,new cHt(t,{detail:e}))}_(t,e){if(this.U.$state.canPlay())return;const{type:n,live:i,totalduration:r,targetduration:s}=e.details,o=new cHt(t,{detail:e});this.U.delegate.f("stream-type-change",{detail:i?"EVENT"===n&&Number.isFinite(r)&&s>=10?"live:dvr":"live":"on-demand",trigger:o}),this.U.delegate.f("duration-change",{detail:r,trigger:o});const a=this.T.media;-1===this.T.currentLevel&&this.U.qualities[jGt](!0,o);for(const t of this.T.audioTracks)this.U.audioTracks[wGt.F]({id:t.id+"",label:t.name,language:t.lang||"",kind:"main"},o);for(const t of this.T.levels)this.U.qualities[wGt.F]({width:t.width,height:t.height,codec:t.codecSet,bitrate:t.bitrate},o);a.dispatchEvent(new cHt("canplay",{trigger:o}))}X(t,e){if(e.fatal)switch(e.type){case"networkError":this.T?.startLoad();break;case"mediaError":this.T?.recoverMediaError();break;default:this.T?.destroy(),this.T=null}}ca(){this.T&&(this.T.currentLevel=-1)}da(){const{qualities:t}=this.U;this.T&&!t.auto&&(this.T[t.switch+"Level"]=t.selectedIndex,TGt&&(this.v.currentTime=this.v.currentTime))}ea(){const{audioTracks:t}=this.U;this.T&&this.T.audioTrack!==t.selectedIndex&&(this.T.audioTrack=t.selectedIndex)}i(){this.U&&(this.U.qualities[GGt]=void 0),this.T?.destroy(),this.T=null,this.V?.(),this.V=null}}class c3t{constructor(t,e,n){this.na=t,this.U=e,this.sa=n,this.oa()}async oa(){const t={onLoadStart:this.pa.bind(this),onLoaded:this.qa.bind(this),onLoadError:this.ra.bind(this)};let e=await async function(t,e={}){if(!rHt(t))return;e.onLoadStart?.();try{if(await function(t){if(Qjt[t])return Qjt[t].promise;const e=jHt();if(!eHt(document.querySelector(`script[src="${t}"]`)))return e.resolve(),e.promise;const n=document.createElement("script");return n.src=t,n.onload=()=>{e.resolve(),delete Qjt[t]},n.onerror=()=>{e.reject(),delete Qjt[t]},setTimeout((()=>document.head.append(n)),0),e.promise}(t),!sHt(window.Hls))throw Error("");const n=window.Hls;return e.onLoaded?.(n),n}catch(t){e.onLoadError?.(t)}return}(this.na,t);if(nHt(e)&&!rHt(this.na)&&(e=await async function(t,e={}){if(nHt(t))return;if(e.onLoadStart?.(),t.prototype&&t.prototype!==Function)return e.onLoaded?.(t),t;try{const n=(await t())?.default;if(!n||!n.isSupported)throw Error("");return e.onLoaded?.(n),n}catch(t){e.onLoadError?.(t)}return}(this.na,t)),!e)return null;if(!e.isSupported()){const t="[vidstack]: `hls.js` is not supported in this environment";return this.U.player.dispatch(new cHt("hls-unsupported")),this.U.delegate.f("error",{detail:{message:t,code:4}}),null}return e}pa(){this.U.player.dispatch(new cHt("hls-lib-load-start"))}qa(t){this.U.player.dispatch(new cHt("hls-lib-loaded",{detail:t})),this.sa(t)}ra(t){const e=qGt(t);this.U.player.dispatch(new cHt("hls-lib-load-error",{detail:e})),this.U.delegate.f("error",{detail:{message:e.message,code:4}})}}class u3t extends o3t{constructor(){super(...arguments),this.$$PROVIDER_TYPE="HLS",this.c=null,this.a=new l3t(this.video),this.b="https://cdn.jsdelivr.net/npm/hls.js@^1.0.0/dist/hls.min.js"}get ctor(){return this.c}get instance(){return this.a.instance}static{this.supported=NGt()}get type(){return"hls"}get canLiveSync(){return!0}get config(){return this.a.d}set config(t){this.a.d=t}get library(){return this.b}set library(t){this.b=t}preconnect(){rHt(this.b)&&Jjt(this.b)}setup(t){super.setup(t),new c3t(this.b,t,(e=>{this.c=e,this.a.setup(e,t),t.delegate.f("provider-setup",{detail:this});const n=MWt(t.$state.source);n&&this.loadSource(n)}))}async loadSource(t,e){rHt(t.src)&&(this.g.preload=e||"",this.a.instance?.loadSource(t.src),this.h=t)}onInstance(t){const e=this.a.instance;return e&&t(e),this.a.e.add(t),()=>this.a.e.delete(t)}destroy(){this.a.i()}}var h3t=Object.freeze({__proto__:null,HLSProvider:u3t}),d3t='<path fill-rule="evenodd" clip-rule="evenodd" d="M4.6661 6.66699C4.29791 6.66699 3.99943 6.96547 3.99943 7.33366V24.667C3.99943 25.0352 4.29791 25.3337 4.6661 25.3337H27.3328C27.701 25.3337 27.9994 25.0352 27.9994 24.667V7.33366C27.9994 6.96547 27.701 6.66699 27.3328 6.66699H4.6661ZM8.66667 21.3333C8.29848 21.3333 8 21.0349 8 20.6667V11.3333C8 10.9651 8.29848 10.6667 8.66667 10.6667H14C14.3682 10.6667 14.6667 10.9651 14.6667 11.3333V12.6667C14.6667 13.0349 14.3682 13.3333 14 13.3333H10.8C10.7264 13.3333 10.6667 13.393 10.6667 13.4667V18.5333C10.6667 18.607 10.7264 18.6667 10.8 18.6667H14C14.3682 18.6667 14.6667 18.9651 14.6667 19.3333V20.6667C14.6667 21.0349 14.3682 21.3333 14 21.3333H8.66667ZM18 21.3333C17.6318 21.3333 17.3333 21.0349 17.3333 20.6667V11.3333C17.3333 10.9651 17.6318 10.6667 18 10.6667H23.3333C23.7015 10.6667 24 10.9651 24 11.3333V12.6667C24 13.0349 23.7015 13.3333 23.3333 13.3333H20.1333C20.0597 13.3333 20 13.393 20 13.4667V18.5333C20 18.607 20.0597 18.6667 20.1333 18.6667H23.3333C23.7015 18.6667 24 18.9651 24 19.3333V20.6667C24 21.0349 23.7015 21.3333 23.3333 21.3333H18Z" fill="currentColor"/>';const p3t={play:'<path d="M10.6667 6.6548C10.6667 6.10764 11.2894 5.79346 11.7295 6.11862L24.377 15.4634C24.7377 15.7298 24.7377 16.2692 24.3771 16.5357L11.7295 25.8813C11.2895 26.2065 10.6667 25.8923 10.6667 25.3451L10.6667 6.6548Z" fill="currentColor"/>',pause:'<path d="M8.66667 6.66667C8.29848 6.66667 8 6.96514 8 7.33333V24.6667C8 25.0349 8.29848 25.3333 8.66667 25.3333H12.6667C13.0349 25.3333 13.3333 25.0349 13.3333 24.6667V7.33333C13.3333 6.96514 13.0349 6.66667 12.6667 6.66667H8.66667Z" fill="currentColor"/> <path d="M19.3333 6.66667C18.9651 6.66667 18.6667 6.96514 18.6667 7.33333V24.6667C18.6667 25.0349 18.9651 25.3333 19.3333 25.3333H23.3333C23.7015 25.3333 24 25.0349 24 24.6667V7.33333C24 6.96514 23.7015 6.66667 23.3333 6.66667H19.3333Z" fill="currentColor"/>',replay:'<path d="M15.6038 12.2147C16.0439 12.5399 16.6667 12.2257 16.6667 11.6786V10.1789C16.6667 10.1001 16.7351 10.0384 16.8134 10.0479C20.1116 10.4494 22.6667 13.2593 22.6667 16.6659C22.6667 20.3481 19.6817 23.3332 15.9995 23.3332C12.542 23.3332 9.69927 20.7014 9.36509 17.332C9.32875 16.9655 9.03371 16.6662 8.66548 16.6662L6.66655 16.6666C6.29841 16.6666 5.99769 16.966 6.02187 17.3334C6.36494 22.5454 10.7012 26.6667 16 26.6667C21.5228 26.6667 26 22.1895 26 16.6667C26 11.4103 21.9444 7.10112 16.7916 6.69757C16.7216 6.69209 16.6667 6.63396 16.6667 6.56372V4.98824C16.6667 4.44106 16.0439 4.12689 15.6038 4.45206L11.0765 7.79738C10.7159 8.06387 10.7159 8.60326 11.0766 8.86973L15.6038 12.2147Z" fill="currentColor"/>',mute:'<path d="M17.5091 24.6594C17.5091 25.2066 16.8864 25.5208 16.4463 25.1956L9.44847 20.0252C9.42553 20.0083 9.39776 19.9991 9.36923 19.9991H4.66667C4.29848 19.9991 4 19.7006 4 19.3325V12.6658C4 12.2976 4.29848 11.9991 4.66667 11.9991H9.37115C9.39967 11.9991 9.42745 11.99 9.45039 11.973L16.4463 6.8036C16.8863 6.47842 17.5091 6.79259 17.5091 7.33977L17.5091 24.6594Z" fill="currentColor"/> <path d="M28.8621 13.6422C29.1225 13.3818 29.1225 12.9597 28.8621 12.6994L27.9193 11.7566C27.659 11.4962 27.2368 11.4962 26.9765 11.7566L24.7134 14.0197C24.6613 14.0717 24.5769 14.0717 24.5248 14.0197L22.262 11.7568C22.0016 11.4964 21.5795 11.4964 21.3191 11.7568L20.3763 12.6996C20.116 12.9599 20.116 13.382 20.3763 13.6424L22.6392 15.9053C22.6913 15.9573 22.6913 16.0418 22.6392 16.0938L20.3768 18.3562C20.1165 18.6166 20.1165 19.0387 20.3768 19.299L21.3196 20.2419C21.58 20.5022 22.0021 20.5022 22.2624 20.2418L24.5248 17.9795C24.5769 17.9274 24.6613 17.9274 24.7134 17.9795L26.976 20.2421C27.2363 20.5024 27.6585 20.5024 27.9188 20.2421L28.8616 19.2992C29.122 19.0389 29.122 18.6168 28.8616 18.3564L26.599 16.0938C26.547 16.0418 26.547 15.9573 26.599 15.9053L28.8621 13.6422Z" fill="currentColor"/>',"volume-low":'<path d="M17.5091 24.6594C17.5091 25.2066 16.8864 25.5207 16.4463 25.1956L9.44847 20.0252C9.42553 20.0083 9.39776 19.9991 9.36923 19.9991H4.66667C4.29848 19.9991 4 19.7006 4 19.3324V12.6658C4 12.2976 4.29848 11.9991 4.66667 11.9991H9.37115C9.39967 11.9991 9.42745 11.99 9.45039 11.973L16.4463 6.80358C16.8863 6.4784 17.5091 6.79258 17.5091 7.33975L17.5091 24.6594Z" fill="currentColor"/> <path d="M22.8424 12.6667C22.8424 12.2985 22.544 12 22.1758 12H20.8424C20.4743 12 20.1758 12.2985 20.1758 12.6667V19.3333C20.1758 19.7015 20.4743 20 20.8424 20H22.1758C22.544 20 22.8424 19.7015 22.8424 19.3333V12.6667Z" fill="currentColor"/>',"volume-high":'<path d="M17.5091 24.6595C17.5091 25.2066 16.8864 25.5208 16.4463 25.1956L9.44847 20.0252C9.42553 20.0083 9.39776 19.9992 9.36923 19.9992H4.66667C4.29848 19.9992 4 19.7007 4 19.3325V12.6658C4 12.2976 4.29848 11.9992 4.66667 11.9992H9.37115C9.39967 11.9992 9.42745 11.99 9.45039 11.9731L16.4463 6.80363C16.8863 6.47845 17.5091 6.79262 17.5091 7.3398L17.5091 24.6595Z" fill="currentColor"/> <path d="M27.5091 9.33336C27.8773 9.33336 28.1758 9.63184 28.1758 10V22C28.1758 22.3682 27.8773 22.6667 27.5091 22.6667H26.1758C25.8076 22.6667 25.5091 22.3682 25.5091 22V10C25.5091 9.63184 25.8076 9.33336 26.1758 9.33336L27.5091 9.33336Z" fill="currentColor"/> <path d="M22.1758 12C22.544 12 22.8424 12.2985 22.8424 12.6667V19.3334C22.8424 19.7016 22.544 20 22.1758 20H20.8424C20.4743 20 20.1758 19.7016 20.1758 19.3334V12.6667C20.1758 12.2985 20.4743 12 20.8424 12H22.1758Z" fill="currentColor"/>',"cc-on":'<path d="M8 28.0003C8 27.6321 8.29848 27.3336 8.66667 27.3336H23.3333C23.7015 27.3336 24 27.6321 24 28.0003V29.3336C24 29.7018 23.7015 30.0003 23.3333 30.0003H8.66667C8.29848 30.0003 8 29.7018 8 29.3336V28.0003Z" fill="currentColor"/> <path fill-rule="evenodd" clip-rule="evenodd" d="M4.66602 6.66699C4.29783 6.66699 3.99935 6.96547 3.99935 7.33366V24.667C3.99935 25.0352 4.29783 25.3337 4.66602 25.3337H27.3327C27.7009 25.3337 27.9994 25.0352 27.9994 24.667V7.33366C27.9994 6.96547 27.7009 6.66699 27.3327 6.66699H4.66602ZM8.66659 21.3333C8.2984 21.3333 7.99992 21.0349 7.99992 20.6667V11.3333C7.99992 10.9651 8.2984 10.6667 8.66659 10.6667H13.9999C14.3681 10.6667 14.6666 10.9651 14.6666 11.3333V12.6667C14.6666 13.0349 14.3681 13.3333 13.9999 13.3333H10.7999C10.7263 13.3333 10.6666 13.393 10.6666 13.4667V18.5333C10.6666 18.607 10.7263 18.6667 10.7999 18.6667H13.9999C14.3681 18.6667 14.6666 18.9651 14.6666 19.3333V20.6667C14.6666 21.0349 14.3681 21.3333 13.9999 21.3333H8.66659ZM17.9999 21.3333C17.6317 21.3333 17.3333 21.0349 17.3333 20.6667V11.3333C17.3333 10.9651 17.6317 10.6667 17.9999 10.6667H23.3333C23.7014 10.6667 23.9999 10.9651 23.9999 11.3333V12.6667C23.9999 13.0349 23.7014 13.3333 23.3333 13.3333H20.1333C20.0596 13.3333 19.9999 13.393 19.9999 13.4667V18.5333C19.9999 18.607 20.0596 18.6667 20.1333 18.6667H23.3333C23.7014 18.6667 23.9999 18.9651 23.9999 19.3333V20.6667C23.9999 21.0349 23.7014 21.3333 23.3333 21.3333H17.9999Z" fill="currentColor"/>',"cc-off":d3t,"pip-enter":'<path d="M16 15.3333C15.6318 15.3333 15.3333 15.6318 15.3333 16V20C15.3333 20.3682 15.6318 20.6667 16 20.6667H21.3333C21.7015 20.6667 22 20.3682 22 20V16C22 15.6318 21.7015 15.3333 21.3333 15.3333H16Z" fill="currentColor"/> <path fill-rule="evenodd" clip-rule="evenodd" d="M5.33333 7.33334C5.33333 6.96515 5.63181 6.66667 5.99999 6.66667H26C26.3682 6.66667 26.6667 6.96515 26.6667 7.33334V24.6667C26.6667 25.0349 26.3682 25.3333 26 25.3333H5.99999C5.63181 25.3333 5.33333 25.0349 5.33333 24.6667V7.33334ZM7.99999 10C7.99999 9.63182 8.29847 9.33334 8.66666 9.33334H23.3333C23.7015 9.33334 24 9.63182 24 10V22C24 22.3682 23.7015 22.6667 23.3333 22.6667H8.66666C8.29847 22.6667 7.99999 22.3682 7.99999 22V10Z" fill="currentColor"/>',"pip-exit":'<path d="M5.33334 26V19.4667C5.33334 19.393 5.39304 19.3333 5.46668 19.3333H7.86668C7.94031 19.3333 8.00001 19.393 8.00001 19.4667V23.3333C8.00001 23.7015 8.29849 24 8.66668 24H23.3333C23.7015 24 24 23.7015 24 23.3333V8.66666C24 8.29847 23.7015 7.99999 23.3333 7.99999H19.4667C19.393 7.99999 19.3333 7.9403 19.3333 7.86666V5.46666C19.3333 5.39302 19.393 5.33333 19.4667 5.33333H26C26.3682 5.33333 26.6667 5.63181 26.6667 5.99999V26C26.6667 26.3682 26.3682 26.6667 26 26.6667H6.00001C5.63182 26.6667 5.33334 26.3682 5.33334 26Z" fill="currentColor"/> <path d="M14.0098 8.42359H10.806C10.6872 8.42359 10.6277 8.56721 10.7117 8.6512L16.5491 14.4886C16.8094 14.7489 16.8094 15.171 16.5491 15.4314L15.3234 16.657C15.0631 16.9174 14.641 16.9174 14.3806 16.657L8.63739 10.9138C8.55339 10.8298 8.40978 10.8893 8.40978 11.0081V14.0236C8.40978 14.3918 8.1113 14.6903 7.74311 14.6903H6.00978C5.64159 14.6903 5.34311 14.3918 5.34311 14.0236L5.34311 6.02359C5.34311 5.6554 5.64159 5.35692 6.00978 5.35692L14.0098 5.35692C14.378 5.35692 14.6764 5.6554 14.6764 6.02359V7.75692C14.6764 8.12511 14.378 8.42359 14.0098 8.42359Z" fill="currentColor"/>',"fs-enter":'<path d="M25.3299 7.26517C25.2958 6.929 25.0119 6.66666 24.6667 6.66666H19.3334C18.9652 6.66666 18.6667 6.96514 18.6667 7.33333V9.33333C18.6667 9.70152 18.9652 10 19.3334 10L21.8667 10C21.9403 10 22 10.0597 22 10.1333V12.6667C22 13.0349 22.2985 13.3333 22.6667 13.3333H24.6667C25.0349 13.3333 25.3334 13.0349 25.3334 12.6667V7.33333C25.3334 7.31032 25.3322 7.28758 25.3299 7.26517Z" fill="currentColor"/> <path d="M22 21.8667C22 21.9403 21.9403 22 21.8667 22L19.3334 22C18.9652 22 18.6667 22.2985 18.6667 22.6667V24.6667C18.6667 25.0349 18.9652 25.3333 19.3334 25.3333L24.6667 25.3333C25.0349 25.3333 25.3334 25.0349 25.3334 24.6667V19.3333C25.3334 18.9651 25.0349 18.6667 24.6667 18.6667H22.6667C22.2985 18.6667 22 18.9651 22 19.3333V21.8667Z" fill="currentColor"/> <path d="M12.6667 22H10.1334C10.0597 22 10 21.9403 10 21.8667V19.3333C10 18.9651 9.70154 18.6667 9.33335 18.6667H7.33335C6.96516 18.6667 6.66669 18.9651 6.66669 19.3333V24.6667C6.66669 25.0349 6.96516 25.3333 7.33335 25.3333H12.6667C13.0349 25.3333 13.3334 25.0349 13.3334 24.6667V22.6667C13.3334 22.2985 13.0349 22 12.6667 22Z" fill="currentColor"/> <path d="M10 12.6667V10.1333C10 10.0597 10.0597 10 10.1334 10L12.6667 10C13.0349 10 13.3334 9.70152 13.3334 9.33333V7.33333C13.3334 6.96514 13.0349 6.66666 12.6667 6.66666H7.33335C6.96516 6.66666 6.66669 6.96514 6.66669 7.33333V12.6667C6.66669 13.0349 6.96516 13.3333 7.33335 13.3333H9.33335C9.70154 13.3333 10 13.0349 10 12.6667Z" fill="currentColor"/>',"fs-exit":'<path d="M19.3334 13.3333C18.9652 13.3333 18.6667 13.0349 18.6667 12.6667L18.6667 7.33333C18.6667 6.96514 18.9652 6.66666 19.3334 6.66666H21.3334C21.7015 6.66666 22 6.96514 22 7.33333V9.86666C22 9.9403 22.0597 10 22.1334 10L24.6667 10C25.0349 10 25.3334 10.2985 25.3334 10.6667V12.6667C25.3334 13.0349 25.0349 13.3333 24.6667 13.3333L19.3334 13.3333Z" fill="currentColor"/> <path d="M13.3334 19.3333C13.3334 18.9651 13.0349 18.6667 12.6667 18.6667H7.33335C6.96516 18.6667 6.66669 18.9651 6.66669 19.3333V21.3333C6.66669 21.7015 6.96516 22 7.33335 22H9.86669C9.94032 22 10 22.0597 10 22.1333L10 24.6667C10 25.0349 10.2985 25.3333 10.6667 25.3333H12.6667C13.0349 25.3333 13.3334 25.0349 13.3334 24.6667L13.3334 19.3333Z" fill="currentColor"/> <path d="M18.6667 24.6667C18.6667 25.0349 18.9652 25.3333 19.3334 25.3333H21.3334C21.7015 25.3333 22 25.0349 22 24.6667V22.1333C22 22.0597 22.0597 22 22.1334 22H24.6667C25.0349 22 25.3334 21.7015 25.3334 21.3333V19.3333C25.3334 18.9651 25.0349 18.6667 24.6667 18.6667L19.3334 18.6667C18.9652 18.6667 18.6667 18.9651 18.6667 19.3333L18.6667 24.6667Z" fill="currentColor"/> <path d="M10.6667 13.3333H12.6667C13.0349 13.3333 13.3334 13.0349 13.3334 12.6667L13.3334 10.6667V7.33333C13.3334 6.96514 13.0349 6.66666 12.6667 6.66666H10.6667C10.2985 6.66666 10 6.96514 10 7.33333L10 9.86666C10 9.9403 9.94033 10 9.86669 10L7.33335 10C6.96516 10 6.66669 10.2985 6.66669 10.6667V12.6667C6.66669 13.0349 6.96516 13.3333 7.33335 13.3333L10.6667 13.3333Z" fill="currentColor"/>',"seek-forward":'<path d="M15.3333 10.3452C15.3333 10.8924 15.9561 11.2066 16.3962 10.8814L20.9234 7.5364C21.2841 7.26993 21.2841 6.73054 20.9235 6.46405L16.3962 3.11873C15.9561 2.79356 15.3333 3.10773 15.3333 3.6549V5.22682C15.3333 5.29746 15.2778 5.35579 15.2073 5.36066C9.31791 5.76757 4.66667 10.674 4.66667 16.6667C4.66667 22.9259 9.74078 28 16 28C22.0352 28 26.9686 23.2827 27.314 17.3341C27.3354 16.9665 27.0348 16.6673 26.6666 16.6673H24.6666C24.2984 16.6673 24.0029 16.9668 23.9726 17.3337C23.6336 21.4399 20.1937 24.6667 16 24.6667C11.5817 24.6667 8 21.085 8 16.6667C8 12.5225 11.1517 9.11428 15.1887 8.70739C15.2663 8.69957 15.3333 8.76096 15.3333 8.83893V10.3452Z" fill="currentColor"/> <path fill-rule="evenodd" clip-rule="evenodd" d="M17.0879 19.679C17.4553 19.9195 17.8928 20.0398 18.4004 20.0398C18.9099 20.0398 19.3474 19.9205 19.7129 19.6818C20.0803 19.4413 20.3635 19.0938 20.5623 18.6392C20.7612 18.1847 20.8606 17.6373 20.8606 16.9972C20.8625 16.3608 20.764 15.8192 20.5652 15.3722C20.3663 14.9252 20.0822 14.5853 19.7129 14.3523C19.3455 14.1175 18.908 14 18.4004 14C17.8928 14 17.4553 14.1175 17.0879 14.3523C16.7224 14.5853 16.4402 14.9252 16.2413 15.3722C16.0443 15.8173 15.9449 16.3589 15.943 16.9972C15.9411 17.6354 16.0396 18.1818 16.2385 18.6364C16.4373 19.089 16.7205 19.4366 17.0879 19.679ZM19.1362 18.4262C18.9487 18.7349 18.7034 18.8892 18.4004 18.8892C18.1996 18.8892 18.0225 18.8211 17.8691 18.6847C17.7157 18.5464 17.5964 18.3372 17.5112 18.0568C17.4278 17.7765 17.3871 17.4233 17.389 16.9972C17.3909 16.3684 17.4847 15.9025 17.6703 15.5995C17.8559 15.2945 18.0992 15.1421 18.4004 15.1421C18.603 15.1421 18.7801 15.2093 18.9316 15.3438C19.0831 15.4782 19.2015 15.6828 19.2867 15.9574C19.372 16.2301 19.4146 16.5767 19.4146 16.9972C19.4165 17.6392 19.3237 18.1156 19.1362 18.4262Z" fill="currentColor"/> <path d="M13.7746 19.8978C13.8482 19.8978 13.9079 19.8381 13.9079 19.7644V14.2129C13.9079 14.1393 13.8482 14.0796 13.7746 14.0796H12.642C12.6171 14.0796 12.5927 14.0865 12.5716 14.0997L11.2322 14.9325C11.1931 14.9568 11.1693 14.9996 11.1693 15.0457V15.9497C11.1693 16.0539 11.2833 16.1178 11.3722 16.0635L12.464 15.396C12.4682 15.3934 12.473 15.3921 12.4779 15.3921C12.4926 15.3921 12.5045 15.404 12.5045 15.4187V19.7644C12.5045 19.8381 12.5642 19.8978 12.6378 19.8978H13.7746Z" fill="currentColor"/>',"seek-backward":'<path d="M16.6667 10.3452C16.6667 10.8924 16.0439 11.2066 15.6038 10.8814L11.0766 7.5364C10.7159 7.26993 10.7159 6.73054 11.0766 6.46405L15.6038 3.11873C16.0439 2.79356 16.6667 3.10773 16.6667 3.6549V5.22682C16.6667 5.29746 16.7223 5.35579 16.7927 5.36066C22.6821 5.76757 27.3333 10.674 27.3333 16.6667C27.3333 22.9259 22.2592 28 16 28C9.96483 28 5.03145 23.2827 4.68601 17.3341C4.66466 16.9665 4.96518 16.6673 5.33339 16.6673H7.3334C7.70157 16.6673 7.99714 16.9668 8.02743 17.3337C8.36638 21.4399 11.8064 24.6667 16 24.6667C20.4183 24.6667 24 21.085 24 16.6667C24 12.5225 20.8483 9.11428 16.8113 8.70739C16.7337 8.69957 16.6667 8.76096 16.6667 8.83893V10.3452Z" fill="currentColor"/> <path fill-rule="evenodd" clip-rule="evenodd" d="M17.0879 19.679C17.4553 19.9195 17.8928 20.0398 18.4004 20.0398C18.9099 20.0398 19.3474 19.9205 19.7129 19.6818C20.0803 19.4413 20.3635 19.0938 20.5623 18.6392C20.7612 18.1847 20.8606 17.6373 20.8606 16.9972C20.8625 16.3608 20.764 15.8192 20.5652 15.3722C20.3663 14.9252 20.0822 14.5853 19.7129 14.3523C19.3455 14.1175 18.908 14 18.4004 14C17.8928 14 17.4553 14.1175 17.0879 14.3523C16.7224 14.5853 16.4402 14.9252 16.2413 15.3722C16.0443 15.8173 15.9449 16.3589 15.943 16.9972C15.9411 17.6354 16.0396 18.1818 16.2385 18.6364C16.4373 19.089 16.7205 19.4366 17.0879 19.679ZM19.1362 18.4262C18.9487 18.7349 18.7034 18.8892 18.4004 18.8892C18.1996 18.8892 18.0226 18.8211 17.8691 18.6847C17.7157 18.5464 17.5964 18.3372 17.5112 18.0568C17.4279 17.7765 17.3871 17.4233 17.389 16.9972C17.3909 16.3684 17.4847 15.9025 17.6703 15.5995C17.8559 15.2945 18.0993 15.1421 18.4004 15.1421C18.603 15.1421 18.7801 15.2093 18.9316 15.3438C19.0832 15.4782 19.2015 15.6828 19.2868 15.9574C19.372 16.2301 19.4146 16.5767 19.4146 16.9972C19.4165 17.6392 19.3237 18.1156 19.1362 18.4262Z" fill="currentColor"/> <path d="M13.7746 19.8978C13.8482 19.8978 13.9079 19.8381 13.9079 19.7644V14.2129C13.9079 14.1393 13.8482 14.0796 13.7746 14.0796H12.642C12.6171 14.0796 12.5927 14.0865 12.5716 14.0997L11.2322 14.9325C11.1931 14.9568 11.1693 14.9996 11.1693 15.0457V15.9497C11.1693 16.0539 11.2833 16.1178 11.3722 16.0635L12.464 15.396C12.4682 15.3934 12.473 15.3921 12.4779 15.3921C12.4926 15.3921 12.5045 15.404 12.5045 15.4187V19.7644C12.5045 19.8381 12.5642 19.8978 12.6378 19.8978H13.7746Z" fill="currentColor"/>',"menu-chapters":'<path d="M16.6927 25.3346C16.3245 25.3346 16.026 25.0361 16.026 24.6679L16.026 7.3346C16.026 6.96641 16.3245 6.66794 16.6927 6.66794L18.6927 6.66794C19.0609 6.66794 19.3594 6.96642 19.3594 7.3346L19.3594 24.6679C19.3594 25.0361 19.0609 25.3346 18.6927 25.3346H16.6927Z" fill="currentColor"/> <path d="M24.026 25.3346C23.6578 25.3346 23.3594 25.0361 23.3594 24.6679L23.3594 7.3346C23.3594 6.96641 23.6578 6.66794 24.026 6.66794L26.026 6.66794C26.3942 6.66794 26.6927 6.96642 26.6927 7.3346V24.6679C26.6927 25.0361 26.3942 25.3346 26.026 25.3346H24.026Z" fill="currentColor"/> <path d="M5.48113 23.9407C5.38584 24.2963 5.59689 24.6619 5.95254 24.7572L7.88439 25.2748C8.24003 25.3701 8.60559 25.159 8.70089 24.8034L13.1871 8.06067C13.2824 7.70503 13.0713 7.33947 12.7157 7.24417L10.7838 6.72654C10.4282 6.63124 10.0626 6.8423 9.96733 7.19794L5.48113 23.9407Z" fill="currentColor"/>',"menu-settings":'<path fill-rule="evenodd" clip-rule="evenodd" d="M13.5722 5.33333C13.2429 5.33333 12.9629 5.57382 12.9132 5.89938L12.4063 9.21916C12.4 9.26058 12.3746 9.29655 12.3378 9.31672C12.2387 9.37118 12.1409 9.42779 12.0444 9.48648C12.0086 9.5083 11.9646 9.51242 11.9255 9.49718L8.79572 8.27692C8.48896 8.15732 8.14083 8.27958 7.9762 8.56472L5.5491 12.7686C5.38444 13.0538 5.45271 13.4165 5.70981 13.6223L8.33308 15.7225C8.3658 15.7487 8.38422 15.7887 8.38331 15.8306C8.38209 15.8867 8.38148 15.9429 8.38148 15.9993C8.38148 16.0558 8.3821 16.1121 8.38332 16.1684C8.38423 16.2102 8.36582 16.2503 8.33313 16.2765L5.7103 18.3778C5.45334 18.5836 5.38515 18.9462 5.54978 19.2314L7.97688 23.4352C8.14155 23.7205 8.48981 23.8427 8.79661 23.723L11.926 22.5016C11.9651 22.4864 12.009 22.4905 12.0449 22.5123C12.1412 22.5709 12.2388 22.6274 12.3378 22.6818C12.3745 22.7019 12.4 22.7379 12.4063 22.7793L12.9132 26.0993C12.9629 26.4249 13.2429 26.6654 13.5722 26.6654H18.4264C18.7556 26.6654 19.0356 26.425 19.0854 26.0995L19.5933 22.7801C19.5997 22.7386 19.6252 22.7027 19.6619 22.6825C19.7614 22.6279 19.8596 22.5711 19.9564 22.5121C19.9923 22.4903 20.0362 22.4862 20.0754 22.5015L23.2035 23.7223C23.5103 23.842 23.8585 23.7198 24.0232 23.4346L26.4503 19.2307C26.6149 18.9456 26.5467 18.583 26.2898 18.3771L23.6679 16.2766C23.6352 16.2504 23.6168 16.2104 23.6177 16.1685C23.619 16.1122 23.6196 16.0558 23.6196 15.9993C23.6196 15.9429 23.619 15.8866 23.6177 15.8305C23.6168 15.7886 23.6353 15.7486 23.668 15.7224L26.2903 13.623C26.5474 13.4172 26.6156 13.0544 26.451 12.7692L24.0239 8.56537C23.8592 8.28023 23.5111 8.15797 23.2043 8.27757L20.0758 9.49734C20.0367 9.51258 19.9927 9.50846 19.9569 9.48664C19.8599 9.42762 19.7616 9.37071 19.6618 9.31596C19.6251 9.2958 19.5997 9.25984 19.5933 9.21843L19.0854 5.89915C19.0356 5.57369 18.7556 5.33333 18.4264 5.33333H13.5722ZM16.0001 20.2854C18.3672 20.2854 20.2862 18.3664 20.2862 15.9993C20.2862 13.6322 18.3672 11.7132 16.0001 11.7132C13.6329 11.7132 11.714 13.6322 11.714 15.9993C11.714 18.3664 13.6329 20.2854 16.0001 20.2854Z" fill="currentColor"/>',"menu-arrow-left":'<path d="M13.0908 14.3334C12.972 14.3334 12.9125 14.1898 12.9965 14.1058L17.7021 9.40022C17.9625 9.13987 17.9625 8.71776 17.7021 8.45741L16.2879 7.04319C16.0275 6.78284 15.6054 6.78284 15.3451 7.04319L6.8598 15.5285C6.59945 15.7888 6.59945 16.2109 6.8598 16.4713L8.27401 17.8855L8.27536 17.8868L15.3453 24.9568C15.6057 25.2172 16.0278 25.2172 16.2881 24.9568L17.7024 23.5426C17.9627 23.2822 17.9627 22.8601 17.7024 22.5998L12.9969 17.8944C12.9129 17.8104 12.9724 17.6668 13.0912 17.6668L26 17.6668C26.3682 17.6668 26.6667 17.3683 26.6667 17.0001V15.0001C26.6667 14.6319 26.3682 14.3334 26 14.3334L13.0908 14.3334Z" fill="currentColor"/>',"menu-arrow-right":'<path d="M17.947 16.095C17.999 16.043 17.999 15.9585 17.947 15.9065L11.6295 9.58899C11.3691 9.32864 11.3691 8.90653 11.6295 8.64618L13.2323 7.04341C13.4926 6.78306 13.9147 6.78306 14.1751 7.04341L21.0289 13.8973C21.0392 13.9064 21.0493 13.9158 21.0591 13.9257L22.6619 15.5285C22.9223 15.7888 22.9223 16.2109 22.6619 16.4713L14.1766 24.9565C13.9163 25.2169 13.4942 25.2169 13.2338 24.9565L11.631 23.3538C11.3707 23.0934 11.3707 22.6713 11.631 22.411L17.947 16.095Z" fill="currentColor"/>',"menu-audio":'<path fill-rule="evenodd" clip-rule="evenodd" d="M26.6667 5.99998C26.6667 5.63179 26.3682 5.33331 26 5.33331H11.3333C10.9651 5.33331 10.6667 5.63179 10.6667 5.99998V17.5714C10.6667 17.6694 10.5644 17.7342 10.4741 17.6962C9.91823 17.4625 9.30754 17.3333 8.66667 17.3333C6.08934 17.3333 4 19.4226 4 22C4 24.5773 6.08934 26.6666 8.66667 26.6666C11.244 26.6666 13.3333 24.5773 13.3333 22V8.66665C13.3333 8.29846 13.6318 7.99998 14 7.99998L23.3333 7.99998C23.7015 7.99998 24 8.29846 24 8.66665V14.9048C24 15.0027 23.8978 15.0675 23.8075 15.0296C23.2516 14.7958 22.6409 14.6666 22 14.6666C19.4227 14.6666 17.3333 16.756 17.3333 19.3333C17.3333 21.9106 19.4227 24 22 24C24.5773 24 26.6667 21.9106 26.6667 19.3333V5.99998ZM22 21.3333C23.1046 21.3333 24 20.4379 24 19.3333C24 18.2287 23.1046 17.3333 22 17.3333C20.8954 17.3333 20 18.2287 20 19.3333C20 20.4379 20.8954 21.3333 22 21.3333ZM8.66667 24C9.77124 24 10.6667 23.1045 10.6667 22C10.6667 20.8954 9.77124 20 8.66667 20C7.5621 20 6.66667 20.8954 6.66667 22C6.66667 23.1045 7.5621 24 8.66667 24Z" fill="currentColor"/>',"menu-speed":'<path d="M25.14 25.1089C25.0171 25.2532 24.8356 25.3333 24.646 25.3333H22.8124C22.1084 25.3333 21.7734 24.1872 22.2745 23.6927C23.9161 22.0729 24.9336 19.822 24.9336 17.3333C24.9336 12.3997 20.9336 8.39973 16 8.39973C11.0664 8.39973 7.06641 12.3997 7.06641 17.3333C7.06641 19.822 8.08389 22.0729 9.72555 23.6927C10.2266 24.1872 9.89155 25.3333 9.18762 25.3333H7.35398C7.16436 25.3333 6.98294 25.2532 6.86001 25.1089C5.07703 23.015 4 20.2991 4 17.3333C4 10.7057 9.3724 5.33333 16 5.33333C22.6276 5.33333 28 10.7057 28 17.3333C28 20.2991 26.923 23.015 25.14 25.1089Z" fill="currentColor"/> <path d="M21.1992 14.3399C21.4595 14.0796 21.4595 13.6575 21.1992 13.3971L20.2564 12.4543C19.996 12.194 19.5739 12.194 19.3136 12.4543L16.4492 15.3187C16.4185 15.3493 16.3749 15.3629 16.332 15.3568C16.2236 15.3414 16.1127 15.3334 16 15.3334C14.7113 15.3334 13.6667 16.378 13.6667 17.6667C13.6667 18.9554 14.7113 20 16 20C17.2887 20 18.3333 18.9554 18.3333 17.6667C18.3333 17.5464 18.3242 17.4283 18.3067 17.313C18.3001 17.2696 18.3136 17.2255 18.3446 17.1945L21.1992 14.3399Z" fill="currentColor"/>',"menu-quality":'<path d="M18.6669 10.4001C18.6669 10.7683 18.3684 11.0667 18.0002 11.0667H16.2668C15.8987 11.0667 15.6002 10.7683 15.6002 10.4001V9.86674C15.6002 9.7931 15.5405 9.73341 15.4669 9.73341H5.99998C5.63179 9.73341 5.33331 9.43493 5.33331 9.06674V7.33341C5.33331 6.96522 5.63179 6.66674 5.99998 6.66674H15.4669C15.5405 6.66674 15.6002 6.60704 15.6002 6.53341V6.00007C15.6002 5.63188 15.8987 5.3334 16.2668 5.3334H18.0002C18.3684 5.3334 18.6669 5.63188 18.6669 6.00007V10.4001Z" fill="currentColor"/> <path d="M11.3334 18.8668C11.7016 18.8668 12.0001 18.5683 12.0001 18.2001V13.8001C12.0001 13.4319 11.7016 13.1335 11.3334 13.1335H9.60006C9.23187 13.1335 8.93339 13.4319 8.93339 13.8001V14.3335C8.93339 14.4071 8.8737 14.4668 8.80006 14.4668H6.00006C5.63187 14.4668 5.33339 14.7653 5.33339 15.1335V16.8668C5.33339 17.235 5.63187 17.5335 6.00006 17.5335H8.80006C8.8737 17.5335 8.93339 17.5932 8.93339 17.6668V18.2001C8.93339 18.5683 9.23187 18.8668 9.60006 18.8668H11.3334Z" fill="currentColor"/> <path d="M18.6667 26.0001C18.6667 26.3683 18.3682 26.6668 18 26.6668H16.2667C15.8985 26.6668 15.6 26.3683 15.6 26.0001V25.4668C15.6 25.3931 15.5403 25.3334 15.4667 25.3334H6.00014C5.63195 25.3334 5.33348 25.0349 5.33348 24.6668V22.9334C5.33348 22.5652 5.63195 22.2668 6.00014 22.2668H15.4667C15.5403 22.2668 15.6 22.2071 15.6 22.1334V21.6001C15.6 21.2319 15.8985 20.9334 16.2667 20.9334H18C18.3682 20.9334 18.6667 21.2319 18.6667 21.6001V26.0001Z" fill="currentColor"/> <path d="M22 24.6668C22 25.0349 22.2985 25.3334 22.6667 25.3334H26.0001C26.3683 25.3334 26.6668 25.0349 26.6668 24.6668V22.9334C26.6668 22.5652 26.3683 22.2668 26.0001 22.2668H22.6667C22.2985 22.2668 22 22.5652 22 22.9334V24.6668Z" fill="currentColor"/> <path d="M16.0001 17.5335C15.6319 17.5335 15.3334 17.235 15.3334 16.8668V15.1335C15.3334 14.7653 15.6319 14.4668 16.0001 14.4668H26.0001C26.3683 14.4668 26.6667 14.7653 26.6667 15.1335V16.8668C26.6667 17.235 26.3683 17.5335 26.0001 17.5335H16.0001Z" fill="currentColor"/> <path d="M22.0002 9.06674C22.0002 9.43493 22.2987 9.73341 22.6669 9.73341H26C26.3682 9.73341 26.6666 9.43493 26.6666 9.06674V7.3334C26.6666 6.96521 26.3682 6.66674 26 6.66674H22.6669C22.2987 6.66674 22.0002 6.96522 22.0002 7.33341V9.06674Z" fill="currentColor"/>',"menu-captions":d3t};var f3t=Object.freeze({__proto__:null,icons:p3t});const m3t=/,/g;class g3t extends f2t{parse(t,e){if(""===t)this.a&&(this.j.push(this.a),this.f.onCue?.(this.a),this.a=null),this.c=p2t.None;else if(this.c===p2t.Cue)this.a.text+=(this.a.text?"\n":"")+t;else if(t.includes("--\x3e")){const n=this.o(t,e);n&&(this.a=new Z1t(n[0],n[1],n[2].join(" ")),this.a.id=this.l,this.c=p2t.Cue)}this.l=t}o(t,e){return super.o(t.replace(m3t,"."),e)}}var y3t=Object.freeze({__proto__:null,SRTParser:g3t,default:function(){return new g3t}});const b3t=/^Format:[\s\t]*/,v3t=/^Style:[\s\t]*/,x3t=/^Dialogue:[\s\t]*/,w3t=/[\s\t]*,[\s\t]*/,S3t=/\{[^}]+\}/g,k3t=/\\N/g,C3t=/^\[(.*)[\s\t]?Styles\]$/,T3t=/^\[(.*)[\s\t]?Events\]$/;class _3t{f;O=0;a=null;j=[];k=[];N=null;d;P={};async init(t){this.f=t,t.errors&&(this.d=(await Promise.resolve().then((function(){return A3t}))).ParseErrorBuilder)}parse(t,e){if(this.O)switch(this.O){case 1:if(""===t)this.O=0;else if(v3t.test(t))if(this.N){const e=t.replace(v3t,"").split(w3t);this.S(e)}else this.e(this.d?.T("Style",e));else b3t.test(t)?this.N=t.replace(b3t,"").split(w3t):T3t.test(t)&&(this.N=null,this.O=2);break;case 2:if(""===t)this.Q();else if(x3t.test(t))if(this.Q(),this.N){const n=t.replace(x3t,"").split(w3t),i=this.U(n,e);i&&(this.a=i)}else this.e(this.d?.T("Dialogue",e));else this.a?this.a.text+="\n"+t.replace(S3t,"").replace(k3t,"\n"):b3t.test(t)?this.N=t.replace(b3t,"").split(w3t):C3t.test(t)?(this.N=null,this.O=1):T3t.test(t)&&(this.N=null)}else""===t||(C3t.test(t)?(this.N=null,this.O=1):T3t.test(t)&&(this.N=null,this.O=2))}done(){return{metadata:{},cues:this.j,regions:[],errors:this.k}}Q(){this.a&&(this.j.push(this.a),this.f.onCue?.(this.a),this.a=null)}S(t){let e,n,i,r,s="Default",o={},a="center",l="bottom",c=1.2,u=3,h=[];for(let d=0;d<this.N.length;d++){const p=this.N[d],f=t[d];switch(p){case"Name":s=f;break;case"Fontname":o["font-family"]=f;break;case"Fontsize":o["font-size"]=`calc(${f} / var(--overlay-height))`;break;case"PrimaryColour":const t=E3t(f);t&&(o["--cue-color"]=t);break;case"BorderStyle":u=parseInt(f,10);break;case"BackColour":r=E3t(f);break;case"OutlineColour":const d=E3t(f);d&&(i=d);break;case"Bold":parseInt(f)&&(o["font-weight"]="bold");break;case"Italic":parseInt(f)&&(o["font-style"]="italic");break;case"Underline":parseInt(f)&&(o["text-decoration"]="underline");break;case"StrikeOut":parseInt(f)&&(o["text-decoration"]="line-through");break;case"Spacing":o["letter-spacing"]=f+"px";break;case"AlphaLevel":o.opacity=parseFloat(f);break;case"ScaleX":h.push(`scaleX(${parseFloat(f)/100})`);break;case"ScaleY":h.push(`scaleY(${parseFloat(f)/100})`);break;case"Angle":h.push(`rotate(${f}deg)`);break;case"Shadow":c=1.2*parseInt(f,10);break;case"MarginL":o["--cue-width"]="auto",o["--cue-left"]=parseFloat(f)+"px";break;case"MarginR":o["--cue-width"]="auto",o["--cue-right"]=parseFloat(f)+"px";break;case"MarginV":n=parseFloat(f);break;case"Outline":e=parseInt(f,10);break;case"Alignment":const p=parseInt(f,10);switch(p>=4&&(l=p>=7?"top":"center"),p%3){case 1:a="start";break;case 2:a="center";break;case 3:a="end"}}}if(o.R=l,o["--cue-white-space"]="normal",o["--cue-line-height"]="normal",o["--cue-text-align"]=a,"center"===l?(o["--cue-top"]="50%",h.push("translateY(-50%)")):o[`--cue-${l}`]=(n||0)+"px",1===u&&(o["--cue-padding-y"]="0"),(1===u||r)&&(o["--cue-bg-color"]=1===u?"none":r),3===u&&i&&(o["--cue-outline"]=`${e}px solid ${i}`),1===u&&"number"==typeof e){const t=r??"#000";o["--cue-text-shadow"]=[i&&M3t(1.2*e,1.2*c,i),i?M3t(e*(e/2),c*(e/2),t):M3t(e,c,t)].filter(Boolean).join(", ")}h.length&&(o["--cue-transform"]=h.join(" ")),this.P[s]=o}U(t,e){const n=this.V(t),i=this.o(n.Start,n.End,e);if(!i)return;const r=new Z1t(i[0],i[1],""),s={...this.P[n.Style]||{}},o=n.Name?`<v ${n.Name}>`:"",a=s.R,l=n.MarginL&&parseFloat(n.MarginL),c=n.MarginR&&parseFloat(n.MarginR),u=n.MarginV&&parseFloat(n.MarginV);return l&&(s["--cue-width"]="auto",s["--cue-left"]=l+"px"),c&&(s["--cue-width"]="auto",s["--cue-right"]=c+"px"),u&&"center"!==a&&(s[`--cue-${a}`]=u+"px"),r.text=o+t.slice(this.N.length-1).join(", ").replace(S3t,"").replace(k3t,"\n"),delete s.R,Object.keys(s).length&&(r.style=s),r}V(t){const e={};for(let n=0;n<this.N.length;n++)e[this.N[n]]=t[n];return e}o(t,e,n){const i=m2t(t),r=m2t(e);if(null!==i&&null!==r&&r>i)return[i,r];null===i&&this.e(this.d?.q(t,n)),null===r&&this.e(this.d?.r(e,n)),null!=i&&null!==r&&r>i&&this.e(this.d?.s(i,r,n))}e(t){if(t){if(this.k.push(t),this.f.strict)throw this.f.cancel(),t;this.f.onError?.(t)}}}function E3t(t){const e=parseInt(t.replace("&H",""),16);if(e>=0){return"rgba("+[255&e,e>>8&255,e>>16&255,(e>>24&255^255)/255].join(",")+")"}return null}function M3t(t,e,n){const i=Math.ceil(2*Math.PI*t);let r="";for(let s=0;s<i;s++){const o=2*Math.PI*s/i;r+=t*Math.cos(o)+"px "+e*Math.sin(o)+"px 0 "+n+(s==i-1?"":",")}return r}var $3t=Object.freeze({__proto__:null,SSAParser:_3t,default:function(){return new _3t}});const I3t={p:()=>new V1t({code:U1t.BadSignature,reason:"missing WEBVTT file header",line:1}),q:(t,e)=>new V1t({code:U1t.BadTimestamp,reason:`cue start timestamp \`${t}\` is invalid on line ${e}`,line:e}),r:(t,e)=>new V1t({code:U1t.BadTimestamp,reason:`cue end timestamp \`${t}\` is invalid on line ${e}`,line:e}),s:(t,e,n)=>new V1t({code:U1t.BadTimestamp,reason:`cue end timestamp \`${e}\` is greater than start \`${t}\` on line ${n}`,line:n}),w:(t,e,n)=>new V1t({code:U1t.BadSettingValue,reason:`invalid value for cue setting \`${t}\` on line ${n} (value: ${e})`,line:n}),v:(t,e,n)=>new V1t({code:U1t.UnknownSetting,reason:`unknown cue setting \`${t}\` on line ${n} (value: ${e})`,line:n}),u:(t,e,n)=>new V1t({code:U1t.BadSettingValue,reason:`invalid value for region setting \`${t}\` on line ${n} (value: ${e})`,line:n}),t:(t,e,n)=>new V1t({code:U1t.UnknownSetting,reason:`unknown region setting \`${t}\` on line ${n} (value: ${e})`,line:n}),T:(t,e)=>new V1t({code:U1t.BadFormat,reason:`format missing for \`${t}\` block on line ${e}`,line:e})};var A3t=Object.freeze({__proto__:null,ParseErrorBuilder:I3t});export{fK as ArrayIterable,xK as Component,pK as LazyIterable,iK as LogLevel,i3 as Model,K1 as ServiceIterable,eK as Stream,hnt as TFJSBaseModel,jnt as TFJSCustomClassifier,Hnt as TFJSCustomModel,rit as account,pit as batchPrediction,wit as button,Rit as cocoSsd,wmt as confidencePlot,Umt as confusionMatrix,nK as createStream,x1t as dashboard,r2 as dataStore,e3 as dataset,Vnt as dataset2tfjs,sgt as datasetBrowser,ayt as datasetScatter,wyt as datasetTable,Eyt as detectionBoxes,Oyt as fileUpload,umt as genericChart,oK as getLogStream,Uyt as imageDisplay,abt as imageUpload,n3 as isDataset,tK as isStream,mK as iterableFromArray,Y1 as iterableFromService,Zbt as kmeansClustering,ivt as knnClassifier,sK as logger,mvt as mediaRecorder,yK as mergeDeep,wvt as microphone,kvt as mlpClassifier,Tvt as mlpRegressor,Hvt as mobileNet,lxt as modelParameters,BH as notification,fxt as number,xxt as numberArray,Nxt as onnxModel,swt as pca,Hkt as poseDetection,fit as predictionProgress,uit as progressBar,yzt as scatterPlot,kzt as select,Ozt as sketchPad,SBt as slider,ymt as text,MBt as textArea,OBt as textField,PBt as textInput,GBt as tfjsModel,cK as throwError,JBt as toggle,UUt as trainingHistory,uUt as trainingPlot,hit as trainingProgress,uWt as umap,aQt as videoPlayer,MQt as webcam,B1t as wizard};
//# sourceMappingURL=marcelle.bundle.esm.js.map
